<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"wetts.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="Stay Hungry, Stay Foolish. [build by hexo&#x2F;next&#x2F;gitalk&#x2F;hexo-generator-search&#x2F;LaTeX]">
<meta property="og:type" content="website">
<meta property="og:title" content="Wetts&#39;s blog">
<meta property="og:url" content="https://wetts.github.io/index.html">
<meta property="og:site_name" content="Wetts&#39;s blog">
<meta property="og:description" content="Stay Hungry, Stay Foolish. [build by hexo&#x2F;next&#x2F;gitalk&#x2F;hexo-generator-search&#x2F;LaTeX]">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Zhang Wetts">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://wetts.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Wetts's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Wetts's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Stay Hungry, Stay Foolish.</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/wetts" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wetts.github.io/2021/07/12/%E8%AF%AD%E8%A8%80/Java/JVM/Java-JVM-GC%E6%B5%81%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Zhang Wetts">
      <meta itemprop="description" content="Stay Hungry, Stay Foolish. <br><br><p style="font-size:8px;">[build by hexo/next/gitalk/hexo-generator-search/LaTeX]</p>">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wetts's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/12/%E8%AF%AD%E8%A8%80/Java/JVM/Java-JVM-GC%E6%B5%81%E7%A8%8B/" class="post-title-link" itemprop="url">Java-JVM-GC流程.md</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-07-12 02:56:32" itemprop="dateCreated datePublished" datetime="2021-07-12T02:56:32+08:00">2021-07-12</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>转自：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/shuiyj/p/12640692.html">https://www.cnblogs.com/shuiyj/p/12640692.html</a></p>
<p><img src="/2021/07/12/%E8%AF%AD%E8%A8%80/Java/JVM/Java-JVM-GC%E6%B5%81%E7%A8%8B/1.png" alt="1"></p>
<h2 id="挤满新生代的最后一个对象"><a href="#挤满新生代的最后一个对象" class="headerlink" title="挤满新生代的最后一个对象"></a>挤满新生代的最后一个对象</h2><p>我们应当知道，新创建的对象一般会被分配在新生代中。常用的新生代的垃圾回收器是 ParNew 垃圾回收器，它按照 8:1:1 将新生代分成 Eden 区，以及两个 Survivor 区。</p>
<p>某一时刻，我们创建的对象将 Eden 区全部挤满，这个对象就是「挤满新生代的最后一个对象」。此时，Minor GC 就触发了。</p>
<h2 id="正式-Minor-GC-前的检查"><a href="#正式-Minor-GC-前的检查" class="headerlink" title="正式 Minor GC 前的检查"></a>正式 Minor GC 前的检查</h2><p>在正式 Minor GC 前，JVM 会先检查新生代中对象，是比老年代中剩余空间大还是小。<strong>为什么要做这样的检查呢？</strong>原因很简单，假如 Minor GC 之后 Survivor 区放不下剩余对象，这些对象就要进入到老年代，所以要提前检查老年代是不是够用。这样就有两种情况：</p>
<ol>
<li>老年代剩余空间大于新生代中的对象大小，那就直接 Minor GC，GC 完 survivor 不够放，老年代也绝对够放</li>
<li>老年代剩余空间小于新生代中的对象大小，这个时候就要查看是否启用了「老年代空间分配担保规则」，具体来说就是看 <code>-XX:-HandlePromotionFailure</code> 参数是否设置了（一般都会设置）</li>
</ol>
<p>老年代空间分配担保规则是这样的。如果老年代中剩余空间大小，大于历次 Minor GC 之后剩余对象的大小，那就允许进行 Minor GC。因为从概率上来说，以前的放的下，这次的也应该放的下。那就有两种情况：</p>
<ol>
<li>老年代中剩余空间大小，大于历次 Minor GC 之后剩余对象的大小，进行 Minor GC</li>
<li>老年代中剩余空间大小，小于历次 Minor GC 之后剩余对象的大小，进行 Full GC，把老年代空出来再检查</li>
</ol>
<h2 id="Minor-GC-后的处境"><a href="#Minor-GC-后的处境" class="headerlink" title="Minor GC 后的处境"></a>Minor GC 后的处境</h2><p>前面说了，开启<strong>老年代空间分配担保规则</strong>只能说是大概率上来说，Minor GC 剩余后的对象够放到老年代，所以当然也会有万一，Minor GC 后会有这样三种情况：</p>
<ol>
<li>Minor GC 之后的对象足够放到 Survivor 区，皆大欢喜，GC 结束</li>
<li>Minor GC 之后的对象不够放到 Survivor 区，接着进入到老年代，老年代能放下，那也可以，GC 结束</li>
<li>Minor GC 之后的对象不够放到 Survivor 区，老年代也放不下，那就只能 Full GC</li>
</ol>
<h2 id="实在不行只能-OOM"><a href="#实在不行只能-OOM" class="headerlink" title="实在不行只能 OOM"></a>实在不行只能 OOM</h2><p>前面都是成功 GC 的例子，还有 3 种情况，会导致 GC 失败，报 OOM：</p>
<ol>
<li>紧接上一节 Full GC 之后，老年代任然放不下剩余对象，就只能 OOM</li>
<li>未开启老年代分配担保机制，且一次 Full GC 后，老年代任然放不下剩余对象，也只能 OOM</li>
<li>开启老年代分配担保机制，但是担保不通过，一次 Full GC 后，老年代任然放不下剩余对象，也是能 OOM</li>
</ol>
<hr>
<p>转自：<a target="_blank" rel="noopener" href="https://www.modb.pro/db/26526">https://www.modb.pro/db/26526</a></p>
<h2 id="堆内存结构"><a href="#堆内存结构" class="headerlink" title="堆内存结构"></a>堆内存结构</h2><p>我们以 Java 官方的 HotSpot JVM 为例，在描述 GC 过程前，先了解一下堆内存的结构。</p>
<p><img src="/2021/07/12/%E8%AF%AD%E8%A8%80/Java/JVM/Java-JVM-GC%E6%B5%81%E7%A8%8B/2.png" alt="2"><br>JVM 将堆内存分为了三部分：新生代（Young Generation），老年代（Old Generation），永久代（Permanent Generation）。其中新生代又分为三部分：伊甸园区（Eden），和两个幸存区 S0 和 S1。</p>
<p>注：JDK1.8 之后，Java 官方的 HotSpot JVM 去掉了永久代，取而代之的是元数据区 Metaspace。Metaspace 使用的是本地内存，而不是堆内存，也就是说在默认情况下 Metaspace 的大小只与本地内存的大小有关。因此 JDK1.8 之后，就见不到 java.lang.OutOfMemoryError: PermGen space 这种由于永久代空间不足导致的内存溢出的问题了。</p>
<h2 id="垃圾回收全过程"><a href="#垃圾回收全过程" class="headerlink" title="垃圾回收全过程"></a>垃圾回收全过程</h2><p><img src="/2021/07/12/%E8%AF%AD%E8%A8%80/Java/JVM/Java-JVM-GC%E6%B5%81%E7%A8%8B/3.png" alt="3"><br>新创建的对象会先被分配到到 Eden 区。JVM 刚启动时，Eden 区对象数量较少，两个 Survivor 区 S0、S1 几乎是空的。</p>
<p><img src="/2021/07/12/%E8%AF%AD%E8%A8%80/Java/JVM/Java-JVM-GC%E6%B5%81%E7%A8%8B/4.png" alt="4"><br>随着时间的推移，Eden 区的对象越来越多。当 Eden 区放不下时（占用空间达到容量阈值），新生代就会发生垃圾回收，我们称之为 Minor GC 或者 Young GC。</p>
<p><img src="/2021/07/12/%E8%AF%AD%E8%A8%80/Java/JVM/Java-JVM-GC%E6%B5%81%E7%A8%8B/5.png" alt="5"><br>发生 GC 时，第一步会通过可达性分析算法找到可达对象。如上图，蓝色为可达对象，其他紫色为不可达对象。第二步，被标示的可达对象会被转移到 S0（此时 S0 是 From Survivor），此时存活对象年龄加 1，三个对象年龄都变为 1。第三步，清除 Eden 区所有对象。</p>
<p><img src="/2021/07/12/%E8%AF%AD%E8%A8%80/Java/JVM/Java-JVM-GC%E6%B5%81%E7%A8%8B/6.png" alt="6"><br>GC 后各区域对象占用情况，如上图所示。</p>
<p><img src="/2021/07/12/%E8%AF%AD%E8%A8%80/Java/JVM/Java-JVM-GC%E6%B5%81%E7%A8%8B/7.png" alt="7"><br>程序继续运行，Eden 区再次达到容量阈值时，会再次发生 GC。这时 S0（From Survivor）已经有了对象。还是同样的步骤，通过可达性分析算法找到可达对象，然后再将 Eden 和 S0 中的可达对象转移到 S1（To Survivor），各存活对象年龄加 1。最后将 Eden 和 S0 中的所有对象清除。</p>
<p><img src="/2021/07/12/%E8%AF%AD%E8%A8%80/Java/JVM/Java-JVM-GC%E6%B5%81%E7%A8%8B/8.png" alt="8"><br>GC 后 S0 区域被清空。如上图所示。S0 和 S1 发生了互换，S1 变成了 From Survivor，S0 变成了 To Survivor。</p>
<p>注意，To Survivor 区永远都为空。这实际上是垃圾回收算法-复制算法在年轻代的实际应用。把年轻代分为 Eden、S0、S1 三个区域，每次垃圾回收时把可达对象复制到 S0 或 S1，然后再清除掉 Eden 和（S1 或 S0）中的所有对象。由于每次 GC 时，新生代的可达对象非常少（绝大部分对象要被回收掉），一般不会超过新生代总体空间的 10%，所以搜寻可达对象以及复制对象的成本都会非常低。而且这种复制的方式还能避免产生堆内存碎片，提高内存利用率。很多年轻代垃圾收集器都采用复制算法，如 ParNew。</p>
<p><img src="/2021/07/12/%E8%AF%AD%E8%A8%80/Java/JVM/Java-JVM-GC%E6%B5%81%E7%A8%8B/9.png" alt="9"><br>在程序运行过程中，新生代 GC 会反复发生，长寿对象会在 S0 和 S1 之间反复交换，年龄也会越来越大，当对象达到年龄上限时，会被晋升到老年代。这个年龄上限默认是 15，可以通过参数 -XX:MaxTenuringThreshold 设置。如下图，有些年轻代对象年龄达到了上限 15，被转移到了老年代。</p>
<p><img src="/2021/07/12/%E8%AF%AD%E8%A8%80/Java/JVM/Java-JVM-GC%E6%B5%81%E7%A8%8B/10.png" alt="10"><br><strong>其他晋升方式</strong>。新生代对象晋升到老年代，除了根据年龄正常晋升外。为了提高 JVM 的性能，JVM 设计者还考虑了其他晋升方式。</p>
<p><img src="/2021/07/12/%E8%AF%AD%E8%A8%80/Java/JVM/Java-JVM-GC%E6%B5%81%E7%A8%8B/11.png" alt="11"><br><strong>大对象直接晋升</strong>。大对象会跨过年轻代直接分配到老年代。可以通过 -XX:PretenureSizeThreshold 参数设置对象大小。如果参数被设置成 5MB，超过 5MB 的大对象会直接分配到老年代。这样做的目的，是为了避免大对象在Eden区及两个 Survivor 区之间大量的内存复制，大对象的内存复制耗时比普通对象要高很多。</p>
<p>注意：PretenureSizeThreshold参数只对Serial和ParNew两种回收器有效。</p>
<p><img src="/2021/07/12/%E8%AF%AD%E8%A8%80/Java/JVM/Java-JVM-GC%E6%B5%81%E7%A8%8B/12.png" alt="12"><br><strong>动态对象年龄判定</strong>。如果在 Survivor 空间中相同年龄对象大小的总和大于 Survivor 空间的一半，年龄大于或等于该年龄的对象会直接进入老年代，而不用等到 MaxTenuringThreshold 中设置的年龄上限。上图，年龄为1的对象超过了 Survivor 空间的一半，所以这几个对象会直接进入老年代。</p>
<p><img src="/2021/07/12/%E8%AF%AD%E8%A8%80/Java/JVM/Java-JVM-GC%E6%B5%81%E7%A8%8B/13.png" alt="13"><br>实际上，上面对动态对象年龄判定的描述并不精确。上图的场景也会导致相关对象晋升到老年代。年龄为 1 的对象加上年龄为 2 的对象超过了半数，这时包括年龄为 2 的对象以及年龄更大的对象都会被晋升到老年代。所以上图中年龄为 2 和 3 的对象都会被晋升到老年代。</p>
<p><strong>老年代垃圾回收</strong>。随着年轻代对象的不断晋升，老年代的对象变得越来越多，达到容量阈值后老年代也会发生垃圾回收，我们称之为 Major GC 或者 Full GC，Full GC 并不是全局 GC，它只发生在老年代。</p>
<p>虽然年轻代和老年代都会发生GC，但是每次GC的时间和成本却大不相同。由于老年代空间大小一般是年轻代的几倍，再加上老年代对象存活率很高，所以整个标记过程比较慢，GC 成本也非常高。我们经常说的JVM调优，主要是为了尽量减少老年代Full GC的时间和频次。</p>
<p>老年代垃圾回收器，很少使用复制算法，主要为了避免大量对象的内存复制带来的时间和空间上的开销，一般采用标记清除、标记整理算法，就地标记回收。例如，老年代垃圾收集器 CMS 就采用了标记清除算法。对于标记清除算法带来的内存碎片问题，CMS 提供了两个参数做碎片整理，-XX:+UseCMSCompactAtFullCollection和-XX:CMSFullGCsBeforeCompaction。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wetts.github.io/2021/07/11/%E8%AF%AD%E8%A8%80/Java/JVM/Java-JVM-%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0%E6%B3%95%E4%B8%8E%E8%AF%BB%E5%86%99%E5%B1%8F%E9%9A%9C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Zhang Wetts">
      <meta itemprop="description" content="Stay Hungry, Stay Foolish. <br><br><p style="font-size:8px;">[build by hexo/next/gitalk/hexo-generator-search/LaTeX]</p>">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wetts's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/11/%E8%AF%AD%E8%A8%80/Java/JVM/Java-JVM-%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0%E6%B3%95%E4%B8%8E%E8%AF%BB%E5%86%99%E5%B1%8F%E9%9A%9C/" class="post-title-link" itemprop="url">Java-JVM-三色标记法与读写屏障.md</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-07-11 21:58:53" itemprop="dateCreated datePublished" datetime="2021-07-11T21:58:53+08:00">2021-07-11</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>转自：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/12544c0ad5c1">https://www.jianshu.com/p/12544c0ad5c1</a></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文主要介绍了三色标记法的基本思路、多标导致的浮动垃圾、漏标的处理方案（读写屏障）等。</p>
<h2 id="垃圾回收的简单回顾"><a href="#垃圾回收的简单回顾" class="headerlink" title="垃圾回收的简单回顾"></a>垃圾回收的简单回顾</h2><p>关于垃圾回收算法，基本就是那么几种：标记-清除、标记-复制、标记-整理。在此基础上可以增加分代（新生代/老年代），每代采取不同的回收算法，以提高整体的分配和回收效率。</p>
<p>无论使用哪种算法，标记总是必要的一步。这是理算当然的，你不先找到垃圾，怎么进行回收？</p>
<p>垃圾回收器的工作流程大体如下：</p>
<ol>
<li>标记出哪些对象是存活的，哪些是垃圾（可回收）；</li>
<li>进行回收（清除/复制/整理），如果有移动过对象（复制/整理），还需要更新引用。</li>
</ol>
<p>本文着重来看下标记的部分。</p>
<h2 id="三色标记法"><a href="#三色标记法" class="headerlink" title="三色标记法"></a>三色标记法</h2><h3 id="基本算法"><a href="#基本算法" class="headerlink" title="基本算法"></a>基本算法</h3><p>要找出存活对象，根据可达性分析，从GC Roots开始进行遍历访问，可达的则为存活对象：</p>
<p><img src="/2021/07/11/%E8%AF%AD%E8%A8%80/Java/JVM/Java-JVM-%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0%E6%B3%95%E4%B8%8E%E8%AF%BB%E5%86%99%E5%B1%8F%E9%9A%9C/1.png" alt="1"><br>最终结果：A/D/E/F/G 可达</p>
<p>我们把遍历对象图过程中遇到的对象，按“是否访问过”这个条件标记成以下三种颜色：</p>
<ul>
<li>白色：尚未访问过。</li>
<li>黑色：本对象已访问过，而且本对象 引用到 的其他对象 也全部访问过了。</li>
<li>灰色：本对象已访问过，但是本对象 引用到 的其他对象 尚未全部访问完。全部访问后，会转换为黑色。</li>
</ul>
<p><img src="/2021/07/11/%E8%AF%AD%E8%A8%80/Java/JVM/Java-JVM-%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0%E6%B3%95%E4%B8%8E%E8%AF%BB%E5%86%99%E5%B1%8F%E9%9A%9C/2.webp" alt="2"><br>三色标记遍历过程</p>
<p>假设现在有白、灰、黑三个集合（表示当前对象的颜色），其遍历访问过程为：</p>
<ol>
<li>初始时，所有对象都在 【白色集合】中；</li>
<li>将GC Roots 直接引用到的对象 挪到 【灰色集合】中；</li>
<li>从灰色集合中获取对象：<ol>
<li>将本对象 引用到的 其他对象 全部挪到 【灰色集合】中；</li>
<li>将本对象 挪到 【黑色集合】里面。</li>
</ol>
</li>
<li>重复步骤3，直至【灰色集合】为空时结束。</li>
<li>结束后，仍在【白色集合】的对象即为GC Roots 不可达，可以进行回收。</li>
</ol>
<blockquote>
<p>注：如果标记结束后对象仍为白色，意味着已经“找不到”该对象在哪了，不可能会再被重新引用。</p>
</blockquote>
<p>当Stop The World （以下简称 STW）时，对象间的引用是不会发生变化的，可以轻松完成标记。</p>
<p>而当需要支持并发标记时，即标记期间应用线程还在继续跑，<strong>对象间的引用可能发生变化，多标和漏标的情况就有可能发生</strong>。</p>
<h3 id="多标-浮动垃圾"><a href="#多标-浮动垃圾" class="headerlink" title="多标-浮动垃圾"></a>多标-浮动垃圾</h3><p>假设已经遍历到E（变为灰色了），此时应用执行了 <code>objD.fieldE = null</code>：</p>
<p><img src="/2021/07/11/%E8%AF%AD%E8%A8%80/Java/JVM/Java-JVM-%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0%E6%B3%95%E4%B8%8E%E8%AF%BB%E5%86%99%E5%B1%8F%E9%9A%9C/3.webp" alt="3"><br>D &gt; E 的引用断开</p>
<p>此刻之后，对象E/F/G是“应该”被回收的。然而因为<strong>E已经变为灰色</strong>了，其仍会被<strong>当作存活对象</strong>继续遍历下去。最终的结果是：这部分对象仍会被标记为存活，即<strong>本轮GC不会回收这部分内存</strong>。</p>
<p>这部分本应该回收 但是 没有回收到的内存，被称之为“<strong>浮动垃圾</strong>”。浮动垃圾并不会影响应用程序的正确性，只是需要等到下一轮垃圾回收中才被清除。</p>
<p>另外，针对并发标记开始后的<strong>新对象</strong>，通常的做法是直接全部<strong>当成黑色</strong>，本轮不会进行清除。这部分对象期间可能会变为垃圾，这也算是浮动垃圾的一部分。</p>
<h3 id="漏标-读写屏障"><a href="#漏标-读写屏障" class="headerlink" title="漏标-读写屏障"></a>漏标-读写屏障</h3><p>假设GC线程已经遍历到E（变为灰色了），此时应用线程先执行了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var G = objE.fieldG; </span><br><span class="line">objE.fieldG = null;  // 灰色E 断开引用 白色G </span><br><span class="line">objD.fieldG = G;  // 黑色D 引用 白色G</span><br></pre></td></tr></table></figure>

<p><img src="/2021/07/11/%E8%AF%AD%E8%A8%80/Java/JVM/Java-JVM-%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0%E6%B3%95%E4%B8%8E%E8%AF%BB%E5%86%99%E5%B1%8F%E9%9A%9C/4.webp" alt="4"><br>E &gt; G 断开，D引用 G</p>
<p>此时切回GC线程继续跑，因为<strong>E已经没有对G的引用了，所以不会将G放到灰色集合</strong>；尽管因为D重新引用了G，但因为<strong>D已经是黑色</strong>了，不会再重新做遍历处理。</p>
<p>最终导致的结果是：G会一直停留在白色集合中，<strong>最后被当作垃圾进行清除</strong>。这直接<strong>影响到了应用程序的正确性</strong>，是不可接受的。</p>
<p>不难分析，漏标只有<strong>同时满足</strong>以下两个条件时才会发生：</p>
<ol>
<li>条件一：灰色对象 断开了 白色对象的引用（直接或间接的引用）；即灰色对象 原来成员变量的引用 发生了变化。</li>
<li>条件二：黑色对象 重新引用了 该白色对象；即黑色对象 成员变量增加了 新的引用。</li>
</ol>
<p>从代码的角度看：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var G = objE.fieldG; // 1.读</span><br><span class="line">objE.fieldG = null;  // 2.写</span><br><span class="line">objD.fieldG = G;     // 3.写</span><br></pre></td></tr></table></figure>

<ol>
<li>读取 对象E的成员变量fieldG的引用值，即对象G；</li>
<li>对象E 往其成员变量fieldG，写入 null值。</li>
<li>对象D 往其成员变量fieldG，写入 对象G ；</li>
</ol>
<p>我们只要在上面这三步中的任意一步中做一些“手脚”，<strong>将对象G记录起来，然后作为灰色对象再进行遍历</strong>即可。比如放到一个特定的集合，等初始的GC Roots遍历完（并发标记），该集合的对象 遍历即可（重新标记）。</p>
<blockquote>
<p><strong>重新标记通常是需要STW的</strong>，因为应用程序一直在跑的话，该集合可能会一直增加新的对象，导致永远都跑不完。当然，并发标记期间也可以将该集合中的大部分先跑了，从而缩短重新标记STW的时间，这个是优化问题了。</p>
</blockquote>
<p>写屏障用于拦截第二和第三步；而读屏障则是拦截第一步。</p>
<p>它们的拦截的目的很简单：就是在读写前后，将对象G给记录下来。</p>
<h4 id="写屏障（Store-Barrier）"><a href="#写屏障（Store-Barrier）" class="headerlink" title="写屏障（Store Barrier）"></a>写屏障（Store Barrier）</h4><p>给某个对象的成员变量赋值时，其底层代码大概长这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* @param field 某对象的成员变量，如 D.fieldG</span><br><span class="line">* @param new_value 新值，如 null</span><br><span class="line">*/</span><br><span class="line">void oop_field_store(oop* field, oop new_value) &#123; </span><br><span class="line">    *field = new_value; // 赋值操作</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>所谓的写屏障，其实就是指在赋值操作前后，加入一些处理（可以参考AOP的概念）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void oop_field_store(oop* field, oop new_value) &#123;  </span><br><span class="line">    pre_write_barrier(field); // 写屏障-写前操作</span><br><span class="line">    *field = new_value; </span><br><span class="line">    post_write_barrier(field, value);  // 写屏障-写后操作</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="写屏障-SATB"><a href="#写屏障-SATB" class="headerlink" title="写屏障 + SATB"></a>写屏障 + SATB</h5><p>当对象E的成员变量的引用发生变化时（<code>objE.fieldG = null;</code>），我们可以利用写屏障，将E原来成员变量的引用对象G记录下来：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void pre_write_barrier(oop* field) &#123;</span><br><span class="line">    oop old_value = *field; // 获取旧值</span><br><span class="line">    remark_set.add(old_value); // 记录 原来的引用对象</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>【当原来成员变量的引用发生变化之前，记录下原来的引用对象】</strong></p>
<p>这种做法的思路是：<strong>尝试保留开始时的对象图，即原始快照（Snapshot At The Beginning，SATB）</strong>，当某个时刻 的GC Roots确定后，当时的对象图就已经确定了。</p>
<p>比如 当时 D是引用着G的，那后续的标记也应该是按照这个时刻的对象图走（D引用着G）。如果期间发生变化，则可以记录起来，保证标记依然按照原本的视图来。</p>
<p>值得一提的是，扫描所有GC Roots 这个操作（即初始标记）通常是需要STW的，否则有可能永远都扫不完，因为并发期间可能增加新的GC Roots。</p>
<blockquote>
<p>SATB破坏了条件一：【灰色对象 断开了 白色对象的引用】，从而保证了不会漏标。</p>
</blockquote>
<p>一点小优化：如果不是处于垃圾回收的并发标记阶段，或者已经被标记过了，其实是没必要再记录了，所以可以加个简单的判断：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void pre_write_barrier(oop* field) &#123;</span><br><span class="line">  // 处于GC并发标记阶段 且 该对象没有被标记（访问）过</span><br><span class="line">  if($gc_phase == GC_CONCURRENT_MARK &amp;&amp; !isMarkd(field)) &#123; </span><br><span class="line">      oop old_value = *field; // 获取旧值</span><br><span class="line">      remark_set.add(old_value); // 记录  原来的引用对象</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="写屏障-增量更新"><a href="#写屏障-增量更新" class="headerlink" title="写屏障 + 增量更新"></a>写屏障 + 增量更新</h5><p>当对象D的成员变量的引用发生变化时（objD.fieldG = G;），我们可以利用写屏障，将D新的成员变量引用对象G记录下来：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void post_write_barrier(oop* field, oop new_value) &#123;  </span><br><span class="line">  if($gc_phase == GC_CONCURRENT_MARK &amp;&amp; !isMarkd(field)) &#123;</span><br><span class="line">      remark_set.add(new_value); // 记录新引用的对象</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>【当有新引用插入进来时，记录下新的引用对象】</strong></p>
<p>这种做法的思路是：不要求保留原始快照，而是<strong>针对新增的引用</strong>，将其记录下来等待遍历，即增量更新（Incremental Update）。</p>
<blockquote>
<p>增量更新破坏了条件二：【黑色对象 重新引用了 该白色对象】，从而保证了不会漏标。</p>
</blockquote>
<h4 id="读屏障（Load-Barrier）"><a href="#读屏障（Load-Barrier）" class="headerlink" title="读屏障（Load Barrier）"></a>读屏障（Load Barrier）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">oop oop_field_load(oop* field) &#123;</span><br><span class="line">    pre_load_barrier(field); // 读屏障-读取前操作</span><br><span class="line">    return *field;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>读屏障是直接针对第一步：<code>var G = objE.fieldG;</code>，当读取成员变量时，一律记录下来：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void pre_load_barrier(oop* field, oop old_value) &#123;  </span><br><span class="line">  if($gc_phase == GC_CONCURRENT_MARK &amp;&amp; !isMarkd(field)) &#123;</span><br><span class="line">      oop old_value = *field;</span><br><span class="line">      remark_set.add(old_value); // 记录读取到的对象</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种做法是保守的，但也是安全的。因为条件二中【黑色对象 重新引用了 该白色对象】，重新引用的前提是：得获取到该白色对象，此时已经读屏障就发挥作用了。</p>
<h3 id="三色标记法与现代垃圾回收器"><a href="#三色标记法与现代垃圾回收器" class="headerlink" title="三色标记法与现代垃圾回收器"></a>三色标记法与现代垃圾回收器</h3><p>现代追踪式（可达性分析）的垃圾回收器几乎都借鉴了三色标记的算法思想，尽管实现的方式不尽相同：比如白色/黑色集合一般都不会出现（但是有其他体现颜色的地方）、灰色集合可以通过栈/队列/缓存日志等方式进行实现、遍历方式可以是广度/深度遍历等等。</p>
<p>对于读写屏障，以Java HotSpot VM为例，其并发标记时对漏标的处理方案如下：</p>
<ul>
<li>CMS：写屏障 + 增量更新</li>
<li>G1：写屏障 + SATB</li>
<li>ZGC：读屏障</li>
</ul>
<p>工程实现中，读写屏障还有其他功能，比如写屏障可以用于记录跨代/区引用的变化，读屏障可以用于支持移动对象的并发执行等。功能之外，还有性能的考虑，所以对于选择哪种，每款垃圾回收器都有自己的想法。</p>
<p>值得注意的是，CMS中使用的增量更新，在重新标记阶段，除了需要遍历 写屏障的记录，还需要重新扫描遍历GC Roots（当然标记过的无需再遍历了），这是由于CMS对于astore_x等指令不添加写屏障的原因，具体可参考<a target="_blank" rel="noopener" href="https://hllvm-group.iteye.com/group/topic/44529">这里</a>。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wetts.github.io/2021/07/11/%E5%B7%A5%E7%A8%8B/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81-Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Zhang Wetts">
      <meta itemprop="description" content="Stay Hungry, Stay Foolish. <br><br><p style="font-size:8px;">[build by hexo/next/gitalk/hexo-generator-search/LaTeX]</p>">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wetts's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/11/%E5%B7%A5%E7%A8%8B/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81-Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/" class="post-title-link" itemprop="url">分布式锁-Redis分布式锁.md</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-07-11 16:23:46" itemprop="dateCreated datePublished" datetime="2021-07-11T16:23:46+08:00">2021-07-11</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/" itemprop="url" rel="index"><span itemprop="name">分布式</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>转自：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/s8xjm1ZCKIoTGT3DCVA4aw">https://mp.weixin.qq.com/s/s8xjm1ZCKIoTGT3DCVA4aw</a></p>
<p><img src="/2021/07/11/%E5%B7%A5%E7%A8%8B/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81-Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/1.jpg" alt="1"></p>
<h2 id="为什么需要分布式锁？"><a href="#为什么需要分布式锁？" class="headerlink" title="为什么需要分布式锁？"></a>为什么需要分布式锁？</h2><p>在开始讲分布式锁之前，有必要简单介绍一下，为什么需要分布式锁？</p>
<p>与分布式锁相对应的是「单机锁」，我们在写多线程程序时，避免同时操作一个共享变量产生数据问题，通常会使用一把锁来「互斥」，以保证共享变量的正确性，其使用范围是在「同一个进程」中。</p>
<p>如果换做是多个进程，需要同时操作一个共享资源，如何互斥呢？</p>
<p>例如，现在的业务应用通常都是微服务架构，这也意味着一个应用会部署多个进程，那这多个进程如果需要修改 MySQL 中的同一行记录时，为了避免操作乱序导致数据错误，此时，我们就需要引入「分布式锁」来解决这个问题了。</p>
<p><img src="/2021/07/11/%E5%B7%A5%E7%A8%8B/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81-Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/2.png" alt="2"></p>
<p>想要实现分布式锁，必须借助一个外部系统，所有进程都去这个系统上申请「加锁」。</p>
<p>而这个外部系统，必须要实现「互斥」的能力，即两个请求同时进来，只会给一个进程返回成功，另一个返回失败（或等待）。</p>
<p>这个外部系统，可以是 MySQL，也可以是 Redis 或 Zookeeper。但为了追求更好的性能，我们通常会选择使用 Redis 或 Zookeeper 来做。</p>
<p>下面我就以 Redis 为主线，由浅入深，带你深度剖析一下，分布式锁的各种「安全性」问题，帮你彻底理解分布式锁。</p>
<h2 id="分布式锁怎么实现？"><a href="#分布式锁怎么实现？" class="headerlink" title="分布式锁怎么实现？"></a>分布式锁怎么实现？</h2><p>我们从最简单的开始讲起。</p>
<p>想要实现分布式锁，必须要求 Redis 有「互斥」的能力，我们可以使用 SETNX 命令，这个命令表示SET if Not eXists，即如果 key 不存在，才会设置它的值，否则什么也不做。</p>
<p>两个客户端进程可以执行这个命令，达到互斥，就可以实现一个分布式锁。</p>
<p>客户端 1 申请加锁，加锁成功：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; SETNX lock 1</span><br><span class="line">(integer) 1     // 客户端1，加锁成功</span><br></pre></td></tr></table></figure>
<p>客户端 2 申请加锁，因为它后到达，加锁失败：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; SETNX lock 1</span><br><span class="line">(integer) 0     // 客户端2，加锁失败</span><br></pre></td></tr></table></figure>
<p>此时，加锁成功的客户端，就可以去操作「共享资源」，例如，修改 MySQL 的某一行数据，或者调用一个 API 请求。</p>
<p>操作完成后，还要及时释放锁，给后来者让出操作共享资源的机会。如何释放锁呢？</p>
<p>也很简单，直接使用 DEL 命令删除这个 key 即可：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; DEL lock // 释放锁</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure>
<p>这个逻辑非常简单，整体的路程就是这样：<br><img src="/2021/07/11/%E5%B7%A5%E7%A8%8B/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81-Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/3.png" alt="3"><br>但是，它存在一个很大的问题，当客户端 1 拿到锁后，如果发生下面的场景，就会造成「死锁」：</p>
<ol>
<li>程序处理业务逻辑异常，没及时释放锁</li>
<li>进程挂了，没机会释放锁</li>
</ol>
<p>这时，这个客户端就会一直占用这个锁，而其它客户端就「永远」拿不到这把锁了。</p>
<p>怎么解决这个问题呢？</p>
<h2 id="如何避免死锁？"><a href="#如何避免死锁？" class="headerlink" title="如何避免死锁？"></a>如何避免死锁？</h2><p>我们很容易想到的方案是，在申请锁时，给这把锁设置一个「租期」。</p>
<p>在 Redis 中实现时，就是给这个 key 设置一个「过期时间」。这里我们假设，操作共享资源的时间不会超过 10s，那么在加锁时，给这个 key 设置 10s 过期即可：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; SETNX lock 1    // 加锁</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; EXPIRE lock 10  // 10s后自动过期</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure>
<p>这样一来，无论客户端是否异常，这个锁都可以在 10s 后被「自动释放」，其它客户端依旧可以拿到锁。</p>
<p>但这样真的没问题吗？</p>
<p>还是有问题。</p>
<p>现在的操作，加锁、设置过期是 2 条命令，有没有可能只执行了第一条，第二条却「来不及」执行的情况发生呢？例如：</p>
<ol>
<li>SETNX 执行成功，执行 EXPIRE 时由于网络问题，执行失败</li>
<li>SETNX 执行成功，Redis 异常宕机，EXPIRE 没有机会执行</li>
<li>SETNX 执行成功，客户端异常崩溃，EXPIRE 也没有机会执行<br>总之，这两条命令不能保证是原子操作（一起成功），就有潜在的风险导致过期时间设置失败，依旧发生「死锁」问题。</li>
</ol>
<p>怎么办？</p>
<p>在 Redis 2.6.12 版本之前，我们需要想尽办法，保证 SETNX 和 EXPIRE 原子性执行，还要考虑各种异常情况如何处理。</p>
<p>但在 Redis 2.6.12 之后，Redis 扩展了 SET 命令的参数，用这一条命令就可以了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 一条命令保证原子性执行</span><br><span class="line">127.0.0.1:6379&gt; SET lock 1 EX 10 NX</span><br><span class="line">OK</span><br></pre></td></tr></table></figure>
<p>这样就解决了死锁问题，也比较简单。</p>
<p>我们再来看分析下，它还有什么问题？</p>
<p>试想这样一种场景：</p>
<ol>
<li>客户端 1 加锁成功，开始操作共享资源</li>
<li>客户端 1 操作共享资源的时间，「超过」了锁的过期时间，锁被「自动释放」</li>
<li>客户端 2 加锁成功，开始操作共享资源</li>
<li>客户端 1 操作共享资源完成，释放锁（但释放的是客户端 2 的锁）</li>
</ol>
<p>看到了么，这里存在两个严重的问题：</p>
<ol>
<li>锁过期：客户端 1 操作共享资源耗时太久，导致锁被自动释放，之后被客户端 2 持有</li>
<li>释放别人的锁：客户端 1 操作共享资源完成后，却又释放了客户端 2 的锁</li>
</ol>
<p>导致这两个问题的原因是什么？我们一个个来看。</p>
<p><strong>第一个问题，可能是我们评估操作共享资源的时间不准确导致的。</strong></p>
<p>例如，操作共享资源的时间「最慢」可能需要 15s，而我们却只设置了 10s 过期，那这就存在锁提前过期的风险。</p>
<p>过期时间太短，那增大冗余时间，例如设置过期时间为 20s，这样总可以了吧？</p>
<p>这样确实可以「缓解」这个问题，降低出问题的概率，但依旧无法「彻底解决」问题。</p>
<p>为什么？</p>
<p>原因在于，客户端在拿到锁之后，在操作共享资源时，遇到的场景有可能是很复杂的，例如，程序内部发生异常、网络请求超时等等。</p>
<p>既然是「预估」时间，也只能是大致计算，除非你能预料并覆盖到所有导致耗时变长的场景，但这其实很难。</p>
<p>有什么更好的解决方案吗？</p>
<p>别急，关于这个问题，我会在后面详细来讲对应的解决方案。</p>
<p>我们继续来看第二个问题。</p>
<p><strong>第二个问题在于，一个客户端释放了其它客户端持有的锁。</strong></p>
<p>想一下，导致这个问题的关键点在哪？</p>
<p>重点在于，每个客户端在释放锁时，都是「无脑」操作，并没有检查这把锁是否还「归自己持有」，所以就会发生释放别人锁的风险，这样的解锁流程，很不「严谨」！</p>
<p>如何解决这个问题呢？</p>
<h2 id="锁被别人释放怎么办"><a href="#锁被别人释放怎么办" class="headerlink" title="锁被别人释放怎么办?"></a>锁被别人释放怎么办?</h2><p>解决办法是：客户端在加锁时，设置一个只有自己知道的「唯一标识」进去。</p>
<p>例如，可以是自己的线程 ID，也可以是一个 UUID（随机且唯一），这里我们以 UUID 举例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 锁的VALUE设置为UUID</span><br><span class="line">127.0.0.1:6379&gt; SET lock $uuid EX 20 NX</span><br><span class="line">OK</span><br></pre></td></tr></table></figure>
<p>这里假设 20s 操作共享时间完全足够，先不考虑锁自动过期的问题。</p>
<p>之后，在释放锁时，要先判断这把锁是否还归自己持有，伪代码可以这么写：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 锁是自己的，才释放</span><br><span class="line">if redis.get(&quot;lock&quot;) == $uuid:</span><br><span class="line">    redis.del(&quot;lock&quot;)</span><br></pre></td></tr></table></figure>
<p>这里释放锁使用的是 GET + DEL 两条命令，这时，又会遇到我们前面讲的原子性问题了。</p>
<ol>
<li>客户端 1 执行 GET，判断锁是自己的</li>
<li>客户端 2 执行了 SET 命令，强制获取到锁（虽然发生概率比较低，但我们需要严谨地考虑锁的安全性模型）</li>
<li>客户端 1 执行 DEL，却释放了客户端 2 的锁</li>
</ol>
<p>4由此可见，这两个命令还是必须要原子执行才行。</p>
<p>怎样原子执行呢？Lua 脚本。</p>
<p>我们可以把这个逻辑，写成 Lua 脚本，让 Redis 来执行。</p>
<p>因为 Redis 处理每一个请求是「单线程」执行的，在执行一个 Lua 脚本时，其它请求必须等待，直到这个 Lua 脚本处理完成，这样一来，GET + DEL 之间就不会插入其它命令了。</p>
<p><img src="/2021/07/11/%E5%B7%A5%E7%A8%8B/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81-Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/4.png" alt="4"><br>安全释放锁的 Lua 脚本如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 判断锁是自己的，才释放</span><br><span class="line">if redis.call(&quot;GET&quot;,KEYS[1]) == ARGV[1]</span><br><span class="line">then</span><br><span class="line">    return redis.call(&quot;DEL&quot;,KEYS[1])</span><br><span class="line">else</span><br><span class="line">    return 0</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>好了，这样一路优化，整个的加锁、解锁的流程就更「严谨」了。</p>
<p>这里我们先小结一下，基于 Redis 实现的分布式锁，一个严谨的的流程如下：</p>
<ol>
<li>加锁：SET lock_key $unique_id EX $expire_time NX</li>
<li>操作共享资源</li>
<li>释放锁：Lua 脚本，先 GET 判断锁是否归属自己，再 DEL 释放锁</li>
</ol>
<p><img src="/2021/07/11/%E5%B7%A5%E7%A8%8B/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81-Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/5.png" alt="5"><br>好，有了这个完整的锁模型，让我们重新回到前面提到的第一个问题。</p>
<p>锁过期时间不好评估怎么办？</p>
<h2 id="锁过期时间不好评估怎么办？"><a href="#锁过期时间不好评估怎么办？" class="headerlink" title="锁过期时间不好评估怎么办？"></a>锁过期时间不好评估怎么办？</h2><p>前面我们提到，锁的过期时间如果评估不好，这个锁就会有「提前」过期的风险。</p>
<p>当时给的妥协方案是，尽量「冗余」过期时间，降低锁提前过期的概率。</p>
<p>这个方案其实也不能完美解决问题，那怎么办呢？</p>
<p>是否可以设计这样的方案：<strong>加锁时，先设置一个过期时间，然后我们开启一个「守护线程」，定时去检测这个锁的失效时间，如果锁快要过期了，操作共享资源还未完成，那么就自动对锁进行「续期」，重新设置过期时间。</strong></p>
<p>这确实一种比较好的方案。</p>
<p>如果你是 Java 技术栈，幸运的是，已经有一个库把这些工作都封装好了：<strong>Redisson</strong>。</p>
<p>Redisson 是一个 Java 语言实现的 Redis SDK 客户端，在使用分布式锁时，它就采用了「自动续期」的方案来避免锁过期，这个守护线程我们一般也把它叫做「看门狗」线程。</p>
<p><img src="/2021/07/11/%E5%B7%A5%E7%A8%8B/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81-Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/6.png" alt="6"><br>除此之外，这个 SDK 还封装了很多易用的功能：</p>
<ul>
<li>可重入锁</li>
<li>乐观锁</li>
<li>公平锁</li>
<li>读写锁</li>
<li>Redlock（红锁，下面会详细讲）</li>
</ul>
<p>这个 SDK 提供的 API 非常友好，它可以像操作本地锁的方式，操作分布式锁。如果你是 Java 技术栈，可以直接把它用起来。</p>
<blockquote>
<p>这里不重点介绍 Redisson 的使用，大家可以看官方 Github 学习如何使用，比较简单。</p>
</blockquote>
<p>到这里我们再小结一下，基于 Redis 的实现分布式锁，前面遇到的问题，以及对应的解决方案：</p>
<ul>
<li>死锁：设置过期时间</li>
<li>过期时间评估不好，锁提前过期：守护线程，自动续期</li>
<li>锁被别人释放：锁写入唯一标识，释放锁先检查标识，再释放</li>
</ul>
<p>还有哪些问题场景，会危害 Redis 锁的安全性呢？</p>
<p>之前分析的场景都是，锁在「单个」Redis 实例中可能产生的问题，并没有涉及到 Redis 的部署架构细节。</p>
<p>而我们在使用 Redis 时，一般会采用<strong>主从集群 + 哨兵</strong>的模式部署，这样做的好处在于，当主库异常宕机时，哨兵可以实现「故障自动切换」，把从库提升为主库，继续提供服务，以此保证可用性。</p>
<p>那当「主从发生切换」时，这个分布锁会依旧安全吗？</p>
<p>试想这样的场景：</p>
<ol>
<li>客户端 1 在主库上执行 SET 命令，加锁成功</li>
<li>此时，主库异常宕机，SET 命令还未同步到从库上（主从复制是异步的）</li>
<li>从库被哨兵提升为新主库，这个锁在新的主库上，丢失了！</li>
</ol>
<p><img src="/2021/07/11/%E5%B7%A5%E7%A8%8B/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81-Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/7.png" alt="7"><br>可见，当引入 Redis 副本后，分布锁还是可能会受到影响。</p>
<p>怎么解决这个问题？</p>
<p>为此，Redis 的作者提出一种解决方案，就是我们经常听到的 <strong>Redlock（红锁）</strong>。</p>
<p>它真的可以解决上面这个问题吗？</p>
<h2 id="Redlock-真的安全吗？"><a href="#Redlock-真的安全吗？" class="headerlink" title="Redlock 真的安全吗？"></a>Redlock 真的安全吗？</h2><p>好，终于到了这篇文章的重头戏。啊？上面讲的那么多问题，难道只是基础？</p>
<p>是的，那些只是开胃菜，真正的硬菜，从这里刚刚开始。</p>
<p>如果上面讲的内容，你还没有理解，我建议你重新阅读一遍，先理清整个加锁、解锁的基本流程。</p>
<p>如果你已经对 Redlock 有所了解，这里可以跟着我再复习一遍，如果你不了解 Redlock，没关系，我会带你重新认识它。</p>
<p>值得提醒你的是，<strong>后面我不仅仅是讲 Redlock 的原理，还会引出有关「分布式系统」中的很多问题，你最好跟紧我的思路，在脑中一起分析问题的答案</strong>。</p>
<p>现在我们来看，Redis 作者提出的 Redlock 方案，是如何解决主从切换后，锁失效问题的。</p>
<p>Redlock 的方案基于 2 个前提：</p>
<ol>
<li>不再需要部署<strong>从库</strong>和<strong>哨兵</strong>实例，只部署<strong>主库</strong></li>
<li>但主库要部署多个，官方推荐至少 5 个实例</li>
</ol>
<p>也就是说，想用使用 Redlock，你至少要部署 5 个 Redis 实例，而且都是主库，它们之间没有任何关系，都是一个个孤立的实例。</p>
<blockquote>
<p><strong>注意：不是部署 Redis Cluster，就是部署 5 个简单的 Redis 实例。</strong></p>
</blockquote>
<p><img src="/2021/07/11/%E5%B7%A5%E7%A8%8B/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81-Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/8.png" alt="8"><br>Redlock 具体如何使用呢？</p>
<p>整体的流程是这样的，一共分为 5 步：</p>
<ol>
<li>客户端先获取「当前时间戳T1」</li>
<li>客户端依次向这 5 个 Redis 实例发起加锁请求（用前面讲到的 SET 命令），且每个请求会设置超时时间（毫秒级，要远小于锁的有效时间），如果某一个实例加锁失败（包括网络超时、锁被其它人持有等各种异常情况），就立即向下一个 Redis 实例申请加锁</li>
<li>如果客户端从 &gt;=3 个（大多数）以上 Redis 实例加锁成功，则再次获取「当前时间戳T2」，如果 T2 - T1 &lt; 锁的过期时间，此时，认为客户端加锁成功，否则认为加锁失败</li>
<li>加锁成功，去操作共享资源（例如修改 MySQL 某一行，或发起一个 API 请求）</li>
<li>加锁失败，向「全部节点」发起释放锁请求（前面讲到的 Lua 脚本释放锁）</li>
</ol>
<p>我简单帮你总结一下，有 4 个重点：</p>
<ol>
<li>客户端在多个 Redis 实例上申请加锁</li>
<li>必须保证大多数节点加锁成功</li>
<li>大多数节点加锁的总耗时，要小于锁设置的过期时间</li>
<li>释放锁，要向全部节点发起释放锁请求</li>
</ol>
<p>第一次看可能不太容易理解，建议你把上面的文字多看几遍，加深记忆。</p>
<p>然后，记住这 5 步，非常重要，下面会根据这个流程，剖析各种可能导致锁失效的问题假设。</p>
<p>好，明白了 Redlock 的流程，我们来看 Redlock 为什么要这么做。</p>
<p><strong>1) 为什么要在多个实例上加锁？</strong></p>
<p>本质上是为了「容错」，部分实例异常宕机，剩余的实例加锁成功，整个锁服务依旧可用。</p>
<p><strong>2) 为什么大多数加锁成功，才算成功？</strong></p>
<p>多个 Redis 实例一起来用，其实就组成了一个「分布式系统」。</p>
<p>在分布式系统中，总会出现「异常节点」，所以，在谈论分布式系统问题时，需要考虑异常节点达到多少个，也依旧不会影响整个系统的「正确性」。</p>
<p>这是一个分布式系统「容错」问题，这个问题的结论是：如果只存在「故障」节点，只要大多数节点正常，那么整个系统依旧是可以提供正确服务的。</p>
<blockquote>
<p>这个问题的模型，就是我们经常听到的「拜占庭将军」问题，感兴趣可以去看算法的推演过程。</p>
</blockquote>
<p><strong>3) 为什么步骤 3 加锁成功后，还要计算加锁的累计耗时？</strong></p>
<p>因为操作的是多个节点，所以耗时肯定会比操作单个实例耗时更久，而且，因为是网络请求，网络情况是复杂的，有可能存在延迟、丢包、超时等情况发生，网络请求越多，异常发生的概率就越大。</p>
<p>所以，即使大多数节点加锁成功，但如果加锁的累计耗时已经「超过」了锁的过期时间，那此时有些实例上的锁可能已经失效了，这个锁就没有意义了。</p>
<p><strong>4) 为什么释放锁，要操作所有节点？</strong></p>
<p>在某一个 Redis 节点加锁时，可能因为「网络原因」导致加锁失败。</p>
<p>例如，客户端在一个 Redis 实例上加锁成功，但在读取响应结果时，网络问题导致读取失败，那这把锁其实已经在 Redis 上加锁成功了。</p>
<p>所以，释放锁时，不管之前有没有加锁成功，需要释放「所有节点」的锁，以保证清理节点上「残留」的锁。</p>
<p>好了，明白了 Redlock 的流程和相关问题，看似 Redlock 确实解决了 Redis 节点异常宕机锁失效的问题，保证了锁的「安全性」。</p>
<p>但事实真的如此吗？</p>
<h2 id="Redlock-的争论谁对谁错？"><a href="#Redlock-的争论谁对谁错？" class="headerlink" title="Redlock 的争论谁对谁错？"></a>Redlock 的争论谁对谁错？</h2><p>Redis 作者把这个方案一经提出，就马上受到业界著名的分布式系统专家的质疑！</p>
<p>这个专家叫 Martin，是英国剑桥大学的一名分布式系统研究员。在此之前他曾是软件工程师和企业家，从事大规模数据基础设施相关的工作。它还经常在大会做演讲，写博客，写书，也是开源贡献者。</p>
<p><img src="/2021/07/11/%E5%B7%A5%E7%A8%8B/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81-Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/9.png" alt="9"></p>
<p>他马上写了篇文章，质疑这个 Redlock 的算法模型是有问题的，并对分布式锁的设计，提出了自己的看法。</p>
<p>之后，Redis 作者 Antirez 面对质疑，不甘示弱，也写了一篇文章，反驳了对方的观点，并详细剖析了 Redlock 算法模型的更多设计细节。</p>
<p>而且，关于这个问题的争论，在当时互联网上也引起了非常激烈的讨论。</p>
<p><strong>二人思路清晰，论据充分，这是一场高手过招，也是分布式系统领域非常好的一次思想的碰撞！双方都是分布式系统领域的专家，却对同一个问题提出很多相反的论断，究竟是怎么回事？</strong></p>
<p>下面我会从他们的争论文章中，提取重要的观点，整理呈现给你。</p>
<blockquote>
<p>提醒：后面的信息量极大，可能不宜理解，最好放慢速度阅读。</p>
</blockquote>
<h3 id="分布式专家-Martin-对于-Relock-的质疑"><a href="#分布式专家-Martin-对于-Relock-的质疑" class="headerlink" title="分布式专家 Martin 对于 Relock 的质疑"></a>分布式专家 Martin 对于 Relock 的质疑</h3><p>在他的文章中，主要阐述了 4 个论点：</p>
<p><strong>1) 分布式锁的目的是什么？</strong></p>
<p>Martin 表示，你必须先清楚你在使用分布式锁的目的是什么？</p>
<p>他认为有两个目的。</p>
<p><strong>第一，效率。</strong></p>
<p>使用分布式锁的互斥能力，是避免不必要地做同样的两次工作（例如一些昂贵的计算任务）。如果锁失效，并不会带来「恶性」的后果，例如发了 2 次邮件等，无伤大雅。</p>
<p><strong>第二，正确性。</strong></p>
<p>使用锁用来防止并发进程互相干扰。如果锁失效，会造成多个进程同时操作同一条数据，产生的后果是数据严重错误、永久性不一致、数据丢失等恶性问题，就像给患者服用了重复剂量的药物，后果很严重。</p>
<p>他认为，如果你是为了前者——效率，那么使用单机版 Redis 就可以了，即使偶尔发生锁失效（宕机、主从切换），都不会产生严重的后果。而使用 Redlock 太重了，没必要。</p>
<p>而如果是为了正确性，Martin 认为 Redlock 根本达不到安全性的要求，也依旧存在锁失效的问题！</p>
<p><strong>2) 锁在分布式系统中会遇到的问题</strong></p>
<p>Martin 表示，一个分布式系统，更像一个复杂的「野兽」，存在着你想不到的各种异常情况。</p>
<p>这些异常场景主要包括三大块，这也是分布式系统会遇到的三座大山：NPC。</p>
<ul>
<li>N：Network Delay，网络延迟</li>
<li>P：Process Pause，进程暂停（GC）</li>
<li>C：Clock Drift，时钟漂移</li>
</ul>
<p>Martin 用一个进程暂停（GC）的例子，指出了 Redlock 安全性问题：</p>
<ol>
<li>客户端 1 请求锁定节点 A、B、C、D、E</li>
<li>客户端 1 的拿到锁后，进入 GC（时间比较久）</li>
<li>所有 Redis 节点上的锁都过期了</li>
<li>客户端 2 获取到了 A、B、C、D、E 上的锁</li>
<li>客户端 1 GC 结束，认为成功获取锁</li>
<li>客户端 2 也认为获取到了锁，发生「冲突」</li>
</ol>
<p><img src="/2021/07/11/%E5%B7%A5%E7%A8%8B/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81-Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/10.png" alt="10"><br>Martin 认为，GC 可能发生在程序的任意时刻，而且执行时间是不可控的。</p>
<blockquote>
<p>注：当然，即使是使用没有 GC 的编程语言，在发生网络延迟、时钟漂移时，也都有可能导致 Redlock 出现问题，这里 Martin 只是拿 GC 举例。</p>
</blockquote>
<p><strong>3) 假设时钟正确的是不合理的</strong></p>
<p>又或者，当多个 Redis 节点「时钟」发生问题时，也会导致 Redlock 锁失效。</p>
<ol>
<li>客户端 1 获取节点 A、B、C 上的锁，但由于网络问题，无法访问 D 和 E</li>
<li>节点 C 上的时钟「向前跳跃」，导致锁到期</li>
<li>客户端 2 获取节点 C、D、E 上的锁，由于网络问题，无法访问 A 和 B</li>
<li>客户端 1 和 2 现在都相信它们持有了锁（冲突）</li>
</ol>
<p>Martin 觉得，Redlock 必须「强依赖」多个节点的时钟是保持同步的，一旦有节点时钟发生错误，那这个算法模型就失效了。</p>
<p>即使 C 不是时钟跳跃，而是「崩溃后立即重启」，也会发生类似的问题。</p>
<p>Martin 继续阐述，机器的时钟发生错误，是很有可能发生的：</p>
<ol>
<li>系统管理员「手动修改」了机器时钟</li>
<li>机器时钟在同步 NTP 时间时，发生了大的「跳跃」</li>
</ol>
<p>总之，Martin 认为，Redlock 的算法是建立在「同步模型」基础上的，有大量资料研究表明，同步模型的假设，在分布式系统中是有问题的。</p>
<p>在混乱的分布式系统的中，你不能假设系统时钟就是对的，所以，你必须非常小心你的假设。</p>
<p><strong>4) 提出 fecing token 的方案，保证正确性</strong></p>
<p>相对应的，Martin 提出一种被叫作 fecing token 的方案，保证分布式锁的正确性。</p>
<p>这个模型流程如下：</p>
<ol>
<li>客户端在获取锁时，锁服务可以提供一个「递增」的 token</li>
<li>客户端拿着这个 token 去操作共享资源</li>
<li>共享资源可以根据 token 拒绝「后来者」的请求</li>
</ol>
<p><img src="/2021/07/11/%E5%B7%A5%E7%A8%8B/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81-Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/11.png" alt="11"><br>这样一来，无论 NPC 哪种异常情况发生，都可以保证分布式锁的安全性，因为它是建立在「异步模型」上的。</p>
<p>而 Redlock 无法提供类似 fecing token 的方案，所以它无法保证安全性。</p>
<p>他还表示，<strong>一个好的分布式锁，无论 NPC 怎么发生，可以不在规定时间内给出结果，但并不会给出一个错误的结果。也就是只会影响到锁的「性能」（或称之为活性），而不会影响它的「正确性」</strong>。</p>
<p>Martin 的结论：</p>
<ol>
<li><strong>Redlock 不伦不类</strong>：它对于效率来讲，Redlock 比较重，没必要这么做，而对于正确性来说，Redlock 是不够安全的。</li>
<li><strong>时钟假设不合理</strong>：该算法对系统时钟做出了危险的假设（假设多个节点机器时钟都是一致的），如果不满足这些假设，锁就会失效。</li>
<li><strong>无法保证正确性</strong>：Redlock 不能提供类似 fencing token 的方案，所以解决不了正确性的问题。为了正确性，请使用有「共识系统」的软件，例如 Zookeeper。</li>
</ol>
<p>好了，以上就是 Martin 反对使用 Redlock 的观点，看起来有理有据。</p>
<p>下面我们来看 Redis 作者 Antirez 是如何反驳的。</p>
<h3 id="Redis-作者-Antirez-的反驳"><a href="#Redis-作者-Antirez-的反驳" class="headerlink" title="Redis 作者 Antirez 的反驳"></a>Redis 作者 Antirez 的反驳</h3><p>在 Redis 作者的文章中，重点有 3 个：</p>
<p><strong>1) 解释时钟问题</strong></p>
<p>首先，Redis 作者一眼就看穿了对方提出的最为核心的问题：时钟问题。</p>
<p>Redis 作者表示，Redlock 并不需要完全一致的时钟，只需要大体一致就可以了，允许有「误差」。</p>
<p>例如要计时 5s，但实际可能记了 4.5s，之后又记了 5.5s，有一定误差，但只要不超过「误差范围」锁失效时间即可，这种对于时钟的精度要求并不是很高，而且这也符合现实环境。</p>
<p>对于对方提到的「时钟修改」问题，Redis 作者反驳到：</p>
<ol>
<li>手动修改时钟：不要这么做就好了，否则你直接修改 Raft 日志，那 Raft 也会无法工作…</li>
<li>时钟跳跃：通过「恰当的运维」，保证机器时钟不会大幅度跳跃（每次通过微小的调整来完成），实际上这是可以做到的</li>
</ol>
<blockquote>
<p>为什么 Redis 作者优先解释时钟问题？因为在后面的反驳过程中，需要依赖这个基础做进一步解释。</p>
</blockquote>
<p><strong>2) 解释网络延迟、GC 问题</strong></p>
<p>之后，Redis 作者对于对方提出的，网络延迟、进程 GC 可能导致 Redlock 失效的问题，也做了反驳：</p>
<p>我们重新回顾一下，Martin 提出的问题假设：</p>
<ol>
<li>客户端 1 请求锁定节点 A、B、C、D、E</li>
<li>客户端 1 的拿到锁后，进入 GC</li>
<li>所有 Redis 节点上的锁都过期了</li>
<li>客户端 2 获取节点 A、B、C、D、E 上的锁</li>
<li>客户端 1 GC 结束，认为成功获取锁</li>
<li>客户端 2 也认为获取到锁，发生「冲突」</li>
</ol>
<p><img src="/2021/07/11/%E5%B7%A5%E7%A8%8B/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81-Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/10.png" alt="10"><br>Redis 作者反驳到，这个假设其实是有问题的，Redlock 是可以保证锁安全的。</p>
<p>这是怎么回事呢？</p>
<p>还记得前面介绍 Redlock 流程的那 5 步吗？这里我再拿过来让你复习一下。</p>
<ol>
<li>客户端先获取「当前时间戳T1」</li>
<li>客户端依次向这 5 个 Redis 实例发起加锁请求（用前面讲到的 SET 命令），且每个请求会设置超时时间（毫秒级，要远小于锁的有效时间），如果某一个实例加锁失败（包括网络超时、锁被其它人持有等各种异常情况），就立即向下一个 Redis 实例申请加锁</li>
<li>如果客户端从 3 个（大多数）以上 Redis 实例加锁成功，则再次获取「当前时间戳T2」，如果 T2 - T1 &lt; 锁的过期时间，此时，认为客户端加锁成功，否则认为加锁失败</li>
<li>加锁成功，去操作共享资源（例如修改 MySQL 某一行，或发起一个 API 请求）</li>
<li>加锁失败，向「全部节点」发起释放锁请求（前面讲到的 Lua 脚本释放锁）</li>
</ol>
<p><strong>注意，重点是 1-3，在步骤 3，加锁成功后为什么要重新获取「当前时间戳T2」？还用 T2 - T1 的时间，与锁的过期时间做比较？</strong></p>
<p>Redis 作者强调：如果在 1-3 发生了网络延迟、进程 GC 等耗时长的异常情况，那在第 3 步 T2 - T1，是可以检测出来的，如果超出了锁设置的过期时间，那这时就认为加锁会失败，之后释放所有节点的锁就好了！</p>
<p>Redis 作者继续论述，如果对方认为，发生网络延迟、进程 GC 是在步骤 3 之后，也就是客户端确认拿到了锁，去操作共享资源的途中发生了问题，导致锁失效，那这<strong>不止是 Redlock 的问题，任何其它锁服务例如 Zookeeper，都有类似的问题，这不在讨论范畴内</strong>。</p>
<p>这里我举个例子解释一下这个问题：</p>
<ol>
<li>客户端通过 Redlock 成功获取到锁（通过了大多数节点加锁成功、加锁耗时检查逻辑）</li>
<li>客户端开始操作共享资源，此时发生网络延迟、进程 GC 等耗时很长的情况</li>
<li>此时，锁过期自动释放</li>
<li>客户端开始操作 MySQL（此时的锁可能会被别人拿到，锁失效）</li>
</ol>
<p>Redis 作者这里的结论就是：</p>
<ul>
<li>客户端在拿到锁之前，无论经历什么耗时长问题，Redlock 都能够在第 3 步检测出来</li>
<li>客户端在拿到锁之后，发生 NPC，那 Redlock、Zookeeper 都无能为力</li>
</ul>
<p>所以，Redis 作者认为 Redlock 在保证时钟正确的基础上，是可以保证正确性的。</p>
<p><strong>3) 质疑 fencing token 机制</strong></p>
<p>Redis 作者对于对方提出的 fecing token 机制，也提出了质疑，主要分为 2 个问题，这里最不宜理解，请跟紧我的思路。</p>
<p><strong>第一</strong>，这个方案必须要求要操作的「共享资源服务器」有拒绝「旧 token」的能力。</p>
<p>例如，要操作 MySQL，从锁服务拿到一个递增数字的 token，然后客户端要带着这个 token 去改 MySQL 的某一行，这就需要利用 MySQL 的「事物隔离性」来做。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 两个客户端必须利用事物和隔离性达到目的</span><br><span class="line">// 注意 token 的判断条件</span><br><span class="line">UPDATE table T SET val = $new_val WHERE id = $id AND current_token &lt; $token</span><br></pre></td></tr></table></figure>

<p>但如果操作的不是 MySQL 呢？例如向磁盘上写一个文件，或发起一个 HTTP 请求，那这个方案就无能为力了，这对要操作的资源服务器，提出了更高的要求。</p>
<p>也就是说，大部分要操作的资源服务器，都是没有这种互斥能力的。</p>
<p><strong>再者，既然资源服务器都有了「互斥」能力，那还要分布式锁干什么？</strong></p>
<p>所以，Redis 作者认为这个方案是站不住脚的。</p>
<p><strong>第二</strong>，退一步讲，即使 Redlock 没有提供 fecing token 的能力，但 Redlock 已经提供了随机值（就是前面讲的 UUID），利用这个随机值，也可以达到与 fecing token 同样的效果。</p>
<p>如何做呢？</p>
<blockquote>
<p>Redis 作者只是提到了可以完成 fecing token 类似的功能，但却没有展开相关细节，根据我查阅的资料，大概流程应该如下，如有错误，欢迎交流~</p>
</blockquote>
<ol>
<li>客户端使用 Redlock 拿到锁</li>
<li>客户端在操作共享资源之前，先把这个锁的 VALUE，在要操作的共享资源上做标记</li>
<li>客户端处理业务逻辑，最后，在修改共享资源时，判断这个标记是否与之前一样，一样才修改（类似 CAS 的思路）</li>
</ol>
<p>还是以 MySQL 为例，举个例子就是这样的：</p>
<ol>
<li>客户端使用 Redlock 拿到锁</li>
<li>客户端要修改 MySQL 表中的某一行数据之前，先把锁的 VALUE 更新到这一行的某个字段中（这里假设为 current_token 字段)</li>
<li>客户端处理业务逻辑</li>
<li>客户端修改 MySQL 的这一行数据，把 VALUE 当做 WHERE 条件，再修改<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UPDATE table T SET val = $new_val WHERE id = $id AND current_token = $redlock_value</span><br></pre></td></tr></table></figure></li>
</ol>
<p>可见，这种方案依赖 MySQL 的事物机制，也达到对方提到的 fecing token 一样的效果。</p>
<p>但这里还有个小问题，是网友参与问题讨论时提出的：<strong>两个客户端通过这种方案，先「标记」再「检查+修改」共享资源，那这两个客户端的操作顺序无法保证啊？</strong></p>
<p>而用 Martin 提到的 fecing token，因为这个 token 是单调递增的数字，资源服务器可以拒绝小的 token 请求，保证了操作的「顺序性」！</p>
<p>Redis 作者对这问题做了不同的解释，我觉得很有道理，他解释道：<strong>分布式锁的本质，是为了「互斥」，只要能保证两个客户端在并发时，一个成功，一个失败就好了，不需要关心「顺序性」</strong>。</p>
<p>前面 Martin 的质疑中，一直很关心这个顺序性问题，但 Redis 的作者的看法却不同。</p>
<p>综上，Redis 作者的结论：</p>
<ol>
<li>作者同意对方关于「时钟跳跃」对 Redlock 的影响，但认为时钟跳跃是可以避免的，取决于基础设施和运维。</li>
<li>Redlock 在设计时，充分考虑了 NPC 问题，在 Redlock 步骤 3 之前出现 NPC，可以保证锁的正确性，但在步骤 3 之后发生 NPC，不止是 Redlock 有问题，其它分布式锁服务同样也有问题，所以不在讨论范畴内。</li>
</ol>
<p>是不是觉得很有意思？</p>
<p>在分布式系统中，一个小小的锁，居然可能会遇到这么多问题场景，影响它的安全性！</p>
<p>不知道你看完双方的观点，更赞同哪一方的说法呢？</p>
<p>别急，后面我还会综合以上论点，谈谈自己的理解。</p>
<p>好，讲完了双方对于 Redis 分布锁的争论，你可能也注意到了，Martin 在他的文章中，推荐使用 Zookeeper 实现分布式锁，认为它更安全，确实如此吗？</p>
<h2 id="基于-Zookeeper-的锁安全吗？"><a href="#基于-Zookeeper-的锁安全吗？" class="headerlink" title="基于 Zookeeper 的锁安全吗？"></a>基于 Zookeeper 的锁安全吗？</h2><p>如果你有了解过 Zookeeper，基于它实现的分布式锁是这样的：</p>
<ol>
<li>客户端 1 和 2 都尝试创建「临时节点」，例如 /lock</li>
<li>假设客户端 1 先到达，则加锁成功，客户端 2 加锁失败</li>
<li>客户端 1 操作共享资源</li>
<li>客户端 1 删除 /lock 节点，释放锁</li>
</ol>
<p>你应该也看到了，Zookeeper 不像 Redis 那样，需要考虑锁的过期时间问题，它是采用了「临时节点」，保证客户端 1 拿到锁后，只要连接不断，就可以一直持有锁。</p>
<p>而且，如果客户端 1 异常崩溃了，那么这个临时节点会自动删除，保证了锁一定会被释放。</p>
<p><strong>不错，没有锁过期的烦恼，还能在异常时自动释放锁，是不是觉得很完美？</strong></p>
<p>其实不然。</p>
<p>思考一下，客户端 1 创建临时节点后，Zookeeper 是如何保证让这个客户端一直持有锁呢？</p>
<p>原因就在于，<strong>客户端 1 此时会与 Zookeeper 服务器维护一个 Session，这个 Session 会依赖客户端「定时心跳」来维持连接</strong>。</p>
<p>如果 Zookeeper 长时间收不到客户端的心跳，就认为这个 Session 过期了，也会把这个临时节点删除。</p>
<p><img src="/2021/07/11/%E5%B7%A5%E7%A8%8B/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81-Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/12.png" alt="12"><br>同样地，基于此问题，我们也讨论一下 GC 问题对 Zookeeper 的锁有何影响：</p>
<ol>
<li>客户端 1 创建临时节点 /lock 成功，拿到了锁</li>
<li>客户端 1 发生长时间 GC</li>
<li>客户端 1 无法给 Zookeeper 发送心跳，Zookeeper 把临时节点「删除」</li>
<li>客户端 2 创建临时节点 /lock 成功，拿到了锁</li>
<li>客户端 1 GC 结束，它仍然认为自己持有锁（冲突）</li>
</ol>
<p>可见，即使是使用 Zookeeper，也无法保证进程 GC、网络延迟异常场景下的安全性。</p>
<p><strong>这就是前面 Redis 作者在反驳的文章中提到的：如果客户端已经拿到了锁，但客户端与锁服务器发生「失联」（例如 GC），那不止 Redlock 有问题，其它锁服务都有类似的问题，Zookeeper 也是一样！</strong></p>
<p>所以，这里我们就能得出结论了：<strong>一个分布式锁，在极端情况下，不一定是安全的</strong>。</p>
<p>如果你的业务数据非常敏感，在使用分布式锁时，一定要注意这个问题，不能假设分布式锁 100% 安全。</p>
<p>好，现在我们来总结一下 Zookeeper 在使用分布式锁时优劣：</p>
<p>Zookeeper 的优点：</p>
<ol>
<li>不需要考虑锁的过期时间</li>
<li>watch 机制，加锁失败，可以 watch 等待锁释放，实现乐观锁</li>
</ol>
<p>但它的劣势是：</p>
<ol>
<li>性能不如 Redis</li>
<li>部署和运维成本高</li>
<li>客户端与 Zookeeper 的长时间失联，锁被释放问题</li>
</ol>
<h2 id="我对分布式锁的理解"><a href="#我对分布式锁的理解" class="headerlink" title="我对分布式锁的理解"></a>我对分布式锁的理解</h2><p>好了，前面详细介绍了基于 Redis 的 Redlock 和 Zookeeper 实现的分布锁，在各种异常情况下的安全性问题，下面我想和你聊一聊我的看法，仅供参考，不喜勿喷。</p>
<p><strong>1) 到底要不要用 Redlock？</strong></p>
<p>前面也分析了，Redlock 只有建立在「时钟正确」的前提下，才能正常工作，如果你可以保证这个前提，那么可以拿来使用。</p>
<p>但保证时钟正确，我认为并不是你想的那么简单就能做到的。</p>
<p><strong>第一，从硬件角度来说</strong>，时钟发生偏移是时有发生，无法避免。</p>
<p>例如，CPU 温度、机器负载、芯片材料都是有可能导致时钟发生偏移的。</p>
<p><strong>第二，从我的工作经历来说</strong>，曾经就遇到过时钟错误、运维暴力修改时钟的情况发生，进而影响了系统的正确性，所以，人为错误也是很难完全避免的。</p>
<p>所以，我对 Redlock 的个人看法是，尽量不用它，而且它的性能不如单机版 Redis，部署成本也高，我还是会优先考虑使用主从+ 哨兵的模式 实现分布式锁。</p>
<p>那正确性如何保证呢？第二点给你答案。</p>
<p><strong>2) 如何正确使用分布式锁？</strong></p>
<p>在分析 Martin 观点时，它提到了 fecing token 的方案，给我了很大的启发，虽然这种方案有很大的局限性，但对于保证「正确性」的场景，是一个非常好的思路。</p>
<p>所以，我们可以把这两者结合起来用：</p>
<ol>
<li>使用分布式锁，在上层完成「互斥」目的，虽然极端情况下锁会失效，但它可以最大程度把并发请求阻挡在最上层，减轻操作资源层的压力。</li>
<li>但对于要求数据绝对正确的业务，在资源层一定要做好「兜底」，设计思路可以借鉴 fecing token 的方案来做。</li>
</ol>
<p>两种思路结合，我认为对于大多数业务场景，已经可以满足要求了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>好了，总结一下。</p>
<p>这篇文章，我们主要探讨了基于 Redis 实现的分布式锁，究竟是否安全这个问题。</p>
<p>从最简单分布式锁的实现，到处理各种异常场景，再到引出 Redlock，以及两个分布式专家的辩论，得出了 Redlock 的适用场景。</p>
<p>最后，我们还对比了 Zookeeper 在做分布式锁时，可能会遇到的问题，以及与 Redis 的差异。</p>
<p>这里我把这些内容总结成了思维导图，方便你理解。</p>
<p><img src="/2021/07/11/%E5%B7%A5%E7%A8%8B/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81-Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/13.png" alt="13"></p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>这篇文章的信息量其实是非常大的，我觉得应该把分布锁的问题，彻底讲清楚了。</p>
<p>如果你没有理解，我建议你多读几遍，并在脑海中构建各种假定的场景，反复思辨。</p>
<p>在写这篇文章时，我又重新研读了两位大神关于 Redlock 争辩的这两篇文章，可谓是是收获满满，在这里也分享一些心得给你。</p>
<ol>
<li>在分布式系统环境下，看似完美的设计方案，可能并不是那么「严丝合缝」，如果稍加推敲，就会发现各种问题。所以，在思考分布式系统问题时，一定要<strong>谨慎再谨慎</strong>。</li>
<li>从 Redlock 的争辩中，我们不要过多关注对错，而是要多学习大神的思考方式，以及对一个问题严格审查的严谨精神。</li>
</ol>
<p>最后，用 Martin 在对于 Redlock 争论过后，写下的感悟来结尾：</p>
<p><strong>“前人已经为我们创造出了许多伟大的成果：站在巨人的肩膀上，我们可以才得以构建更好的软件。无论如何，通过争论和检查它们是否经得起别人的详细审查，这是学习过程的一部分。但目标应该是获取知识，而不是为了说服别人，让别人相信你是对的。有时候，那只是意味着停下来，好好地想一想。”</strong></p>
<p>共勉。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wetts.github.io/2021/07/10/%E8%AF%AD%E8%A8%80/Java/basic_Java/API/%E5%B9%B6%E5%8F%91/%E5%85%B6%E4%BB%96/Java-%E5%B9%B6%E5%8F%91-CAS%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Zhang Wetts">
      <meta itemprop="description" content="Stay Hungry, Stay Foolish. <br><br><p style="font-size:8px;">[build by hexo/next/gitalk/hexo-generator-search/LaTeX]</p>">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wetts's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/10/%E8%AF%AD%E8%A8%80/Java/basic_Java/API/%E5%B9%B6%E5%8F%91/%E5%85%B6%E4%BB%96/Java-%E5%B9%B6%E5%8F%91-CAS%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/" class="post-title-link" itemprop="url">Java-并发-CAS的工作原理.md</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-07-10 23:23:14" itemprop="dateCreated datePublished" datetime="2021-07-10T23:23:14+08:00">2021-07-10</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>转自：<a target="_blank" rel="noopener" href="https://blog.csdn.net/zzti_erlie/article/details/79964590">https://blog.csdn.net/zzti_erlie/article/details/79964590</a></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>JUC 是 java.util.concurrent 包的简称，JUC 有 2 大核心，CAS 和 AQS，CAS 是 java.util.concurrent.atomic 包的基础，即A tomicInteger 和 AtomicLong 等是用 CAS 实现的</p>
</blockquote>
<p>volatile 只能保证可见性，不能保证原子性。</p>
<p>但原子类（AtomicInteger 等可以保证原子性），原子类利用 volatile+CAS 来保证原子性，来看看怎么做到的吧。</p>
<p>开 5 个线程，每个线程将 count 加 1000</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">@NotThreadSafe</span><br><span class="line">public class CountTest &#123;</span><br><span class="line"></span><br><span class="line">    public static int count = 0;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        //新建一个线程池</span><br><span class="line">        ExecutorService service = Executors.newCachedThreadPool();</span><br><span class="line">        //Java8 lambda表达式执行runnable接口</span><br><span class="line">        for (int i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">            service.execute(() -&gt; &#123;</span><br><span class="line">                for (int j = 0; j &lt; 1000; j++) &#123;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        //关闭线程池</span><br><span class="line">        service.shutdown();</span><br><span class="line">        try &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(2);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;count = &quot; + count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于这个代码是线程不安全的（因为 <code>count++</code> 不是原子操作），所以最终结果有可能小于 5000，我们可以用 synchronized 保证操作的原子性和可见性</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">@ThreadSafe</span><br><span class="line">public class CountTest &#123;</span><br><span class="line"></span><br><span class="line">    public static int count = 0;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        ExecutorService service = Executors.newCachedThreadPool();</span><br><span class="line">        for (int i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">            service.execute(() -&gt; &#123;</span><br><span class="line">                for (int j = 0; j &lt; 1000; j++) &#123;</span><br><span class="line">                    synchronized (CountTest.class) &#123;</span><br><span class="line">                        count++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        service.shutdown();</span><br><span class="line">        try &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(2);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;count = &quot; + count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>synchronized 属于悲观锁，它有一个明显的缺点，它不管数据存不存在竞争都加锁，随着并发量增加，且如果锁的时间比较长，其性能开销将会变得很大。有没有办法解决这个问题？答案是基于冲突检测的乐观锁。这种模式下，已经没有所谓的锁概念了，每个线程都直接先去执行操作，检测是否与其他线程存在共享数据竞争，如果没有则让此操作成功，如果存在共享数据竞争则不断地重新执行操作，直到成功为止，重新尝试的过程叫自旋</p>
<p>java.util.concurrent.atomic 包就用到了 CAS，如 AtomicInteger 可以用于 Integer 类型的原子性操作，可将上述代码改为如下，也是线程安全的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">@ThreadSafe</span><br><span class="line">public class CountTest &#123;</span><br><span class="line"></span><br><span class="line">    public static AtomicInteger count = new AtomicInteger(0);</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        ExecutorService service = Executors.newCachedThreadPool();</span><br><span class="line">        for (int i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">            service.execute(() -&gt; &#123;</span><br><span class="line">                for (int j = 0; j &lt; 1000; j++) &#123;</span><br><span class="line">                    count.getAndIncrement();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        service.shutdown();</span><br><span class="line">        try &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(2);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;count = &quot; + count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="CAS介绍"><a href="#CAS介绍" class="headerlink" title="CAS介绍"></a>CAS介绍</h2><p>CAS（Compare and Swap）, 翻译成比较并交换。</p>
<blockquote>
<p>CAS 有 3 个操作数，内存值 V，旧的预期值 A，要修改的新值 B。当且仅当预期值 A 和内存值 V 相同时，将内存值 V 修改为 B，否则什么都不做。</p>
</blockquote>
<p><img src="/2021/07/10/%E8%AF%AD%E8%A8%80/Java/basic_Java/API/%E5%B9%B6%E5%8F%91/%E5%85%B6%E4%BB%96/Java-%E5%B9%B6%E5%8F%91-CAS%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/1.png" alt="1"></p>
<p>仔细看图，CAS原理就是这么简单，看源码加深一下印象。</p>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>基于 jdk1.8.0_20</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private static final Unsafe unsafe = Unsafe.getUnsafe();</span><br><span class="line">private static final long valueOffset;</span><br><span class="line"></span><br><span class="line">static &#123;</span><br><span class="line">	try &#123;</span><br><span class="line">		valueOffset = unsafe.objectFieldOffset</span><br><span class="line">			(AtomicInteger.class.getDeclaredField(&quot;value&quot;));</span><br><span class="line">	&#125; catch (Exception ex) &#123; throw new Error(ex); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private volatile int value;</span><br></pre></td></tr></table></figure>

<p>AtomicInteger 的值保存在 value 中，通过 volatile 保证操作的可见性，通过一个静态代码块来保证，类被加载时 valueOffset 已经有值了</p>
<p>Unsafe 是一个不安全的类，提供了一些对底层的操作，我们是不能使用这个类的，valueOffset 是 AtomicInteger 对象 value 成员变量在内存中的偏移量</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public final int getAndIncrement() &#123;</span><br><span class="line">	return unsafe.getAndAddInt(this, valueOffset, 1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//第一个参数为当前这个对象，如count.getAndIncrement()，则这个参数则为count这个对象</span><br><span class="line">//第二个参数为AtomicInteger对象value成员变量在内存中的偏移量</span><br><span class="line">//第三个参数为要增加的值</span><br><span class="line">public final int getAndAddInt(Object var1, long var2, int var4) &#123;</span><br><span class="line">	int var5;</span><br><span class="line">	do &#123;</span><br><span class="line">		//调用底层方法得到value值</span><br><span class="line">		var5 = this.getIntVolatile(var1, var2);</span><br><span class="line">		//通过var1和var2得到底层值,var5为当前值，如果底层值=当前值，则将值设为var5+var4，并返回true，否则返回false</span><br><span class="line">	&#125; while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line"></span><br><span class="line">	return var5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法是由其他语言实现的，就不再分析</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public final native boolean compareAndSwapInt(Object var1, long var2, int var4, int var5);</span><br></pre></td></tr></table></figure>

<p><strong>并发比较低的时候用 CAS 比较合适，并发比较高用 synchronized 比较合适</strong></p>
<h2 id="CAS的缺点"><a href="#CAS的缺点" class="headerlink" title="CAS的缺点"></a>CAS的缺点</h2><ol>
<li><p>只能保证对一个变量的原子性操作<br>当对一个共享变量执行操作时，我们可以使用循环 CAS 的方式来保证原子操作，但是对多个共享变量操作时，循环 CAS 就无法保证操作的原子性，这个时候就可以用锁来保证原子性。</p>
</li>
<li><p>长时间自旋会给 CPU 带来压力<br>我们可以看到 getAndAddInt 方法执行时，如果 CAS 失败，会一直进行尝试。如果 CAS 长时间一直不成功，可能会给 CPU 带来很大的开销。</p>
</li>
<li><p>ABA 问题<br>如果内存地址V初次读取的值是A，并且在准备赋值的时候检查到它的值仍然为 A，那我们就能说它的值没有被其他线程改变过了吗？</p>
</li>
</ol>
<p>如果在这段期间它的值曾经被改成了 B，后来又被改回为 A，那 CAS 操作就会误认为它从来没有被改变过。这个漏洞称为 CAS 操作的“ABA”问题。Java 并发包为了解决这个问题，提供了一个带有标记的原子引用类“AtomicStampedReference”，它可以通过控制变量值的版本来保证 CAS 的正确性。因此，在使用 CAS 前要考虑清楚“ABA”问题是否会影响程序并发的正确性，如果需要解决 ABA 问题，改用传统的互斥同步可能会比原子类更高效。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wetts.github.io/2021/07/10/%E8%AF%AD%E8%A8%80/Java/basic_Java/API/%E5%B9%B6%E5%8F%91/%E5%85%B6%E4%BB%96/Java-%E5%B9%B6%E5%8F%91-ThreadLocal%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E5%92%8C%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Zhang Wetts">
      <meta itemprop="description" content="Stay Hungry, Stay Foolish. <br><br><p style="font-size:8px;">[build by hexo/next/gitalk/hexo-generator-search/LaTeX]</p>">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wetts's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/10/%E8%AF%AD%E8%A8%80/Java/basic_Java/API/%E5%B9%B6%E5%8F%91/%E5%85%B6%E4%BB%96/Java-%E5%B9%B6%E5%8F%91-ThreadLocal%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E5%92%8C%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/" class="post-title-link" itemprop="url">Java-并发-ThreadLocal的应用场景和注意事项.md</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-07-10 22:56:55" itemprop="dateCreated datePublished" datetime="2021-07-10T22:56:55+08:00">2021-07-10</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>转自：<a target="_blank" rel="noopener" href="https://blog.csdn.net/zzti_erlie/article/details/105322946">https://blog.csdn.net/zzti_erlie/article/details/105322946</a></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>ThreadLocal 主要有如下 2 个作用</p>
<ul>
<li>保证线程安全</li>
<li>在线程级别传递变量</li>
</ul>
<h2 id="保证线程安全"><a href="#保证线程安全" class="headerlink" title="保证线程安全"></a>保证线程安全</h2><p>最近一个小伙伴把项目中封装的日期工具类用在多线程环境下居然出了问题，来看看怎么回事吧</p>
<p>日期转换的一个工具类</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class DateUtil &#123;</span><br><span class="line"></span><br><span class="line">    private static final SimpleDateFormat sdf = </span><br><span class="line">            new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);</span><br><span class="line"></span><br><span class="line">    public static Date parse(String dateStr) &#123;</span><br><span class="line">        Date date = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            date = sdf.parse(dateStr);</span><br><span class="line">        &#125; catch (ParseException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        return date;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后将这个工具类用在多线程环境下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">    ExecutorService service = Executors.newFixedThreadPool(20);</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; 20; i++) &#123;</span><br><span class="line">        service.execute(()-&gt;&#123;</span><br><span class="line">            System.out.println(DateUtil.parse(&quot;2019-06-01 16:34:30&quot;));</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    service.shutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果报异常了，因为部分线程获取的时间不对<br><img src="/2021/07/10/%E8%AF%AD%E8%A8%80/Java/basic_Java/API/%E5%B9%B6%E5%8F%91/%E5%85%B6%E4%BB%96/Java-%E5%B9%B6%E5%8F%91-ThreadLocal%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E5%92%8C%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/1.png" alt="1"></p>
<p>这个异常就不从源码的角度分析了，写一个小 Demo，理解了这个小 Demo，就理解了原因</p>
<p>一个将数字加 10 的工具类</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class NumUtil &#123;</span><br><span class="line"></span><br><span class="line">    public static int addNum = 0;</span><br><span class="line"></span><br><span class="line">    public static int add10(int num) &#123;</span><br><span class="line">        addNum = num;</span><br><span class="line">        try &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(1);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        return addNum + 10;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">	ExecutorService service = Executors.newFixedThreadPool(20);</span><br><span class="line"></span><br><span class="line">	for (int i = 0; i &lt; 20; i++) &#123;</span><br><span class="line">		int num = i;</span><br><span class="line">		service.execute(()-&gt;&#123;</span><br><span class="line">			System.out.println(num + &quot; &quot; +  NumUtil.add10(num));</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">	service.shutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后代码的一部分输出为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0 28</span><br><span class="line">3 28</span><br><span class="line">7 28</span><br><span class="line">11 28</span><br><span class="line">15 28</span><br></pre></td></tr></table></figure>

<p>什么鬼，不是加 10 么，怎么都输出了 28？这主要是因为线程切换的原因，线程陆续将 addNum 值设置为 0，3，7 但是都没有执行完（没有执行到 return addNum+10 这一步）就被切换了，当其中一个线程将 addNum 值设置为 18 时，线程陆续开始执行 addNum+10 这一步，结果都输出了 28。SimpleDateFormat 的原因和这个类似，那么我们如何解决这个问题呢？</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="解决方案1：每次来都new新的，空间浪费比较大"><a href="#解决方案1：每次来都new新的，空间浪费比较大" class="headerlink" title="解决方案1：每次来都new新的，空间浪费比较大"></a>解决方案1：每次来都new新的，空间浪费比较大</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class DateUtil &#123;</span><br><span class="line"></span><br><span class="line">    public static Date parse(String dateStr) &#123;</span><br><span class="line">        SimpleDateFormat sdf =</span><br><span class="line">                new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);</span><br><span class="line">        Date date = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            date = sdf.parse(dateStr);</span><br><span class="line">        &#125; catch (ParseException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        return date;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解决方案2：方法用synchronized修饰，并发上不来"><a href="#解决方案2：方法用synchronized修饰，并发上不来" class="headerlink" title="解决方案2：方法用synchronized修饰，并发上不来"></a>解决方案2：方法用synchronized修饰，并发上不来</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class DateUtil &#123;</span><br><span class="line"></span><br><span class="line">    private static final SimpleDateFormat sdf =</span><br><span class="line">            new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);</span><br><span class="line"></span><br><span class="line">    public static synchronized Date parse(String dateStr) &#123;</span><br><span class="line">        Date date = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            date = sdf.parse(dateStr);</span><br><span class="line">        &#125; catch (ParseException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        return date;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解决方案3：用jdk1-8中的日期格式类DateFormatter，DateTimeFormatter"><a href="#解决方案3：用jdk1-8中的日期格式类DateFormatter，DateTimeFormatter" class="headerlink" title="解决方案3：用jdk1.8中的日期格式类DateFormatter，DateTimeFormatter"></a>解决方案3：用jdk1.8中的日期格式类DateFormatter，DateTimeFormatter</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class DateUtil &#123;</span><br><span class="line"></span><br><span class="line">    private static DateTimeFormatter formatter = </span><br><span class="line">            DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm:ss&quot;);</span><br><span class="line"></span><br><span class="line">    public static LocalDateTime parse(String dateStr) &#123;</span><br><span class="line">        return LocalDateTime.parse(dateStr, formatter);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解决方案4：用ThreadLocal，一个线程一个SimpleDateFormat对象"><a href="#解决方案4：用ThreadLocal，一个线程一个SimpleDateFormat对象" class="headerlink" title="解决方案4：用ThreadLocal，一个线程一个SimpleDateFormat对象"></a>解决方案4：用ThreadLocal，一个线程一个SimpleDateFormat对象</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class DateUtil &#123;</span><br><span class="line"></span><br><span class="line">    private static ThreadLocal&lt;DateFormat&gt; threadLocal = ThreadLocal.withInitial(</span><br><span class="line">            ()-&gt; new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;));</span><br><span class="line"></span><br><span class="line">    public static Date parse(String dateStr) &#123;</span><br><span class="line">        Date date = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            date = threadLocal.get().parse(dateStr);</span><br><span class="line">        &#125; catch (ParseException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        return date;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的加 10 的工具类可以改成如下形式（主要为了演示 ThreadLocal 的使用）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class NumUtil &#123;</span><br><span class="line"></span><br><span class="line">    private static ThreadLocal&lt;Integer&gt; addNumThreadLocal = new ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    public static int add10(int num) &#123;</span><br><span class="line">        addNumThreadLocal.set(num);</span><br><span class="line">        try &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(1);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        return addNumThreadLocal.get() + 10;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在2个工具类都能正常使用了，这是为啥呢？</p>
<h2 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h2><p>当多个线程同时读写同一共享变量时存在并发问题，如果不共享不就没有并发问题了，一个线程存一个自己的变量，类比原来好几个人玩同一个球，现在一个人一个球，就没有问题了，如何把变量存在线程上呢？其实 Thread 类内部已经有一个 Map 容器用来存变量了。它的大概结构如下所示<br><img src="/2021/07/10/%E8%AF%AD%E8%A8%80/Java/basic_Java/API/%E5%B9%B6%E5%8F%91/%E5%85%B6%E4%BB%96/Java-%E5%B9%B6%E5%8F%91-ThreadLocal%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E5%92%8C%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/2.png" alt="2"></p>
<p>ThreadLocalMap 是一个 Map，key 是 ThreadLocal，value 是 Object</p>
<p>映射到源码就是如下所示：ThreadLocalMap 是 ThreadLocal 的一个静态内部类</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public class Thread implements Runnable &#123;</span><br><span class="line">    ThreadLocal.ThreadLocalMap threadLocals = null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>往 ThreadLocalMap 里面放值`</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// ThreadLocal类里面的方法，将源码整合了一下</span><br><span class="line">public void set(T value) &#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = t.threadLocals;</span><br><span class="line">    if (map != null)</span><br><span class="line">        map.set(this, value);</span><br><span class="line">    else</span><br><span class="line">		t.threadLocals = new ThreadLocalMap(this, firstValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从 ThreadLocalMap 里面取值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// ThreadLocal类里面的方法，将源码整合了一下</span><br><span class="line">public T get() &#123;</span><br><span class="line">	Thread t = Thread.currentThread();</span><br><span class="line">	ThreadLocalMap map = t.threadLocals；</span><br><span class="line">	if (map != null) &#123;</span><br><span class="line">		ThreadLocalMap.Entry e = map.getEntry(this);</span><br><span class="line">		if (e != null) &#123;</span><br><span class="line">			@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">			T result = (T)e.value;</span><br><span class="line">			return result;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return setInitialValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从 ThreadLocalMap 里面删除值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// ThreadLocal类里面的方法，将源码整合了一下</span><br><span class="line">public void remove() &#123;</span><br><span class="line">	ThreadLocalMap m = Thread.currentThread().threadLocals;</span><br><span class="line">	if (m != null)</span><br><span class="line">		m.remove(this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行如下代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class InfoUtil &#123;</span><br><span class="line"></span><br><span class="line">    private static ThreadLocal&lt;String&gt; nameInfo = new ThreadLocal&lt;&gt;();</span><br><span class="line">    private static ThreadLocal&lt;Integer&gt; ageInfo = new ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    public static void setInfo(String name, Integer age) &#123;</span><br><span class="line">        nameInfo.set(name);</span><br><span class="line">        ageInfo.set(age);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static String getName() &#123;</span><br><span class="line">        return nameInfo.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            InfoUtil.setInfo(&quot;张三&quot;, 10);</span><br><span class="line">            // 张三</span><br><span class="line">            System.out.println(InfoUtil.getName());</span><br><span class="line">        &#125;, &quot;thread1&quot;).start();</span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            InfoUtil.setInfo(&quot;李四&quot;, 20);</span><br><span class="line">            // 李四</span><br><span class="line">            System.out.println(InfoUtil.getName());</span><br><span class="line">        &#125;, &quot;thread2&quot;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>变量的结构如下图<br><img src="/2021/07/10/%E8%AF%AD%E8%A8%80/Java/basic_Java/API/%E5%B9%B6%E5%8F%91/%E5%85%B6%E4%BB%96/Java-%E5%B9%B6%E5%8F%91-ThreadLocal%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E5%92%8C%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/3.png" alt="3"></p>
<h2 id="在线程级别传递变量"><a href="#在线程级别传递变量" class="headerlink" title="在线程级别传递变量"></a>在线程级别传递变量</h2><p>假设有如下一个场景，method1()调用method2()，method2()调用method3()，method3()调用method4()，method1()生成了一个变量想在method4()中使用，有如下2种解决办法</p>
<ol>
<li>method 2 3 4的参数列表上都写上method4想要的变量</li>
<li>method 1 往ThreadLocal中put一个值，method4从ThreadLocal中get出来</li>
</ol>
<p>哪种实现方式比较优雅呢？相信我不说你也能明白了</p>
<p>我在生产环境中一般是这样用的，如果一个请求在系统中的处理流程比较长，可以对请求的日志打一个相同的前缀，这样比较方便处理问题</p>
<p>这个前缀的生成和移除可以配置在拦截器中，切面中，当然也可以在一个方法的前后</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line"></span><br><span class="line">    public static final ThreadLocal&lt;String&gt; SPANID =</span><br><span class="line">            ThreadLocal.withInitial(() -&gt; UUID.randomUUID().toString());</span><br><span class="line"></span><br><span class="line">    public static void start() &#123;</span><br><span class="line">        SPANID.set(UUID.randomUUID().toString());</span><br><span class="line">        // 方法调用过程中可以在日志中打印SPANID表明一个请求的执行链路</span><br><span class="line">        SPANID.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然Spring Cloud已经有现成的链路追踪组件了。</p>
<h2 id="ThreadLocal使用注意事项"><a href="#ThreadLocal使用注意事项" class="headerlink" title="ThreadLocal使用注意事项"></a>ThreadLocal使用注意事项</h2><p>ThreadLocal如果使用不当会造成如下问题</p>
<ol>
<li>脏数据</li>
<li>内存泄露</li>
</ol>
<h3 id="脏数据"><a href="#脏数据" class="headerlink" title="脏数据"></a>脏数据</h3><p>线程复用会造成脏数据。由于线程池会复用 Thread 对象，因此 Thread 类的成员变量 threadLocals 也会被复用。如果在线程的 run() 方法中不显示调用 remove() 清理与线程相关的 ThreadLocal 信息，并且下一个线程不调用 set() 设置初始值，就可能 get() 到上个线程设置的值</p>
<h3 id="内存泄露"><a href="#内存泄露" class="headerlink" title="内存泄露"></a>内存泄露</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">static class ThreadLocalMap &#123;</span><br><span class="line"></span><br><span class="line">	static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; &#123;</span><br><span class="line">		Object value;</span><br><span class="line"></span><br><span class="line">		Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">			super(k);</span><br><span class="line">			value = v;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ThreadLocalMap 使用 ThreadLocal 的弱引用作为 key，如果一个 ThreadLocal 没有外部强引用来引用它，那么系统 GC 的时候，这个 ThreadLocal 势必会被回收，这样一来，ThreadLocalMap 中就会出现 key 为 null 的 Entry，就没有办法访问这些key为 null 的 Entry 的 value，如果当前线程再迟迟不结束的话，这些key为 null 的 Entry 的 value 就会一直存在一条强引用链：<code>Thread Ref -&gt; Thread -&gt; ThreaLocalMap -&gt; Entry -&gt; value</code> 永远无法回收，造成内存泄漏</p>
<p>大白话一点，ThreadLocalMap 的 key 是弱引用，GC时会被回收掉，那么就有可能存在 <code>ThreadLocalMap&lt;null, Object&gt;</code> 的情况，这个 Object 就是泄露的对象</p>
<p>其实，ThreadLocalMap 的设计中已经考虑到这种情况，也加上了一些防护措施：在 ThreadLocal的get()，set()，remove() 的时候都会清除线程 ThreadLocalMap 里所有 key 为 null 的 value</p>
<h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><p>解决以上两个问题的办法很简单，就是在每次用完 ThreadLocal 后，及时调用 remove() 方法清理即可</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wetts.github.io/2021/07/10/%E8%AF%AD%E8%A8%80/Java/JVM/Java%E8%87%AA%E5%B8%A6%E7%9A%84%E8%B0%83%E4%BC%98%E5%B7%A5%E5%85%B7%EF%BC%88jps%E3%80%81jstat%E3%80%81jstack%E3%80%81jmap%E3%80%81jhat%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Zhang Wetts">
      <meta itemprop="description" content="Stay Hungry, Stay Foolish. <br><br><p style="font-size:8px;">[build by hexo/next/gitalk/hexo-generator-search/LaTeX]</p>">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wetts's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/10/%E8%AF%AD%E8%A8%80/Java/JVM/Java%E8%87%AA%E5%B8%A6%E7%9A%84%E8%B0%83%E4%BC%98%E5%B7%A5%E5%85%B7%EF%BC%88jps%E3%80%81jstat%E3%80%81jstack%E3%80%81jmap%E3%80%81jhat%EF%BC%89/" class="post-title-link" itemprop="url">Java自带的调优工具（jps、jstat、jstack、jmap、jhat）.md</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-07-10 16:26:05" itemprop="dateCreated datePublished" datetime="2021-07-10T16:26:05+08:00">2021-07-10</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>转自：<a target="_blank" rel="noopener" href="https://blog.51cto.com/superleedo/2132016%E3%80%81https://my.oschina.net/feichexia/blog/196575">https://blog.51cto.com/superleedo/2132016、https://my.oschina.net/feichexia/blog/196575</a></p>
<h3 id="jps（Java-Virtual-Machine-Process-Status-Tool）"><a href="#jps（Java-Virtual-Machine-Process-Status-Tool）" class="headerlink" title="jps（Java Virtual Machine Process Status Tool）"></a>jps（Java Virtual Machine Process Status Tool）</h3><p>用来输出 JVM 中运行的进程状态信息。语法格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jps [options] [hostid]</span><br></pre></td></tr></table></figure>
<p>如果不指定 hostid 就默认为当前主机或服务器。</p>
<p>命令行参数选项说明如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-q 不输出类名、Jar名和传入main方法的参数</span><br><span class="line">-m 输出传入main方法的参数</span><br><span class="line">-l 输出main类或Jar的全限名</span><br><span class="line">-v 输出传入JVM的参数</span><br></pre></td></tr></table></figure>

<h3 id="jstack"><a href="#jstack" class="headerlink" title="jstack"></a>jstack</h3><p>主要用来查看某个 Java 进程内的线程堆栈信息。语法格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jstack [option] pid</span><br><span class="line">jstack [option] executable core</span><br><span class="line">jstack [option] [server-id@]remote-hostname-or-ip</span><br></pre></td></tr></table></figure>

<p>命令行参数选项说明如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-l long listings，会打印出额外的锁信息，在发生死锁时可以用jstack -l pid来观察锁持有情况</span><br><span class="line">-m mixed mode，不仅会输出Java堆栈信息，还会输出C/C++堆栈信息（比如Native方法）</span><br></pre></td></tr></table></figure>

<p>jstack 可以定位到线程堆栈，根据堆栈信息我们可以定位到具体代码，所以它在 JVM 性能调优中使用得非常多。下面我们来一个实例找出某个 Java 进程中最耗费 CPU 的 Java 线程并定位堆栈信息，用到的命令有 ps、top、printf、jstack、grep。</p>
<p>第一步先找出 Java 进程 ID，我部署在服务器上的 Java 应用名称为 mrf-center：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:/# ps -ef | grep mrf-center | grep -v grep</span><br><span class="line">root     21711     1  1 14:47 pts/3    00:02:10 java -jar mrf-center.jar</span><br></pre></td></tr></table></figure>

<p>得到进程 ID 为 21711，第二步找出该进程内最耗费 CPU 的线程，可以使用 <code>ps -Lfp pid</code> 或者 <code>ps -mp pid -o THREAD, tid, time</code> 或者 <code>top -Hp pid</code>，我这里用第三个，输出如下：</p>
<p><img src="/2021/07/10/%E8%AF%AD%E8%A8%80/Java/JVM/Java%E8%87%AA%E5%B8%A6%E7%9A%84%E8%B0%83%E4%BC%98%E5%B7%A5%E5%85%B7%EF%BC%88jps%E3%80%81jstat%E3%80%81jstack%E3%80%81jmap%E3%80%81jhat%EF%BC%89/1.png" alt="1"></p>
<p> TIME 列就是各个 Java 线程耗费的 CPU 时间，CPU 时间最长的是线程 ID 为 21742 的线程，用<br> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printf &quot;%x\n&quot; 21742</span><br></pre></td></tr></table></figure><br>得到 21742 的十六进制值为 <code>54ee</code>，下面会用到。</p>
<p>OK，下一步终于轮到 jstack 上场了，它用来输出进程 21711 的堆栈信息，然后根据线程 ID 的十六进制值 grep，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:/# jstack 21711 | grep 54ee</span><br><span class="line">&quot;PollIntervalRetrySchedulerThread&quot; prio=10 tid=0x00007f950043e000 nid=0x54ee in Object.wait() [0x00007f94c6eda000]</span><br></pre></td></tr></table></figure>

<p>可以看到 CPU 消耗在 PollIntervalRetrySchedulerThread 这个类的 <code>Object.wait()</code>，我找了下我的代码，定位到下面的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// Idle wait</span><br><span class="line">getLog().info(&quot;Thread [&quot; + getName() + &quot;] is idle waiting...&quot;);</span><br><span class="line">schedulerThreadState = PollTaskSchedulerThreadState.IdleWaiting;</span><br><span class="line">long now = System.currentTimeMillis();</span><br><span class="line">long waitTime = now + getIdleWaitTime();</span><br><span class="line">long timeUntilContinue = waitTime - now;</span><br><span class="line">synchronized(sigLock) &#123;</span><br><span class="line">	try &#123;</span><br><span class="line">    	if(!halted.get()) &#123;</span><br><span class="line">    		sigLock.wait(timeUntilContinue);</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125; </span><br><span class="line">	catch (InterruptedException ignore) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它是轮询任务的空闲等待代码，上面的 <code>sigLock.wait(timeUntilContinue)</code> 就对应了前面的 <code>Object.wait()</code>。</p>
<h3 id="jmap（Memory-Map）和jhat（Java-Heap-Analysis-Tool）"><a href="#jmap（Memory-Map）和jhat（Java-Heap-Analysis-Tool）" class="headerlink" title="jmap（Memory Map）和jhat（Java Heap Analysis Tool）"></a>jmap（Memory Map）和jhat（Java Heap Analysis Tool）</h3><p>jmap 用来查看堆内存使用状况，一般结合 jhat 使用。</p>
<p>jmap 语法格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jmap [option] pid</span><br><span class="line">jmap [option] executable core</span><br><span class="line">jmap [option] [server-id@]remote-hostname-or-ip</span><br></pre></td></tr></table></figure>

<p>如果运行在 64 位 JVM 上，可能需要指定 <code>-J-d64</code> 命令选项参数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmap -permstat pid</span><br></pre></td></tr></table></figure>
<p>打印进程的类加载器和类加载器加载的持久代对象信息，输出：类加载器名称、对象是否存活（不可靠）、对象地址、父类加载器、已加载的类大小等信息，如下图：<br><img src="/2021/07/10/%E8%AF%AD%E8%A8%80/Java/JVM/Java%E8%87%AA%E5%B8%A6%E7%9A%84%E8%B0%83%E4%BC%98%E5%B7%A5%E5%85%B7%EF%BC%88jps%E3%80%81jstat%E3%80%81jstack%E3%80%81jmap%E3%80%81jhat%EF%BC%89/2.png" alt="2"></p>
<p>使用 <code>jmap -heap pid</code> 查看进程堆内存使用情况，包括使用的 GC 算法、堆配置参数和各代中堆内存使用情况。比如下面的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:/# jmap -heap 21711</span><br><span class="line">Attaching to process ID 21711, please wait...</span><br><span class="line">Debugger attached successfully.</span><br><span class="line">Server compiler detected.</span><br><span class="line">JVM version is 20.10-b01</span><br><span class="line"></span><br><span class="line">using thread-local object allocation.</span><br><span class="line">Parallel GC with 4 thread(s)</span><br><span class="line"></span><br><span class="line">Heap Configuration:</span><br><span class="line">   MinHeapFreeRatio = 40</span><br><span class="line">   MaxHeapFreeRatio = 70</span><br><span class="line">   MaxHeapSize      = 2067791872 (1972.0MB)</span><br><span class="line">   NewSize          = 1310720 (1.25MB)</span><br><span class="line">   MaxNewSize       = 17592186044415 MB</span><br><span class="line">   OldSize          = 5439488 (5.1875MB)</span><br><span class="line">   NewRatio         = 2</span><br><span class="line">   SurvivorRatio    = 8</span><br><span class="line">   PermSize         = 21757952 (20.75MB)</span><br><span class="line">   MaxPermSize      = 85983232 (82.0MB)</span><br><span class="line"></span><br><span class="line">Heap Usage:</span><br><span class="line">PS Young Generation</span><br><span class="line">Eden Space:</span><br><span class="line">   capacity = 6422528 (6.125MB)</span><br><span class="line">   used     = 5445552 (5.1932830810546875MB)</span><br><span class="line">   free     = 976976 (0.9317169189453125MB)</span><br><span class="line">   84.78829520089286% used</span><br><span class="line">From Space:</span><br><span class="line">   capacity = 131072 (0.125MB)</span><br><span class="line">   used     = 98304 (0.09375MB)</span><br><span class="line">   free     = 32768 (0.03125MB)</span><br><span class="line">   75.0% used</span><br><span class="line">To Space:</span><br><span class="line">   capacity = 131072 (0.125MB)</span><br><span class="line">   used     = 0 (0.0MB)</span><br><span class="line">   free     = 131072 (0.125MB)</span><br><span class="line">   0.0% used</span><br><span class="line">PS Old Generation</span><br><span class="line">   capacity = 35258368 (33.625MB)</span><br><span class="line">   used     = 4119544 (3.9287033081054688MB)</span><br><span class="line">   free     = 31138824 (29.69629669189453MB)</span><br><span class="line">   11.683876009235595% used</span><br><span class="line">PS Perm Generation</span><br><span class="line">   capacity = 52428800 (50.0MB)</span><br><span class="line">   used     = 26075168 (24.867218017578125MB)</span><br><span class="line">   free     = 26353632 (25.132781982421875MB)</span><br><span class="line">   49.73443603515625% used</span><br><span class="line">   ....</span><br></pre></td></tr></table></figure>

<p>使用 <code>jmap -histo[:live] pid</code> 查看堆内存中的对象数目、大小统计直方图，如果带上 live 则只统计活对象，如下：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:/# jmap -histo:live 21711 | more</span><br><span class="line"></span><br><span class="line"> num     #instances         #bytes  class name</span><br><span class="line">----------------------------------------------</span><br><span class="line">   1:         38445        5597736  &lt;constMethodKlass&gt;</span><br><span class="line">   2:         38445        5237288  &lt;methodKlass&gt;</span><br><span class="line">   3:          3500        3749504  &lt;constantPoolKlass&gt;</span><br><span class="line">   4:         60858        3242600  &lt;symbolKlass&gt;</span><br><span class="line">   5:          3500        2715264  &lt;instanceKlassKlass&gt;</span><br><span class="line">   6:          2796        2131424  &lt;constantPoolCacheKlass&gt;</span><br><span class="line">   7:          5543        1317400  [I</span><br><span class="line">   8:         13714        1010768  [C</span><br><span class="line">   9:          4752        1003344  [B</span><br><span class="line">  10:          1225         639656  &lt;methodDataKlass&gt;</span><br><span class="line">  11:         14194         454208  java.lang.String</span><br><span class="line">  12:          3809         396136  java.lang.Class</span><br><span class="line">  13:          4979         311952  [S</span><br><span class="line">  14:          5598         287064  [[I</span><br><span class="line">  15:          3028         266464  java.lang.reflect.Method</span><br><span class="line">  16:           280         163520  &lt;objArrayKlassKlass&gt;</span><br><span class="line">  17:          4355         139360  java.util.HashMap$Entry</span><br><span class="line">  18:          1869         138568  [Ljava.util.HashMap$Entry;</span><br><span class="line">  19:          2443          97720  java.util.LinkedHashMap$Entry</span><br><span class="line">  20:          2072          82880  java.lang.ref.SoftReference</span><br><span class="line">  21:          1807          71528  [Ljava.lang.Object;</span><br><span class="line">  22:          2206          70592  java.lang.ref.WeakReference</span><br><span class="line">  23:           934          52304  java.util.LinkedHashMap</span><br><span class="line">  24:           871          48776  java.beans.MethodDescriptor</span><br><span class="line">  25:          1442          46144  java.util.concurrent.ConcurrentHashMap$HashEntry</span><br><span class="line">  26:           804          38592  java.util.HashMap</span><br><span class="line">  27:           948          37920  java.util.concurrent.ConcurrentHashMap$Segment</span><br><span class="line">  28:          1621          35696  [Ljava.lang.Class;</span><br><span class="line">  29:          1313          34880  [Ljava.lang.String;</span><br><span class="line">  30:          1396          33504  java.util.LinkedList$Entry</span><br><span class="line">  31:           462          33264  java.lang.reflect.Field</span><br><span class="line">  32:          1024          32768  java.util.Hashtable$Entry</span><br><span class="line">  33:           948          31440  [Ljava.util.concurrent.ConcurrentHashMap$HashEntry;</span><br></pre></td></tr></table></figure>

<p>class name 是对象类型，说明如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">B  byte</span><br><span class="line">C  char</span><br><span class="line">D  double</span><br><span class="line">F  float</span><br><span class="line">I  int</span><br><span class="line">J  long</span><br><span class="line">Z  boolean</span><br><span class="line">[  数组，如[I表示int[]</span><br><span class="line">[L+类名 其他对象</span><br></pre></td></tr></table></figure>

<p>还有一个很常用的情况是：用 jmap 把进程内存使用情况 dump 到文件中，再用 jhat 分析查看。 jmap 进行 dump 命令格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmap -dump:format=b,file=dumpFileName pid</span><br></pre></td></tr></table></figure>

<p>我一样地对上面进程 ID 为 21711 进行 Dump：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:/# jmap -dump:format=b,file=/tmp/dump.dat 21711     </span><br><span class="line">Dumping heap to /tmp/dump.dat ...</span><br><span class="line">Heap dump file created</span><br></pre></td></tr></table></figure>

<p>dump 出来的文件可以用 MAT、VisualVM 等工具查看，这里用 jhat 查看：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:/# jhat -port 9998 /tmp/dump.dat</span><br><span class="line">Reading from /tmp/dump.dat...</span><br><span class="line">Dump file created Tue Jan 28 17:46:14 CST 2014</span><br><span class="line">Snapshot read, resolving...</span><br><span class="line">Resolving 132207 objects...</span><br><span class="line">Chasing references, expect 26 dots..........................</span><br><span class="line">Eliminating duplicate references..........................</span><br><span class="line">Snapshot resolved.</span><br><span class="line">Started HTTP server on port 9998</span><br><span class="line">Server is ready.</span><br></pre></td></tr></table></figure>

<p>注意如果 Dump 文件太大，可能需要加上 <code>-J-Xmx512m</code> 这种参数指定最大堆内存，即 <code>jhat -J-Xmx512m -port 9998 /tmp/dump.dat</code>。然后就可以在浏览器中输入 <code>主机地址:9998</code> 查看了：<br><img src="/2021/07/10/%E8%AF%AD%E8%A8%80/Java/JVM/Java%E8%87%AA%E5%B8%A6%E7%9A%84%E8%B0%83%E4%BC%98%E5%B7%A5%E5%85%B7%EF%BC%88jps%E3%80%81jstat%E3%80%81jstack%E3%80%81jmap%E3%80%81jhat%EF%BC%89/3.png" alt="3"></p>
<p>上面红线框出来的部分大家可以自己去摸索下，最后一项支持 OQL（对象查询语言）。</p>
<h3 id="jstat"><a href="#jstat" class="headerlink" title="jstat"></a>jstat</h3><p>JVM 统计监测工具。语法格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jstat [ generalOption | outputOptions vmid [interval[s|ms] [count]] ]</span><br></pre></td></tr></table></figure>

<p>vmid 是 Java 虚拟机 ID，在 Linux/Unix 系统上一般就是进程 ID。interval 是采样时间间隔。count 是采样数目。比如下面输出的是 GC 信息，采样时间间隔为 250ms，采样数为 4：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:/# jstat -gc 21711 250 4</span><br><span class="line"> S0C    S1C    S0U    S1U      EC       EU        OC         OU       PC     PU    YGC     YGCT    FGC    FGCT     GCT   </span><br><span class="line">192.0  192.0   64.0   0.0    6144.0   1854.9   32000.0     4111.6   55296.0 25472.7    702    0.431   3      0.218    0.649</span><br><span class="line">192.0  192.0   64.0   0.0    6144.0   1972.2   32000.0     4111.6   55296.0 25472.7    702    0.431   3      0.218    0.649</span><br><span class="line">192.0  192.0   64.0   0.0    6144.0   1972.2   32000.0     4111.6   55296.0 25472.7    702    0.431   3      0.218    0.649</span><br><span class="line">192.0  192.0   64.0   0.0    6144.0   2109.7   32000.0     4111.6   55296.0 25472.7    702    0.431   3      0.218    0.649</span><br></pre></td></tr></table></figure>

<p>要明白上面各列的意义，先看 JVM 堆内存布局：<br><img src="/2021/07/10/%E8%AF%AD%E8%A8%80/Java/JVM/Java%E8%87%AA%E5%B8%A6%E7%9A%84%E8%B0%83%E4%BC%98%E5%B7%A5%E5%85%B7%EF%BC%88jps%E3%80%81jstat%E3%80%81jstack%E3%80%81jmap%E3%80%81jhat%EF%BC%89/4.jpg" alt="4"></p>
<p>可以看出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">堆内存 = 年轻代 + 年老代 + 永久代</span><br><span class="line">年轻代 = Eden区 + 两个Survivor区（From和To）</span><br></pre></td></tr></table></figure>

<p>现在来解释各列含义：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">S0C、S1C、S0U、S1U：Survivor 0/1区容量（Capacity）和使用量（Used）</span><br><span class="line">EC、EU：Eden区容量和使用量</span><br><span class="line">OC、OU：年老代容量和使用量</span><br><span class="line">PC、PU：永久代容量和使用量</span><br><span class="line">YGC、YGT：年轻代GC次数和GC耗时</span><br><span class="line">FGC、FGCT：Full GC次数和Full GC耗时</span><br><span class="line">GCT：GC总耗时</span><br></pre></td></tr></table></figure>

<h3 id="hprof（Heap-CPU-Profiling-Tool）"><a href="#hprof（Heap-CPU-Profiling-Tool）" class="headerlink" title="hprof（Heap/CPU Profiling Tool）"></a>hprof（Heap/CPU Profiling Tool）</h3><p>hprof 能够展现 CPU 使用率，统计堆内存使用情况。语法格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">java -agentlib:hprof[=options] ToBeProfiledClass</span><br><span class="line">java -Xrunprof[:options] ToBeProfiledClass</span><br><span class="line">javac -J-agentlib:hprof[=options] ToBeProfiledClass</span><br></pre></td></tr></table></figure>

<p>完整的命令选项如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Option Name and Value  Description                    Default</span><br><span class="line">---------------------  -----------                    -------</span><br><span class="line">heap=dump|sites|all    heap profiling                 all</span><br><span class="line">cpu=samples|times|old  CPU usage                      off</span><br><span class="line">monitor=y|n            monitor contention             n</span><br><span class="line">format=a|b             text(txt) or binary output     a</span><br><span class="line">file=&lt;file&gt;            write data to file             java.hprof[.txt]</span><br><span class="line">net=&lt;host&gt;:&lt;port&gt;      send data over a socket        off</span><br><span class="line">depth=&lt;size&gt;           stack trace depth              4</span><br><span class="line">interval=&lt;ms&gt;          sample interval in ms          10</span><br><span class="line">cutoff=&lt;value&gt;         output cutoff point            0.0001</span><br><span class="line">lineno=y|n             line number in traces?         y</span><br><span class="line">thread=y|n             thread in traces?              n</span><br><span class="line">doe=y|n                dump on exit?                  y</span><br><span class="line">msa=y|n                Solaris micro state accounting n</span><br><span class="line">force=y|n              force output to &lt;file&gt;         y</span><br><span class="line">verbose=y|n            print messages about dumps     y</span><br></pre></td></tr></table></figure>

<p>来几个官方指南上的实例。</p>
<p>CPU Usage Sampling Profiling(cpu=samples) 的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -agentlib:hprof=cpu=samples,interval=20,depth=3 Hello</span><br></pre></td></tr></table></figure>

<p>上面每隔 20 毫秒采样 CPU 消耗信息，堆栈深度为 3，生成的 profile 文件名称是 java.hprof.txt，在当前目录。</p>
<p>CPU Usage Times Profiling(cpu=times) 的例子，它相对于 CPU Usage Sampling Profile 能够获得更加细粒度的 CPU 消耗信息，能够细到每个方法调用的开始和结束，它的实现使用了字节码注入技术（BCI）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javac -J-agentlib:hprof=cpu=times Hello.java</span><br></pre></td></tr></table></figure>

<p>Heap Allocation Profiling(heap=sites) 的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javac -J-agentlib:hprof=heap=sites Hello.java</span><br></pre></td></tr></table></figure>

<p>Heap Dump(heap=dump) 的例子，它比上面的 Heap Allocation Profiling 能生成更详细的 Heap Dump 信息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javac -J-agentlib:hprof=heap=dump Hello.java</span><br></pre></td></tr></table></figure>

<p><strong>虽然在 JVM 启动参数中加入 -Xrunprof:heap=sites 参数可以生成 CPU/Heap Profile 文件，但对 JVM 性能影响非常大，不建议在线上服务器环境使用。</strong></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wetts.github.io/2021/06/04/%E8%AF%AD%E8%A8%80/Java/%E6%A1%86%E6%9E%B6%E3%80%81%E7%9B%B8%E5%85%B3%E6%8A%80%E6%9C%AF/Spring/%E7%94%A8%E6%B3%95/Spring-%E6%A1%86%E6%9E%B6%E8%AE%BE%E8%AE%A1-%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Zhang Wetts">
      <meta itemprop="description" content="Stay Hungry, Stay Foolish. <br><br><p style="font-size:8px;">[build by hexo/next/gitalk/hexo-generator-search/LaTeX]</p>">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wetts's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/06/04/%E8%AF%AD%E8%A8%80/Java/%E6%A1%86%E6%9E%B6%E3%80%81%E7%9B%B8%E5%85%B3%E6%8A%80%E6%9C%AF/Spring/%E7%94%A8%E6%B3%95/Spring-%E6%A1%86%E6%9E%B6%E8%AE%BE%E8%AE%A1-%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/" class="post-title-link" itemprop="url">Spring-框架设计-循环依赖.md</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-06-04 09:20:37" itemprop="dateCreated datePublished" datetime="2021-06-04T09:20:37+08:00">2021-06-04</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>转自：<a target="_blank" rel="noopener" href="https://blog.csdn.net/zzti_erlie/article/details/106876517">https://blog.csdn.net/zzti_erlie/article/details/106876517</a></p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>先说一下什么是循环依赖，Spring 在初始化 A 的时候需要注入 B，而初始化 B 的时候需要注入 A，在 Spring 启动后这 2 个 Bean 都要被初始化完成</p>
<p>Spring的循环依赖有两种场景</p>
<ol>
<li>构造器的循环依赖</li>
<li>属性的循环依赖</li>
</ol>
<p>构造器的循环依赖，可以在构造函数中使用 <code>@Lazy</code> 注解延迟加载。在注入依赖时，先注入代理对象，当首次使用时再创建对象完成注入</p>
<p>属性的循环依赖主要是通过3个map来解决的</p>
<h2 id="构造器的循环依赖"><a href="#构造器的循环依赖" class="headerlink" title="构造器的循环依赖"></a>构造器的循环依赖</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class ConstructorA &#123;</span><br><span class="line"></span><br><span class="line">	private ConstructorB constructorB;</span><br><span class="line"></span><br><span class="line">	@Autowired</span><br><span class="line">	public ConstructorA(ConstructorB constructorB) &#123;</span><br><span class="line">		this.constructorB = constructorB;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class ConstructorB &#123;</span><br><span class="line"></span><br><span class="line">	private ConstructorA constructorA;</span><br><span class="line"></span><br><span class="line">	@Autowired</span><br><span class="line">	public ConstructorB(ConstructorA constructorA) &#123;</span><br><span class="line">		this.constructorA = constructorA;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@ComponentScan(&quot;com.javashitang.dependency.constructor&quot;)</span><br><span class="line">public class ConstructorConfig &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class ConstructorMain &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		AnnotationConfigApplicationContext context =</span><br><span class="line">				new AnnotationConfigApplicationContext(ConstructorConfig.class);</span><br><span class="line">		System.out.println(context.getBean(ConstructorA.class));</span><br><span class="line">		System.out.println(context.getBean(ConstructorB.class));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行 ConstructorMain 的 main 方法的时候会在第一行就报异常，说明 Spring 没办法初始化所有的 Bean，即上面这种形式的循环依赖 Spring 无法解决。</p>
<p>我们可以在 ConstructorA 或者 ConstructorB 构造函数的参数上加上 @Lazy 注解就可以解决</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Autowired</span><br><span class="line">public ConstructorB(@Lazy ConstructorA constructorA) &#123;</span><br><span class="line">	this.constructorA = constructorA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为我们主要关注属性的循环依赖，构造器的循环依赖就不做过多分析了</p>
<h2 id="属性的循环依赖"><a href="#属性的循环依赖" class="headerlink" title="属性的循环依赖"></a>属性的循环依赖</h2><p>先演示一下什么是属性的循环依赖</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class FieldA &#123;</span><br><span class="line"></span><br><span class="line">	@Autowired</span><br><span class="line">	private FieldB fieldB;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class FieldB &#123;</span><br><span class="line"></span><br><span class="line">	@Autowired</span><br><span class="line">	private FieldA fieldA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@ComponentScan(&quot;com.javashitang.dependency.field&quot;)</span><br><span class="line">public class FieldConfig &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class FieldMain &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		AnnotationConfigApplicationContext context =</span><br><span class="line">				new AnnotationConfigApplicationContext(FieldConfig.class);</span><br><span class="line">		// com.javashitang.dependency.field.FieldA@3aa9e816</span><br><span class="line">		System.out.println(context.getBean(FieldA.class));</span><br><span class="line">		// com.javashitang.dependency.field.FieldB@17d99928</span><br><span class="line">		System.out.println(context.getBean(FieldB.class));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Spring 容器正常启动，能获取到 FieldA 和 FieldB 这2个 Bean</p>
<p>属性的循环依赖在面试中还是经常被问到的。总体来说也不复杂，但是涉及到 Spring Bean 的初始化过程，所以感觉比较复杂，我写个 demo 演示一下整个过程</p>
<p>Spring 的 Bean 的初始化过程其实比较复杂，为了方便理解 Demo，我就把 Spring Bean 的初始化过程分为 2 部分</p>
<ol>
<li>bean 的实例化过程，即调用构造函数将对象创建出来</li>
<li>bean 的初始化过程，即填充 bean 的各种属性</li>
</ol>
<p>bean 初始化过程完毕，则 bean 就能被正常创建出来了</p>
<p>下面开始写 Demo，ObjectFactory 接口用来生产 Bean，和 Spring 中定义的接口一样</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface ObjectFactory&lt;T&gt; &#123;</span><br><span class="line">	T getObject();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">public class DependencyDemo &#123;</span><br><span class="line"></span><br><span class="line">	// 初始化完毕的Bean</span><br><span class="line">	private final Map&lt;String, Object&gt; singletonObjects =</span><br><span class="line">			new ConcurrentHashMap&lt;&gt;(256);</span><br><span class="line"></span><br><span class="line">	// 正在初始化的Bean对应的工厂，此时对象已经被实例化</span><br><span class="line">	private final Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories =</span><br><span class="line">			new HashMap&lt;&gt;(16);</span><br><span class="line"></span><br><span class="line">	// 存放正在初始化的Bean，对象还没有被实例化之前就放进来了</span><br><span class="line">	private final Set&lt;String&gt; singletonsCurrentlyInCreation =</span><br><span class="line">			Collections.newSetFromMap(new ConcurrentHashMap&lt;&gt;(16));</span><br><span class="line"></span><br><span class="line">	public  &lt;T&gt; T getBean(Class&lt;T&gt; beanClass) throws Exception &#123;</span><br><span class="line">		// 类名为Bean的名字</span><br><span class="line">		String beanName = beanClass.getSimpleName();</span><br><span class="line">		// 已经初始化好了，或者正在初始化</span><br><span class="line">		Object initObj = getSingleton(beanName, true);</span><br><span class="line">		if (initObj != null) &#123;</span><br><span class="line">			return (T) initObj;</span><br><span class="line">		&#125;</span><br><span class="line">		// bean正在被初始化</span><br><span class="line">		singletonsCurrentlyInCreation.add(beanName);</span><br><span class="line">		// 实例化bean</span><br><span class="line">		Object object = beanClass.getDeclaredConstructor().newInstance();</span><br><span class="line">		singletonFactories.put(beanName, () -&gt; &#123;</span><br><span class="line">			return object;</span><br><span class="line">		&#125;);</span><br><span class="line">		// 开始初始化bean，即填充属性</span><br><span class="line">		Field[] fields = object.getClass().getDeclaredFields();</span><br><span class="line">		for (Field field : fields) &#123;</span><br><span class="line">			field.setAccessible(true);</span><br><span class="line">			// 获取需要注入字段的class</span><br><span class="line">			Class&lt;?&gt; fieldClass = field.getType();</span><br><span class="line">			field.set(object, getBean(fieldClass));</span><br><span class="line">		&#125;</span><br><span class="line">		// 初始化完毕</span><br><span class="line">		singletonObjects.put(beanName, object);</span><br><span class="line">		singletonsCurrentlyInCreation.remove(beanName);</span><br><span class="line">		return (T) object;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * allowEarlyReference参数的含义是Spring是否允许循环依赖，默认为true</span><br><span class="line">	 * 所以当allowEarlyReference设置为false的时候，当项目存在循环依赖，会启动失败</span><br><span class="line">	 */</span><br><span class="line">	public Object getSingleton(String beanName, boolean allowEarlyReference) &#123;</span><br><span class="line">		Object singletonObject = this.singletonObjects.get(beanName);</span><br><span class="line">		if (singletonObject == null </span><br><span class="line">				&amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">			synchronized (this.singletonObjects) &#123;</span><br><span class="line">				if (singletonObject == null &amp;&amp; allowEarlyReference) &#123;</span><br><span class="line">					ObjectFactory&lt;?&gt; singletonFactory =</span><br><span class="line">							this.singletonFactories.get(beanName);</span><br><span class="line">					if (singletonFactory != null) &#123;</span><br><span class="line">						singletonObject = singletonFactory.getObject();</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		return singletonObject;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * 判断bean是否正在被初始化</span><br><span class="line">	 */</span><br><span class="line">	public boolean isSingletonCurrentlyInCreation(String beanName) &#123;</span><br><span class="line">		return this.singletonsCurrentlyInCreation.contains(beanName);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>测试一波</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">	DependencyDemo dependencyDemo = new DependencyDemo();</span><br><span class="line">	// 假装扫描出来的对象</span><br><span class="line">	Class[] classes = &#123;A.class, B.class&#125;;</span><br><span class="line">	// 假装项目初始化所有bean</span><br><span class="line">	for (Class aClass : classes) &#123;</span><br><span class="line">		dependencyDemo.getBean(aClass);</span><br><span class="line">	&#125;</span><br><span class="line">	// true</span><br><span class="line">	System.out.println(</span><br><span class="line">			dependencyDemo.getBean(B.class).getA() == dependencyDemo.getBean(A.class));</span><br><span class="line">	// true</span><br><span class="line">	System.out.println(</span><br><span class="line">			dependencyDemo.getBean(A.class).getB() == dependencyDemo.getBean(B.class));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>是不是很简单？我们只用了 2 个 map 就搞定了 Spring 的循环依赖</p>
<p>2 个 Map 就能搞定循环依赖，那为什么 Spring 要用 3 个 Map 呢？</p>
<p>原因其实也很简单，当我们从 singletonFactories 中根据 BeanName 获取相应的 ObjectFactory，然后调用 getObject() 这个方法返回对应的 Bean。在我们的例子中 ObjectFactory 的实现很简单哈，就是将实例化好的对象直接返回，但是在 Spring 中就没有这么简单了，执行过程比较复杂，为了避免每次拿到 ObjectFactory 然后调用 getObject()，我们直接把 ObjectFactory 创建的对象缓存起来不就行了，这样就能提高效率了</p>
<p>比如 A 依赖 B 和 C，B 和 C 又依赖 A，如果不做缓存那么初始化 B 和 C 都会调用 A 对应的 ObjectFactory的getObject() 方法。如果做缓存只需要 B 或者 C 调用一次即可。</p>
<p>知道了思路，我们把上面的代码改一波，加个缓存。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">public class DependencyDemo &#123;</span><br><span class="line"></span><br><span class="line">	// 初始化完毕的Bean</span><br><span class="line">	private final Map&lt;String, Object&gt; singletonObjects =</span><br><span class="line">			new ConcurrentHashMap&lt;&gt;(256);</span><br><span class="line"></span><br><span class="line">	// 正在初始化的Bean对应的工厂，此时对象已经被实例化</span><br><span class="line">	private final Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories =</span><br><span class="line">			new HashMap&lt;&gt;(16);</span><br><span class="line"></span><br><span class="line">	// 缓存Bean对应的工厂生产好的Bean</span><br><span class="line">	private final Map&lt;String, Object&gt; earlySingletonObjects =</span><br><span class="line">			new HashMap&lt;&gt;(16);</span><br><span class="line"></span><br><span class="line">	// 存放正在初始化的Bean，对象还没有被实例化之前就放进来了</span><br><span class="line">	private final Set&lt;String&gt; singletonsCurrentlyInCreation =</span><br><span class="line">			Collections.newSetFromMap(new ConcurrentHashMap&lt;&gt;(16));</span><br><span class="line"></span><br><span class="line">	public  &lt;T&gt; T getBean(Class&lt;T&gt; beanClass) throws Exception &#123;</span><br><span class="line">		// 类名为Bean的名字</span><br><span class="line">		String beanName = beanClass.getSimpleName();</span><br><span class="line">		// 已经初始化好了，或者正在初始化</span><br><span class="line">		Object initObj = getSingleton(beanName, true);</span><br><span class="line">		if (initObj != null) &#123;</span><br><span class="line">			return (T) initObj;</span><br><span class="line">		&#125;</span><br><span class="line">		// bean正在被初始化</span><br><span class="line">		singletonsCurrentlyInCreation.add(beanName);</span><br><span class="line">		// 实例化bean</span><br><span class="line">		Object object = beanClass.getDeclaredConstructor().newInstance();</span><br><span class="line">		singletonFactories.put(beanName, () -&gt; &#123;</span><br><span class="line">			return object;</span><br><span class="line">		&#125;);</span><br><span class="line">		// 开始初始化bean，即填充属性</span><br><span class="line">		Field[] fields = object.getClass().getDeclaredFields();</span><br><span class="line">		for (Field field : fields) &#123;</span><br><span class="line">			field.setAccessible(true);</span><br><span class="line">			// 获取需要注入字段的class</span><br><span class="line">			Class&lt;?&gt; fieldClass = field.getType();</span><br><span class="line">			field.set(object, getBean(fieldClass));</span><br><span class="line">		&#125;</span><br><span class="line">		singletonObjects.put(beanName, object);</span><br><span class="line">		singletonsCurrentlyInCreation.remove(beanName);</span><br><span class="line">		earlySingletonObjects.remove(beanName);</span><br><span class="line">		return (T) object;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * allowEarlyReference参数的含义是Spring是否允许循环依赖，默认为true</span><br><span class="line">	 */</span><br><span class="line">	public Object getSingleton(String beanName, boolean allowEarlyReference) &#123;</span><br><span class="line">		Object singletonObject = this.singletonObjects.get(beanName);</span><br><span class="line">		if (singletonObject == null</span><br><span class="line">				&amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">			synchronized (this.singletonObjects) &#123;</span><br><span class="line">				singletonObject = this.earlySingletonObjects.get(beanName);</span><br><span class="line">				if (singletonObject == null &amp;&amp; allowEarlyReference) &#123;</span><br><span class="line">					ObjectFactory&lt;?&gt; singletonFactory =</span><br><span class="line">							this.singletonFactories.get(beanName);</span><br><span class="line">					if (singletonFactory != null) &#123;</span><br><span class="line">						singletonObject = singletonFactory.getObject();</span><br><span class="line">						this.earlySingletonObjects.put(beanName, singletonObject);</span><br><span class="line">						this.singletonFactories.remove(beanName);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		return singletonObject;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们写的 getSingleton 的实现和 org.springframework.beans.factory.support.DefaultSingletonBeanRegistry#getSingleton(java.lang.String, boolean) 的实现一模一样，这个方法几乎所有分析 Spring 循环依赖的文章都会提到，这次你明白工作原理是什么了把</p>
<h2 id="总结一波"><a href="#总结一波" class="headerlink" title="总结一波"></a>总结一波</h2><ol>
<li>拿 bean 的时候先从 singletonObjects（一级缓存）中获取</li>
<li>如果获取不到，并且对象正在创建中，就从 earlySingletonObjects（二级缓存）中获取</li>
<li>如果还是获取不到就从 singletonFactories（三级缓存）中获取，然后将获取到的对象放到 earlySingletonObjects（二级缓存）中，并且将 bean 对应的 singletonFactories（三级缓存）清除</li>
<li>bean 初始化完毕，放到 singletonObjects（一级缓存）中，将 bean 对应的 earlySingletonObjects（二级缓存）清除</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wetts.github.io/2021/06/03/%E8%AF%AD%E8%A8%80/Java/basic_Java/API/%E5%B9%B6%E5%8F%91/%E5%85%B6%E4%BB%96/Java-%E5%A4%9A%E7%BA%BF%E7%A8%8B-Callable%E6%8E%A5%E5%8F%A3%E5%8F%8AFutrue%E6%8E%A5%E5%8F%A3%E8%AF%A6%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Zhang Wetts">
      <meta itemprop="description" content="Stay Hungry, Stay Foolish. <br><br><p style="font-size:8px;">[build by hexo/next/gitalk/hexo-generator-search/LaTeX]</p>">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wetts's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/06/03/%E8%AF%AD%E8%A8%80/Java/basic_Java/API/%E5%B9%B6%E5%8F%91/%E5%85%B6%E4%BB%96/Java-%E5%A4%9A%E7%BA%BF%E7%A8%8B-Callable%E6%8E%A5%E5%8F%A3%E5%8F%8AFutrue%E6%8E%A5%E5%8F%A3%E8%AF%A6%E8%A7%A3/" class="post-title-link" itemprop="url">Java-多线程-Callable接口及Futrue接口详解.md</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-06-03 15:34:03" itemprop="dateCreated datePublished" datetime="2021-06-03T15:34:03+08:00">2021-06-03</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>转自：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/guanbin-529/p/11784914.html">https://www.cnblogs.com/guanbin-529/p/11784914.html</a></p>
<h2 id="Callable接口"><a href="#Callable接口" class="headerlink" title="Callable接口"></a>Callable接口</h2><p>有两种创建线程的方法：一种是通过创建 Thread 类，另一种是通过使用 Runnable 创建线程。但是，Runnable 缺少的一项功能是，当线程终止时（即run() 完成时），我们无法使线程返回结果。为了支持此功能，Java 中提供了 Callable 接口。</p>
<ul>
<li>为了实现 Runnable，需要实现不返回任何内容的 run() 方法，而对于 Callable，需要实现在完成时返回结果的 call() 方法。请注意，不能使用 Callable 创建线程，只能使用 Runnable 创建线程。</li>
<li>另一个区别是 call() 方法可以引发异常，而 run() 则不能。</li>
<li>为实现 Callable 而必须重写 call 方法。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// Java program to illustrate Callable </span><br><span class="line">// to return a random number </span><br><span class="line">import java.util.Random; </span><br><span class="line">import java.util.concurrent.Callable; </span><br><span class="line">import java.util.concurrent.FutureTask; </span><br><span class="line">  </span><br><span class="line">class CallableExample implements Callable </span><br><span class="line">&#123; </span><br><span class="line">  </span><br><span class="line">    public Object call() throws Exception </span><br><span class="line">    &#123; </span><br><span class="line">        // Create random number generator </span><br><span class="line">        Random generator = new Random(); </span><br><span class="line">  </span><br><span class="line">        Integer randomNumber = generator.nextInt(5); </span><br><span class="line">  </span><br><span class="line">        // To simulate a heavy computation, </span><br><span class="line">        // we delay the thread for some random time </span><br><span class="line">        Thread.sleep(randomNumber * 1000); </span><br><span class="line">  </span><br><span class="line">        return randomNumber; </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h2 id="Futrue接口"><a href="#Futrue接口" class="headerlink" title="Futrue接口"></a>Futrue接口</h2><p>当 call() 方法完成时，结果必须存储在主线程已知的对象中，以便主线程可以知道该线程返回的结果。为此，可以使用 Future 对象。将 Future 视为保存结果的对象–它可能暂时不保存结果，但将来会保存（一旦 Callable 返回）。因此，Future 基本上是主线程可以跟踪进度以及其他线程的结果的一种方式。要实现此接口，必须重写 5 种方法，但是由于下面的示例使用了库中的具体实现，因此这里仅列出了重要的方法。</p>
<ul>
<li>public boolean cancel(boolean mayInterrupt)：用于停止任务。如果尚未启动，它将停止任务。如果已启动，则仅在 mayInterrupt 为 true 时才会中断任务。</li>
<li>public Object get() 抛出 InterruptedException，ExecutionException：用于获取任务的结果。如果任务完成，它将立即返回结果，否则将等待任务完成，然后返回结果。</li>
<li>public boolean isDone()：如果任务完成，则返回 true，否则返回 false</li>
</ul>
<p>可以看到 Callable 和 Future 做两件事：Callable 与 Runnable类似，因为它封装了要在另一个线程上运行的任务，而 Future 用于存储从另一个线程获得的结果。实际上，future 也可以与 Runnable 一起使用。</p>
<p>要创建线程，需要 Runnable。为了获得结果，需要 future。</p>
<p>Java 库具有具体的 FutureTask 类型，该类型实现 Runnable 和 Future，并方便地将两种功能组合在一起。<br>可以通过为其构造函数提供 Callable 来创建 FutureTask。然后，将 FutureTask 对象提供给 Thread 的构造函数以创建 Thread 对象。因此，间接地使用 Callable 创建线程。</p>
<h3 id="使用Callable和Future的完整示例"><a href="#使用Callable和Future的完整示例" class="headerlink" title="使用Callable和Future的完整示例"></a>使用Callable和Future的完整示例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line">package com.example.thread.callable;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.Date;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author: GuanBin</span><br><span class="line"> * @date: Created in 下午11:19 2019/10/31</span><br><span class="line"> */</span><br><span class="line">public class TestCallable implements Callable&lt;Object&gt; &#123;</span><br><span class="line"></span><br><span class="line">    private int taskNum;</span><br><span class="line"></span><br><span class="line">    public TestCallable(int taskNum) &#123;</span><br><span class="line">        this.taskNum = taskNum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //1，2主要区别是创建线程的方式</span><br><span class="line">    public static void main(String[] args) throws ExecutionException, InterruptedException &#123;</span><br><span class="line">        test1();</span><br><span class="line">        test2();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 使用Executors.newFixedThreadPool创建线程池</span><br><span class="line">     * @throws InterruptedException</span><br><span class="line">     * @throws ExecutionException</span><br><span class="line">     */</span><br><span class="line">    private static void test1() throws InterruptedException, ExecutionException &#123;</span><br><span class="line">        System.out.println(&quot;----程序开始运行----&quot;);</span><br><span class="line">        Date date1 = new Date();</span><br><span class="line">        int taskSize=5;</span><br><span class="line">        ExecutorService pool = Executors.newFixedThreadPool(taskSize);</span><br><span class="line">        List&lt;Future&gt; list = new ArrayList&lt;Future&gt;();</span><br><span class="line">        for (int i = 0; i &lt; taskSize; i++) &#123;</span><br><span class="line">            Callable c = new TestCallable(i);</span><br><span class="line">            // 执行任务并获取Future对象</span><br><span class="line">            Future f = pool.submit(c);</span><br><span class="line">            list.add(f);</span><br><span class="line">        &#125;</span><br><span class="line">        // 关闭线程池</span><br><span class="line">        pool.shutdown();</span><br><span class="line">        // 获取所有并发任务的运行结果</span><br><span class="line">        for (Future f : list) &#123;</span><br><span class="line">            // 从Future对象上获取任务的返回值，并输出到控制台</span><br><span class="line">            System.out.println(&quot;&gt;&gt;&gt;&quot; + f.get().toString()); //OPTION + return 抛异常</span><br><span class="line">        &#125;</span><br><span class="line">        Date date2 = new Date();</span><br><span class="line">        System.out.println(&quot;----程序结束运行----，程序运行时间【&quot; + (date2.getTime() - date1.getTime()) + &quot;毫秒】&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 线程直接使用new Thread来创建</span><br><span class="line">     * @throws ExecutionException</span><br><span class="line">     * @throws InterruptedException</span><br><span class="line">     */</span><br><span class="line">    private static void test2() throws ExecutionException, InterruptedException &#123;</span><br><span class="line">        System.out.println(&quot;----程序开始运行----&quot;);</span><br><span class="line">        Date date1 = new Date();</span><br><span class="line">        int taskSize=5;</span><br><span class="line">        FutureTask[] randomNumberTasks = new FutureTask[5];</span><br><span class="line">        List&lt;Future&gt; list = new ArrayList&lt;Future&gt;();</span><br><span class="line">        for (int i = 0; i &lt; randomNumberTasks.length; i++) &#123;</span><br><span class="line">            Callable c = new TestCallable(i);</span><br><span class="line">            // 执行任务并获取Future对象</span><br><span class="line">            randomNumberTasks[i]=   new FutureTask(c);</span><br><span class="line"></span><br><span class="line">            Thread t = new Thread(randomNumberTasks[i]);</span><br><span class="line">            t.start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 获取所有并发任务的运行结果</span><br><span class="line">        for (Future f : randomNumberTasks) &#123;</span><br><span class="line">            // 从Future对象上获取任务的返回值，并输</span><br><span class="line">            System.out.println(&quot;&gt;&gt;&gt;&quot; + f.get().toString()); //OPTION + return 抛异常</span><br><span class="line">        &#125;</span><br><span class="line">        Date date2 = new Date();</span><br><span class="line">        System.out.println(&quot;----程序结束运行----，程序运行时间【&quot; + (date2.getTime() - date1.getTime()) + &quot;毫秒】&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * call方法的实现，主要用于执行线程的具体实现，并返回结果</span><br><span class="line">     * @return</span><br><span class="line">     * @throws Exception</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public Object call() throws Exception &#123;</span><br><span class="line">        System.out.println(&quot;&gt;&gt;&gt;&quot; + taskNum + &quot;任务启动&quot;);</span><br><span class="line">        Date dateTmp1 = new Date();</span><br><span class="line">        Thread.sleep(1000);</span><br><span class="line">        Date dateTmp2 = new Date();</span><br><span class="line">        long time = dateTmp2.getTime() - dateTmp1.getTime();</span><br><span class="line">        System.out.println(&quot;&gt;&gt;&gt;&quot; + taskNum + &quot;任务终止&quot;);</span><br><span class="line">        return taskNum + &quot;任务返回运行结果,当前任务时间【&quot; + time + &quot;毫秒】&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">----程序开始运行----</span><br><span class="line">&gt;&gt;&gt;0任务启动</span><br><span class="line">&gt;&gt;&gt;1任务启动</span><br><span class="line">&gt;&gt;&gt;2任务启动</span><br><span class="line">&gt;&gt;&gt;3任务启动</span><br><span class="line">&gt;&gt;&gt;4任务启动</span><br><span class="line">&gt;&gt;&gt;0任务终止</span><br><span class="line">&gt;&gt;&gt;0任务返回运行结果,当前任务时间【1002毫秒】</span><br><span class="line">&gt;&gt;&gt;1任务终止</span><br><span class="line">&gt;&gt;&gt;2任务终止</span><br><span class="line">&gt;&gt;&gt;4任务终止</span><br><span class="line">&gt;&gt;&gt;1任务返回运行结果,当前任务时间【1005毫秒】</span><br><span class="line">&gt;&gt;&gt;2任务返回运行结果,当前任务时间【1005毫秒】</span><br><span class="line">&gt;&gt;&gt;3任务终止</span><br><span class="line">&gt;&gt;&gt;3任务返回运行结果,当前任务时间【1005毫秒】</span><br><span class="line">&gt;&gt;&gt;4任务返回运行结果,当前任务时间【1005毫秒】</span><br><span class="line">----程序结束运行----，程序运行时间【1007毫秒】</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure>

<h3 id="使用-Callable-和-FutureTask-的完整示例"><a href="#使用-Callable-和-FutureTask-的完整示例" class="headerlink" title="使用 Callable 和 FutureTask 的完整示例"></a>使用 Callable 和 FutureTask 的完整示例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">// Java program to illustrate Callable and FutureTask </span><br><span class="line">// for random number generation </span><br><span class="line">import java.util.Random; </span><br><span class="line">import java.util.concurrent.Callable; </span><br><span class="line">import java.util.concurrent.FutureTask; </span><br><span class="line">  </span><br><span class="line">class CallableExample implements Callable </span><br><span class="line">&#123; </span><br><span class="line">  </span><br><span class="line">  public Object call() throws Exception </span><br><span class="line">  &#123; </span><br><span class="line">    Random generator = new Random(); </span><br><span class="line">    Integer randomNumber = generator.nextInt(5); </span><br><span class="line">  </span><br><span class="line">    Thread.sleep(randomNumber * 1000); </span><br><span class="line">  </span><br><span class="line">    return randomNumber; </span><br><span class="line">  &#125; </span><br><span class="line">  </span><br><span class="line">&#125; </span><br><span class="line">  </span><br><span class="line">public class CallableFutureTest </span><br><span class="line">&#123; </span><br><span class="line">  public static void main(String[] args) throws Exception </span><br><span class="line">  &#123; </span><br><span class="line">  </span><br><span class="line">    // FutureTask is a concrete class that </span><br><span class="line">    // implements both Runnable and Future </span><br><span class="line">    FutureTask[] randomNumberTasks = new FutureTask[5]; </span><br><span class="line">  </span><br><span class="line">    for (int i = 0; i &lt; 5; i++) </span><br><span class="line">    &#123; </span><br><span class="line">      Callable callable = new CallableExample(); </span><br><span class="line">  </span><br><span class="line">      // Create the FutureTask with Callable </span><br><span class="line">      randomNumberTasks[i] = new FutureTask(callable); </span><br><span class="line">  </span><br><span class="line">      // As it implements Runnable, create Thread </span><br><span class="line">      // with FutureTask </span><br><span class="line">      Thread t = new Thread(randomNumberTasks[i]); </span><br><span class="line">      t.start(); </span><br><span class="line">    &#125; </span><br><span class="line">  </span><br><span class="line">    for (int i = 0; i &lt; 5; i++) </span><br><span class="line">    &#123; </span><br><span class="line">      // As it implements Future, we can call get() </span><br><span class="line">      System.out.println(randomNumberTasks[i].get()); </span><br><span class="line">  </span><br><span class="line">      // This method blocks till the result is obtained </span><br><span class="line">      // The get method can throw checked exceptions </span><br><span class="line">      // like when it is interrupted. This is the reason </span><br><span class="line">      // for adding the throws clause to main </span><br><span class="line">    &#125; </span><br><span class="line">  &#125; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>启动线程后，与线程的所有交互都使用 FutureTask，因为它实现了 Future 接口。因此，不需要存储 Thread 对象。使用 FutureTask 对象，还可以取消任务，检查任务是否完成或尝试获取结果。</p>
<h3 id="使用Runnable来获取返回结果的实现"><a href="#使用Runnable来获取返回结果的实现" class="headerlink" title="使用Runnable来获取返回结果的实现"></a>使用Runnable来获取返回结果的实现</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">// Java program to illustrate Runnable </span><br><span class="line">// for random number generation </span><br><span class="line">import java.util.Random; </span><br><span class="line">import java.util.concurrent.Callable; </span><br><span class="line">import java.util.concurrent.FutureTask; </span><br><span class="line">  </span><br><span class="line">class RunnableExample implements Runnable </span><br><span class="line">&#123; </span><br><span class="line">    // Shared object to store result </span><br><span class="line">    private Object result = null; </span><br><span class="line">  </span><br><span class="line">    public void run() </span><br><span class="line">    &#123; </span><br><span class="line">        Random generator = new Random(); </span><br><span class="line">        Integer randomNumber = generator.nextInt(5); </span><br><span class="line">  </span><br><span class="line">        // As run cannot throw any Exception </span><br><span class="line">        try</span><br><span class="line">        &#123; </span><br><span class="line">            Thread.sleep(randomNumber * 1000); </span><br><span class="line">        &#125; </span><br><span class="line">        catch (InterruptedException e) </span><br><span class="line">        &#123; </span><br><span class="line">            e.printStackTrace(); </span><br><span class="line">        &#125; </span><br><span class="line">  </span><br><span class="line">        // Store the return value in result when done </span><br><span class="line">        result = randomNumber; </span><br><span class="line">  </span><br><span class="line">        // Wake up threads blocked on the get() method </span><br><span class="line">        synchronized(this) </span><br><span class="line">        &#123; </span><br><span class="line">            notifyAll(); </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">  </span><br><span class="line">    public synchronized Object get() </span><br><span class="line">          throws InterruptedException </span><br><span class="line">    &#123; </span><br><span class="line">        while (result == null) </span><br><span class="line">            wait(); </span><br><span class="line">  </span><br><span class="line">        return result; </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line">  </span><br><span class="line">// Code is almost same as the previous example with a </span><br><span class="line">// few changes made to use Runnable instead of Callable </span><br><span class="line">public class RunnableTest </span><br><span class="line">&#123; </span><br><span class="line">    public static void main(String[] args) throws Exception </span><br><span class="line">    &#123; </span><br><span class="line">        RunnableExample[] randomNumberTasks = new RunnableExample[5]; </span><br><span class="line">  </span><br><span class="line">        for (int i = 0; i &lt; 5; i++) </span><br><span class="line">        &#123; </span><br><span class="line">            randomNumberTasks[i] = new RunnableExample(); </span><br><span class="line">            Thread t = new Thread(randomNumberTasks[i]); </span><br><span class="line">            t.start(); </span><br><span class="line">        &#125; </span><br><span class="line">  </span><br><span class="line">        for (int i = 0; i &lt; 5; i++) </span><br><span class="line">            System.out.println(randomNumberTasks[i].get()); </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wetts.github.io/2021/06/01/%E8%AF%AD%E8%A8%80/Java/basic_Java/API/%E5%B9%B6%E5%8F%91/%E5%85%B6%E4%BB%96/Java-%E5%B9%B6%E5%8F%91-%E6%8E%A7%E5%88%B6%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Zhang Wetts">
      <meta itemprop="description" content="Stay Hungry, Stay Foolish. <br><br><p style="font-size:8px;">[build by hexo/next/gitalk/hexo-generator-search/LaTeX]</p>">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wetts's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/06/01/%E8%AF%AD%E8%A8%80/Java/basic_Java/API/%E5%B9%B6%E5%8F%91/%E5%85%B6%E4%BB%96/Java-%E5%B9%B6%E5%8F%91-%E6%8E%A7%E5%88%B6%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/" class="post-title-link" itemprop="url">Java-并发-控制多线程执行顺序.md</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-06-01 16:33:14" itemprop="dateCreated datePublished" datetime="2021-06-01T16:33:14+08:00">2021-06-01</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>转自：<a target="_blank" rel="noopener" href="https://blog.csdn.net/zzti_erlie/article/details/84926355">https://blog.csdn.net/zzti_erlie/article/details/84926355</a></p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>先看如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line"></span><br><span class="line">    static Thread thread1 = new Thread(()-&gt; &#123;</span><br><span class="line">        System.out.println(&quot;thread1&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    static Thread thread2 = new Thread(()-&gt; &#123;</span><br><span class="line">        System.out.println(&quot;thread2&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    static Thread thread3 = new Thread(()-&gt; &#123;</span><br><span class="line">        System.out.println(&quot;thread3&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        thread3.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重复执行多次，发现输出并不是按照线程的启动顺序来执行。因为这个里面涉及到CPU对线程的调度问题。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">thread1</span><br><span class="line">thread3</span><br><span class="line">thread2</span><br></pre></td></tr></table></figure>

<p>如何让 thread1，thread2，thread3 顺序执行呢？</p>
<h2 id="方法1"><a href="#方法1" class="headerlink" title="方法1"></a>方法1</h2><p>通过join方法去保证多线程顺序执行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line"></span><br><span class="line">    static Thread thread1 = new Thread(()-&gt; &#123;</span><br><span class="line">        System.out.println(&quot;thread1&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    static Thread thread2 = new Thread(()-&gt; &#123;</span><br><span class="line">        System.out.println(&quot;thread2&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    static Thread thread3 = new Thread(()-&gt; &#123;</span><br><span class="line">        System.out.println(&quot;thread3&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread1.join();</span><br><span class="line">        thread2.start();</span><br><span class="line">        thread2.join();</span><br><span class="line">        thread3.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到输出一直是如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">thread1</span><br><span class="line">thread2</span><br><span class="line">thread3</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure>

<p>join 是怎么实现这个功能的呢？</p>
<p>join 方法让主线程等待子线程结束以后才能继续运行，因此保证了线程的顺序执行</p>
<h2 id="方法2"><a href="#方法2" class="headerlink" title="方法2"></a>方法2</h2><p>使用单例线程池，用唯一的工作线程执行任务，保证所有任务按照指定顺序执行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService executorService = Executors.newSingleThreadExecutor();</span><br></pre></td></tr></table></figure>

<p>这个会把线程放在一个 FIFO 队列，依次执行线程</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line"></span><br><span class="line">    static Thread thread1 = new Thread(()-&gt; &#123;</span><br><span class="line">        System.out.println(&quot;thread1&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    static Thread thread2 = new Thread(()-&gt; &#123;</span><br><span class="line">        System.out.println(&quot;thread2&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    static Thread thread3 = new Thread(()-&gt; &#123;</span><br><span class="line">        System.out.println(&quot;thread3&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    static ExecutorService executorService = Executors.newSingleThreadExecutor();</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        executorService.submit(thread1);</span><br><span class="line">        executorService.submit(thread2);</span><br><span class="line">        executorService.submit(thread3);</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出一直为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">thread1</span><br><span class="line">thread2</span><br><span class="line">thread3</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wetts.github.io/2021/05/13/%E8%AF%AD%E8%A8%80/Java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%BE%8B/Java-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E9%97%AE%E9%A2%98%E4%B8%BA%E4%BD%95%E5%8F%AF%E4%BB%A5%E9%80%9A%E8%BF%87%E6%9E%9A%E4%B8%BE%E8%A7%A3%E5%86%B3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Zhang Wetts">
      <meta itemprop="description" content="Stay Hungry, Stay Foolish. <br><br><p style="font-size:8px;">[build by hexo/next/gitalk/hexo-generator-search/LaTeX]</p>">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wetts's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/13/%E8%AF%AD%E8%A8%80/Java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%BE%8B/Java-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E9%97%AE%E9%A2%98%E4%B8%BA%E4%BD%95%E5%8F%AF%E4%BB%A5%E9%80%9A%E8%BF%87%E6%9E%9A%E4%B8%BE%E8%A7%A3%E5%86%B3/" class="post-title-link" itemprop="url">Java-设计模式-单例模式问题为何可以通过枚举解决.md</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-05-13 21:30:07" itemprop="dateCreated datePublished" datetime="2021-05-13T21:30:07+08:00">2021-05-13</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>转自：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/call-me-pengye/p/11214435.html">https://www.cnblogs.com/call-me-pengye/p/11214435.html</a></p>
<p>首先我们都知道 enum 默认继承了 java.lang.Enum 类并实现了 java.lang.Seriablizable 和 java.lang.Comparable 两个接口。接下来我们将依次说明枚举是如何防止这三种方式对单例的破环</p>
<h2 id="克隆"><a href="#克隆" class="headerlink" title="克隆"></a>克隆</h2><p>一个普通的类要是clone必须实现 java.lang.Cloneable 接口，重写 clone() 方法，同理我们来看看枚举能否也是一样<br><img src="/2021/05/13/%E8%AF%AD%E8%A8%80/Java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%BE%8B/Java-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E9%97%AE%E9%A2%98%E4%B8%BA%E4%BD%95%E5%8F%AF%E4%BB%A5%E9%80%9A%E8%BF%87%E6%9E%9A%E4%B8%BE%E8%A7%A3%E5%86%B3/1.png" alt="1"></p>
<p>我们可以看到 enum 是不被允许重写 clone()，因为 Enum 类已经将 clone() 方法定义为 final 了，并且 Enum 在使用 clone() 时直接抛出异常，如下图，这就是枚举为什么能防止克隆破环的原因，它根本就不允许克隆<br><img src="/2021/05/13/%E8%AF%AD%E8%A8%80/Java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%BE%8B/Java-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E9%97%AE%E9%A2%98%E4%B8%BA%E4%BD%95%E5%8F%AF%E4%BB%A5%E9%80%9A%E8%BF%87%E6%9E%9A%E4%B8%BE%E8%A7%A3%E5%86%B3/2.png" alt="2"></p>
<h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class DestroySingleton &#123;</span><br><span class="line">    </span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        //通过反射获取</span><br><span class="line">        Constructor&lt;Singleton&gt; constructor = Singleton.class.getDeclaredConstructor();</span><br><span class="line">        constructor.setAccessible(true);</span><br><span class="line">        Singleton reflex = constructor.newInstance();</span><br><span class="line">        System.out.println(&quot;reflex的hashCode:&quot;+reflex.hashCode());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们先来看一下反射实现的主要步骤：首先通过 class 的 getDeclaredConstructor() 获取到反射对象的构造器，然后通过 newInstance() 调用其构造方法获取对象，getDeclaredConstructor() 主要是通过 getConstructor0() 来获取构造器，具体代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@CallerSensitive</span><br><span class="line">public Constructor&lt;T&gt; getDeclaredConstructor(Class&lt;?&gt;... parameterTypes)</span><br><span class="line">    throws NoSuchMethodException, SecurityException &#123;</span><br><span class="line">    checkMemberAccess(Member.DECLARED, Reflection.getCallerClass(), true);</span><br><span class="line">    return getConstructor0(parameterTypes, Member.DECLARED);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 getConstructor0 中，他会先调用 privateGetDeclaredConstructors 方法去获取；具体代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">private Constructor&lt;T&gt; getConstructor0(Class&lt;?&gt;[] parameterTypes,int which) throws NoSuchMethodException</span><br><span class="line">    &#123;</span><br><span class="line">        Constructor&lt;T&gt;[] constructors = privateGetDeclaredConstructors((which == Member.PUBLIC));</span><br><span class="line">        for (Constructor&lt;T&gt; constructor : constructors) &#123;</span><br><span class="line">            if (arrayContentsEq(parameterTypes,constructor.getParameterTypes())) &#123;</span><br><span class="line">                return getReflectionFactory().copyConstructor(constructor);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        throw new NoSuchMethodException(getName() + &quot;.&lt;init&gt;&quot; + argumentTypesToString(parameterTypes));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>在 privateGetDeclaredConstructors() 中 publicOnly 的值是 false，ReflectionData 的 publicConstructors 和 declaredConstructors 都是 null；而 privateGetDeclaredConstructors() 中真正决定 <code>Constructor&lt;T&gt;[]</code> 的代码是 getDeclaredConstructors0(publicOnly)。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">private Constructor&lt;T&gt;[] privateGetDeclaredConstructors(boolean publicOnly) &#123;</span><br><span class="line">        checkInitted();</span><br><span class="line">        Constructor&lt;T&gt;[] res;</span><br><span class="line">        ReflectionData&lt;T&gt; rd = reflectionData();</span><br><span class="line">        if (rd != null) &#123;</span><br><span class="line">            res = publicOnly ? rd.publicConstructors : rd.declaredConstructors;</span><br><span class="line">            if (res != null) return res;</span><br><span class="line">        &#125;</span><br><span class="line">        // No cached value available; request value from VM</span><br><span class="line">        if (isInterface()) &#123;</span><br><span class="line">            @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">            Constructor&lt;T&gt;[] temporaryRes = (Constructor&lt;T&gt;[]) new Constructor&lt;?&gt;[0];</span><br><span class="line">            res = temporaryRes;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            res = getDeclaredConstructors0(publicOnly);</span><br><span class="line">        &#125;</span><br><span class="line">        if (rd != null) &#123;</span><br><span class="line">            if (publicOnly) &#123;</span><br><span class="line">                rd.publicConstructors = res;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                rd.declaredConstructors = res;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>在得到 <code>Constructor&lt;T&gt;[]</code> 后回到 getConstructor0() 将依次对其进行轮询判断，找到合适的 Constructor 并交由 ReflectionFactory 工厂 copy 出一个 Constructor。其中轮询的判断条件由 parameterTypes 和 constructor.getParameterTypes() 决定，parameterTypes 是个空数组；普通类的 constructor.getParameterTypes() 得出的结果也是空数组，而枚举产生的数组为:<code>[class java.lang.String, int]</code>；接着就交由 arrayContentsEq() 执行，并返回一个 boolean值。</p>
<p>arrayContentsEq 具体代码如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">private static boolean arrayContentsEq(Object[] a1, Object[] a2) &#123;</span><br><span class="line">        if (a1 == null) &#123;</span><br><span class="line">            return a2 == null || a2.length == 0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (a2 == null) &#123;</span><br><span class="line">            return a1.length == 0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (a1.length != a2.length) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; a1.length; i++) &#123;</span><br><span class="line">            if (a1[i] != a2[i]) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>普通类在 arrayContentsEq() 中所有的 if 和 for 都通不过，最后直接返回 true；而枚举类则会因为 <code>a1.length != a2.length</code>（注：a2.length的之为2）条件成立而返回 false。于是普通类接着执行 <code>return getReflectionFactory().copyConstructor(constructor);</code> 而枚举类则直接抛出异常 <code>throw new NoSuchMethodException(getName() + &quot;.&lt;init&gt;&quot; + argumentTypesToString(parameterTypes));</code> 具体错误信息如下：</p>
<blockquote>
<p>Exception in thread “main” java.lang.NoSuchMethodException: designPatterns.singleton.useenum.Singleton.<init>()<br>　　　　 at java.lang.Class.getConstructor0(Class.java:3082)<br>　　　　 at java.lang.Class.getDeclaredConstructor(Class.java:2178)<br>　　　　 at designPatterns.singleton.useenum.DestroySingleton.main(DestroySingleton.java:18)</init></p>
</blockquote>
<p>从控制台输出的信息来看 parameterTypes 的确是一个空对象，但是为什么给出 init() 的 NoSuchMethodException 异常。这就是为什么枚举不能通过反射实例化的原因之一，另一个原因就是：在获取到类构造器后通过 newInstance() 来实例化前，枚举是无法通过</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if( (clazz.getModifiers() &amp; Modifier.ENUM) != 0 )</span><br></pre></td></tr></table></figure>
<p>条件判断的，具体代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@CallerSensitive</span><br><span class="line">    public T newInstance(Object ... initargs)</span><br><span class="line">        throws InstantiationException, IllegalAccessException,</span><br><span class="line">               IllegalArgumentException, InvocationTargetException</span><br><span class="line">    &#123;</span><br><span class="line">        if (!override) &#123;</span><br><span class="line">            if (!Reflection.quickCheckMemberAccess(clazz, modifiers)) &#123;</span><br><span class="line">                Class&lt;?&gt; caller = Reflection.getCallerClass();</span><br><span class="line">                checkAccess(caller, clazz, null, modifiers);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if ((clazz.getModifiers() &amp; Modifier.ENUM) != 0)</span><br><span class="line">            throw new IllegalArgumentException(&quot;Cannot reflectively create enum objects&quot;);</span><br><span class="line">        ConstructorAccessor ca = constructorAccessor;   // read volatile</span><br><span class="line">        if (ca == null) &#123;</span><br><span class="line">            ca = acquireConstructorAccessor();</span><br><span class="line">        &#125;</span><br><span class="line">        @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">        T inst = (T) ca.newInstance(initargs);</span><br><span class="line">        return inst;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class CreateClassBySerialized &#123;</span><br><span class="line">    </span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">    public static &lt;T extends Serializable&gt; T createClassBySerialized(T  t) throws IOException, ClassNotFoundException&#123;</span><br><span class="line">        ByteArrayOutputStream bos = new ByteArrayOutputStream();</span><br><span class="line">        ObjectOutputStream oos = new ObjectOutputStream(bos);</span><br><span class="line">        oos.writeObject(t);</span><br><span class="line">        ByteArrayInputStream bis = new ByteArrayInputStream(bos.toByteArray());</span><br><span class="line">        ObjectInputStream ois = new ObjectInputStream(bis);</span><br><span class="line">        T object = (T) ois.readObject();</span><br><span class="line">        if (ois != null)    ois.close();</span><br><span class="line">        if (bis != null) bis.close();</span><br><span class="line">        if (oos != null) oos.close();</span><br><span class="line">        if (bos != null) bos.close();</span><br><span class="line">        return object;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class DestroySingleton &#123;</span><br><span class="line">    </span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        //通过序列化，反序列化获取</span><br><span class="line">        Singleton serialize = CreateClassBySerialized.createClassBySerialized(Singleton.getInstance());</span><br><span class="line">        System.out.println(&quot;serialize的hashCode:&quot;+serialize.hashCode());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先我们先来看看为什么添加 readResolve() 方法就能防止序列化对单例的破环。关键的代码就是在 readObject() 里的 readObject0() 实现的，readObject() 具体代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public final Object readObject() throws IOException, ClassNotFoundException&#123;</span><br><span class="line">     if (enableOverride) &#123;</span><br><span class="line">         return readObjectOverride();</span><br><span class="line">     &#125;</span><br><span class="line">     // if nested read, passHandle contains handle of enclosing object</span><br><span class="line">     int outerHandle = passHandle;</span><br><span class="line">     try &#123;</span><br><span class="line">         Object obj = readObject0(false);</span><br><span class="line">         handles.markDependency(outerHandle, passHandle);</span><br><span class="line">         ClassNotFoundException ex = handles.lookupException(passHandle);</span><br><span class="line">         if (ex != null) &#123;</span><br><span class="line">             throw ex;</span><br><span class="line">         &#125;</span><br><span class="line">         if (depth == 0) &#123;</span><br><span class="line">             vlist.doCallbacks();</span><br><span class="line">         &#125;</span><br><span class="line">         return obj;</span><br><span class="line">     &#125; finally &#123;</span><br><span class="line">         passHandle = outerHandle;</span><br><span class="line">         if (closed &amp;&amp; depth == 0) &#123;</span><br><span class="line">             clear();</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>而 readObject0() 对类的实现体现在 switch 选择器上：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">switch (tc) &#123;</span><br><span class="line">    case TC_NULL:</span><br><span class="line">        return readNull();</span><br><span class="line">    case TC_REFERENCE:</span><br><span class="line">        return readHandle(unshared);</span><br><span class="line">    case TC_CLASS:</span><br><span class="line">        return readClass(unshared);</span><br><span class="line">    case TC_CLASSDESC:</span><br><span class="line">    case TC_PROXYCLASSDESC:</span><br><span class="line">        return readClassDesc(unshared);</span><br><span class="line">    case TC_STRING:</span><br><span class="line">    case TC_LONGSTRING:</span><br><span class="line">        return checkResolve(readString(unshared));</span><br><span class="line">    case TC_ARRAY:</span><br><span class="line">        return checkResolve(readArray(unshared));</span><br><span class="line">    case TC_ENUM:</span><br><span class="line">        return checkResolve(readEnum(unshared));</span><br><span class="line">    case TC_OBJECT:</span><br><span class="line">        return checkResolve(readOrdinaryObject(unshared));</span><br><span class="line">    case TC_EXCEPTION:</span><br><span class="line">        IOException ex = readFatalException();</span><br><span class="line">        throw new WriteAbortedException(&quot;writing aborted&quot;, ex);</span><br><span class="line">    case TC_BLOCKDATA:</span><br><span class="line">    case TC_BLOCKDATALONG:</span><br><span class="line">        if (oldMode) &#123;</span><br><span class="line">            bin.setBlockDataMode(true);</span><br><span class="line">            bin.peek();             // force header read</span><br><span class="line">            throw new OptionalDataException(bin.currentBlockRemaining());</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            throw new StreamCorruptedException(&quot;unexpected block data&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    case TC_ENDBLOCKDATA:</span><br><span class="line">        if (oldMode) &#123;</span><br><span class="line">            throw new OptionalDataException(true);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            throw new StreamCorruptedException(&quot;unexpected end of block data&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    default:</span><br><span class="line">        throw new StreamCorruptedException(String.format(&quot;invalid type code: %02X&quot;, tc));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>tc 值不同，类的实现方式也不同；普通类(TC_OBJECT)由 readOrdinaryObject(unshared) 来实现，枚举类(TC_ENUM)由 readOrdinaryObject(unshared) 来实现。</p>
<p>readOrdinaryObject(unshared) 决定了类是通过构造器实现还是通过 readResolve() 来实现</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">if (obj != null &amp;&amp; handles.lookupException(passHandle) == null &amp;&amp; desc.hasReadResolveMethod())</span><br><span class="line">&#123;</span><br><span class="line">    Object rep = desc.invokeReadResolve(obj);</span><br><span class="line">    if (unshared &amp;&amp; rep.getClass().isArray()) &#123;</span><br><span class="line">        rep = cloneArray(rep);</span><br><span class="line">    &#125;</span><br><span class="line">    if (rep != obj) &#123;</span><br><span class="line">        // Filter the replacement object</span><br><span class="line">        if (rep != null) &#123;</span><br><span class="line">            if (rep.getClass().isArray()) &#123;</span><br><span class="line">                filterCheck(rep.getClass(), Array.getLength(rep));</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                filterCheck(rep.getClass(), -1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        handles.setObject(passHandle, obj = rep);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中 desc.hasReadResolveMethod() 就是来用判断是否有 readResolve()</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">boolean hasReadResolveMethod() &#123;</span><br><span class="line">    requireInitialized();</span><br><span class="line">    return (readResolveMethod != null);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果不存在 readResolve() 则 readResolveMethod 为 null，反之则为 readResolve() 对应的 Method 对象（我这儿的是 private java.lang.Object designPatterns.singleton.doublecheck.Singleton.readResolve() ）。于是乎就执行 desc.invokeReadResolve(obj) 代码，通过 Method.invoke 执行 readResolve() 方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">Object invokeReadResolve(Object obj) throws IOException, UnsupportedOperationException</span><br><span class="line">&#123;</span><br><span class="line">    requireInitialized();</span><br><span class="line">    if (readResolveMethod != null) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            return readResolveMethod.invoke(obj, (Object[]) null);</span><br><span class="line">        &#125; catch (InvocationTargetException ex) &#123;</span><br><span class="line">            Throwable th = ex.getTargetException();</span><br><span class="line">            if (th instanceof ObjectStreamException) &#123;</span><br><span class="line">                throw (ObjectStreamException) th;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                throwMiscException(th);</span><br><span class="line">                throw new InternalError(th);  // never reached</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (IllegalAccessException ex) &#123;</span><br><span class="line">            // should not occur, as access checks have been suppressed</span><br><span class="line">            throw new InternalError(ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        throw new UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@CallerSensitive</span><br><span class="line">public Object invoke(Object obj, Object... args) throws IllegalAccessException, IllegalArgumentException,InvocationTargetException</span><br><span class="line">&#123;</span><br><span class="line">    if (!override) &#123;</span><br><span class="line">        if (!Reflection.quickCheckMemberAccess(clazz, modifiers)) &#123;</span><br><span class="line">            Class&lt;?&gt; caller = Reflection.getCallerClass();</span><br><span class="line">            checkAccess(caller, clazz, obj, modifiers);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    MethodAccessor ma = methodAccessor;             // read volatile</span><br><span class="line">    if (ma == null) &#123;</span><br><span class="line">        ma = acquireMethodAccessor();</span><br><span class="line">    &#125;</span><br><span class="line">    return ma.invoke(obj, args);                   // readResolve最终执行处&#125;</span><br></pre></td></tr></table></figure>

<p>这样就得到了我们的静态 singleton，实现单例模式。而在实现枚举的 readEnum() 方法中，枚举的实现是通过调用 java.lang.Enum的 静态方法 valueOf 来实现的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;T extends Enum&lt;T&gt;&gt; T valueOf(Class&lt;T&gt; enumType,String name) &#123;</span><br><span class="line">        T result = enumType.enumConstantDirectory().get(name);</span><br><span class="line">        if (result != null)</span><br><span class="line">            return result;</span><br><span class="line">        if (name == null)</span><br><span class="line">            throw new NullPointerException(&quot;Name is null&quot;);</span><br><span class="line">        throw new IllegalArgumentException(</span><br><span class="line">            &quot;No enum constant &quot; + enumType.getCanonicalName() + &quot;.&quot; + name);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>enumType.enumConstantDirectory() 返回的对象是继承了枚举常量的 hashMap，其中 key 键是枚举常量名字，value 键是常量枚举对象本身；当它拿到枚举类中全部的枚举后，再其轮询将每一个枚举常量存入 hashMap 中：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, T&gt; enumConstantDirectory() &#123;</span><br><span class="line">        if (enumConstantDirectory == null) &#123;</span><br><span class="line">            T[] universe = getEnumConstantsShared();</span><br><span class="line">            if (universe == null)</span><br><span class="line">                throw new IllegalArgumentException(</span><br><span class="line">                    getName() + &quot; is not an enum type&quot;);</span><br><span class="line">            Map&lt;String, T&gt; m = new HashMap&lt;&gt;(2 * universe.length);</span><br><span class="line">            for (T constant : universe)</span><br><span class="line">                m.put(((Enum&lt;?&gt;)constant).name(), constant);</span><br><span class="line">            enumConstantDirectory = m;</span><br><span class="line">        &#125;</span><br><span class="line">        return enumConstantDirectory;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//getEnumConstantsShared()就是获取到的一个个枚举对象</span><br><span class="line">T[] getEnumConstantsShared() &#123;</span><br><span class="line">        if (enumConstants == null) &#123;</span><br><span class="line">            if (!isEnum()) return null;</span><br><span class="line">            try &#123;</span><br><span class="line">                final Method values = getMethod(&quot;values&quot;);</span><br><span class="line">                java.security.AccessController.doPrivileged(</span><br><span class="line">                    new java.security.PrivilegedAction&lt;Void&gt;() &#123;</span><br><span class="line">                        public Void run() &#123;</span><br><span class="line">                                values.setAccessible(true);</span><br><span class="line">                                return null;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;);</span><br><span class="line">                @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">                T[] temporaryConstants = (T[])values.invoke(null);</span><br><span class="line">                enumConstants = temporaryConstants;</span><br><span class="line">            &#125;</span><br><span class="line">            // These can happen when users concoct enum-like classes</span><br><span class="line">            // that don&#x27;t comply with the enum spec.</span><br><span class="line">            catch (InvocationTargetException | NoSuchMethodException |</span><br><span class="line">                   IllegalAccessException ex) &#123; return null; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return enumConstants;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>当我们拿到枚举的 hashMap 后，通过 get(name) 方法获取对应的枚举然后层层返回。代码中实现枚举的入口代码是 Enum.valueOf((Class)cl, name)，这样实现的现过其实就是 EnumClass.name(我代码的体现是Singleton.INSTANCE)，这样来看的话无论是 EnumClass.name 获取对象，还是 Enum.valueOf((Class)cl, name) 获取对象，它们得到的都是同一个对象，这其实就是枚举保持单例的原理。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/69/">69</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Zhang Wetts"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">Zhang Wetts</p>
  <div class="site-description" itemprop="description">Stay Hungry, Stay Foolish. <br><br><p style="font-size:8px;">[build by hexo/next/gitalk/hexo-generator-search/LaTeX]</p></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">681</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">67</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">349</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/wetts" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;wetts" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:zhang.wetts@163.com" title="E-Mail → mailto:zhang.wetts@163.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Zhang Wetts</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

  


<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/hibiki.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"react":{"opacity":0}});</script></body>
</html>
