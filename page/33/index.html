<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"wetts.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="Stay Hungry, Stay Foolish. [build by hexo&#x2F;next&#x2F;gitalk&#x2F;hexo-generator-search&#x2F;LaTeX]">
<meta property="og:type" content="website">
<meta property="og:title" content="Wetts&#39;s blog">
<meta property="og:url" content="https://wetts.github.io/page/33/index.html">
<meta property="og:site_name" content="Wetts&#39;s blog">
<meta property="og:description" content="Stay Hungry, Stay Foolish. [build by hexo&#x2F;next&#x2F;gitalk&#x2F;hexo-generator-search&#x2F;LaTeX]">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Zhang Wetts">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://wetts.github.io/page/33/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Wetts's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Wetts's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Stay Hungry, Stay Foolish.</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/wetts" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wetts.github.io/2016/12/09/%E8%AF%AD%E8%A8%80/Java/basic_Java/API/reflection/Java-Reflection-4.%E5%8F%98%E9%87%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Zhang Wetts">
      <meta itemprop="description" content="Stay Hungry, Stay Foolish. <br><br><p style="font-size:8px;">[build by hexo/next/gitalk/hexo-generator-search/LaTeX]</p>">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wetts's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2016/12/09/%E8%AF%AD%E8%A8%80/Java/basic_Java/API/reflection/Java-Reflection-4.%E5%8F%98%E9%87%8F/" class="post-title-link" itemprop="url">Java-Reflection-4.变量</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2016-12-09 16:57:17" itemprop="dateCreated datePublished" datetime="2016-12-09T16:57:17+08:00">2016-12-09</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>转自：<a target="_blank" rel="noopener" href="http://ifeve.com/java-reflection-fields/">http://ifeve.com/java-reflection-fields/</a></p>
<p>使用Java反射机制你可以运行期检查一个类的变量信息(成员变量)或者获取或者设置变量的值。通过使用java.lang.reflect.Field类就可以实现上述功能。在本节会带你深入了解Field对象的信息。</p>
<h2 id="获取Field对象"><a href="#获取Field对象" class="headerlink" title="获取Field对象"></a>获取Field对象</h2><p>可以通过Class对象获取Field对象，如下例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class aClass = ...//获取Class对象</span><br><span class="line">Field[] methods = aClass.getFields();</span><br></pre></td></tr></table></figure>
<p>返回的Field对象数组包含了指定类中声明为公有的(public)的所有变量集合。</p>
<p>如果你知道你要访问的变量名称，你可以通过如下的方式获取指定的变量：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class  aClass = MyObject.class</span><br><span class="line">Field field = aClass.getField(&quot;someField&quot;);</span><br></pre></td></tr></table></figure>
<p>上面的例子返回的Field类的实例对应的就是在MyObject类中声明的名为someField的成员变量，就是这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public class MyObject&#123;</span><br><span class="line">  public String someField = null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在调用getField()方法时，如果根据给定的方法参数没有找到对应的变量，那么就会抛出NoSuchFieldException。</p>
<h2 id="变量名称"><a href="#变量名称" class="headerlink" title="变量名称"></a>变量名称</h2><p>一旦你获取了Field实例，你可以通过调用Field.getName()方法获取他的变量名称，如下例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Field field = ... //获取Field对象</span><br><span class="line">String fieldName = field.getName();</span><br></pre></td></tr></table></figure>

<h2 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h2><p>你可以通过调用Field.getType()方法来获取一个变量的类型（如String, int等等）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Field field = aClass.getField(&quot;someField&quot;);</span><br><span class="line">Object fieldType = field.getType();</span><br></pre></td></tr></table></figure>

<h2 id="获取或设置（get-set）变量值"><a href="#获取或设置（get-set）变量值" class="headerlink" title="获取或设置（get/set）变量值"></a>获取或设置（get/set）变量值</h2><p>一旦你获得了一个Field的引用，你就可以通过调用Field.get()或Field.set()方法，获取或者设置变量的值，如下例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Class  aClass = MyObject.class</span><br><span class="line">Field field = aClass.getField(&quot;someField&quot;);</span><br><span class="line"></span><br><span class="line">MyObject objectInstance = new MyObject();</span><br><span class="line"></span><br><span class="line">Object value = field.get(objectInstance);</span><br><span class="line">field.set(objetInstance, value);</span><br></pre></td></tr></table></figure>
<p>传入Field.get()/Field.set()方法的参数objetInstance应该是拥有指定变量的类的实例。在上述的例子中传入的参数是MyObject类的实例，是因为someField是MyObject类的实例。</p>
<p>如果变量是静态变量的话(public static)那么在调用Field.get()/Field.set()方法的时候传入null做为参数而不用传递拥有该变量的类的实例。(译者注：你如果传入拥有该变量的类的实例也可以得到相同的结果)</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wetts.github.io/2016/12/09/%E8%AF%AD%E8%A8%80/Java/basic_Java/API/reflection/Java-Reflection-3.%E6%9E%84%E9%80%A0%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Zhang Wetts">
      <meta itemprop="description" content="Stay Hungry, Stay Foolish. <br><br><p style="font-size:8px;">[build by hexo/next/gitalk/hexo-generator-search/LaTeX]</p>">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wetts's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2016/12/09/%E8%AF%AD%E8%A8%80/Java/basic_Java/API/reflection/Java-Reflection-3.%E6%9E%84%E9%80%A0%E5%99%A8/" class="post-title-link" itemprop="url">Java-Reflection-3.构造器</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2016-12-09 16:52:22" itemprop="dateCreated datePublished" datetime="2016-12-09T16:52:22+08:00">2016-12-09</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>转自：<a target="_blank" rel="noopener" href="http://ifeve.com/java-reflection-constructors/">http://ifeve.com/java-reflection-constructors/</a></p>
<p>利用Java的反射机制你可以检查一个类的构造方法，并且可以在运行期创建一个对象。这些功能都是通过java.lang.reflect.Constructor这个类实现的。本节将深入的阐述Java Constructor对象。</p>
<h2 id="获取Constructor对象"><a href="#获取Constructor对象" class="headerlink" title="获取Constructor对象"></a>获取Constructor对象</h2><p>我们可以通过Class对象来获取Constructor类的实例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class aClass = ...//获取Class对象</span><br><span class="line">Constructor[] constructors = aClass.getConstructors();</span><br></pre></td></tr></table></figure>
<p>返回的Constructor数组包含每一个声明为公有的（Public）构造方法。</p>
<p>如果你知道你要访问的构造方法的方法参数类型，你可以用下面的方法获取指定的构造方法，这例子返回的构造方法的方法参数为String类型：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class aClass = ...//获取Class对象</span><br><span class="line">Constructor constructor = aClass.getConstructor(new Class[]&#123;String.class&#125;);</span><br></pre></td></tr></table></figure>
<p>如果没有指定的构造方法能满足匹配的方法参数则会抛出：NoSuchMethodException。</p>
<h2 id="构造方法参数"><a href="#构造方法参数" class="headerlink" title="构造方法参数"></a>构造方法参数</h2><p>你可以通过如下方式获取指定构造方法的方法参数信息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Constructor constructor = ... //获取Constructor对象</span><br><span class="line">Class[] parameterTypes = constructor.getParameterTypes();</span><br></pre></td></tr></table></figure>

<h2 id="利用Constructor对象实例化一个类"><a href="#利用Constructor对象实例化一个类" class="headerlink" title="利用Constructor对象实例化一个类"></a>利用Constructor对象实例化一个类</h2><p>你可以通过如下方法实例化一个类：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Constructor constructor = MyObject.class.getConstructor(String.class);</span><br><span class="line">MyObject myObject = (MyObject)constructor.newInstance(&quot;constructor-arg1&quot;);</span><br></pre></td></tr></table></figure>
<p>constructor.newInstance()方法的方法参数是一个可变参数列表，但是当你调用构造方法的时候你必须提供精确的参数，即形参与实参必须一一对应。在这个例子中构造方法需要一个String类型的参数，那我们在调用newInstance方法的时候就必须传入一个String类型的参数。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wetts.github.io/2016/12/09/%E8%AF%AD%E8%A8%80/Java/basic_Java/API/reflection/Java-Reflection-2.Classes/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Zhang Wetts">
      <meta itemprop="description" content="Stay Hungry, Stay Foolish. <br><br><p style="font-size:8px;">[build by hexo/next/gitalk/hexo-generator-search/LaTeX]</p>">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wetts's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2016/12/09/%E8%AF%AD%E8%A8%80/Java/basic_Java/API/reflection/Java-Reflection-2.Classes/" class="post-title-link" itemprop="url">Java-Reflection-2.Classes</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2016-12-09 16:43:51" itemprop="dateCreated datePublished" datetime="2016-12-09T16:43:51+08:00">2016-12-09</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>转自：<a target="_blank" rel="noopener" href="http://ifeve.com/java-reflection-classes/">http://ifeve.com/java-reflection-classes/</a></p>
<p>使用Java反射机制可以在运行时期检查Java类的信息，检查Java类的信息往往是你在使用Java反射机制的时候所做的第一件事情，通过获取类的信息你可以获取以下相关的内容：</p>
<ul>
<li>Class对象</li>
<li>类名</li>
<li>修饰符</li>
<li>包信息</li>
<li>父类</li>
<li>实现的接口</li>
<li>构造器</li>
<li>方法</li>
<li>变量</li>
<li>注解</li>
</ul>
<p>除了上述这些内容，还有很多的信息你可以通过反射机制获得，如果你想要知道全部的信息你可以查看相应的文档<a target="_blank" rel="noopener" href="http://docs.oracle.com/javase/6/docs/api/java/lang/Class.html">JavaDoc for java.lang.Class</a>里面有详尽的描述。</p>
<p>在本节中我们会简短的涉及上述所提及的信息，上述的一些主题我们会使用单独的章节进行更详细的描述，比如这段内容会描述如何获取一个类的所有方法或者指定方法，但是在单独的章节中则会向你展示如何调用反射获得的方法(Method Object)，如何在多个同名方法中通过给定的参数集合匹配到指定的方法，在一个方法通过反射机制调用的时候会抛出那些异常？如何准确的获取getter/setter方法等等。本节的内容主要是介绍Class类以及你能从Class类中获取哪些信息。</p>
<h2 id="Class对象"><a href="#Class对象" class="headerlink" title="Class对象"></a>Class对象</h2><p>在你想检查一个类的信息之前，你首先需要获取类的Class对象。Java中的所有类型包括基本类型(int, long, float等等)，即使是数组都有与之关联的Class类的对象。如果你在编译期知道一个类的名字的话，那么你可以使用如下的方式获取一个类的Class对象。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class myObjectClass = MyObject.class;</span><br></pre></td></tr></table></figure>
<p>如果你在编译期不知道类的名字，但是你可以在运行期获得到类名的字符串,那么你则可以这么做来获取Class对象:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String className = ... ;//在运行期获取的类名字符串</span><br><span class="line">Class class = Class.forName(className);</span><br></pre></td></tr></table></figure>
<p>在使用Class.forName()方法时，你必须提供一个类的全名，这个全名包括类所在的包的名字。例如MyObject类位于com.jenkov.myapp包，那么他的全名就是com.jenkov.myapp.MyObject。</p>
<p>如果在调用Class.forName()方法时，没有在编译路径下(classpath)找到对应的类，那么将会抛出ClassNotFoundException。</p>
<h2 id="类名"><a href="#类名" class="headerlink" title="类名"></a>类名</h2><p>你可以从Class对象中获取两个版本的类名。</p>
<p>通过getName() 方法返回类的全限定类名（包含包名）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class aClass = ... //获取Class对象，具体方式可见Class对象小节</span><br><span class="line">String className = aClass.getName();</span><br></pre></td></tr></table></figure>
<p>如果你仅仅只是想获取类的名字(不包含包名)，那么你可以使用getSimpleName()方法:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class aClass = ... //获取Class对象，具体方式可见Class对象小节</span><br><span class="line">String simpleClassName = aClass.getSimpleName();</span><br></pre></td></tr></table></figure>

<h2 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h2><p>可以通过Class对象来访问一个类的修饰符，即public,private,static等等的关键字，你可以使用如下方法来获取类的修饰符：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class aClass = ... //获取Class对象，具体方式可见Class对象小节</span><br><span class="line">int modifiers = aClass.getModifiers();</span><br></pre></td></tr></table></figure>
<p>修饰符都被包装成一个int类型的数字，这样每个修饰符都是一个位标识(flag bit)，这个位标识可以设置和清除修饰符的类型。<br>可以使用java.lang.reflect.Modifier类中的方法来检查修饰符的类型：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Modifier.isAbstract(int modifiers);</span><br><span class="line">Modifier.isFinal(int modifiers);</span><br><span class="line">Modifier.isInterface(int modifiers);</span><br><span class="line">Modifier.isNative(int modifiers);</span><br><span class="line">Modifier.isPrivate(int modifiers);</span><br><span class="line">Modifier.isProtected(int modifiers);</span><br><span class="line">Modifier.isPublic(int modifiers);</span><br><span class="line">Modifier.isStatic(int modifiers);</span><br><span class="line">Modifier.isStrict(int modifiers);</span><br><span class="line">Modifier.isSynchronized(int modifiers);</span><br><span class="line">Modifier.isTransient(int modifiers);</span><br><span class="line">Modifier.isVolatile(int modifiers);</span><br></pre></td></tr></table></figure>

<h2 id="包信息"><a href="#包信息" class="headerlink" title="包信息"></a>包信息</h2><p>可以使用Class对象通过如下的方式获取包信息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class aClass = ... //获取Class对象，具体方式可见Class对象小节</span><br><span class="line">Package package = aClass.getPackage();</span><br></pre></td></tr></table></figure>
<p>通过Package对象你可以获取包的相关信息，比如包名，你也可以通过Manifest文件访问位于编译路径下jar包的指定信息，比如你可以在Manifest文件中指定包的版本编号。更多的Package类信息可以阅读<a target="_blank" rel="noopener" href="http://docs.oracle.com/javase/6/docs/api/java/lang/Package.html">java.lang.Package</a>。</p>
<h2 id="父类"><a href="#父类" class="headerlink" title="父类"></a>父类</h2><p>通过Class对象你可以访问类的父类，如下例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class superclass = aClass.getSuperclass();</span><br></pre></td></tr></table></figure>
<p>可以看到superclass对象其实就是一个Class类的实例，所以你可以继续在这个对象上进行反射操作。</p>
<h2 id="实现的接口"><a href="#实现的接口" class="headerlink" title="实现的接口"></a>实现的接口</h2><p>可以通过如下方式获取指定类所实现的接口集合：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class  aClass = ... //获取Class对象，具体方式可见Class对象小节</span><br><span class="line">Class[] interfaces = aClass.getInterfaces();</span><br></pre></td></tr></table></figure>
<p>由于一个类可以实现多个接口，因此getInterfaces();方法返回一个Class数组，在Java中接口同样有对应的Class对象。</p>
<p>注意：getInterfaces()方法仅仅只返回当前类所实现的接口。当前类的父类如果实现了接口，这些接口是不会在返回的Class集合中的，尽管实际上当前类其实已经实现了父类接口。</p>
<h2 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h2><p>你可以通过如下方式访问一个类的构造方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Constructor[] constructors = aClass.getConstructors();</span><br></pre></td></tr></table></figure>
<p>更多有关Constructor的信息可以访问Constructors。</p>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>你可以通过如下方式访问一个类的所有方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Method[] method = aClass.getMethods();</span><br></pre></td></tr></table></figure>
<p>更多有关Method的信息可以访问Methods。</p>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>你可以通过如下方式访问一个类的成员变量：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Field[] field = aClass.getFields();</span><br></pre></td></tr></table></figure>
<p>更多有关Field的信息可以访问Fields。</p>
<h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><p>你可以通过如下方式访问一个类的注解：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Annotation[] annotations = aClass.getAnnotations();</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wetts.github.io/2016/12/09/%E8%AF%AD%E8%A8%80/Java/basic_Java/API/reflection/Java-Reflection-1.Java%E5%8F%8D%E5%B0%84%E6%8C%87%E5%8D%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Zhang Wetts">
      <meta itemprop="description" content="Stay Hungry, Stay Foolish. <br><br><p style="font-size:8px;">[build by hexo/next/gitalk/hexo-generator-search/LaTeX]</p>">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wetts's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2016/12/09/%E8%AF%AD%E8%A8%80/Java/basic_Java/API/reflection/Java-Reflection-1.Java%E5%8F%8D%E5%B0%84%E6%8C%87%E5%8D%97/" class="post-title-link" itemprop="url">Java-Reflection-1.Java反射指南</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2016-12-09 16:36:11" itemprop="dateCreated datePublished" datetime="2016-12-09T16:36:11+08:00">2016-12-09</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>转自：<a target="_blank" rel="noopener" href="http://ifeve.com/java-reflection-tutorial/">http://ifeve.com/java-reflection-tutorial/</a></p>
<p>Java反射机制可以让我们在编译期(Compile Time)之外的运行期(Runtime)检查类，接口，变量以及方法的信息。反射还可以让我们在运行期实例化对象，调用方法，通过调用get/set方法获取变量的值。</p>
<p>Java反射机制功能强大而且非常实用。举个例子，你可以用反射机制把Java对象映射到数据库表，就像Butterfly Persistence所做的那样，或者把脚本中的一段语句在运行期映射到相应的对象调用方法上，就像 Butterfly Container在解析它的配置脚本时所做的那样。</p>
<p>目前在互联网上已经有不胜枚举的Java反射指南，然而大多数的指南包括Sun公司所发布的反射指南中都仅仅只是介绍了一些反射的表面内容以及它的潜能。</p>
<p>在这个系列的文章中，我们会比其他指南更深入的去理解Java反射机制，它会阐述Java反射机制的基本原理包括如何去使用数组，注解，泛型以及动态代理还有类的动态加载以及类的重载的实现。同时也会向你展示如何实现一些比较有特性的功能，比如从一个类中读取所有的get/set方法，或者访问一个类的私有变量以及私有方法。在这个系列的指南中同时也会说明一些非反射相关的但是令人困惑的问题，比如哪些泛型信息在运行时是有效的，一些人声称所有的泛型信息在运行期都会消失，其实这是不对的。</p>
<p>该系列文章中所描述介绍的是Java 6版本的反射机制。</p>
<h4 id="Java反射的例子"><a href="#Java反射的例子" class="headerlink" title="Java反射的例子"></a>Java反射的例子</h4><p>下面是一个Java反射的简单例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Method[] methods = MyObject.class.getMethods();</span><br><span class="line"></span><br><span class="line">for(Method method : methods)&#123;</span><br><span class="line">    System.out.println(&quot;method = &quot; + method.getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中通过调用MyObject类的class属性获取对应的Class类的对象，通过这个Class类的对象获取MyObject类中的方法集合。迭代这个方法的集合并且打印每个方法的名字。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wetts.github.io/2016/12/09/%E8%AF%AD%E8%A8%80/Java/%E6%A1%86%E6%9E%B6%E3%80%81%E7%9B%B8%E5%85%B3%E6%8A%80%E6%9C%AF/Spring/%E7%94%A8%E6%B3%95/SpringMVC-%E6%95%B4%E5%90%88Swagger2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Zhang Wetts">
      <meta itemprop="description" content="Stay Hungry, Stay Foolish. <br><br><p style="font-size:8px;">[build by hexo/next/gitalk/hexo-generator-search/LaTeX]</p>">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wetts's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2016/12/09/%E8%AF%AD%E8%A8%80/Java/%E6%A1%86%E6%9E%B6%E3%80%81%E7%9B%B8%E5%85%B3%E6%8A%80%E6%9C%AF/Spring/%E7%94%A8%E6%B3%95/SpringMVC-%E6%95%B4%E5%90%88Swagger2/" class="post-title-link" itemprop="url">SpringMVC-整合Swagger2</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2016-12-09 10:13:04" itemprop="dateCreated datePublished" datetime="2016-12-09T10:13:04+08:00">2016-12-09</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>在SpringMVC项目中使用Swagger2。</p>
<h2 id="添加Swagger2依赖"><a href="#添加Swagger2依赖" class="headerlink" title="添加Swagger2依赖"></a>添加Swagger2依赖</h2><p>向<code>pom.xml</code>中添加</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;io.springfox&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.6.1&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;io.springfox&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.6.1&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<h2 id="创建Swagger2配置类"><a href="#创建Swagger2配置类" class="headerlink" title="创建Swagger2配置类"></a>创建Swagger2配置类</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@EnableWebMvc //NOTE: Only needed in a non-springboot application</span><br><span class="line">@EnableSwagger2</span><br><span class="line">public class MySwaggerConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public Docket createRestApi() &#123;</span><br><span class="line">        return new Docket(DocumentationType.SWAGGER_2)</span><br><span class="line">                .apiInfo(apiInfo())</span><br><span class="line">                .select()</span><br><span class="line">                .paths(PathSelectors.any())</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private ApiInfo apiInfo() &#123;</span><br><span class="line">        return new ApiInfoBuilder()</span><br><span class="line">                .title(&quot;SpringMVC 中使用Swagger2构建RESTful APIs&quot;)</span><br><span class="line">                .description(&quot;SpringMVC 中使用Swagger2构建RESTful APIs&quot;)</span><br><span class="line">                .termsOfServiceUrl(&quot;https://wetts.github.io/&quot;)</span><br><span class="line">                .contact(new Contact(&quot;wetts&quot;, &quot;https://wetts.github.io/&quot;, &quot;zhang.wetts@163.com&quot;))</span><br><span class="line">                .version(&quot;1.0&quot;)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="配置Spring配置文件"><a href="#配置Spring配置文件" class="headerlink" title="配置Spring配置文件"></a>配置Spring配置文件</h2><p>在SpringMVC的配置文件中添加</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean class=&quot;com.wetts.restful.demo.MySwaggerConfig&quot;&gt;&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;mvc:resources location=&quot;classpath:/META-INF/resources/&quot; mapping=&quot;swagger-ui.html&quot;/&gt;</span><br><span class="line">&lt;mvc:resources location=&quot;classpath:/META-INF/resources/webjars/&quot; mapping=&quot;/webjars/**&quot;/&gt;</span><br></pre></td></tr></table></figure>

<h2 id="添加Controller中内容"><a href="#添加Controller中内容" class="headerlink" title="添加Controller中内容"></a>添加Controller中内容</h2><h3 id="Api"><a href="#Api" class="headerlink" title="@Api"></a>@Api</h3><p>用在类上，说明该类的作用</p>
<p><code>@Api(value = &quot;UserController&quot;, description = &quot;用户相关api&quot;)</code></p>
<h3 id="ApiOperation"><a href="#ApiOperation" class="headerlink" title="@ApiOperation"></a>@ApiOperation</h3><p>用在方法上，说明方法的作用</p>
<p><code>@ApiOperation(value = &quot;查找用户&quot;, notes = &quot;查找用户&quot;, httpMethod = &quot;GET&quot;, produces = MediaType.APPLICATION_JSON_UTF8_VALUE)</code></p>
<h3 id="ApiImplicitParams"><a href="#ApiImplicitParams" class="headerlink" title="@ApiImplicitParams"></a>@ApiImplicitParams</h3><p>用在方法上包含一组参数说明</p>
<h3 id="ApiImplicitParam"><a href="#ApiImplicitParam" class="headerlink" title="@ApiImplicitParam"></a>@ApiImplicitParam</h3><p>用在@ApiImplicitParams注解中，指定一个请求参数的各个方面</p>
<ul>
<li>paramType：参数放在哪个地方</li>
<li>path（用于restful接口）–&gt;请求参数的获取：@PathVariable</li>
<li>name：参数名</li>
<li>dataType：参数类型</li>
<li>required：参数是否必须传</li>
<li>value：参数的意思</li>
<li>defaultValue：参数的默认值<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@ApiImplicitParams(&#123;</span><br><span class="line">        @ApiImplicitParam(name = &quot;id&quot;, value = &quot;唯一id&quot;, required = true, dataType = &quot;Long&quot;, paramType = &quot;path&quot;),</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="ApiResponses"><a href="#ApiResponses" class="headerlink" title="@ApiResponses"></a>@ApiResponses</h3><p>用于表示一组响应</p>
<h3 id="ApiResponse"><a href="#ApiResponse" class="headerlink" title="@ApiResponse"></a>@ApiResponse</h3><p>用在@ApiResponses中，一般用于表达一个错误的响应信息</p>
<ul>
<li>code：数字，例如400</li>
<li>message：信息，例如”请求参数没填好”</li>
<li>response：抛出异常的类</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@ApiResponses(value = &#123;  </span><br><span class="line">          @ApiResponse(code = 400, message = &quot;No Name Provided&quot;)  </span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>

<h3 id="ApiModel"><a href="#ApiModel" class="headerlink" title="@ApiModel"></a>@ApiModel</h3><p>描述一个Model的信息（这种一般用在post创建的时候，使用@RequestBody这样的场景，请求参数无法使用@ApiImplicitParam注解进行描述的时候）</p>
<p><code>@ApiModel(value = &quot;用户实体类&quot;)</code></p>
<h3 id="ApiModelProperty"><a href="#ApiModelProperty" class="headerlink" title="@ApiModelProperty"></a>@ApiModelProperty</h3><p>描述一个model的属性</p>
<p><code>@ApiModelProperty(value = &quot;登录用户&quot;)</code></p>
<h2 id="启动项目后访问路径"><a href="#启动项目后访问路径" class="headerlink" title="启动项目后访问路径"></a>启动项目后访问路径</h2><p><code>http://localhost:8080/swagger-ui.html</code>访问路径</p>
<p><code>http://localhost:8080/v2/api-docs</code> 文档json路径</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wetts.github.io/2016/12/07/%E7%B3%BB%E7%BB%9F%E3%80%81%E6%9C%8D%E5%8A%A1%E5%99%A8/%E6%9C%8D%E5%8A%A1%E5%99%A8/Nginx/Nginx-%E8%AF%AD%E6%B3%95-proxy_pass%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Zhang Wetts">
      <meta itemprop="description" content="Stay Hungry, Stay Foolish. <br><br><p style="font-size:8px;">[build by hexo/next/gitalk/hexo-generator-search/LaTeX]</p>">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wetts's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2016/12/07/%E7%B3%BB%E7%BB%9F%E3%80%81%E6%9C%8D%E5%8A%A1%E5%99%A8/%E6%9C%8D%E5%8A%A1%E5%99%A8/Nginx/Nginx-%E8%AF%AD%E6%B3%95-proxy_pass%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98/" class="post-title-link" itemprop="url">Nginx-语法-proxy_pass中的路径问题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2016-12-07 22:57:17" itemprop="dateCreated datePublished" datetime="2016-12-07T22:57:17+08:00">2016-12-07</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/" itemprop="url" rel="index"><span itemprop="name">服务器</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="用-来匹配"><a href="#用-来匹配" class="headerlink" title="用^~来匹配"></a>用<code>^~</code>来匹配</h2><p><code>http://127.0.0.1:81/demo/test.html</code></p>
<h3 id="http-host"><a href="#http-host" class="headerlink" title="http://host/"></a><code>http://host/</code></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location ^~ /demo/ &#123;</span><br><span class="line">  proxy_pass http://127.0.0.1:8080/;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代理到<code>http://127.0.0.1:8080/test.html</code></p>
<h3 id="http-host-1"><a href="#http-host-1" class="headerlink" title="http://host"></a><code>http://host</code></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location ^~ /demo/ &#123;</span><br><span class="line">  proxy_pass http://127.0.0.1:8080;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代理到<code>http://127.0.0.1:8080/demo/test.html</code></p>
<h3 id="http-host-lt-path-gt"><a href="#http-host-lt-path-gt" class="headerlink" title="http://host/&lt;path&gt;/"></a><code>http://host/&lt;path&gt;/</code></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location ^~ /demo/ &#123;</span><br><span class="line">  proxy_pass http://127.0.0.1:8080/a/;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代理到<code>http://127.0.0.1:8080/a/test.html</code></p>
<h3 id="http-host-lt-path-gt-1"><a href="#http-host-lt-path-gt-1" class="headerlink" title="http://host/&lt;path&gt;"></a><code>http://host/&lt;path&gt;</code></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location ^~ /demo/ &#123;</span><br><span class="line">  proxy_pass http://127.0.0.1:8080/a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代理到<code>http://127.0.0.1:8080/atest.html</code></p>
<h2 id="用-来匹配-1"><a href="#用-来匹配-1" class="headerlink" title="用=来匹配"></a>用<code>=</code>来匹配</h2><p><code>http://127.0.0.1:81/demo/</code></p>
<h3 id="http-host-2"><a href="#http-host-2" class="headerlink" title="http://host/"></a><code>http://host/</code></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location = /demo/ &#123;</span><br><span class="line">  proxy_pass http://127.0.0.1:8080/;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代理到<code>http://127.0.0.1:8080/</code></p>
<h3 id="http-host-3"><a href="#http-host-3" class="headerlink" title="http://host"></a><code>http://host</code></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location = /demo/ &#123;</span><br><span class="line">  proxy_pass http://127.0.0.1:8080;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代理到<code>http://127.0.0.1:8080/demo/</code></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wetts.github.io/2016/12/06/%E8%AF%AD%E8%A8%80/Java/basic_Java/API/%E5%AE%B9%E5%99%A8/Java-API-%E5%AE%B9%E5%99%A8-HashMap%E6%AD%BB%E5%BE%AA%E7%8E%AF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Zhang Wetts">
      <meta itemprop="description" content="Stay Hungry, Stay Foolish. <br><br><p style="font-size:8px;">[build by hexo/next/gitalk/hexo-generator-search/LaTeX]</p>">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wetts's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2016/12/06/%E8%AF%AD%E8%A8%80/Java/basic_Java/API/%E5%AE%B9%E5%99%A8/Java-API-%E5%AE%B9%E5%99%A8-HashMap%E6%AD%BB%E5%BE%AA%E7%8E%AF/" class="post-title-link" itemprop="url">Java-API-容器-HashMap死循环</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2016-12-06 18:53:32" itemprop="dateCreated datePublished" datetime="2016-12-06T18:53:32+08:00">2016-12-06</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>转自：<a target="_blank" rel="noopener" href="http://coolshell.cn/articles/9606.html">http://coolshell.cn/articles/9606.html</a></p>
<h2 id="问题的症状"><a href="#问题的症状" class="headerlink" title="问题的症状"></a>问题的症状</h2><p>从前我们的Java代码因为一些原因使用了HashMap这个东西，但是当时的程序是单线程的，一切都没有问题。后来，我们的程序性能有问题，所以需要变成多线程的，于是，变成多线程后到了线上，发现程序经常占了100%的CPU，查看堆栈，你会发现程序都Hang在了HashMap.get()这个方法上了，重启程序后问题消失。但是过段时间又会来。而且，这个问题在测试环境里可能很难重现。</p>
<p>我们简单的看一下我们自己的代码，我们就知道HashMap被多个线程操作。而Java的文档说HashMap是非线程安全的，应该用ConcurrentHashMap。</p>
<p>但是在这里我们可以来研究一下原因。</p>
<h2 id="Hash表数据结构"><a href="#Hash表数据结构" class="headerlink" title="Hash表数据结构"></a>Hash表数据结构</h2><p>我需要简单地说一下HashMap这个经典的数据结构。</p>
<p>HashMap通常会用一个指针数组（假设为table[]）来做分散所有的key，当一个key被加入时，会通过Hash算法通过key算出这个数组的下标i，然后就把这个&lt;key, value&gt;插到table[i]中，如果有两个不同的key被算在了同一个i，那么就叫冲突，又叫碰撞，这样会在table[i]上形成一个链表。</p>
<p>我们知道，如果table[]的尺寸很小，比如只有2个，如果要放进10个keys的话，那么碰撞非常频繁，于是一个O(1)的查找算法，就变成了链表遍历，性能变成了O(n)，这是Hash表的缺陷（可参看《<a target="_blank" rel="noopener" href="http://coolshell.cn/articles/6424.html">Hash Collision DoS 问题</a>》）。</p>
<p>所以，Hash表的尺寸和容量非常的重要。一般来说，Hash表这个容器当有数据要插入时，都会检查容量有没有超过设定的thredhold，如果超过，需要增大Hash表的尺寸，但是这样一来，整个Hash表里的无素都需要被重算一遍。这叫rehash，这个成本相当的大。</p>
<p>相信大家对这个基础知识已经很熟悉了。</p>
<h2 id="HashMap的rehash源代码"><a href="#HashMap的rehash源代码" class="headerlink" title="HashMap的rehash源代码"></a>HashMap的rehash源代码</h2><p>下面，我们来看一下Java的HashMap的源代码。</p>
<p>Put一个Key,Value对到Hash表中：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public V put(K key, V value)</span><br><span class="line">&#123;</span><br><span class="line">  ......</span><br><span class="line">  //算Hash值</span><br><span class="line">  int hash = hash(key.hashCode());</span><br><span class="line">  int i = indexFor(hash, table.length);</span><br><span class="line">  //如果该key已被插入，则替换掉旧的value （链接操作）</span><br><span class="line">  for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) &#123;</span><br><span class="line">    Object k;</span><br><span class="line">    if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">      V oldValue = e.value;</span><br><span class="line">      e.value = value;</span><br><span class="line">      e.recordAccess(this);</span><br><span class="line">      return oldValue;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  modCount++;</span><br><span class="line">  //该key不存在，需要增加一个结点</span><br><span class="line">  addEntry(hash, key, value, i);</span><br><span class="line">  return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>检查容量是否超标</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void addEntry(int hash, K key, V value, int bucketIndex)</span><br><span class="line">&#123;</span><br><span class="line">  Entry&lt;K,V&gt; e = table[bucketIndex];</span><br><span class="line">  table[bucketIndex] = new Entry&lt;K,V&gt;(hash, key, value, e);</span><br><span class="line">  //查看当前的size是否超过了我们设定的阈值threshold，如果超过，需要resize</span><br><span class="line">  if (size++ &gt;= threshold)</span><br><span class="line">    resize(2 * table.length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>新建一个更大尺寸的hash表，然后把数据从老的Hash表中迁移到新的Hash表中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void resize(int newCapacity)</span><br><span class="line">&#123;</span><br><span class="line">  Entry[] oldTable = table;</span><br><span class="line">  int oldCapacity = oldTable.length;</span><br><span class="line">  ......</span><br><span class="line">  //创建一个新的Hash Table</span><br><span class="line">  Entry[] newTable = new Entry[newCapacity];</span><br><span class="line">  //将Old Hash Table上的数据迁移到New Hash Table上</span><br><span class="line">  transfer(newTable);</span><br><span class="line">  table = newTable;</span><br><span class="line">  threshold = (int)(newCapacity * loadFactor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>迁移的源代码，注意高亮处：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">void transfer(Entry[] newTable)</span><br><span class="line">&#123;</span><br><span class="line">  Entry[] src = table;</span><br><span class="line">  int newCapacity = newTable.length;</span><br><span class="line">  //下面这段代码的意思是：</span><br><span class="line">  //  从OldTable里摘一个元素出来，然后放到NewTable中</span><br><span class="line">  for (int j = 0; j &lt; src.length; j++) &#123;</span><br><span class="line">    Entry&lt;K,V&gt; e = src[j];</span><br><span class="line">    if (e != null) &#123;</span><br><span class="line">      src[j] = null;</span><br><span class="line">      do &#123;</span><br><span class="line">          Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">          int i = indexFor(e.hash, newCapacity);</span><br><span class="line">          e.next = newTable[i];</span><br><span class="line">          newTable[i] = e;</span><br><span class="line">          e = next;</span><br><span class="line">      &#125; while (e != null);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>好了，这个代码算是比较正常的。而且没有什么问题。</p>
<h2 id="正常的ReHash的过程"><a href="#正常的ReHash的过程" class="headerlink" title="正常的ReHash的过程"></a>正常的ReHash的过程</h2><p>画了个图做了个演示。</p>
<ul>
<li>我假设了我们的hash算法就是简单的用key mod 一下表的大小（也就是数组的长度）。</li>
<li>最上面的是old hash 表，其中的Hash表的size=2, 所以key = 3, 7, 5，在mod 2以后都冲突在table[1]这里了。</li>
<li>接下来的三个步骤是Hash表 resize成4，然后所有的&lt;key,value&gt; 重新rehash的过程</li>
</ul>
<p><img src="/2016/12/06/%E8%AF%AD%E8%A8%80/Java/basic_Java/API/%E5%AE%B9%E5%99%A8/Java-API-%E5%AE%B9%E5%99%A8-HashMap%E6%AD%BB%E5%BE%AA%E7%8E%AF/HashMap01.png" alt="HashMap01"></p>
<h2 id="并发下的Rehash"><a href="#并发下的Rehash" class="headerlink" title="并发下的Rehash"></a>并发下的Rehash</h2><h3 id="1）假设我们有两个线程。我用红色和浅蓝色标注了一下。"><a href="#1）假设我们有两个线程。我用红色和浅蓝色标注了一下。" class="headerlink" title="1）假设我们有两个线程。我用红色和浅蓝色标注了一下。"></a>1）假设我们有两个线程。我用红色和浅蓝色标注了一下。</h3><p>我们再回头看一下我们的 transfer代码中的这个细节：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">do &#123;</span><br><span class="line">    Entry&lt;K,V&gt; next = e.next; // &lt;--假设线程一执行到这里就被调度挂起了</span><br><span class="line">    int i = indexFor(e.hash, newCapacity);</span><br><span class="line">    e.next = newTable[i];</span><br><span class="line">    newTable[i] = e;</span><br><span class="line">    e = next;</span><br><span class="line">&#125; while (e != null);</span><br></pre></td></tr></table></figure>
<p>而我们的线程二执行完成了。于是我们有下面的这个样子。</p>
<p><img src="/2016/12/06/%E8%AF%AD%E8%A8%80/Java/basic_Java/API/%E5%AE%B9%E5%99%A8/Java-API-%E5%AE%B9%E5%99%A8-HashMap%E6%AD%BB%E5%BE%AA%E7%8E%AF/HashMap02.png" alt="HashMap02"></p>
<p>注意，因为Thread1的 e 指向了key(3)，而next指向了key(7)，其在线程二rehash后，指向了线程二重组后的链表。我们可以看到链表的顺序被反转后。</p>
<h3 id="2）线程一被调度回来执行。"><a href="#2）线程一被调度回来执行。" class="headerlink" title="2）线程一被调度回来执行。"></a>2）线程一被调度回来执行。</h3><p>先是执行 newTalbe[i] = e;</p>
<p>然后是e = next，导致了e指向了key(7)，</p>
<p>而下一次循环的next = e.next导致了next指向了key(3)</p>
<p><img src="/2016/12/06/%E8%AF%AD%E8%A8%80/Java/basic_Java/API/%E5%AE%B9%E5%99%A8/Java-API-%E5%AE%B9%E5%99%A8-HashMap%E6%AD%BB%E5%BE%AA%E7%8E%AF/HashMap03.png" alt="HashMap03"></p>
<h3 id="3）一切安好。"><a href="#3）一切安好。" class="headerlink" title="3）一切安好。"></a>3）一切安好。</h3><p>线程一接着工作。把key(7)摘下来，放到newTable[i]的第一个，然后把e和next往下移。</p>
<p><img src="/2016/12/06/%E8%AF%AD%E8%A8%80/Java/basic_Java/API/%E5%AE%B9%E5%99%A8/Java-API-%E5%AE%B9%E5%99%A8-HashMap%E6%AD%BB%E5%BE%AA%E7%8E%AF/HashMap04.png" alt="HashMap04"></p>
<h3 id="4）环形链接出现。"><a href="#4）环形链接出现。" class="headerlink" title="4）环形链接出现。"></a>4）环形链接出现。</h3><p>e.next = newTable[i] 导致  key(3).next 指向了 key(7)</p>
<p>注意：此时的key(7).next 已经指向了key(3)， 环形链表就这样出现了。</p>
<p><img src="/2016/12/06/%E8%AF%AD%E8%A8%80/Java/basic_Java/API/%E5%AE%B9%E5%99%A8/Java-API-%E5%AE%B9%E5%99%A8-HashMap%E6%AD%BB%E5%BE%AA%E7%8E%AF/HashMap05.png" alt="HashMap05"></p>
<p>于是，当我们的线程一调用到，HashTable.get(11)时，悲剧就出现了——Infinite Loop。</p>
<h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><p>有人把这个问题报给了Sun，不过Sun不认为这个是一个问题。因为HashMap本来就不支持并发。要并发就用ConcurrentHashmap</p>
<p><a target="_blank" rel="noopener" href="http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6423457">http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6423457</a></p>
<p>我在这里把这个事情记录下来，只是为了让大家了解并体会一下并发环境下的危险。</p>
<p>参考：<a target="_blank" rel="noopener" href="http://mailinator.blogspot.com/2009/06/beautiful-race-condition.html">http://mailinator.blogspot.com/2009/06/beautiful-race-condition.html</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wetts.github.io/2016/12/06/%E8%AF%AD%E8%A8%80/Java/basic_Java/API/%E5%AE%B9%E5%99%A8/Java-API-%E5%AE%B9%E5%99%A8-Java%E4%B8%AD%E7%9A%84Copy-On-Write%E5%AE%B9%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Zhang Wetts">
      <meta itemprop="description" content="Stay Hungry, Stay Foolish. <br><br><p style="font-size:8px;">[build by hexo/next/gitalk/hexo-generator-search/LaTeX]</p>">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wetts's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2016/12/06/%E8%AF%AD%E8%A8%80/Java/basic_Java/API/%E5%AE%B9%E5%99%A8/Java-API-%E5%AE%B9%E5%99%A8-Java%E4%B8%AD%E7%9A%84Copy-On-Write%E5%AE%B9%E5%99%A8/" class="post-title-link" itemprop="url">Java-API-容器-Java中的Copy-On-Write容器</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2016-12-06 18:16:01" itemprop="dateCreated datePublished" datetime="2016-12-06T18:16:01+08:00">2016-12-06</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>转自：<a target="_blank" rel="noopener" href="http://ifeve.com/java-copy-on-write/">http://ifeve.com/java-copy-on-write/</a></p>
<p>Copy-On-Write简称COW，是一种用于程序设计中的优化策略。其基本思路是，从一开始大家都在共享同一个内容，当某个人想要修改这个内容的时候，才会真正把内容Copy出去形成一个新的内容然后再改，这是一种延时懒惰策略。从JDK1.5开始Java并发包里提供了两个使用CopyOnWrite机制实现的并发容器,它们是CopyOnWriteArrayList和CopyOnWriteArraySet。CopyOnWrite容器非常有用，可以在非常多的并发场景中使用到。</p>
<h3 id="什么是CopyOnWrite容器"><a href="#什么是CopyOnWrite容器" class="headerlink" title="什么是CopyOnWrite容器"></a>什么是CopyOnWrite容器</h3><p>CopyOnWrite容器即写时复制的容器。通俗的理解是当我们往一个容器添加元素的时候，不直接往当前容器添加，而是先将当前容器进行Copy，复制出一个新的容器，然后新的容器里添加元素，添加完元素之后，再将原容器的引用指向新的容器。这样做的好处是我们可以对CopyOnWrite容器进行并发的读，而不需要加锁，因为当前容器不会添加任何元素。所以CopyOnWrite容器也是一种读写分离的思想，读和写不同的容器。</p>
<h3 id="CopyOnWriteArrayList的实现原理"><a href="#CopyOnWriteArrayList的实现原理" class="headerlink" title="CopyOnWriteArrayList的实现原理"></a>CopyOnWriteArrayList的实现原理</h3><p>在使用CopyOnWriteArrayList之前，我们先阅读其源码了解下它是如何实现的。以下代码是向ArrayList里添加元素，可以发现在添加的时候是需要加锁的，否则多线程写的时候会Copy出N个副本出来。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public boolean add(T e) &#123;</span><br><span class="line">  final ReentrantLock lock = this.lock;</span><br><span class="line">  lock.lock();</span><br><span class="line">  try &#123;</span><br><span class="line">    Object[] elements = getArray();</span><br><span class="line">    int len = elements.length;</span><br><span class="line">    // 复制出新数组</span><br><span class="line">    Object[] newElements = Arrays.copyOf(elements, len + 1);</span><br><span class="line">    // 把新元素添加到新数组里</span><br><span class="line">    newElements[len] = e;</span><br><span class="line">    // 把原数组引用指向新数组</span><br><span class="line">    setArray(newElements);</span><br><span class="line">    return true;</span><br><span class="line">  &#125; finally &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">final void setArray(Object[] a) &#123;</span><br><span class="line">  array = a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>读的时候不需要加锁，如果读的时候有多个线程正在向ArrayList添加数据，读还是会读到旧的数据，因为写的时候不会锁住旧的ArrayList。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public E get(int index) &#123;</span><br><span class="line">  return get(getArray(), index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>JDK中并没有提供CopyOnWriteMap，我们可以参考CopyOnWriteArrayList来实现一个，基本代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Collection;</span><br><span class="line">import java.util.Map;</span><br><span class="line">import java.util.Set;</span><br><span class="line"></span><br><span class="line">public class CopyOnWriteMap&lt;K, V&gt; implements Map&lt;K, V&gt;, Cloneable &#123;</span><br><span class="line">  private volatile Map&lt;K, V&gt; internalMap;</span><br><span class="line"></span><br><span class="line">  public CopyOnWriteMap() &#123;</span><br><span class="line">    internalMap = new HashMap&lt;K, V&gt;();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public V put(K key, V value) &#123;</span><br><span class="line">    synchronized (this) &#123;</span><br><span class="line">      Map&lt;K, V&gt; newMap = new HashMap&lt;K, V&gt;(internalMap);</span><br><span class="line">      V val = newMap.put(key, value);</span><br><span class="line">      internalMap = newMap;</span><br><span class="line">      return val;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public V get(Object key) &#123;</span><br><span class="line">    return internalMap.get(key);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void putAll(Map&lt;? extends K, ? extends V&gt; newData) &#123;</span><br><span class="line">    synchronized (this) &#123;</span><br><span class="line">      Map&lt;K, V&gt; newMap = new HashMap&lt;K, V&gt;(internalMap);</span><br><span class="line">      newMap.putAll(newData);</span><br><span class="line">      internalMap = newMap;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现很简单，只要了解了CopyOnWrite机制，我们可以实现各种CopyOnWrite容器，并且在不同的应用场景中使用。</p>
<h3 id="CopyOnWrite的应用场景"><a href="#CopyOnWrite的应用场景" class="headerlink" title="CopyOnWrite的应用场景"></a>CopyOnWrite的应用场景</h3><p>CopyOnWrite并发容器用于读多写少的并发场景。比如白名单，黑名单，商品类目的访问和更新场景，假如我们有一个搜索网站，用户在这个网站的搜索框中，输入关键字搜索内容，但是某些关键字不允许被搜索。这些不能被搜索的关键字会被放在一个黑名单当中，黑名单每天晚上更新一次。当用户搜索时，会检查当前关键字在不在黑名单当中，如果在，则提示不能搜索。实现代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">package com.ifeve.book;</span><br><span class="line"></span><br><span class="line">import java.util.Map;</span><br><span class="line">import com.ifeve.book.forkjoin.CopyOnWriteMap;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 黑名单服务</span><br><span class="line"> *</span><br><span class="line"> * @author fangtengfei</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class BlackListServiceImpl &#123;</span><br><span class="line">  private static CopyOnWriteMap&lt;String, Boolean&gt; blackListMap = new CopyOnWriteMap&lt;String, Boolean&gt;(1000);</span><br><span class="line"></span><br><span class="line">  public static boolean isBlackList(String id) &#123;</span><br><span class="line">    return blackListMap.get(id) == null ? false : true;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static void addBlackList(String id) &#123;</span><br><span class="line">    blackListMap.put(id, Boolean.TRUE);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * 批量添加黑名单</span><br><span class="line">   *</span><br><span class="line">   * @param ids</span><br><span class="line">   */</span><br><span class="line">  public static void addBlackList(Map&lt;String,Boolean&gt; ids) &#123;</span><br><span class="line">    blackListMap.putAll(ids);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码很简单，但是使用CopyOnWriteMap需要注意两件事情：</p>
<ol>
<li>减少扩容开销。根据实际需要，初始化CopyOnWriteMap的大小，避免写时CopyOnWriteMap扩容的开销。</li>
<li>使用批量添加。因为每次添加，容器每次都会进行复制，所以减少添加次数，可以减少容器的复制次数。如使用上面代码里的addBlackList方法。</li>
</ol>
<h3 id="CopyOnWrite的缺点"><a href="#CopyOnWrite的缺点" class="headerlink" title="CopyOnWrite的缺点"></a>CopyOnWrite的缺点</h3><p>CopyOnWrite容器有很多优点，但是同时也存在两个问题，即内存占用问题和数据一致性问题。所以在开发的时候需要注意一下。</p>
<h4 id="内存占用问题。"><a href="#内存占用问题。" class="headerlink" title="内存占用问题。"></a>内存占用问题。</h4><p>因为CopyOnWrite的写时复制机制，所以在进行写操作的时候，内存里会同时驻扎两个对象的内存，旧的对象和新写入的对象（注意:在复制的时候只是复制容器里的引用，只是在写的时候会创建新对象添加到新容器里，而旧容器的对象还在使用，所以有两份对象内存）。如果这些对象占用的内存比较大，比如说200M左右，那么再写入100M数据进去，内存就会占用300M，那么这个时候很有可能造成频繁的Yong GC和Full GC。之前我们系统中使用了一个服务由于每晚使用CopyOnWrite机制更新大对象，造成了每晚15秒的Full GC，应用响应时间也随之变长。</p>
<h4 id="针对内存占用问题。"><a href="#针对内存占用问题。" class="headerlink" title="针对内存占用问题。"></a>针对内存占用问题。</h4><p>可以通过压缩容器中的元素的方法来减少大对象的内存消耗，比如，如果元素全是10进制的数字，可以考虑把它压缩成36进制或64进制。或者不使用CopyOnWrite容器，而使用其他的并发容器，如ConcurrentHashMap。</p>
<h4 id="数据一致性问题。"><a href="#数据一致性问题。" class="headerlink" title="数据一致性问题。"></a>数据一致性问题。</h4><p>CopyOnWrite容器只能保证数据的最终一致性，不能保证数据的实时一致性。所以如果你希望写入的的数据，马上能读到，请不要使用CopyOnWrite容器。</p>
<p>关于C++的STL中，曾经也有过Copy-On-Write的玩法，参见陈皓的《C++ STL String类中的Copy-On-Write》，后来，因为有很多线程安全上的事，就被去掉了。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wetts.github.io/2016/12/06/%E5%B7%A5%E5%85%B7/%E4%B8%AD%E9%97%B4%E4%BB%B6/RPC/RPC%E3%80%81WebService%E3%80%81RMI%E3%80%81JMS%E7%9A%84%E5%8C%BA%E5%88%AB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Zhang Wetts">
      <meta itemprop="description" content="Stay Hungry, Stay Foolish. <br><br><p style="font-size:8px;">[build by hexo/next/gitalk/hexo-generator-search/LaTeX]</p>">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wetts's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2016/12/06/%E5%B7%A5%E5%85%B7/%E4%B8%AD%E9%97%B4%E4%BB%B6/RPC/RPC%E3%80%81WebService%E3%80%81RMI%E3%80%81JMS%E7%9A%84%E5%8C%BA%E5%88%AB/" class="post-title-link" itemprop="url">RPC、WebService、RMI、JMS的区别</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2016-12-06 15:03:29" itemprop="dateCreated datePublished" datetime="2016-12-06T15:03:29+08:00">2016-12-06</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/" itemprop="url" rel="index"><span itemprop="name">分布式</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>转自：<a target="_blank" rel="noopener" href="http://blog.csdn.net/shan9liang/article/details/8995023">http://blog.csdn.net/shan9liang/article/details/8995023</a></p>
<h2 id="RPC（Remote-Procedure-Call-Protocol）"><a href="#RPC（Remote-Procedure-Call-Protocol）" class="headerlink" title="RPC（Remote Procedure Call Protocol）"></a>RPC（Remote Procedure Call Protocol）</h2><p>RPC 使用 C/S 方式，采用 http 协议，发送请求到服务器，等待服务器返回结果。这个请求包括一个参数集和一个文本集，通常形成“classname.methodname”形式。优点是跨语言跨平台，C 端、S 端有更大的独立性，缺点是不支持对象，无法在编译器检查错误，只能在运行期检查。</p>
<h2 id="Web-Service"><a href="#Web-Service" class="headerlink" title="Web Service"></a>Web Service</h2><p>Web Service 提供的服务是基于 web 容器的，底层使用 http 协议，类似一个远程的服务提供者，比如天气预报服务，对各地客户端提供天气预报，是一种请求应答的机制，是跨系统跨平台的。就是通过一个 servlet，提供服务出去。</p>
<p>首先客户端从服务器得到 WebService 的 WSDL，同时在客户端声称一个代理类（Proxy Class）这个代理类负责与 WebService 服务器进行 Request 和Response 当一个数据（XML 格式的）被封装成 SOAP 格式的数据流发送到服务器端的时候，就会生成一个进程对象并且把接收到这个 Request 的 SOAP 包进行解析，然后对事物进行处理，处理结束以后再对这个计算结果进行 SOAP 包装，然后把这个包作为一个 Response 发送给客户端的代理类（Proxy Class），同样地，这个代理类也对这个 SOAP 包进行解析处理，继而进行后续操作。这就是 WebService 的一个运行过程。</p>
<p>Web Service 大体上分为 5 个层次:</p>
<ol>
<li>Http 传输信道</li>
<li>XML 的数据格式</li>
<li>SOAP 封装格式</li>
<li>WSDL 的描述方式</li>
<li>UDDI UDDI 是一种目录服务，企业可以使用它对 Webservices 进行注册和搜索</li>
</ol>
<h2 id="RMI-（Remote-Method-Invocation）"><a href="#RMI-（Remote-Method-Invocation）" class="headerlink" title="RMI （Remote Method Invocation）"></a>RMI （Remote Method Invocation）</h2><p>RMI 采用stubs 和 skeletons 来进行远程对象（remote object）的通讯。stub 充当远程对象的客户端代理，有着和远程对象相同的远程接口，远程对象的调用实际是通过调用该对象的客户端代理对象 stub 来完成的，通过该机制 RMI 就好比它是本地工作，采用 tcp/ip 协议，客户端直接调用服务端上的一些方法。优点是强类型，编译期可检查错误，缺点是只能基于 Java 语言，客户机与服务器紧耦合。</p>
<h2 id="JMS（Java-Messaging-Service）"><a href="#JMS（Java-Messaging-Service）" class="headerlink" title="JMS（Java Messaging Service）"></a>JMS（Java Messaging Service）</h2><p>JMS 是 Java 的消息服务，JMS 的客户端之间可以通过JMS服务进行异步的消息传输。JMS 支持两种消息模型：Point-to-Point（P2P）和 Publish/Subscribe（Pub/Sub），即点对点和发布订阅模型。</p>
<hr>
<p>几者的区别与联系</p>
<h3 id="1、RPC-与-RMI"><a href="#1、RPC-与-RMI" class="headerlink" title="1、RPC 与 RMI"></a>1、RPC 与 RMI</h3><p>（1）RPC 跨语言，而 RMI只支持Java。</p>
<p>（2）RMI 调用远程对象方法，允许方法返回 Java 对象以及基本数据类型，而RPC 不支持对象的概念，传送到 RPC 服务的消息由外部数据表示（External Data Representation, XDR）语言表示，这种语言抽象了字节序类和数据类型结构之间的差异。只有由 XDR 定义的数据类型才能被传递， 可以说 RMI 是面向对象方式的 Java RPC 。</p>
<p>（3）在方法调用上，RMI 中，远程接口使每个远程方法都具有方法签名。如果一个方法在服务器上执行，但是没有相匹配的签名被添加到这个远程接口上，那么这个新方法就不能被RMI客户方所调用。</p>
<p>在 RPC 中，当一个请求到达 RPC 服务器时，这个请求就包含了一个参数集和一个文本值，通常形成“classname.methodname”的形式。这就向 RPC 服务器表明，被请求的方法在为 “classname”的类中，名叫“methodname”。然后 RPC 服务器就去搜索与之相匹配的类和方法，并把它作为那种方法参数类型的输入。这里的参数类型是与 RPC 请求中的类型是匹配的。一旦匹配成功，这个方法就被调用了，其结果被编码后返回客户方。</p>
<h3 id="2、JMS-和-RMI"><a href="#2、JMS-和-RMI" class="headerlink" title="2、JMS 和 RMI"></a>2、JMS 和 RMI</h3><p>采用 JMS 服务，对象是在物理上被异步从网络的某个 JVM 上直接移动到另一个 JVM 上（是消息通知机制）</p>
<p>而 RMI 对象是绑定在本地 JVM 中，只有函数参数和返回值是通过网络传送的（是请求应答机制）。</p>
<p>RMI 一般都是同步的，也就是说，当 client 调用 Server 的一个方法的时候，需要等到对方的返回，才能继续执行 client 端，这个过程调用本地方法感觉上是一样的，这也是 RMI 的一个特点。</p>
<p>JMS 一般只是一个点发出一个 Message 到 Message Server，发出之后一般不会关心谁用了这个 message。<br>所以，一般 RMI 的应用是紧耦合，JMS 的应用相对来说是松散耦合应用。</p>
<h3 id="3、Webservice-与-RMI"><a href="#3、Webservice-与-RMI" class="headerlink" title="3、Webservice 与 RMI"></a>3、Webservice 与 RMI</h3><p>RMI 是在 tcp 协议上传递可序列化的 java 对象，只能用在 java 虚拟机上，绑定语言，客户端和服务端都必须是 java</p>
<p>webservice 没有这个限制，webservice 是在 http 协议上传递 xml 文本文件，与语言和平台无关。</p>
<h3 id="4、Webservice-与-JMS"><a href="#4、Webservice-与-JMS" class="headerlink" title="4、Webservice 与 JMS"></a>4、Webservice 与 JMS</h3><p>Webservice 专注于远程服务调用，jms 专注于信息交换。</p>
<p>大多数情况下 Webservice 是两系统间的直接交互（Consumer &lt;–&gt; Producer），而大多数情况下 jms 是三方系统交互（Consumer &lt;- Broker -&gt; Producer）。当然，JMS 也可以实现 request-response 模式的通信，只要 Consumer 或 Producer 其中一方兼任 broker 即可。</p>
<p>JMS 可以做到异步调用完全隔离了客户端和服务提供者，能够抵御流量洪峰；WebService 服务通常为同步调用，需要有复杂的对象转换，相比 SOAP，现在 JSON，rest 都是很好的 http 架构方案；（举一个例子，电子商务的分布式系统中，有支付系统和业务系统，支付系统负责用户付款，在用户在银行付款后需要通知各个业务系统，那么这个时候，既可以用同步也可以用异步，使用异步的好处就能抵御网站暂时的流量高峰，或者能应对慢消费者。）</p>
<p>JMS 是 java 平台上的消息规范。一般 jms 消息不是一个 xml，而是一个 java 对象，很明显，jms 没考虑异构系统，说白了，JMS 就没考虑非 java 的东西。但是好在现在大多数的 jms provider（就是 JMS 的各种实现产品）都解决了异构问题。相比 WebService 的跨平台各有千秋吧。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wetts.github.io/2016/12/03/%E5%B7%A5%E5%85%B7/%E5%85%B6%E4%BB%96/Hexo-%E4%BD%BF%E7%94%A8%E6%9C%AC%E5%9C%B0%E5%9B%BE%E7%89%87/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Zhang Wetts">
      <meta itemprop="description" content="Stay Hungry, Stay Foolish. <br><br><p style="font-size:8px;">[build by hexo/next/gitalk/hexo-generator-search/LaTeX]</p>">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wetts's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2016/12/03/%E5%B7%A5%E5%85%B7/%E5%85%B6%E4%BB%96/Hexo-%E4%BD%BF%E7%94%A8%E6%9C%AC%E5%9C%B0%E5%9B%BE%E7%89%87/" class="post-title-link" itemprop="url">Hexo-使用本地图片</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2016-12-03 11:12:03" itemprop="dateCreated datePublished" datetime="2016-12-03T11:12:03+08:00">2016-12-03</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%B7%A5%E5%85%B7/" itemprop="url" rel="index"><span itemprop="name">工具</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>转自：<a target="_blank" rel="noopener" href="http://www.tuicool.com/articles/umEBVfI">http://www.tuicool.com/articles/umEBVfI</a></p>
<h3 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h3><p>在 hexo 中使用本地图片是件非常让人纠结的事情，在 markdown 里的图片地址似乎永远无法和最后生成的网页保持一致。</p>
<p>这些问题使得我一度不愿意使用本地图片而选择用图床，但被移动运营商无耻的横条广告逼得打算上 https，图床只支持 http 就成了问题。</p>
<p>hexo 下插入图片现在大概有几个方案</p>
<h4 id="放在根目录"><a href="#放在根目录" class="headerlink" title="放在根目录"></a>放在根目录</h4><p>早期大部分的方案是把图片放在 source/img 下，然后在 markdown 里写 <code>![img](/source/img/img.png)</code> 。显然这样在本地的编辑器里完全不能正确识别图片的位置。</p>
<h4 id="asset-image"><a href="#asset-image" class="headerlink" title="asset-image"></a>asset-image</h4><p>在 hexo 2.x 时出现的插件，后来被吸纳进 hexo 3 core ，用法的介绍见 <a target="_blank" rel="noopener" href="https://hexo.io/zh-cn/docs/asset-folders.html">资源文件夹 | Hexo</a> 。比较尴尬的是，这种方法直接放弃了 markdown 原来的语法，使用类似 的语法，。markdown 本来有插入图片的语法不好好支持，专门用一个新的语法来插入本地图片，让我这种强迫症不太能接受。</p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p><a target="_blank" rel="noopener" href="https://github.com/CodeFalling/hexo-asset-image">CodeFalling/hexo-asset-image</a></p>
<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>首先确认 <code>_config.yml</code> 中有 <code>post_asset_folder:true</code>。</p>
<p>在 hexo 目录，执行</p>
<p><code>npm install https://github.com/CodeFalling/hexo-asset-image --save</code></p>
<p>假设在</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MacGesture2-Publish</span><br><span class="line">├── apppicker.jpg</span><br><span class="line">├── logo.jpg</span><br><span class="line">└── rules.jpg</span><br><span class="line">MacGesture2-Publish.md</span><br></pre></td></tr></table></figure>
<p>这样的目录结构（目录名和文章名一致），只要使用 <code>![logo](MacGesture2-Publish/logo.jpg)</code> 就可以插入图片。</p>
<p>生成的结构为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public/2015/10/18/MacGesture2-Publish</span><br><span class="line">├── apppicker.jpg</span><br><span class="line">├── index.html</span><br><span class="line">├── logo.jpg</span><br><span class="line">└── rules.jpg</span><br></pre></td></tr></table></figure>
<p>同时，生成的 html 是</p>
<p><code>&lt;img src=&quot;/2015/10/18/MacGesture2-Publish/logo.jpg&quot; alt=&quot;logo&quot;&gt;</code></p>
<p>而不是愚蠢的</p>
<p><code>&lt;img src=&quot;MacGesture2-Publish/logo.jpg&quot; alt=&quot;logo&quot;&gt;</code></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/32/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/32/">32</a><span class="page-number current">33</span><a class="page-number" href="/page/34/">34</a><span class="space">&hellip;</span><a class="page-number" href="/page/69/">69</a><a class="extend next" rel="next" href="/page/34/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Zhang Wetts"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">Zhang Wetts</p>
  <div class="site-description" itemprop="description">Stay Hungry, Stay Foolish. <br><br><p style="font-size:8px;">[build by hexo/next/gitalk/hexo-generator-search/LaTeX]</p></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">682</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">67</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">349</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/wetts" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;wetts" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:zhang.wetts@163.com" title="E-Mail → mailto:zhang.wetts@163.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Zhang Wetts</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

  


<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/hibiki.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"react":{"opacity":0.7}});</script></body>
</html>
