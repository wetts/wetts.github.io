<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"wetts.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="Stay Hungry, Stay Foolish. [build by hexo&#x2F;next&#x2F;gitalk&#x2F;hexo-generator-search&#x2F;LaTeX]">
<meta property="og:type" content="website">
<meta property="og:title" content="Wetts&#39;s blog">
<meta property="og:url" content="https://wetts.github.io/page/7/index.html">
<meta property="og:site_name" content="Wetts&#39;s blog">
<meta property="og:description" content="Stay Hungry, Stay Foolish. [build by hexo&#x2F;next&#x2F;gitalk&#x2F;hexo-generator-search&#x2F;LaTeX]">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Zhang Wetts">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://wetts.github.io/page/7/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Wetts's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Wetts's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Stay Hungry, Stay Foolish.</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/wetts" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wetts.github.io/2020/03/14/%E7%B3%BB%E7%BB%9F&%E6%9C%8D%E5%8A%A1%E5%99%A8/Linux/Linux-%E7%8E%AF%E5%A2%83-%E8%B7%AF%E5%BE%84%E7%9A%84%E6%84%8F%E4%B9%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Zhang Wetts">
      <meta itemprop="description" content="Stay Hungry, Stay Foolish. <br><br><p style="font-size:8px;">[build by hexo/next/gitalk/hexo-generator-search/LaTeX]</p>">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wetts's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/14/%E7%B3%BB%E7%BB%9F&%E6%9C%8D%E5%8A%A1%E5%99%A8/Linux/Linux-%E7%8E%AF%E5%A2%83-%E8%B7%AF%E5%BE%84%E7%9A%84%E6%84%8F%E4%B9%89/" class="post-title-link" itemprop="url">Linux-环境-路径的意义</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-03-14 16:33:30 / 修改时间：16:57:46" itemprop="dateCreated datePublished" datetime="2020-03-14T16:33:30+08:00">2020-03-14</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">系统</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="boot"><a href="#boot" class="headerlink" title="/boot"></a>/boot</h3><p>引导程序，内核等存放的目录。</p>
<p>这个目录，包括了在引导过程中所必需的文件，引导程序的相关文件（例如 grub、lilo 以及相应的配置文件以及 Linux 操作系统内核相关文件（例如 vmlinuz 等一般都存放在这里。在最开始的启动阶段，通过引导程序将内核加载到内存，完成内核的启动（这个时候，虚拟文件系统还不存在，加载的内核虽然是从硬盘读取的，但是没经过 Linux 的虚拟文件系统，这是比较底层的东西来实现的。然后内核自己创建好虚拟文件系统，并且从虚拟文件系统的其他子目录中（例如 /sbin 和 /etc 加载需要在开机启动的其他程序或者服务或者特定的动作（部分可以由用户自己在相应的目录中修改相应的文件来配制。如果我们的机器中包含多个操作系统，那么可以通过修改这个目录中的某个配置文件（例如 grub.conf 来调整启动的默认操作系统，系统启动的择菜单，以及启动延迟等参数）。</p>
<h3 id="sbin"><a href="#sbin" class="headerlink" title="/sbin"></a>/sbin</h3><p>超级用户可以使用的命令的存放目录。</p>
<p>存放大多涉及系统管理的命令（例如引导系统的 init 程序，是超级权限用户 root 的可执行命令存放地，普通用户无权限执行这个目录下的命令（但是时普通用户也可能会用到。这个目录和 /usr/sbin; /usr/X11R6/sbin 或 /usr/local/sbin 等目录是相似的，我们要记住，凡是目录 sbin 中包含的都是 root 权限才能执行的，这样就行了。后面会具体区分）。</p>
<h3 id="bin"><a href="#bin" class="headerlink" title="/bin"></a>/bin</h3><p>普通用户可以使用的命令的存放目录。</p>
<p>系统所需要的那些命令位于此目录，比如 ls、cp、mkdir 等命令；类似的目录还 /usr/bin，/usr/local/bin 等等。这个目录中的文件都是可执行的、普通用户都可以使用的命令。作为基础系统所需要的最基础的命令就是放在这里。</p>
<h3 id="lib"><a href="#lib" class="headerlink" title="/lib"></a>/lib</h3><p>根目录下的所程序的共享库目录。</p>
<p>此目录下包含系统引导和在根用户执行命令时候所必需用到的共享库。做个不太好但是比较形象的比喻，点类似于 Windows 上面的 system32 目录。理说，这里存放的文件应该是 /bin 目录下程序所需要的库文件的存放地，也不排除一些例外的情况。类似的目录还 /usr/lib，/usr/local/lib 等等。</p>
<h3 id="dev"><a href="#dev" class="headerlink" title="/dev"></a>/dev</h3><p>设备文件目录。</p>
<p>在 Linux 中设备都是以文件形式出现，这里的设备可以是硬盘，键盘，鼠标，网卡，终端，等设备，通过访问这些文件可以访问到相应的设备。设备文件可以使用 mknod 命令来创建，具体参见相应的命令；而为了将对这些设备文件的访问转化为对设备的访问，需要向相应的设备提供设备驱动模块（一般将设备驱动编译之后，生成的结果是一个 *.ko 类型的二进制文件），在内核启动之后，再通过 insmod 等命令加载相应的设备驱动之后，我们就可以通过设备文件来访问设备了。一般来说，想要 Linux 系统支持某个设备，只要个东西：相应的硬件设备，支持硬件的驱动模块，以及相应的设备文件。</p>
<h3 id="home"><a href="#home" class="headerlink" title="/home"></a>/home</h3><p>普通用户的家目录（$HOME 目录）。</p>
<p>在 Linux 机器上，用户主目录通常直接或间接地置在此目录下。其结构通常由本地机的管理员来决定。通常而言，系统的每个用户都自己的家目录，目录以用户名作为名字存放在 /home 下面（例如 quietheart 用户，其家目录的名字为 /home/quietheart。该目录中保存了绝大多数的用户文件（用户自己的配置文件，定制文件，文档，数据等），root 用户除外（参见后面的 /root 目录。由于这个目录包含了用户实际的数据，通常系统管理员为这个目录单独挂载一个独立的磁盘分区，这样这个目录的文件系统格式就可能和其他目录不一样了（尽管表面上看，这个目录还是属于根目录的一棵子树上），有利于数据的维护。</p>
<h3 id="root"><a href="#root" class="headerlink" title="/root"></a>/root</h3><p>用户 root 的 $HOME 目录。</p>
<p>系统管理员（就是 root 用户或超级用户）的主目录比较特殊，不存放在 /home 中，而是直接放在 /root 目录下了。</p>
<h3 id="etc"><a href="#etc" class="headerlink" title="/etc"></a>/etc</h3><p>全局的配置文件存放目录。</p>
<p>系统和程序一般都可以通过修改相应的配置文件，来进行配置。例如，要配置系统开机的时候启动那些程序，配置某个程序启动的时候显示什么样的风格等等。通常这些配置文件都集中存放在 /etc 目录中，所以想要配置什么东西的话，可以在 /etc 下面寻找我们可能需要修改的文件。一些大型套件，如 X11，在 /etc 下它们自己的子目录。系统配置文件可以放在这里或在 /usr/etc。 不过所程序总是在 /etc 目录下查找所需的配置文件，你也可以将这些文件链接到目录 /usr/etc。另外，还一个需要注意的常见现象就是，当某个程序在某个用户下运行的时候，可能会在该用户的家目录中生成一个配置文件（一般这个文件最开始就是 /etc 下相应配置文件的拷贝），存放相应于“当前用户”的配置，这样当前用户可以通过配置这个家目录的配置文件，来改变程序的行为，并且这个行为只是该用户特定的。原因就是：一般来说一个程序启动，如果需要读取一些配置文件的话，它会首先读取当前用户家目录的配置文件，如果存在就使用；如果不存在它就到 /etc 下读取全局的配置文件进而启动程序。就是这个配置文件不自动生成，我们手动在自己的家目录中创建一个文件的话，也有许多程序会首先读取到这个家目录的文件并且以它的配置作为启动的选项（例如我们可以在家目录中创建 vim 程序的配置文件 .vimrc，来配置自己的 vim 程序）。</p>
<h3 id="usr"><a href="#usr" class="headerlink" title="/usr"></a>/usr</h3><p>这个目录中包含了命令库文件和在通常操作中不会修改的文件。</p>
<p>这个目录对于系统来说也是一个非常重要的目录，其地位类似 Windows 上面的”Program Files”目录。安装程序的时候，默认就是安装在此文件内部某个子文件夹内。输入命令后系统默认执行 /usr/bin 下的程序（当然，前提是这个目录的路径已经被添加到了系统的环境变量中）。此目录通常也会挂载一个独立的磁盘分区，它应保存共享只读类文件，这样它可以被运行 Linux 的不同主机挂载。</p>
<h3 id="usr-lib"><a href="#usr-lib" class="headerlink" title="/usr/lib"></a>/usr/lib</h3><p>目标库文件，包括动态连接库加上一些通常不是直接调用的可执行文件的存放位置。</p>
<p>这个目录功能类似 /lib 目录，按理说，这里存放的文件应该是 /bin 目录下程序所需要的库文件的存放地，也不排除一些例外的情况。</p>
<h3 id="usr-bin"><a href="#usr-bin" class="headerlink" title="/usr/bin"></a>/usr/bin</h3><p>一般使用者使用并且不是系统自检等所必需可执行文件的目录。</p>
<p>此目录相当于根文件系统下的对应目录（/bin），非启动系统，非修复系统以及非本地安装的程序一般都放在此目录下。</p>
<h3 id="usr-sbin"><a href="#usr-sbin" class="headerlink" title="/usr/sbin"></a>/usr/sbin</h3><p>管理员使用的非系统必须的可执行文件存放目录。</p>
<p>此目录相当于根文件系统下的对应目录（/sbin），保存系统管理程序的二进制文件，并且这些文件不是系统启动或文件系统挂载 /usr 目录或修复系统所必需的。</p>
<h3 id="usr-share"><a href="#usr-share" class="headerlink" title="/usr/share"></a>/usr/share</h3><p>存放共享文件的目录。</p>
<p>在此目录下不同的子目录中保存了同一个操作系统在不同构架下工作时特定应用程序的共享数据（例如程序文档信息）。使用者可以找到通常放在 /usr/doc 或 /usr/lib 或 /usr/man 目录下的这些类似数据。</p>
<h3 id="usr-include"><a href="#usr-include" class="headerlink" title="/usr/include"></a>/usr/include</h3><p>C 程序语言编译使用的头文件。</p>
<p>linux 下开发和编译应用程序所需要的头文件一般都存放在这里，通过头文件来使用某些库函数。默认来说这个路径被添加到了环境变量中，这样编译开发程序的时候编译器会自动搜索这个路径，从中找到你的程序中可能包含的头文件。</p>
<h3 id="usr-local"><a href="#usr-local" class="headerlink" title="/usr/local"></a>/usr/local</h3><p>安装本地程序的一般默认路径。</p>
<p>当我们下载一个程序源代码，编译并且安装的时候，如果不特别指定安装的程序路径，那么默认会将程序相关的文件安装到这个目录的对应目录下。例如，安装的程序可执行文件被安装（安装实质就是复制到了 /usr/local/bin 下面，此程序可执行文件所需要依赖的库文件被安装到了/usr/local/lib目录下），被安装的软件如果是某个开发库（例如 Qt，Gtk 等）那么相应的头文件可能就被安装到了 /usr/local/include 中等等。也就是说，这个目录存放的内容，一般都是我们后来自己安装的软件的默认路径，如果择了这个默认路径作为软件的安装路径，被安装的软件的所文件都限制在这个目录中，其中的子目录就相应于根目录的子目录。</p>
<h3 id="proc"><a href="#proc" class="headerlink" title="/proc"></a>/proc</h3><p>特殊文件目录。</p>
<p>这个目录采用一种特殊的文件系统格式（proc 格式，内核支持这种格式。其中包含了全部虚拟文件。它们并不保存在磁盘中，也不占据磁盘空间（尽管命令 ls -c 会显示它们的大小）。当您查看它们时，您实际上看到的是内存里的信息，这些文件助于我们了解系统内部信息。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">├1/ 关于进程1的信息目录。每个进程在/proc 下一个名为其进程号的目录。</span><br><span class="line">├cpuinfo 处理器信息，如类型、制造商、型号和性能。</span><br><span class="line">├devices 当前运行的核心配置的设备驱动的列表。</span><br><span class="line">├dma 显示当前使用的DMA通道。</span><br><span class="line">├filesystems 核心配置的文件系统。</span><br><span class="line">├interrupts 显示使用的中断，and how many of each there have been.</span><br><span class="line">├ioports 当前使用的I/O端口。</span><br><span class="line">├kcore 系统物理内存映象。与物理内存大小一样，但实际不占这么多内存；</span><br><span class="line">├kmsg 核心输出的消息。也被送到syslog 。</span><br><span class="line">├ksyms 核心符号表。</span><br><span class="line">├loadavg 系统”平均负载”；3个没意义的指示器指出系统当前的工作量。</span><br><span class="line">├meminfo 存储器使用信息，包括物理内存和swap。</span><br><span class="line">├modules 当前加载了哪些核心模块。</span><br><span class="line">├net 网络协议状态信息。</span><br><span class="line">├self 到查看/proc 的程序的进程目录的符号连接。</span><br><span class="line">├stat 系统的不同状态</span><br><span class="line">├uptime 系统启动的时间长度。</span><br><span class="line">└version 核心版本。</span><br></pre></td></tr></table></figure>

<h3 id="opt"><a href="#opt" class="headerlink" title="/opt"></a>/opt</h3><p>可择的文件目录。</p>
<p>这个目录表示的是可择的意思，些自定义软件包或者第方工具，就可以安装在这里。比如在 Fedora Core 5.0 中，OpenOffice 就是安装在这里。些我们自己编译的软件包，就可以安装在这个目录中；通过源码包安装的软件，可以把它们的安装路径设置成 /opt 这样来安装。这个目录的作用一点类似 /usr/local。</p>
<h3 id="mnt"><a href="#mnt" class="headerlink" title="/mnt"></a>/mnt</h3><p>临时挂载目录。</p>
<p>这个目录一般是用于存放挂载储存设备的挂载目录的，比如磁盘，光驱，网络文件系统等，当我们需要挂载某个磁盘设备的时候，可以把磁盘设备挂载到这个目录上去，这样我们可以直接通过访问这个目录来访问那个磁盘了。一般来说，我们最好在 /mnt 目录下面多建立几个子目录，挂载的时候挂载到这些子目录上面，因为通常我们可能不仅仅是挂载一个设备吧。</p>
<h3 id="media"><a href="#media" class="headerlink" title="/media"></a>/media</h3><p>挂载的媒体设备目录。</p>
<p>挂载的媒体设备目录，一般外部设备挂载到这里，例如 cdrom 等。比如我们插入一个 U 盘，我们一般会发现，Linux 自动在这个目录下建立一个 disk 目录，然后把U盘挂载到这个 disk 目录上，通过访问这个 disk 来访问 U 盘。</p>
<h3 id="var"><a href="#var" class="headerlink" title="/var"></a>/var</h3><p>内容经常变化的目录。</p>
<p>此目录下文件的大小可能会改变，如缓冲文件，日志文件，缓存文件，等一般都存放在这里。</p>
<h3 id="tmp"><a href="#tmp" class="headerlink" title="/tmp"></a>/tmp</h3><p>临时文件目录。</p>
<p>该目录存放系统中的一些临时文件，文件可能会被系统自动清空。系统直接把 tmpfs 类型的文件系统挂载到这个目录上，tmpfs 文件系统由 Linux 内核支持，在这个文件系统中的数据，实际上是内存中的，由于内存的数据断电易失，当系统重新启动的时候我们就会发现这个目录被清空了。</p>
<h3 id="lost-found"><a href="#lost-found" class="headerlink" title="/lost+found"></a>/lost+found</h3><p>恢复文件存放的位置。</p>
<p>当系统崩溃的时候，在系统修复过程中需要恢复的文件，可能就会在这里被找到了，这个目录一般为空。</p>
<p>另外，有些目录初学者容易混淆，这里简单区分一下：</p>
<p>/bin，/sbin 与 /usr/bin，/usr/sbin：</p>
<ul>
<li>/bin：一般存放对于用户和系统来说“必须”的程序（二进制文件）。</li>
<li>/sbin：一般存放用于系统管理的“必需”的程序（二进制文件），一般普通用户不会使用，根用户使用。</li>
<li>/usr/bin：一般存放的只是对用户和系统来说“不是必需的”程序（二进制文件）。</li>
<li>/usr/sbin：一般存放用于系统管理的系统管理的不是必需的程序（二进制文件）。</li>
</ul>
<p>/lib 与 /usr/lib（/lib 和 /usr/lib 的区别类似 /bin，/sbin 与 /usr/bin，/usr/sbin）：</p>
<ul>
<li>/lib：一般存放对于用户和系统来说“必须”的库（二进制文件）。</li>
<li>/usr/lib：一般存放的只是对用户和系统来说“不是必需的”库（二进制文件）。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wetts.github.io/2020/03/14/%E7%B3%BB%E7%BB%9F&%E6%9C%8D%E5%8A%A1%E5%99%A8/VM/VM-%E4%B8%89%E7%A7%8D%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Zhang Wetts">
      <meta itemprop="description" content="Stay Hungry, Stay Foolish. <br><br><p style="font-size:8px;">[build by hexo/next/gitalk/hexo-generator-search/LaTeX]</p>">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wetts's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/14/%E7%B3%BB%E7%BB%9F&%E6%9C%8D%E5%8A%A1%E5%99%A8/VM/VM-%E4%B8%89%E7%A7%8D%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%BC%8F/" class="post-title-link" itemprop="url">VM-三种网络模式</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-03-14 14:57:32 / 修改时间：15:10:06" itemprop="dateCreated datePublished" datetime="2020-03-14T14:57:32+08:00">2020-03-14</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/VM/" itemprop="url" rel="index"><span itemprop="name">VM</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>虚拟机有三种网络模式，分别是 Bridged（桥接模式）、NAT（网络地址转换模式）、Host-only（主机模式）。</p>
<h3 id="NAT（网络地址转换模式）"><a href="#NAT（网络地址转换模式）" class="headerlink" title="NAT（网络地址转换模式）"></a>NAT（网络地址转换模式）</h3><p>使用 NAT 模式，就是让虚拟系统借助 NAT 的功能，通过宿主机所在的网络来访问公网。在这种模式下宿主机成为双网卡主机，同时参与现有的宿主局域网和新建的虚拟局域网，但由于加设了一个虚拟的 NAT 服务器，使得虚拟局域网内的虚拟机在对外访问时，使用的则是宿主机的IP地址，这样从外部网络来看，只能看到宿主机，完全看不到新建的虚拟局域网。</p>
<p>这种情况下虚拟机可以上网可以 ping 通主机，但是主机 ping 不通虚拟机。</p>
<p>优点：利用 Virtualbox 安装一个新的虚拟系统，在虚拟系统中不用进行任何手工配置就能直接访问互联网，只要宿主机器能访问互联网即可。</p>
<h3 id="Bridged（桥接模式）"><a href="#Bridged（桥接模式）" class="headerlink" title="Bridged（桥接模式）"></a>Bridged（桥接模式）</h3><p>在这种模式下，Virtualbox 虚拟出来的操作系统就像是局域网中的一台独立的主机，它可以访问网内任何一台机器，需要手工为虚拟系统配置 IP 地址、网掩码，而且还要和宿主机器处于同一网段，这样虚拟系统才能和宿主机器进行通信，虚拟系统和宿主机器的关系，就像连接在同一个 Hub 上的两台电脑。从网络技术上理解相当于在宿主机前端加设了一个虚拟交换机，然后宿主机和所有虚拟机共享这个交换机。</p>
<p>这种情况下主机和虚拟机可以互相通信，虚拟机也可以上外网。</p>
<p>优点：利用 Virtualbox 在局域网内新建一个虚拟服务器，为局域网用户提供网络服务。</p>
<h3 id="Host-only（主机模式）"><a href="#Host-only（主机模式）" class="headerlink" title="Host-only（主机模式）"></a>Host-only（主机模式）</h3><p>在某些特殊的网络调试环境中，要求将真实环境和虚拟环境隔离开，这时就可采用 host-only 模式，在这种模式下宿主机上的所有虚拟机是可以相互通信的，但虚拟机和真实的网络是被隔离开的。</p>
<p>在这种模式下新建了一个由所有虚拟机与宿主机所构成的局域网，但该局域网与宿主机本身所处的现有局域网是相互独立的，如果不做额外路由设置，这两个局域网之间不会连通，因此新建的局域网可以认为是一个单独从属于当前宿主机的私有网络，其成员为当前宿主机和相关的所有虚拟机。</p>
<p>从网络技术上讲相当于为宿主机增添了一个虚拟网卡，让宿主机变成一台双网卡主机（宿主网卡+虚拟网卡）。同时在宿主机后端加设一个虚拟交换机，让宿主机和所有虚拟机构成另一个虚拟的局域网。由于具备双网卡，宿主机可同时参与两个局域网（现有的宿主局域网+新建的虚拟局域网），只不过缺省情况下两个局域网不连通。</p>
<p>优点：利用 Virtualbox 创建一个与网内其他机器相隔离的虚拟系统，进行某些特殊的网络调试工作。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wetts.github.io/2020/03/14/%E7%B3%BB%E7%BB%9F&%E6%9C%8D%E5%8A%A1%E5%99%A8/vagrant/vagrant-%E7%BD%91%E7%BB%9C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Zhang Wetts">
      <meta itemprop="description" content="Stay Hungry, Stay Foolish. <br><br><p style="font-size:8px;">[build by hexo/next/gitalk/hexo-generator-search/LaTeX]</p>">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wetts's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/14/%E7%B3%BB%E7%BB%9F&%E6%9C%8D%E5%8A%A1%E5%99%A8/vagrant/vagrant-%E7%BD%91%E7%BB%9C/" class="post-title-link" itemprop="url">vagrant-网络</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-03-14 14:37:41 / 修改时间：15:11:43" itemprop="dateCreated datePublished" datetime="2020-03-14T14:37:41+08:00">2020-03-14</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/vagrant/" itemprop="url" rel="index"><span itemprop="name">vagrant</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>vagrant 中一共提供了三种网络配置。</p>
<h3 id="端口映射（Forwarded-port）"><a href="#端口映射（Forwarded-port）" class="headerlink" title="端口映射（Forwarded port）"></a>端口映射（Forwarded port）</h3><p>这种方式，就是把本机和虚拟机的端口进行映射。比如：我配置本机计算机的8080端口为虚拟机的 80 端口，这样我访问该机器的 8080 端口，vagrant 会把请求转发到虚拟机的 80 端口是那个去处理。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">config.vm.forwarded_port 80, 8080</span><br></pre></td></tr></table></figure>

<p>通过这种方式，我们可以有针对性的把虚拟机的某些端口公布到外网让其他人去访问。</p>
<p>端口转发隐含着一个 provider 的 NAT 网络将被首先创建。所以，如果你单独定义一条端口转发的配置语句的话，VM 将会自动建立 NAT 网络环境。</p>
<h3 id="私有网络（Private-network）"><a href="#私有网络（Private-network）" class="headerlink" title="私有网络（Private network）"></a>私有网络（Private network）</h3><p>这种方式是只允许主机访问虚拟机。如果多个虚拟机设定在同一个网段，那么几个虚拟机之间也可以互相访问。这种方式，就好像是搭建了一个私有的 linux 集群。而且只有一个出口，那就是该主机。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">config.vm.network &quot;private_network&quot;, ip: &quot;192.168.21.4&quot;</span><br></pre></td></tr></table></figure>

<p>使用这种方式，非常安全，因为只有一个出口，但是你的虚拟机只允许你自己进行操作。团队成员不能操作，那你的电脑就成服务器主机了。</p>
<p>值得注意的是，ip 地址“192.168.21.4”不是随便指定的。首先你可以不指定，这表示虚机启动时会 DHCP 到一个可用的 IP 地址（例如：192.168.33.101），这是 vagrant 通过 virtualbox 私有网络的 DHCP 机制获得的。如果你要自行指定明确的 IP 地址，要保证该地址是在恰当的网段中，例如 192.168.33.71。</p>
<p>多台虚拟机在私有网络模式下也可以互相访问，只要设置为相同的网段就可以。本质上说，这是使用 provider 的 HostOnly 模式。</p>
<h3 id="公有网络（Public-network）"><a href="#公有网络（Public-network）" class="headerlink" title="公有网络（Public network）"></a>公有网络（Public network）</h3><p>虚拟机享受实体机器一样的待遇，一样的网络配置，vagrant1.3 版本之后也可以设定静态 IP。设定语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">config.vm.network &quot;public_network&quot;, ip: &quot;192.168.1.120&quot;</span><br></pre></td></tr></table></figure>

<p>这种网络配置方式，方便团队开发，别人也可以访问你的虚拟机。当然，你和你的虚拟机必须在同一个网段中。</p>
<p>可以不指定ip，也可以指定 LAN 网段中的一个可用的地址，但需要注意不要和 LAN 中已有的主机或者保留的 IP 地址相冲突。</p>
<p>本质上说，这是使用 provider 的桥接网络模式。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wetts.github.io/2020/03/14/%E7%B3%BB%E7%BB%9F&%E6%9C%8D%E5%8A%A1%E5%99%A8/Linux/Linux-%E5%91%BD%E4%BB%A4-su/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Zhang Wetts">
      <meta itemprop="description" content="Stay Hungry, Stay Foolish. <br><br><p style="font-size:8px;">[build by hexo/next/gitalk/hexo-generator-search/LaTeX]</p>">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wetts's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/14/%E7%B3%BB%E7%BB%9F&%E6%9C%8D%E5%8A%A1%E5%99%A8/Linux/Linux-%E5%91%BD%E4%BB%A4-su/" class="post-title-link" itemprop="url">Linux-命令-su</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-03-14 12:24:24 / 修改时间：21:36:51" itemprop="dateCreated datePublished" datetime="2020-03-14T12:24:24+08:00">2020-03-14</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">系统</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>su 是用户切换的命令。```</p>
<ul>
<li><code>su [user]</code>：切换到其他用户，但是不切换环境变量</li>
<li><code>su - [user]</code>：则是完整的切换到新的用户环境</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wetts.github.io/2020/03/14/%E7%B3%BB%E7%BB%9F&%E6%9C%8D%E5%8A%A1%E5%99%A8/Linux/Linux-%E5%91%BD%E4%BB%A4-apt%E4%B8%8Eapt-get%E7%9A%84%E5%8C%BA%E5%88%AB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Zhang Wetts">
      <meta itemprop="description" content="Stay Hungry, Stay Foolish. <br><br><p style="font-size:8px;">[build by hexo/next/gitalk/hexo-generator-search/LaTeX]</p>">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wetts's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/14/%E7%B3%BB%E7%BB%9F&%E6%9C%8D%E5%8A%A1%E5%99%A8/Linux/Linux-%E5%91%BD%E4%BB%A4-apt%E4%B8%8Eapt-get%E7%9A%84%E5%8C%BA%E5%88%AB/" class="post-title-link" itemprop="url">Linux-命令-apt与apt-get的区别</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-03-14 00:50:21 / 修改时间：12:24:41" itemprop="dateCreated datePublished" datetime="2020-03-14T00:50:21+08:00">2020-03-14</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">系统</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>参考：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.sysgeek.cn/apt-vs-apt-get/">https://www.sysgeek.cn/apt-vs-apt-get/</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/c58de6f018fa">https://www.jianshu.com/p/c58de6f018fa</a></li>
</ul>
<hr>
<p>Ubuntu 16.04 发布时，一个引人注目的新特性便是 <code>apt</code> 命令的引入。其实早在 2014 年，apt 命令就已经发布了第一个稳定版，只是直到 2016 年的 Ubuntu 16.04 系统发布时才开始引人关注。</p>
<p>随着 <code>apt install package</code> 命令的使用频率和普遍性逐步超过 <code>apt-get install package</code>，越来越多的其它 Linux 发行版也开始遵循 Ubuntu 的脚步，开始鼓励用户使用 <code>apt</code> 而不是 <code>apt-get</code>。</p>
<p>那么，<code>apt-get</code> 与 <code>apt</code> 命令之间到底有什么区别呢？如果它们有类似的命令结构，为什么还需要新的 <code>apt</code> 命令呢？是否 <code>apt</code> 真的比 <code>apt-get</code> 更好？普通用户应该使用新的 <code>apt</code> 命令还是坚持旧有习惯继续使用 <code>apt-get</code> 呢？</p>
<h3 id="apt-与-apt-get"><a href="#apt-与-apt-get" class="headerlink" title="apt 与 apt-get"></a>apt 与 apt-get</h3><p>在开始对比 <code>apt</code> 与 <code>apt-get</code> 命令的区别之前，我们先来看看这两个命令的背景，以及它们要试图达到的目的。</p>
<p>Debian 作为 Ubuntu、Linux Mint 和 elementary OS 等 Linux 操作系统的母板，其具有强健的「包管理」系统，它的每个组件和应用程序都内置在系统中安装的软件包中。Debian 使用一套名为 Advanced Packaging Tool（APT）的工具来管理这种包系统，不过请不要把它与 <code>apt</code> 命令混淆，它们之间是其实不是同一个东西。</p>
<p>在基于 Debian 的 Linux 发行版中，有各种工具可以与 APT 进行交互，以方便用户安装、删除和管理的软件包。<code>apt-get</code> 便是其中一款广受欢迎的命令行工具，另外一款较为流行的是 Aptitude 这一命令行与 GUI 兼顾的小工具。</p>
<p>如果你已阅读过我们的 <code>apt-get</code> 命令指南，可能已经遇到过许多类似的命令，如 <code>apt-cache</code>、<code>apt-config</code> 等。如你所见，这些命令都比较低级又包含众多功能，普通的 Linux 用户也许永远都不会使用到。换种说法来说，就是最常用的 Linux 包管理命令都被分散在了 <code>apt-get</code>、<code>apt-cache</code> 和 <code>apt-config</code> 这三条命令当中。</p>
<p><code>apt</code> 命令的引入就是为了解决命令过于分散的问题，它包括了 <code>apt-get</code> 命令出现以来使用最广泛的功能选项，以及 <code>apt-cache</code> 和 <code>apt-config</code> 命令中很少用到的功能。</p>
<p>在使用 <code>apt</code> 命令时，用户不必再由 <code>apt-get</code> 转到 <code>apt-cache</code> 或 <code>apt-config</code>，而且 <code>apt</code> 更加结构化，并为用户提供了管理软件包所需的必要选项。</p>
<blockquote>
<p>简单来说就是：<code>apt</code> = <code>apt-get</code>、<code>apt-cache</code> 和 <code>apt-config</code> 中最常用命令选项的集合。</p>
</blockquote>
<h3 id="apt-与-apt-get-之间的区别"><a href="#apt-与-apt-get-之间的区别" class="headerlink" title="apt 与 apt-get 之间的区别"></a>apt 与 apt-get 之间的区别</h3><p>通过 <code>apt</code> 命令，用户可以在同一地方集中得到所有必要的工具，<code>apt</code> 的主要目的是提供一种以「让终端用户满意」的方式来处理 Linux 软件包的有效方式。</p>
<p><code>apt</code> 具有更精减但足够的命令选项，而且参数选项的组织方式更为有效。除此之外，它默认启用的几个特性对最终用户也非常有帮助。例如，可以在使用 <code>apt</code> 命令安装或删除程序时看到进度条。</p>
<p><code>apt</code> 还会在更新存储库数据库时提示用户可升级的软件包个数。</p>
<p>如果你使用 <code>apt</code> 的其它命令选项，也可以实现与使用 <code>apt-get</code> 时相同的操作。</p>
<h4 id="apt-和-apt-get-命令之间的区别"><a href="#apt-和-apt-get-命令之间的区别" class="headerlink" title="apt 和 apt-get 命令之间的区别"></a>apt 和 apt-get 命令之间的区别</h4><p>虽然 <code>apt</code> 与 <code>apt-get</code> 有一些类似的命令选项，但它并不能完全向下兼容 <code>apt-get</code> 命令。也就是说，可以用 <code>apt</code> 替换部分 <code>apt-get</code> 系列命令，但不是全部。</p>
<table>
<thead>
<tr>
<th align="center">apt 命令</th>
<th align="center">取代的命令</th>
<th align="center">命令的功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center">apt install</td>
<td align="center">apt-get install</td>
<td align="center">安装软件包</td>
</tr>
<tr>
<td align="center">apt remove</td>
<td align="center">apt-get remove</td>
<td align="center">移除软件包</td>
</tr>
<tr>
<td align="center">apt purge</td>
<td align="center">apt-get purge</td>
<td align="center">移除软件包及配置文件</td>
</tr>
<tr>
<td align="center">apt update</td>
<td align="center">apt-get update</td>
<td align="center">刷新存储库索引</td>
</tr>
<tr>
<td align="center">apt upgrade</td>
<td align="center">apt-get upgrade</td>
<td align="center">升级所有可升级的软件包</td>
</tr>
<tr>
<td align="center">apt autoremove</td>
<td align="center">apt-get autoremove</td>
<td align="center">自动删除不需要的包</td>
</tr>
<tr>
<td align="center">apt full-upgrade</td>
<td align="center">apt-get dist-upgrade</td>
<td align="center">在升级软件包时自动处理依赖关系</td>
</tr>
<tr>
<td align="center">apt search</td>
<td align="center">apt-cache search</td>
<td align="center">搜索应用程序</td>
</tr>
<tr>
<td align="center">apt show</td>
<td align="center">apt-cache show</td>
<td align="center">显示装细节</td>
</tr>
</tbody></table>
<p>当然，<code>apt</code> 还有一些自己的命令：</p>
<table>
<thead>
<tr>
<th align="center">新的apt命令</th>
<th align="center">命令的功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center">apt list</td>
<td align="center">列出包含条件的包（已安装，可升级等）</td>
</tr>
<tr>
<td align="center">apt edit-sources</td>
<td align="center">编辑源列表</td>
</tr>
</tbody></table>
<p>需要大家注意的是：<code>apt</code> 命令也还在不断发展，因此，你可能会在将来的版本中看到新的选项。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wetts.github.io/2020/03/12/%E5%A4%A7%E6%95%B0%E6%8D%AE/Hadoop/HBase/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Zhang Wetts">
      <meta itemprop="description" content="Stay Hungry, Stay Foolish. <br><br><p style="font-size:8px;">[build by hexo/next/gitalk/hexo-generator-search/LaTeX]</p>">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wetts's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/12/%E5%A4%A7%E6%95%B0%E6%8D%AE/Hadoop/HBase/" class="post-title-link" itemprop="url">HBase.md</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-03-12 18:59:31" itemprop="dateCreated datePublished" datetime="2020-03-12T18:59:31+08:00">2020-03-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-05-08 17:19:48" itemprop="dateModified" datetime="2020-05-08T17:19:48+08:00">2020-05-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Hadoop/" itemprop="url" rel="index"><span itemprop="name">Hadoop</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>HBase 利用 Hadoop MapReduce 来处理 HBase 中的海量数据，实现高性能计算；利用 Zookeeper 作为协同服务，实现稳定服务和失败恢复；使用 HDFS 作为高可靠的底层存储，利用廉价集群提供海量数据存储能力。当然，HBase 也可以直接使用本地文件系统而不用 HDFS 作为底层数据存储方式，不过，为了提高数据可靠性和系统的健壮性，发挥 HBase 处理大数据量等功能，一般都使用 HDFS 作为 HBase 的底层数据存储方式。此外，为了方便在 HBase 上进行数据处理，Sqoop 为 HBase 提供了高效、便捷的 RDBMS 数据导人功能，Pig 和 Hive 为 HBase 提供了高层语言支持。HBase 是 BigTable 的开源实现。</p>
<p><img src="/2020/03/12/%E5%A4%A7%E6%95%B0%E6%8D%AE/Hadoop/HBase/HBase%E4%B8%8E%E5%85%B6%E4%BB%96%E9%83%A8%E5%88%86%E7%9A%84%E5%85%B3%E7%B3%BB.png" alt="HBase与其他部分的关系"></p>
<p><img src="/2020/03/12/%E5%A4%A7%E6%95%B0%E6%8D%AE/Hadoop/HBase/HBase%E4%B8%8EBigTable.png" alt="HBase与BigTable"></p>
<h2 id="HBase-数据模型"><a href="#HBase-数据模型" class="headerlink" title="HBase 数据模型"></a>HBase 数据模型</h2><h3 id="数据模型概述"><a href="#数据模型概述" class="headerlink" title="数据模型概述"></a>数据模型概述</h3><p>HBase 是一个稀疏、多维度、排序的映射表，这张表的索引是行键、列族、列限定符和时间戳。每个值是一个未经解释的字符串，没有数据类型。用户在表中存储数据，每一行都有一个可排序的行键和任意多的列。表在水平方向由一个或者多个列族组成，同一个列族中可以包含任意多个列，同一个列族里面的数据存储在一起。列族支持动态扩展，可以很轻松地添加-个列族或列，无需预先定义列的数量以及类型，所有列均以字符串形式存储，用户需要自行进行数据类型转换。由于同-张表里面的每一行数据都可以有截然不同的列，因此对于整个映射表的每行数据而言，有些列的值就是空的，所以说 HBase 是稀疏的。</p>
<p>在 HBase 中执行更新操作时，并不会删除数据旧的版本，而是生成一个新的版本，旧有的版本仍然保留，HBase 可以对允许保留的版本的数量进行设置。客户端可以选择获取距离某个时间最近的版本，或者一次获取所有版本。如果在查询的时候不提供时间戳，那么会返回距离现在最近的那一个版本的数据，因为在存储的时候，数据会按照时间戳排序。</p>
<p>HBase 提供了两种数据版本回收方式：</p>
<ul>
<li>一是保存数据的最后 n 个版本；</li>
<li>二是保存最近一段时间内的版本(如最近7天)。</li>
</ul>
<h3 id="数据模型的相关概念"><a href="#数据模型的相关概念" class="headerlink" title="数据模型的相关概念"></a>数据模型的相关概念</h3><p><img src="/2020/03/12/%E5%A4%A7%E6%95%B0%E6%8D%AE/Hadoop/HBase/HBase%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B%E5%AE%9E%E4%BE%8B.png" alt="HBase数据模型实例"></p>
<h4 id="表"><a href="#表" class="headerlink" title="表"></a>表</h4><p>HBase 采用表来组织数据，表由行和列组成，列划分为若千个列族。</p>
<h4 id="行"><a href="#行" class="headerlink" title="行"></a>行</h4><p>每个 HBase 表都由若干行组成，每个行由行键（Row Key）来标识。访问表中的行只有 3 种方式：</p>
<ol>
<li>通过单个行键访问；</li>
<li>通过一个行键的区间来访问；</li>
<li>全表扫描。</li>
</ol>
<p>行键可以是任意字符串（最大长度是 64 KB，实际应用中长度一般为 10~100 字节），在 HBase 内部，行键保存为字节数组。存储时，数据按照行键的字典序排序存储。在设计行键时，要充分考虑这个特性，将经常一起读取的行存储在一起。</p>
<h4 id="列族"><a href="#列族" class="headerlink" title="列族"></a>列族</h4><p>一个 HBase 表被分组成许多“列族”的集合，它是基本的访问控制单元。列族需要在表创建时就定义好，数量不能太多（HBase 的一些缺陷使得列族数量只限于几十个），而且不要频繁修改。</p>
<p>存储在一个列族当中的所有数据，通常都属于同一种数据类型，这通常意味着具有更高的压缩率。表中的每个列都归属于某个列族，数据可以被存放到列族的某个列下面，但是在把数据存放到这个列族的某个列下面之前，必须首先创建这个列族。在创建完成一个列族以后，就可以使用同一个列族当中的列。列名都以列族作为前缀。例如，courses:history 和 courses:math 这两个列都属于 courses 这个列族。</p>
<p>在 HBase 中，访问控制、磁盘和内存的使用统计都是在列族层面进行的。实际应用中，我们可以借助列族上的控制权限帮助实现特定的目的。比如，我们可以允许一些应用能够向表中添加新的数据，而另一些应用则只允许浏览数据。HBase 列族还可以被配置成支持不同类型的访问模式。比如，一个列族也可以被设置成放入内存当中，以消耗内存为代价，从而换取更好的响应性能。</p>
<h4 id="列限定符"><a href="#列限定符" class="headerlink" title="列限定符"></a>列限定符</h4><p>列族里的数据通过列限定符（或列）来定位。列限定符不用事先定义，也不需要在不同行之间保持一致。列限定符没有数据类型，总被视为字节数组 byte[]。</p>
<h4 id="单元格"><a href="#单元格" class="headerlink" title="单元格"></a>单元格</h4><p>在 HBase 表中，通过行、列族和列限定符确定一个“单元格”(Cell)。单元格中存储的数据没有数据类型，总被视为字节数组 bytel]。每个单元格中可以保存一个数据的多个版本，每个版本对应一个不同的时间戳。</p>
<h4 id="时间戳"><a href="#时间戳" class="headerlink" title="时间戳"></a>时间戳</h4><p>每个单元格都保存着同一份数据的多个版本，这些版本采用时间戳进行索引。每次对一个单元格执行操作（新建、修改、删除）时，HBase 都会隐式地自动生成并存储一个时间戳。时间戳一般是 64 位整型，可以由用户自己赋值（自己生成唯一时间戳可以避免应用程序中出现数据版本冲突），也可以由 HBase 在数据写入时自动赋值。一个单元格的不同版本是根据时间戳降序的顺序进行存储的，这样，最新的版本可以被最先读取。</p>
<h3 id="数据坐标"><a href="#数据坐标" class="headerlink" title="数据坐标"></a>数据坐标</h3><p>HBase 使用坐标来定位表中的数据，也就是说，每个值都是通过坐标来访问的。对于我们熟悉的关系数据库而言，数据定位可以理解为采用“二维坐标”，即根据行和列就可以确定表中一个具体的值。但是，HBase中需要根据行键、列族、列限定符和时间戳来确定一个单元格，因此可以视为一个“四维坐标”，即 [行键，列族，列限定符，时间戳]。</p>
<h3 id="概念视图"><a href="#概念视图" class="headerlink" title="概念视图"></a>概念视图</h3><p>在 HBase 的概念视图中，一个表可以视为一个稀疏、多维的映射关系。</p>
<p><img src="/2020/03/12/%E5%A4%A7%E6%95%B0%E6%8D%AE/Hadoop/HBase/HBase%E6%95%B0%E6%8D%AE%E7%9A%84%E6%A6%82%E5%BF%B5%E8%A7%86%E5%9B%BE.png" alt="HBase数据的概念视图"></p>
<p>上图行键是一个反向 URL（即 com.cnn.www），之所以这样存放，是因为 HBase 是按照行键的字典序来排序存储数据的，采用反向 URL 的方式，可以让来自同一个网站的数据内容都保存在相邻的位置，在按照行键的值进行水平分区时，就可以尽量把来自同一个网站的数据划分到同一个分区（Region）中。</p>
<h3 id="物理视图"><a href="#物理视图" class="headerlink" title="物理视图"></a>物理视图</h3><p>从概念视图层面，HBase 中的每个表是由许多行组成的，但是在物理存储层面，它是采用了基于列的存储方式，而不是像传统关系数据库那样采用基于行的存储方式，这也是 HBase 和传统关系数据库的重要区别。</p>
<p><img src="/2020/03/12/%E5%A4%A7%E6%95%B0%E6%8D%AE/Hadoop/HBase/HBase%E6%95%B0%E6%8D%AE%E7%9A%84%E7%89%A9%E7%90%86%E8%A7%86%E5%9B%BE.png" alt="HBase数据的物理视图"></p>
<h3 id="面向列的存储"><a href="#面向列的存储" class="headerlink" title="面向列的存储"></a>面向列的存储</h3><p>行式数据库使用 NSM（N-ary Storage Model）存储模型，一个元组（或行）会被连续地存储在磁盘页中，也就是说，数据是一行一行被存储的，第一行写人磁盘页后，再继续写人第二行，依此类推。在从磁盘中读取数据时，需要从磁盘中顺序扫描每个元组的完整内容，然后从每个元组中筛选出查询所需要的属性。如果每个元组只有少量属性的值对于查询是有用的，那么 NSM 就会浪费许多磁盘空间和内存带宽。</p>
<p>列式数据库采用 DSM（Decomposition Storage Model）存储模型，它是在 1985 年提出来的，目的是最小化无用的 I/O。DSM 采用了不同于 NSM 的思路，对于采用 DSM 存储模型的关系数据库而言，DSM 会对关系进行垂直分解，并为每个属性分配一个子关系。因此，一个具有 n 个属性的关系会被分解成 n 个子关系，每个子关系单独存储，每个子关系只有当其相应的属性被请求时才会被访问。也就是说，DSM 是以关系数据库中的属性或列为单位进行存储，关系中多个元组的同一属性值（或同一列值）会被存储在一起，而一个元组中不同属性值则通常会被分别存放于不同的磁盘页中。</p>
<p><img src="/2020/03/12/%E5%A4%A7%E6%95%B0%E6%8D%AE/Hadoop/HBase/%E8%A1%8C%E5%BC%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E5%92%8C%E5%88%97%E5%BC%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84.png" alt="行式存储结构和列式存储结构"></p>
<ul>
<li>行式数据库主要适合于小批量的数据处理，如联机事务型数据处理，我们平时熟悉的 Oracle 和 MySQL 等关系数据库都属于行式数据库。</li>
<li>列式数据库主要适合于批量数据处理和即席查询（Ad-Hoc Query）。</li>
</ul>
<p>列式存储的优点是：</p>
<ul>
<li>可以降低 IO 开销，支持大量并发用户查询，其数据处理速度比传统方法快 100 倍，因为仅需要处理可以回答这些查询的列，而不是分类整理与特定查询无关的数据行；</li>
<li>具有较高的数据压缩比，较传统的行式数据库更加有效，甚至能达到 5 倍的效果。</li>
</ul>
<p>列式数据库主要用于数据挖掘、决策支持和地理信息系统等查询密集型系统中，因为一次查询就可以得出结果，而不必每次都要遍历所有的数据库。所以，列式数据库大多都是应用在人口统计调查、医疗分析等行业中，这种行业需要处理大量的数据统计分析，假如采用行式数据库，势必导致消耗的时间会无限放大。</p>
<p>DSM 存储模型的缺陷是：</p>
<ul>
<li>执行连接操作时需要昂贵的元组重构代价，因为一个元组的不同属性被分散到不同磁盘页中存储，当需要一个完整的元组时，就要从多个磁盘页中读取相应字段的值来重新组合得到原来的一个元组。</li>
<li>对于联机事务型数据处理而言，需要频繁对一些元组进行修改（如百货商场售出一件衣服后要立即修改库存数据），如果采用DSM存储模型，就会带来高昂的开销。</li>
</ul>
<h2 id="HBase-的实现原理"><a href="#HBase-的实现原理" class="headerlink" title="HBase 的实现原理"></a>HBase 的实现原理</h2><h3 id="HBase-的功能组件"><a href="#HBase-的功能组件" class="headerlink" title="HBase 的功能组件"></a>HBase 的功能组件</h3><p>HBase 的实现包括3个主要的功能组件：</p>
<ul>
<li>库函数，链接到每个客户端；</li>
<li>一个 Master 主服务器；</li>
<li>许多个 Region 服务器。</li>
</ul>
<hr>
<ul>
<li>Region 服务器负责存储和维护分配给自己的 Region，处理来自客户端的读写请求。</li>
<li>主服务器 Master 负责管理和维护 HBase 表的分区信息，比如，一个表被分成了哪些 Region，每个 Region 被存放在哪台 Region 服务器上，同时也负责维护 Region 服务器列表。</li>
</ul>
<p>因此，如果 Master 主服务器死机，那么整个系统都会无效。Master 会实时监测集群中的 Region 服务器，把特定的 Region 分配到可用的 Region 服务器上，并确保整个集群内部不同 Region 服务器之间的负载均衡，当某个 Region 服务器因出现故障而失效时，Master 会把该故障服务器上存储的 Region 重新分配给其他可用的 Region 服务器。除此以外，Master 还处理模式变化，如表和列族的创建。同客户端并不是直接从 Master 主服务器上读取数据，而是在获得 Region 的存储位置信息后，直接从 Region 服务器上读取数据。尤其需要指出的是，HBase 客户端并不依赖于 Master 而是借助于 Zookeeper 来获得 Region 的位置信息的，所以大多数客户端从来不和主服务器 Master 通信，这种设计方式使 Master 的负载很小。</p>
<h3 id="表和-Region"><a href="#表和-Region" class="headerlink" title="表和 Region"></a>表和 Region</h3><p>在一个 HBase 中，存储了许多表。对于每个 HBase 表而言，表中的行是根据行键的值的字典序进行维护的，表中包含的行的数量可能非常庞大，无法存储在一台机器上，需要分布存储到多台机器上。因此，需要根据行键的值对表中的行进行分区，每个行区间构成一个分区，被称为”Region”，包含了位于某个值域区间内的所有数据，它是负载均衡和数据分发的基本单位，这些 Region 会被分发到不同的 Region 服务器上。</p>
<p><img src="/2020/03/12/%E5%A4%A7%E6%95%B0%E6%8D%AE/Hadoop/HBase/%E4%B8%80%E4%B8%AAHBase%E8%A1%A8%E8%A2%AB%E5%88%92%E5%88%86%E6%88%90%E5%A4%9A%E4%B8%AARegion.png" alt="一个HBase表被划分成多个Region"></p>
<p>初始时，每个表只包含一个Region，随着数据的不断插入，Region 会持续增大，当一个 Region 中包含的行数量达到一个阈值时，就会被自动等分成两个新的 Region。随着表中行的数量继续增加，就会分裂出越来越多的 Region。</p>
<p><img src="/2020/03/12/%E5%A4%A7%E6%95%B0%E6%8D%AE/Hadoop/HBase/%E4%B8%80%E4%B8%AARegion%E5%88%86%E8%A3%82%E6%88%90%E5%A4%9A%E4%B8%AA%E6%96%B0%E7%9A%84Region.png" alt="一个Region分裂成多个新的Region"></p>
<p>每个 Region 的默认大小是 100MB 到 200MB，是 HBase 中负载均衡和数据分发的基本单位。Master 主服务器会把不同的 Region 分配到不同的 Region 服务器上，但是同一个 Region 是不会被拆分到多个 Region 服务器上的。每个 Region 服务器负责管理-个 Region 集合，通常在每个 Region 服务器上会放置 10~1000 个 Region。</p>
<p><img src="/2020/03/12/%E5%A4%A7%E6%95%B0%E6%8D%AE/Hadoop/HBase/%E4%B8%8D%E5%90%8CRegion%E5%88%86%E5%B8%83%E5%9C%A8%E4%B8%8D%E5%90%8CRegion%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A.png" alt="不同Region分布在不同Region服务器上"></p>
<h3 id="Region-的定位"><a href="#Region-的定位" class="headerlink" title="Region 的定位"></a>Region 的定位</h3><p>每个 Region 都有一个 RegionID 来标识它的唯一性，这样，一个 Region 标识符就可以表示成“表名 + 开始主键 + RegionID”。</p>
<p>有了 Region 标识符，就可以唯一标识每个 Region。为了定位每个 Region 所在的位置，就可以构建一张映射表，映射表的每个条目（或每行）包含两项内容，一个是 Region 标识符，另一个是 Region 服务器标识，这个条目就表示 Region 和 Region 服务器之间的对应关系，从而就可以知道某个 Region 被保存在哪个 Region 服务器中。这个映射表包含了关于 Region 的元数据（即 Region 和 Region 服务器之间的对应关系），因此也被称为“元数据表”，又名“.META.表”。</p>
<p>当一个 HBase 表中的 Region 数量非常庞大的时候，.META.表的条目就会非常多，一个服务器保存不下，也需要分区存储到不同的服务器上，因此.META.表也会被分裂成多个 Region，这时，为了定位这些 Region，就需要再构建一个新的映射表，记录所有元数据的具体位置，这个新的映射表就是“根数据表”，又名“-ROOT-表”。-ROOT-表是不能被分割的，永远只存在一个 Region 用于存放-ROOT-表，因此这个用来存放-ROOT-表的唯一一个 Region, 它的名字是在程序中被写死的，Master 主服务器永远知道它的位置。</p>
<p>综上所述，HBase 使用类似 B+树的三层结构来保存 Region 位置信息。</p>
<p><img src="/2020/03/12/%E5%A4%A7%E6%95%B0%E6%8D%AE/Hadoop/HBase/HBase%E7%9A%84%E4%B8%89%E5%B1%82%E7%BB%93%E6%9E%84.png" alt="HBase的三层结构"></p>
<p><img src="/2020/03/12/%E5%A4%A7%E6%95%B0%E6%8D%AE/Hadoop/HBase/HBase%E4%B8%89%E5%B1%82%E7%BB%93%E6%9E%84%E7%9A%84%E5%90%8D%E7%A7%B0%E5%92%8C%E4%BD%9C%E7%94%A8.png" alt="HBase三层结构的名称和作用"></p>
<p>为了加快访问速度，.META.表的全部 Region 都会被保存在内存中。假设.META.表的每行（一个映射条目）在内存中大约占用 1KB，并且每个 Region 限制为 128MB，那么，上面的三层结构可以保存的用户数据表的 Region 数目的计算方法是：(-ROOT-表能够寻址的.META.表的 Region 个数) x (每个.META.表的 Region 可以寻址的用户数据表的 Region 个数)。一个-ROOT-表最多只能有一个 Region，也就是最多只能有 128MB，按照每行（一个映射条目）占用 1KB 内存计算，128MB 空间可以容纳 128MB/1KB=2^17 行，也就是说，一个-ROOT表可以寻址 2^17 个.META.表的 Region。同理，每个.META.表的 Region 可以寻址的用户数据表的 Region 个数是 128MB/1KB=2^17。最终，三层结构可以保存的 Region 数目是 (128MB/1KB) * (128MB/1KB) = 234 个 Region。可以看出，这种数量已经足够可以满足实际应用中的用户数据存储需求。</p>
<p>客户端访问用户数据之前，需要首先访问 Zookeeper，获取-ROOT-表的位置信息，然后访问-ROOT-表，获得.META.表的信息，接着访问.META.表，找到所需的 Region 具体位于哪个 Region 服务器，最后才会到该 Region 服务器读取数据。该过程需要多次网络操作，为了加速寻址过程，一般会在客户端做缓存，把查询过的位置信息缓存起来，这样以后访问相同的数据时，就可以直接从客户端缓存中获取 Region 的位置信息，而不需要每次都经历一个“三级寻址”过程。需要注意的是，随着 HBase 中表的不断更新，Region 的位置信息可能会发生变化，但是客户端缓存并不会自己检测 Region 位置信息是否失效，而是在需要访问数据时，从缓存中获取 Region 位置信息却发现不存在的时候，才会判断出缓存失效，这时，就需要再次经历上述的“三级寻址”过程，重新获取最新的 Region 位置信息去访问数据，并用最新的 Region 位置信息替换缓存中失效的信息。</p>
<p>当一个客户端从 Zookeeper 服务器上拿到-ROOT-表的地址以后，就可以通过“三级寻址”找到用户数据表所在的 Region 服务器，并直接访问该 Region 服务器获得数据，没有必要再连接主服务器 Master。因此，主服务器的负载相对就小了很多。</p>
<h2 id="HBase-运行机制"><a href="#HBase-运行机制" class="headerlink" title="HBase 运行机制"></a>HBase 运行机制</h2><h3 id="HBase-系统架构"><a href="#HBase-系统架构" class="headerlink" title="HBase 系统架构"></a>HBase 系统架构</h3><p>HBase 的系统架构包括客户端、Zookeeper 服务器、Master 主服务器、Region 服务器。需要说明的是，HBase 一般采用 HDFS 作为底层数据存储。</p>
<p><img src="/2020/03/12/%E5%A4%A7%E6%95%B0%E6%8D%AE/Hadoop/HBase/HBase%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84.png" alt="HBase的系统架构"></p>
<h4 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h4><p>客户端包含访问 HBase 的接口，同时在缓存中维护着已经访问过的 Region 位置信息，用来加快后续数据访问过程。HBase 客户端使用 HBase 的 RPC 机制与 Master 和 Region 服务器进行通信。其中，对于管理类操作，客户端与 Master 进行 RPC；而对于数据读写类操作，客户端则会与 Region 服务器进行 RPC。</p>
<h4 id="Zookeeper-服务器"><a href="#Zookeeper-服务器" class="headerlink" title="Zookeeper 服务器"></a>Zookeeper 服务器</h4><p>Zookeeper 服务器并非一台单一的机器，可能是由多台机器构成的集群来提供稳定可靠的协同服务。Zookeeper 能够很容易地实现集群管理的功能，如果有多台服务器组成一个服务器集群，那么必须有一个“总管”知道当前集群中每台机器的服务状态，一旦某台机器不能提供服务，集群中其他机器必须知道，从而做出调整重新分配服务策略。同样，当增加集群的服务能力时，就会增加一台或多台服务器，同样也必须让“总管”知道。</p>
<p>在 HBase 服务器集群中，包含了一个 Master 和多个 Region 服务器，Master 就是这个 HBase 集群的“总管”，它必须知道 Region 服务器的状态。Zookeeper 就可以轻松做到这一点，每个 Region 服务器都需要到 Zookeeper 中进行注册，Zookeeper 会实时监控每个 Region 服务器的状态并通知给 Master，这样，Master 就可以通过 Zookeeper 随时感知到各个 Region 服务器的工作状态。</p>
<p>Zookeeper 不仅能够帮助维护当前的集群中机器的服务状态，而且能够帮助选出一个“总管”，让这个总管来管理集群。HBase 中可以启动多个 Master，但是 Zookeeper 可以帮助选举出一个 Master 作为集群的总管，并保证在任何时刻总有唯一一个 Master 在运行，这就避免了 Master 的“单点失效”问题。</p>
<p>Zookeeper 中保存了-ROOT-表的地址和 Master 的地址，客户端可以通过访问 Zookeeper 获得-ROOT-表的地址，并最终通过“三级寻址”找到所需的数据。Zookeeper 中还存储了 HBase 的模式，包括有哪些表，每个表有哪些列族。</p>
<h4 id="Master"><a href="#Master" class="headerlink" title="Master"></a>Master</h4><p>主服务器 Master 主要负责表和 Region 的管理工作。</p>
<ul>
<li>管理用户对表的增加、删除、修改、查询等操作。</li>
<li>实现不同 Region 服务器之间的负载均衡。</li>
<li>在 Region 分裂或合并后，负责重新调整 Region 的分布。</li>
<li>对发生故障失效的 Region 服务器上的 Region 进行迁移。</li>
</ul>
<p>客户端访问 HBase 上数据的过程并不需要 Master 的参与，客户端可以访问 Zookeeper 获取-ROOT-表的地址，并最终到达相应的 Region 服务器进行数据读写，Master 仅仅维护着表和 Region 的元数据信息，因此负载很低。</p>
<p>任何时刻，一个 Region 只能分配给一个 Region 服务器。Master 维护了当前可用的 Region 服务器列表，以及当前哪些 Region 分配给了哪些 Region 服务器，哪些 Region 还未被分配。当存在未被分配的 Region，并且有一个 Region 服务器上有可用空间时，Master 就给这个 Region 服务器发送一个请求，把该 Region 分配给它。Region 服务器接受请求并完成数据加载后，就开始负责管理该 Region 对象，并对外提供服务。</p>
<h4 id="Region-服务器"><a href="#Region-服务器" class="headerlink" title="Region 服务器"></a>Region 服务器</h4><p>Region 服务器是 HBase 中最核心的模块，负责维护分配给自己的 Region，并响应用户的读写请求。HBase 一般采用 HDFS 作为底层存储文件系统，因此 Region 服务器需要向 HDFS 文件系统中读写数据。采用 HDFS 作为底层存储，可以为 HBase 提供可靠稳定的数据存储，HBase 自身并不具备数据复制和维护数据副本的功能，而HDFS可以为 HBase 提供这些支持。当然，HBase 也可以不采用 HDFS，而是使用其他任何支持 Hadoop 接口的文件系统作为底层存储，比如本地文件系统或云计算环境中的 AmazonS3(Simple Storage Service)。</p>
<h3 id="Region-服务器的工作原理"><a href="#Region-服务器的工作原理" class="headerlink" title="Region 服务器的工作原理"></a>Region 服务器的工作原理</h3><p>Region 服务器是 HBase 中最核心的模块，Region 服务器内部管理了一系列 Region 对象和一个 HLog 文件，其中 HLog 是磁盘上面的记录文件，它记录着所有的更新操作。每个 Region 对象又是由多个 Store 组成的，每个 Store 对应了表中的一个列族的存储。每个 Store 又包含了一个 MemStore 和若千个 StoreFile。</p>
<ul>
<li>MemStore 是在内存中的缓存，保存最近更新的数据; </li>
<li>StoreFile 是磁盘中的文件，这些文件都是 B 树结构的，方便快速读取。StoreFile 在底层的实现方式是 HDFS 文件系统的 HFile, HFile 的数据块通常采用压缩方式存储，压缩之后可以大大减少网络 I/0 和磁盘 I/O。</li>
</ul>
<p><img src="/2020/03/12/%E5%A4%A7%E6%95%B0%E6%8D%AE/Hadoop/HBase/Region%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%90%91HDFS%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E4%B8%AD%E8%AF%BB%E5%86%99%E6%95%B0%E6%8D%AE.png" alt="Region服务器向HDFS文件系统中读写数据"></p>
<h4 id="用户读写数据的过程"><a href="#用户读写数据的过程" class="headerlink" title="用户读写数据的过程"></a>用户读写数据的过程</h4><p>当用户写入数据时，会被分配到相应的 Region 服务器去执行操作。用户数据首先被写人到 MemStore 和 HLog 中，当操作写入 HLog 之后，commit() 调用才会将其返回给客户端。</p>
<p>当用户读取数据时，Region 服务器会首先访问 MemStore 缓存，如果数据不在缓存中，才会到磁盘上面的 StoreFile 中去寻找。</p>
<h4 id="缓存的刷新"><a href="#缓存的刷新" class="headerlink" title="缓存的刷新"></a>缓存的刷新</h4><p>MemStore 缓存的容量有限，系统会周期性地调用 Region.flushcache() 把 MemStore 缓存里面的内容写到磁盘的 StoreFile 文件中，清空缓存，并在 HLog 文件中写入一个标记，用来表示缓存中<br>的内容已经被写人 StoreFile 文件中。每次缓存刷新操作都会在磁盘上生成一个新的 StoreFile 文件，因此每个 Store 会包含多个 StoreFile 文件。</p>
<p>每个 Region 服务器都有一个自己的 HLog 文件，在启动的时候，每个 Region 服务器都会检查自己的 HLog 文件，确认最近一次执行缓存刷新操作之后是否发生新的写人操作。如果没有更新，说明所有数据已经被永久保存到磁盘的 StoreFile 文件中；如果发现更新，就先把这些更新写人 MemStore，然后再刷新缓存，写人到磁盘的 StoreFile 文件中。最后，删除旧的 HLog 文件，并开始为用户提供数据访问服务。</p>
<h4 id="StoreFile-的合并"><a href="#StoreFile-的合并" class="headerlink" title="StoreFile 的合并"></a>StoreFile 的合并</h4><p>每次 MemStore 缓存的刷新操作都会在磁盘上生成一个新的 StoreFile 文件，这样，系统中的每个 Store 就会存在多个 StoreFile 文件。当需要访问某个 Store 中的某个值时，就必须查找所有这些 StoreFile 文件，非常耗费时间。因此，为了减少查找时间，系统一般会调用 Store.compact() 把多个 StoreFile 文件合并成一个大文件。由于合并操作比较耗费资源，因此只会在 StoreFile 文件的数量达到一个阈值的时候才会触发合并操作。</p>
<h3 id="Store-的工作原理"><a href="#Store-的工作原理" class="headerlink" title="Store 的工作原理"></a>Store 的工作原理</h3><p>Region 服务器是 HBase 的核心模块，而 Store 则是 Region 服务器的核心。每个 Store 对应了表中的一个列族的存储。每个 Store 包含一个 MemStore 缓存和若于个 StoreFile 文件。MemStore 是排序的内存缓冲区，当用户写入数据时，系统首先把数据放人 MemStore 缓存，当 MemStore 缓存满时，就会刷新到磁盘中的一个 StoreFile 文件中。随着 StoreFile 文件数量的不断增加，当达到事先设定的数量时，就会触发文件合并操作，多个 StoreFile 文件会被合并成一个大的 StoreFile 文件。当多个 StoreFile 文件合并后，会逐步形成越来越大的 StoreFile 文件，当单个 StoreFile 文件大小超过一定阈值时，就会触发文件分裂操作。同时，当前的 1 个父 Region 会被分裂成 2 个子 Region, 父 Region 会下线，新分裂出的 2 个子 Region 会被 Master 分配到相应的 Region 服务器上。</p>
<p><img src="/2020/03/12/%E5%A4%A7%E6%95%B0%E6%8D%AE/Hadoop/HBase/StoreFile%E7%9A%84%E5%90%88%E5%B9%B6%E5%92%8C%E5%88%86%E8%A3%82%E8%BF%87%E7%A8%8B.png" alt="StoreFile的合并和分裂过程"></p>
<h3 id="HLog-的工作原理"><a href="#HLog-的工作原理" class="headerlink" title="HLog 的工作原理"></a>HLog 的工作原理</h3><p>在分布式环境下，必须要考虑到系统出错的情形，比如当 Region 服务器发生故障时，MemStore 缓存中的数据（还没有被写人文件）会全部丢失。因此，HBase 采用 HLog 来保证系统发生故障时能够恢复到正确的状态。</p>
<p>HBase 系统为每个 Region 服务器配置了一个 HLog 文件，它是一种预写式日志（Write Ahead Log），也就是说，用户更新数据必须首先被记人日志后才能写人 MemStore 缓存，并且直到 MemStore 缓存内容对应的日志已经被写入磁盘之后，该缓存内容才会被刷新写入磁盘。</p>
<p>Zookeeper 会实时监测每个 Region 服务器的状态，当某个 Region 服务器发生故障时，Zookeeper 会通知 Master。Master 首先会处理该故障 Region 服务器上面遗留的 HLog 文件，由于一个 Region 服务器上面可能会维护着多个 Region 对象，这些 Region 对象共用一个HLog文件，因此这个遗留的 HLog 文件中包含了来自多个 Region 对象的日志记录。系统会根据每条日志记录所属的 Region 对象对 HLog 数据进行拆分，分别放到相应 Region 对象的目录下，然后再将失效的 Region 重新分配到可用的 Region 服务器中，并把与该 Region 对象相关的 HLog 日志记录也发送给相应的 Region 服务器。Region 服务器领取到分配给自己的 Region 对象以及与之相关的 HLog 日志记录以后，会重新做一遍日志记录中的各种操作，把日志记录中的数据写人 MemStore 缓存，然后刷新到磁盘的 StoreFile 文件中，完成数据恢复。</p>
<p>需要特别指出的是，HBase 系统中，每个 Region 服务器只需要维护一个 HLog 文件，所有 Region 对象共用一个 HLog，而不是每个 Region 使用一个 HLog。在这种 Region 对象共用一个 HLog 的方式中，多个 Region 对象的更新操作所发生的日志修改，只需要不断把日志记录追加到单个日志文件中，而不需要同时打开、写入到多个日志文件中，因此可以减少磁盘寻址次数，提高对表的写操作性能。这种方式的缺点是，如果个 Region 服务器发生故障，为了恢复其上的 Region 对象，需要将 Region 服务器上的 HLog 按照其所属的 Region 对象进行拆分，然后分发到其他 Region 服务器上执行恢复操作。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wetts.github.io/2020/03/12/%E5%A4%A7%E6%95%B0%E6%8D%AE/Hadoop/HDFS/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Zhang Wetts">
      <meta itemprop="description" content="Stay Hungry, Stay Foolish. <br><br><p style="font-size:8px;">[build by hexo/next/gitalk/hexo-generator-search/LaTeX]</p>">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wetts's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/12/%E5%A4%A7%E6%95%B0%E6%8D%AE/Hadoop/HDFS/" class="post-title-link" itemprop="url">HDFS</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-03-12 14:21:34" itemprop="dateCreated datePublished" datetime="2020-03-12T14:21:34+08:00">2020-03-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-06-12 17:56:44" itemprop="dateModified" datetime="2020-06-12T17:56:44+08:00">2020-06-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Hadoop/" itemprop="url" rel="index"><span itemprop="name">Hadoop</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>HDFS（Hadoop Distributed File System，Hadoop 分布式文件系统）</p>
<h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><h3 id="块"><a href="#块" class="headerlink" title="块"></a>块</h3><p>在传统的文件系统中，为了提高磁盘读写效率，一般以数据块为单位，而不是以字节为单位。比如，机械式硬盘（磁盘的一种）包含了磁头和转动部件，在读取数据时有一个寻道的过程，通过转动盘片和移动磁头的位置，来找到数据在机械式硬盘中的存储位置，然后才能进行读写。在 I/O 开销中，机械式硬盘的寻址时间是最耗时的部分，一旦找到第条记录，剩下的顺序读取效率是非常高的。因此，以块为单位读写数据，可以把磁盘寻道时间分摊到大量数据中。</p>
<p>HDFS 也同样采用了块的概念，默认的一个块大小是 64 MB。</p>
<p>当客户端需要访问一个文件时，首先从名称节点获得组成这个文件的数据块的位置列表，然后根据位置列表获取实际存储各个数据块的数据节点的位置，最后数据节点根据数据块信息在本地 Linux 文件系统中找到对应的文件，并把数据返回给客户端。</p>
<h3 id="名称节点"><a href="#名称节点" class="headerlink" title="名称节点"></a>名称节点</h3><p>名称节点（NameNode）负责管理分布式文件系统的命名空间（Namespace），保存了两个核心的数据结构，即 FsImage 和 EditLog。</p>
<ul>
<li>FsImage：维护文件系统树以及文件树中所有的文件和文件夹的元数据。</li>
<li>EditLog：记录了所有针对文件的创建、删除、重命名等操作。</li>
</ul>
<p><img src="/2020/03/12/%E5%A4%A7%E6%95%B0%E6%8D%AE/Hadoop/HDFS/%E5%90%8D%E7%A7%B0%E8%8A%82%E7%82%B9%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png" alt="名称节点的数据结构"></p>
<p>名称节点记录了每个文件中各个块所在的数据节点的位置信息，但是并不持久化存储这些信息，而是在系统每次启动时扫描所有数据节点重构得到这些信息。</p>
<h3 id="数据节点"><a href="#数据节点" class="headerlink" title="数据节点"></a>数据节点</h3><p>数据节点（DataNode）是分布式文件系统HDFS的工作节点，负责数据的存储和读取，会根据客户端或者名称节点的调度来进行数据的存储和检索，并且向名称节点定期发送自己所存储的块的列表。每个数据节点中的数据会被保存在各自节点的本地Linux文件系统中。</p>
<h3 id="第二名称节点"><a href="#第二名称节点" class="headerlink" title="第二名称节点"></a>第二名称节点</h3><p>在名称节点运行期间，HDFS会不断发生更新操作，这些更新操作都是直接被写人到 EditLog 文件，因此 EditLog 文件也会逐渐变大。在名称节点运行期间，不断变大的 EditLog 文件通常对于系统性能不会产生显著影响，但是当名称节点重启时，需要将 FsImage 加载到内存中，然后逐条执行 EditLog 中的记录，使得 FsImage 保持最新。可想而知，如果 EditLog 很大，就会导致整个过程变得非常缓慢，使得名称节点在启动过程中长期处于“安全模式”，无法正常对外提供写操作，影响了用户的使用。</p>
<p>为了有效解决 EditLog 逐渐变大带来的问题，HDFS 在设计中采用了第二名称节点（Secondary NameNode）。第二名称节点是 HDFS 架构的一个重要组成部分，具有两个方面的功能：</p>
<ul>
<li>首先，可以完成 EditLog 与 Fslmage 的合并操作，减小 EditLog 文件大小，缩短名称节点重启时间；</li>
<li>其次，可以作为名称节点的“检查点”，保存名称节点中的元数据信息。</li>
</ul>
<p>具体如下：</p>
<ol>
<li>EditLog 与 Fslmage 的合并操作。每隔一段时间，第二名称节点会和名称节点通信，请求其停止使用 EditLog 文件（这里假设这个时刻为 t），暂时将新到达的写操作添加到一个新的文件 EditLog.new 中。然后，第二名称节点把名称节点中的 FsImage 文件和 EditLog 文件拉回到本地，再加载到内存中；对二者执行合并操作，即在内存中逐条执行 EditLog 中的操作，使得 FsImage 保持最新。合并结束后，第二名称节点会把合并后得到的最新的 FsImage 文件发送到名称节点。名称节点收到后，会用最新的 FsImage 文件去替换旧的 FsImage 文件，同时用 EditLog.new 文件去替换 EditLog 文件（这里假设这个时刻为 t2），从而减小了，EditLog 文件的大小。</li>
<li>作为名称节点的“检查点”。从上面的合并过程可以看出，第二名称节点会定期和名称节点通信，从名称节点获取 FsImage 文件和 EditLog 文件，执行合并操作得到新的 FsImage 文件。从这个角度来讲，第二名称节点相当于为名称节点设置了一个“检查点”，周期性地备份名称节点中的元数据信息，当名称节点发生故障时，就可以用第二名称节点中记录的元数据信息进行系统恢复。但是，在第二名称节点上合并操作得到的新的 FsImage 文件是合并操作发生时（即 t1 时刻）HDFS 记录的元数据信息，并没有包含 t1 时刻和 t2 时刻期间发生的更新操作，如果名称节点在 t1 时刻和 t2 时刻期间发生故障，系统就会丢失部分元数据信息，在 HDFS 的设计中，也并不支持把系统直接切换到第二名称节点，因此从这个角度来讲，第二名称节点只是起到了名称节点的“检查点”作用，并不能起到“热备份”作用。即使有了第二名称节点的存在，当名称节点发生故障时，系统还是有可能会丢失部分元数据信息的。</li>
</ol>
<p><img src="/2020/03/12/%E5%A4%A7%E6%95%B0%E6%8D%AE/Hadoop/HDFS/%E7%AC%AC%E4%BA%8C%E5%90%8D%E7%A7%B0%E8%8A%82%E7%82%B9%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="第二名称节点工作过程示意图"></p>
<h2 id="HDFS-体系结构"><a href="#HDFS-体系结构" class="headerlink" title="HDFS 体系结构"></a>HDFS 体系结构</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p><img src="/2020/03/12/%E5%A4%A7%E6%95%B0%E6%8D%AE/Hadoop/HDFS/HDFS%E7%9A%84%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.png" alt="HDFS的体系结构"></p>
<h3 id="HDFS-命名控件管理"><a href="#HDFS-命名控件管理" class="headerlink" title="HDFS 命名控件管理"></a>HDFS 命名控件管理</h3><p>HDFS 的命名空间包含目录、文件和块。命名空间管理是指命名空间支持对 HDFS 中的目录、文件和块做类似文件系统的创建、修改、删除等基本操作。在当前的 HDFS 体系结构中，在整个 HDFS 集群中只有一个命名空间，并且只有唯一一个名称节点，该节点负责对这个命名空间进行管理。</p>
<p>HDFS 使用的是传统的分级文件体系，因此用户可以像使用普通文件系统样，创建、删除目录和文件，在目录间转移文件、重命名文件等。但是，HDFS 还没有实现磁盘配额和文件访问权限等功能，也不支持文件的硬连接和软连接（快捷方式）。</p>
<h3 id="通信协议"><a href="#通信协议" class="headerlink" title="通信协议"></a>通信协议</h3><p>HDFS 是一个部署在集群上的分布式文件系统，因此很多数据需要通过网络进行传输。所有的 HDFS 通信协议都是构建在 TCP/IP 协议基础之上的。客户端通过一个可配置的端口向名称节点主动发起 TCP 连，并使用客户端协议与名称节点进行交互。名称节点和数据节点之间则使用数据节点协议进行交互。客户端与数据节点的交互是通过 RPC（Remote Procedure Call）来实现的。在设计上，名称节点不会主动发起 RPC，而是响应来自客户端和数据节点的 RPC 请求。</p>
<h3 id="HDFS-体系结构的局限性"><a href="#HDFS-体系结构的局限性" class="headerlink" title="HDFS 体系结构的局限性"></a>HDFS 体系结构的局限性</h3><p>HDFS只设置唯一一个名称节点，这样做虽然大大简化了系统设计，但也带来了一些明显的局限性，具体如下。</p>
<ol>
<li>命名空间的限制。名称节点是保存在内存中的，因此名称节点能够容纳对象（文件、块）的个数会受到内存空间大小的限制。</li>
<li>性能的瓶颈。整个分布式文件系统的吞吐量受限于单个名称节点的吞吐量。</li>
<li>隔离问题。由于集群中只有一个名称节点，只有一个命名空间，因此无法对不同应用程序进行隔离。</li>
<li>集群的可用性。一旦这个唯一的名称节点发生故障，会导致整个集群变得不可用。</li>
</ol>
<h2 id="HDFS-的存储原理"><a href="#HDFS-的存储原理" class="headerlink" title="HDFS 的存储原理"></a>HDFS 的存储原理</h2><h3 id="数据的冗余存储"><a href="#数据的冗余存储" class="headerlink" title="数据的冗余存储"></a>数据的冗余存储</h3><p>HDFS 采用了多副本方式对数据进行冗余存储，通常一个数据块的多个副本会被分布到不同的数据节点上。</p>
<p><img src="/2020/03/12/%E5%A4%A7%E6%95%B0%E6%8D%AE/Hadoop/HDFS/HDFS%E6%95%B0%E6%8D%AE%E5%9D%97%E5%A4%9A%E5%89%AF%E6%9C%AC%E5%AD%98%E5%82%A8.png" alt="HDFS数据块多副本存储"></p>
<p>多副本方式具有以下 3 个优点：</p>
<ol>
<li>加快数据传输速度。当多个客户端需要同时访问同个文件时，可以让各个客户端分别从不同的数据块副本中读取数据，这就大大加快了数据传输速度。</li>
<li>容易检查数据错误。HDFS 的数据节点之间通过网络传输数据，采用多个副本可以很容易判断数据传输是否出错。</li>
<li>保证数据的可靠性。即使某个数据节点出现故障失效，也不会造成数据丢失。</li>
</ol>
<h3 id="数据存取策略"><a href="#数据存取策略" class="headerlink" title="数据存取策略"></a>数据存取策略</h3><h4 id="数据存放"><a href="#数据存放" class="headerlink" title="数据存放"></a>数据存放</h4><p>HDFS 默认的冗余复制因子是 3，每一个文件块会被同时保存到 3 个地方，其中，有两份副本放在同一个机架的不同机器上面，第三个副本放在不同机架的机器上面，这样既可以保证机架发生异常时的数据恢复，也可以提高数据读写性能（同机架内带宽高）。一般而言，HDFS 副本的放置策略如下：</p>
<ol>
<li>如果是在集群内发起写操作请求，则把第一个副本放置在发起写操作请求的数据节点上，实现就近写入数据。如果是来自集群外部的写操作请求，则从集群内部挑选一台磁盘不太满、CPU 不太忙的数据节点，作为第一个副本的存放地。</li>
<li>第二个副本会被放置在与第一个副本不同的机架的数据节点上。</li>
<li>第三个副本会被放置在与第一个副本相同的机架的其他节点上。</li>
<li>如果还有更多的副本，则继续从集群中随机选择数据节点进行存放。</li>
</ol>
<h4 id="数据读取"><a href="#数据读取" class="headerlink" title="数据读取"></a>数据读取</h4><p>HDFS 提供了一个 API 可以确定一个数据节点所属的机架 ID，客户端也可以调用 API 获取自已所属的机架 ID。当客户端读取数据时，从名称节点获得数据块不同副本的存放位置列表，列表中包含了副本所在的数据节点，可以调用 API 来确定客户端和这些数据节点所属的机架 ID。当发现某个数据块副本对应的机架 ID 和客户端对应的机架 ID 相同时，就优先选择该副本读取数据，如果没有发现，就随机选择-个副本读取数据。</p>
<h4 id="数据复制"><a href="#数据复制" class="headerlink" title="数据复制"></a>数据复制</h4><p>HDFS 的数据复制采用了流水线复制的策略，大大提高了数据复制过程的效率。当客户端要往 HDFS 中写入一个文件时，这个文件会首先被写入本地，并被切分成若千个块，每个块的大小是由 HDFS 的设定值来决定的。每个块都向 HDFS 集群中的名称节点发起写请求，名称节点会根据系统中各个数据节点的使用情况，选择一个数据节点列表返回给客户端，然后客户端就把数据首先写入列表中的第一个数据节点，同时把列表传给第一个数据节点，当第一个数据节点接收到 4 KB 数据的时候，写入本地，并且向列表中的第二个数据节点发起连接请求，把自己已经接收到的 4 KB 数据和列表传给第二个数据节点，当第二个数据节点接收到 4 KB 数据的时候，写人本地，并且向列表中的第三个数据节点发起连接请求，依次类推，列表中的多个数据节点形成一条数据复制的流水线。最后，当文件写完的时候，数据复制也同时完成。</p>
<h3 id="数据错误与恢复"><a href="#数据错误与恢复" class="headerlink" title="数据错误与恢复"></a>数据错误与恢复</h3><h4 id="名称节点出错"><a href="#名称节点出错" class="headerlink" title="名称节点出错"></a>名称节点出错</h4><p>Hadoop 采用两种机制来确保名称节点的安全：</p>
<ul>
<li>第一，把名称节点上的元数据信息同步存储到其他文件系统（比如远程挂载的网络文件系统 NFS）中；</li>
<li>第二，运行一个第二名称节点，当名称节点宕机以后，可以把第二名称节点作为一种弥补措施，利用第二名称节点中的元数据信息进行系统恢复。</li>
</ul>
<h4 id="数据节点出错"><a href="#数据节点出错" class="headerlink" title="数据节点出错"></a>数据节点出错</h4><p>每个数据节点会定期向名称节点发送“心跳”信息，向名称节点报告自己的状态。当数据节点发生故障，或者网络发生断网时，名称节点就无法收到来自一些数据节点的“心跳”信息，这时这些数据节点就会被标记为“宕机”，节点上面的所有数据都会被标记为“不可读”，名称节点不会再给它们发送任何 IO 请求。</p>
<p>这时，有可能出现一种情形，即由于些数据节点的不可用，会导致一些数据块的副本数量小于冗余因子。名称节点会定期检查这种情况，一旦发现某个数据块的副本数量小于冗余因子，就会启动数据冗余复制，为它生成新的副本。HDFS 与其他分布式文件系统的最大区别就是可以调整冗余数据的位置。</p>
<h4 id="数据出错"><a href="#数据出错" class="headerlink" title="数据出错"></a>数据出错</h4><p>网络传输和磁盘错误等因素都会造成数据错误。客户端在读取到数据后，会采用 md5 和 sha1 对数据块进行校验，以确定读取到正确的数据。在文件被创建时，客户端就会对每一个文件块进行信息摘录，并把这些信息写人同一个路径的隐藏文件里面。当客户端读取文件的时候，会先读取该信息文件，然后利用该信息文件对每个读取的数据块进行校验，如果校验出错，客户端就会请求到另外一个数据节点读取该文件块，并且向名称节点报告这个文件块有错误，名称节点会定期检查并且重新复制这个块。</p>
<h2 id="HDFS-的数据读写过程"><a href="#HDFS-的数据读写过程" class="headerlink" title="HDFS 的数据读写过程"></a>HDFS 的数据读写过程</h2><h3 id="读数据的过程"><a href="#读数据的过程" class="headerlink" title="读数据的过程"></a>读数据的过程</h3><p><img src="/2020/03/12/%E5%A4%A7%E6%95%B0%E6%8D%AE/Hadoop/HDFS/HDFS%E8%AF%BB%E6%95%B0%E6%8D%AE%E7%9A%84%E8%BF%87%E7%A8%8B.png" alt="HDFS读数据的过程"></p>
<h3 id="写数据的过程"><a href="#写数据的过程" class="headerlink" title="写数据的过程"></a>写数据的过程</h3><p><img src="/2020/03/12/%E5%A4%A7%E6%95%B0%E6%8D%AE/Hadoop/HDFS/HDFS%E5%86%99%E6%95%B0%E6%8D%AE%E7%9A%84%E8%BF%87%E7%A8%8B.png" alt="HDFS写数据的过程"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wetts.github.io/2020/01/07/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%85%B6%E4%BB%96/%E6%95%B0%E6%8D%AE%E5%BA%93-%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Zhang Wetts">
      <meta itemprop="description" content="Stay Hungry, Stay Foolish. <br><br><p style="font-size:8px;">[build by hexo/next/gitalk/hexo-generator-search/LaTeX]</p>">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wetts's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/07/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%85%B6%E4%BB%96/%E6%95%B0%E6%8D%AE%E5%BA%93-%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5/" class="post-title-link" itemprop="url">数据库-索引优化策略.md</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-01-07 19:50:22" itemprop="dateCreated datePublished" datetime="2020-01-07T19:50:22+08:00">2020-01-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-07-12 00:47:40" itemprop="dateModified" datetime="2021-07-12T00:47:40+08:00">2021-07-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>转自：<a target="_blank" rel="noopener" href="https://blog.csdn.net/zzti_erlie/article/details/103665903">https://blog.csdn.net/zzti_erlie/article/details/103665903</a></p>
<h2 id="索引的种类"><a href="#索引的种类" class="headerlink" title="索引的种类"></a>索引的种类</h2><p>众所周知，索引类似于字典的目录，可以提高查询的效率。</p>
<p>索引从物理上可以分为：聚集索引，非聚集索引</p>
<p>从逻辑上可以分为：普通索引，唯一索引，主键索引，联合索引，全文索引</p>
<h2 id="索引优化策略"><a href="#索引优化策略" class="headerlink" title="索引优化策略"></a>索引优化策略</h2><h3 id="不要在索引列上进行运算或使用函数"><a href="#不要在索引列上进行运算或使用函数" class="headerlink" title="不要在索引列上进行运算或使用函数"></a>不要在索引列上进行运算或使用函数</h3><p>在列上进行运算或使用函数会使索引失效，从而进行全表扫描。如下面例子在 publish_time，id 列上分别加上索引，publish_time 为 datetime 类型，id 为 int 类型</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 全表扫描</span><br><span class="line">select * from article where year(publish_time) &lt; 2019</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 走索引</span><br><span class="line">select * from article where publish_time &lt; &#x27;2019-01-01&#x27;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 全表扫描</span><br><span class="line">select * from article where id  + 1 = 5</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 走索引</span><br><span class="line">select * from article where id = 4</span><br></pre></td></tr></table></figure>

<h3 id="小心隐式类型转换"><a href="#小心隐式类型转换" class="headerlink" title="小心隐式类型转换"></a>小心隐式类型转换</h3><p>假设 id 为 varchar 类型</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 全表扫描</span><br><span class="line">select * from article where id = 100</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 走索引</span><br><span class="line">select * from article where id = &#x27;100&#x27;</span><br></pre></td></tr></table></figure>

<p>为什么呢？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select * from article where id = 100</span><br><span class="line">-- 等价于</span><br><span class="line">select * from article where CAST(id AS signed int) = 100</span><br></pre></td></tr></table></figure>

<p>上一条规则说过，不要在索引列上使用函数，隐式类型转换在索引字段上做了函数操作，因此会全表扫描</p>
<p>那么如果 id 是 int，执行下面这个语句是否会导致全表扫描呢？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from article where id = &#x27;100&#x27;</span><br></pre></td></tr></table></figure>

<p>答案是会用到索引，我们来分析一下为什么会用到索引</p>
<p>我们先来做一个实验，看一下数据库中字符串和数字做比较的时候，是怎么转换的？</p>
<p>这里有个简单的方法执行select “10” &gt; 9即可</p>
<ul>
<li>如果结果是1，则是把字符串转成数字，然后进行比较</li>
<li>如果结果是0，则是把数字转成字符串（因为字符串比较是从高位到低位按照asciss码来逐位比较，“1”比“9”小，所以为0），然后进行比较<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select &quot;10&quot; &gt; 9;</span><br><span class="line">+----------+</span><br><span class="line">| &quot;10&quot; &gt; 9 |</span><br><span class="line">+----------+</span><br><span class="line">|        1 |</span><br><span class="line">+----------+</span><br></pre></td></tr></table></figure></li>
</ul>
<p>结果为 1 表明当字符串和数字进行比较的时候，是把字符串转成数字</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select &quot;a&quot; = 0;</span><br><span class="line">+---------+</span><br><span class="line">| &quot;a&quot; = 0 |</span><br><span class="line">+---------+</span><br><span class="line">|       1 |</span><br><span class="line">+---------+</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select &quot;123abc&quot; = 123;</span><br><span class="line">+----------------+</span><br><span class="line">| &quot;123abc&quot; = 123 |</span><br><span class="line">+----------------+</span><br><span class="line">|              1 |</span><br><span class="line">+----------------+</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select &quot;  123abc456&quot; = 123;</span><br><span class="line">+---------------------+</span><br><span class="line">| &quot;  123abc456&quot; = 123 |</span><br><span class="line">+---------------------+</span><br><span class="line">|                   1 |</span><br><span class="line">+---------------------+</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure>

<p><strong>从实验结果中可以看到，当字符串不含有数字时，会转成 0，否则转成字符串中第一段连续的数字</strong></p>
<p>我们接着来分析上面的例子，为什么一会会用到索引，一会不会用到</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-- id列上有索引，id为varchar，不会走索引</span><br><span class="line">-- id是字符串时，数据库中的id都要转成数字，转成的值不确定（例如id=&#x27;12ab&#x27;会被转成12，不可能从索引上找到12这个值的）</span><br><span class="line">-- 所以得全表扫描</span><br><span class="line">select * from article where id = 100</span><br><span class="line"></span><br><span class="line">-- id列上有索引，id为int，会走索引</span><br><span class="line">-- id是int时，&#x27;100&#x27;会被转成数字100，所以能走索引</span><br><span class="line">select * from article where id = &#x27;100&#x27;</span><br></pre></td></tr></table></figure>

<h3 id="前导模糊查询不会使用索引"><a href="#前导模糊查询不会使用索引" class="headerlink" title="前导模糊查询不会使用索引"></a>前导模糊查询不会使用索引</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 全表扫描</span><br><span class="line">select * from article where author like &#x27;%李&#x27;</span><br></pre></td></tr></table></figure>

<p>%李,%李%都会导致全表扫描，非前导模糊查询可以使用索引</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 走索引</span><br><span class="line">select * from article where author like &#x27;李%&#x27;</span><br></pre></td></tr></table></figure>

<h3 id="联合索引最左前缀原则"><a href="#联合索引最左前缀原则" class="headerlink" title="联合索引最左前缀原则"></a>联合索引最左前缀原则</h3><p>mysql 会一直向右匹配直到遇到范围查询（&gt;、&lt;、between、like）就停止匹配，比如 <code>a = 1 and b = 2 and c &gt; 3 and d = 4</code> 如果建立（a,b,c,d）顺序的索引，d 是用不到索引的，如果建立（a,b,d,c）的索引则都可以用到，a,b,d 的顺序可以任意调整</p>
<ol>
<li>将区分度最高的字段放在最左边</li>
</ol>
<p>当不需要考虑排序和分组时，将区分度最高的列放在前面通常是很好的。这时候索引的作用只是用于优化 WHERE 条件的查找</p>
<p>如果在 a b 列上建立联合索引，该如何建立，才能使查询效率最高</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select count(distinct a) / count(*), count(distinct b) / count(*), count(*) from table</span><br></pre></td></tr></table></figure>

<p>执行如下语句，假设 3 个输出依次为 0.0001,0.373,16049，可以看到 b 列的选择性最高，因此将其作为联合索引的第一列，即建立（b, a）的联合索引</p>
<ol start="2">
<li><p>查询时=可以乱序<br>如果建立了联合索引（a, b）。例如下面的2个写法是等价的，因为MySQL会将查询的顺序优化成和联合索引的顺序一致</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from table where a = &#x27;1&#x27; and b = &#x27;1&#x27;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from table where b = &#x27;1&#x27; and a = &#x27;1&#x27;</span><br></pre></td></tr></table></figure></li>
<li><p>优化查询，避免出现 filesort</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from table where a = ? and b = ? order by c</span><br></pre></td></tr></table></figure>
<p>最左前缀原则不仅用在查询中，还能用在排序中。MySQL 中，有两种方式生成有序结果集：</p>
</li>
<li><p>通过有序索引顺序扫描直接返回有序数据</p>
</li>
<li><p>Filesort排序，对返回的数据进行排序</p>
</li>
</ol>
<p>因为索引的结构是 B+树，索引中的数据是按照一定顺序进行排列的，所以在排序查询中如果能利用索引，就能避免额外的排序操作。EXPLAIN 分析查询时，Extra 显示为 Using index。</p>
<p>所有不是通过索引直接返回排序结果的操作都是 Filesort 排序，也就是说进行了额外的排序操作。EXPLAIN 分析查询时，Extra 显示为 Using filesort，当出现 Using filesort 时对性能损耗较大，所以要尽量避免 Using filesort</p>
<p>对于如下sql</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from table where a = ? and b = ? order by c</span><br></pre></td></tr></table></figure>
<p>可以建立联合索引（a, b, c）</p>
<p>如果索引中有范围查找，那么索引有序性无法利用，如</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from table where a &gt; 10 order by b</span><br></pre></td></tr></table></figure>
<p>索引（a，b）无法排序。</p>
<p>放几个例子</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">-- 使用了a列</span><br><span class="line">where a = 3</span><br><span class="line"></span><br><span class="line">-- 使用了a b列</span><br><span class="line">where a = 3 and b = 5</span><br><span class="line"></span><br><span class="line">-- 使用了a b c列</span><br><span class="line">where a = 3 and c = 4 and b = 5</span><br><span class="line"> </span><br><span class="line">-- 没有使用索引</span><br><span class="line">where b = 3</span><br><span class="line"></span><br><span class="line">-- 使用了a列 </span><br><span class="line">where a = 3 and c = 4</span><br><span class="line"></span><br><span class="line">-- 使用了a b列 </span><br><span class="line">where a = 3 and b &gt; 10 and c = 7</span><br><span class="line"> </span><br><span class="line">-- 使用了a b 列</span><br><span class="line">where a = 3 and b like &#x27;xx%&#x27; and c = 7</span><br></pre></td></tr></table></figure>

<h3 id="union，or，in-都能命中索引，建议使用in"><a href="#union，or，in-都能命中索引，建议使用in" class="headerlink" title="union，or，in 都能命中索引，建议使用in"></a>union，or，in 都能命中索引，建议使用in</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select * from article where id = 1</span><br><span class="line">union all</span><br><span class="line">select * from article where id = 2</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from article where id in (1 , 2)</span><br></pre></td></tr></table></figure>
<p>新版MySQL的or可以命中索引</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from article where id = 1 or id = 2</span><br></pre></td></tr></table></figure>
<p>效率从高到低为union，in，or。in 和 union 的效率差别可以忽略不计，建议使用 in</p>
<h3 id="负向条件索引不会使用索引，建议用-in"><a href="#负向条件索引不会使用索引，建议用-in" class="headerlink" title="负向条件索引不会使用索引，建议用 in"></a>负向条件索引不会使用索引，建议用 in</h3><p>负向条件有：!=、&lt;&gt;、not in、not exists、not like 等</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 全表扫描</span><br><span class="line">select * from article where id != 1 and id != 2</span><br></pre></td></tr></table></figure>
<p>知道 id 的所有取值范围，可以改为类似如下形式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 走索引</span><br><span class="line">select * from article where id in (0, 3, 4)</span><br></pre></td></tr></table></figure>

<h3 id="建立覆盖索引"><a href="#建立覆盖索引" class="headerlink" title="建立覆盖索引"></a>建立覆盖索引</h3><p>众所周知，表数据是放在一个聚集索引上的，而建立的索引为非聚集索引，非聚集索引的叶子节点存放索引键值，以及该索引键指向的主键。一般查找的过程是从非聚集索引上找到数据的主键，然后根据该主键到聚集索引上查找记录，这个过程称为回表，不清楚的看推荐阅读。</p>
<p>如有下面这个sql</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select uid, login_time from user where username = ? and passwd = ?</span><br></pre></td></tr></table></figure>
<p>可以建立（username, passwd, login_time）的联合索引，由于 login_time 的值可以直接从索引中拿到，不用再回表查询，提高了查询效率</p>
<h3 id="经常更改，区分度不高的列上不宜加索引"><a href="#经常更改，区分度不高的列上不宜加索引" class="headerlink" title="经常更改，区分度不高的列上不宜加索引"></a>经常更改，区分度不高的列上不宜加索引</h3><p>更新会变更 B+ 树，更新频繁的字段建立索引会大大降低数据库性能。</p>
<p>“性别”这种区分度不大的属性，建立索引是没有什么意义的，不能有效过滤数据，性能与全表扫描类似。</p>
<p>一般区分度在80%以上的时候就可以建立索引，区分度可以使用 <code>count(distinct(列名))/count(*)</code> 来计算</p>
<h3 id="明确知道只会返回一条记录，可以加limit-1"><a href="#明确知道只会返回一条记录，可以加limit-1" class="headerlink" title="明确知道只会返回一条记录，可以加limit 1"></a>明确知道只会返回一条记录，可以加limit 1</h3><p>当查询确定只有一条记录时，可以加 liimit 1，让 MySQL 停止游标移动，提高查询效率</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select uid from user where username = ? and passwd = ?</span><br></pre></td></tr></table></figure>
<p>可改为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select uid from user where username = ? and passwd = ? limit 1</span><br></pre></td></tr></table></figure>

<h3 id="对文本建立前缀索引"><a href="#对文本建立前缀索引" class="headerlink" title="对文本建立前缀索引"></a>对文本建立前缀索引</h3><p>用邮箱登录是一个常见的问题，如果对email整个字段建立索引，会让索引变得大且慢</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select username from user where email=&#x27;xxx&#x27;;</span><br></pre></td></tr></table></figure>

<p>这时我们可以索引开始的部分字符，这样可以大大节约索引空间，从而提高索引效率，但这样也会降低索引的区分度。索引的区分度是指，不重复的索引值和数据表的记录总数的比值。索引的区分度越高则查询效率越高，因为区分度高的索引可以让MySQL在查找时过滤掉更多的行。</p>
<p>因此我们选择足够长的前缀保证较高的区分度，同时又不能太长（以便节约空间）</p>
<p>可以进行如下实验</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select count(distinct left(email, 5)) / count(*) as col5,</span><br><span class="line">count(distinct left(email, 6)) / count(*) as col6,</span><br><span class="line">count(distinct left(email, 7)) / count(*) as col7</span><br><span class="line">from user</span><br></pre></td></tr></table></figure>

<p>假设输出依次为0.0305，0.0309，0.0310<br>查询显示当前缀长度达到7的时候，再增加前缀长度，区分度提升的幅度已经很小了，因此创建email(7)的前缀索引即可</p>
<p><strong>需要注意的一点是，前缀索引不能使用覆盖索引</strong></p>
<h3 id="建立索引的列不为NULL"><a href="#建立索引的列不为NULL" class="headerlink" title="建立索引的列不为NULL"></a>建立索引的列不为NULL</h3><p>只要列中包含有 NULL 值都将不会被包含在索引中，复合索引中只要有一列含有 NULL值，那么这一列对于此复合索引就是无效的。</p>
<p>因此，在数据库设计时，除非有一个很特别的原因使用 NULL 值，不然尽量不要让字段的默认值为 NULL。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wetts.github.io/2019/12/21/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/MySQL-MVCC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Zhang Wetts">
      <meta itemprop="description" content="Stay Hungry, Stay Foolish. <br><br><p style="font-size:8px;">[build by hexo/next/gitalk/hexo-generator-search/LaTeX]</p>">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wetts's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/12/21/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/MySQL-MVCC/" class="post-title-link" itemprop="url">MySQL-MVCC.md</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-12-21 12:11:49" itemprop="dateCreated datePublished" datetime="2019-12-21T12:11:49+08:00">2019-12-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-07-15 12:45:44" itemprop="dateModified" datetime="2021-07-15T12:45:44+08:00">2021-07-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MySQL/" itemprop="url" rel="index"><span itemprop="name">MySQL</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>转自：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/8845ddca3b23">https://www.jianshu.com/p/8845ddca3b23</a></p>
<h2 id="前提概要"><a href="#前提概要" class="headerlink" title="前提概要"></a>前提概要</h2><h3 id="什么是MVCC"><a href="#什么是MVCC" class="headerlink" title="什么是MVCC?"></a>什么是MVCC?</h3><blockquote>
<p>MVCC，全称Multi-Version Concurrency Control，即多版本并发控制。MVCC是一种并发控制的方法，一般在数据库管理系统中，实现对数据库的并发访问，在编程语言中实现事务内存。</p>
</blockquote>
<p>MVCC在MySQL InnoDB中的实现主要是为了提高数据库并发性能，用更好的方式去处理读-写冲突，做到即使有读写冲突时，也能做到不加锁，非阻塞并发读</p>
<h3 id="什么是当前读和快照读？"><a href="#什么是当前读和快照读？" class="headerlink" title="什么是当前读和快照读？"></a>什么是当前读和快照读？</h3><p>在学习MVCC多版本并发控制之前，我们必须先了解一下，什么是MySQL InnoDB下的当前读和快照读?</p>
<h4 id="当前读"><a href="#当前读" class="headerlink" title="当前读"></a>当前读</h4><p>像select lock in share mode(共享锁), select for update ; update, insert ,delete(排他锁)这些操作都是一种当前读，为什么叫当前读？就是它读取的是记录的最新版本，读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁。</p>
<h4 id="快照读"><a href="#快照读" class="headerlink" title="快照读"></a>快照读</h4><p>像不加锁的select操作就是快照读，即不加锁的非阻塞读；快照读的前提是隔离级别不是串行级别，串行级别下的快照读会退化成当前读；之所以出现快照读的情况，是基于提高并发性能的考虑，快照读的实现是基于多版本并发控制，即MVCC,可以认为MVCC是行锁的一个变种，但它在很多情况下，避免了加锁操作，降低了开销；既然是基于多版本，即快照读可能读到的并不一定是数据的最新版本，而有可能是之前的历史版本</p>
<p>说白了MVCC就是为了实现读-写冲突不加锁，而这个读指的就是快照读, 而非当前读，当前读实际上是一种加锁的操作，是悲观锁的实现</p>
<h4 id="当前读，快照读和MVCC的关系"><a href="#当前读，快照读和MVCC的关系" class="headerlink" title="当前读，快照读和MVCC的关系"></a>当前读，快照读和MVCC的关系</h4><ul>
<li>准确的说，MVCC多版本并发控制指的是 “维持一个数据的多个版本，使得读写操作没有冲突” 这么一个概念。仅仅是一个理想概念</li>
<li>而在MySQL中，实现这么一个MVCC理想概念，我们就需要MySQL提供具体的功能去实现它，而快照读就是MySQL为我们实现MVCC理想模型的其中一个具体非阻塞读功能。而相对而言，当前读就是悲观锁的具体功能实现</li>
<li>要说的再细致一些，快照读本身也是一个抽象概念，再深入研究。MVCC模型在MySQL中的具体实现则是由 3个隐式字段，undo日志 ，Read View 等去完成的，具体可以看下面的MVCC实现原理</li>
</ul>
<h4 id="MVCC能解决什么问题，好处是？"><a href="#MVCC能解决什么问题，好处是？" class="headerlink" title="MVCC能解决什么问题，好处是？"></a>MVCC能解决什么问题，好处是？</h4><h5 id="数据库并发场景有三种，分别为："><a href="#数据库并发场景有三种，分别为：" class="headerlink" title="数据库并发场景有三种，分别为："></a>数据库并发场景有三种，分别为：</h5><ul>
<li>读-读：不存在任何问题，也不需要并发控制</li>
<li>读-写：有线程安全问题，可能会造成事务隔离性问题，可能遇到脏读，幻读，不可重复读</li>
<li>写-写：有线程安全问题，可能会存在更新丢失问题，比如第一类更新丢失，第二类更新丢失</li>
</ul>
<h5 id="MVCC带来的好处是？"><a href="#MVCC带来的好处是？" class="headerlink" title="MVCC带来的好处是？"></a>MVCC带来的好处是？</h5><p>多版本并发控制（MVCC）是一种用来解决读-写冲突的无锁并发控制，也就是为事务分配单向增长的时间戳，为每个修改保存一个版本，版本与事务时间戳关联，读操作只读该事务开始前的数据库的快照。 所以MVCC可以为数据库解决以下问题</p>
<ul>
<li>在并发读写数据库时，可以做到在读操作时不用阻塞写操作，写操作也不用阻塞读操作，提高了数据库并发读写的性能</li>
<li>同时还可以解决脏读，幻读，不可重复读等事务隔离问题，但不能解决更新丢失问题</li>
</ul>
<h5 id="小结一下咯"><a href="#小结一下咯" class="headerlink" title="小结一下咯"></a>小结一下咯</h5><p>总之，MVCC就是因为大牛们，不满意只让数据库采用悲观锁这样性能不佳的形式去解决读-写冲突问题，而提出的解决方案，所以在数据库中，因为有了MVCC，所以我们可以形成两个组合：</p>
<ul>
<li>MVCC + 悲观锁<ul>
<li>MVCC解决读写冲突，悲观锁解决写写冲突</li>
</ul>
</li>
<li>MVCC + 乐观锁<ul>
<li>MVCC解决读写冲突，乐观锁解决写写冲突</li>
</ul>
</li>
</ul>
<p>这种组合的方式就可以最大程度的提高数据库并发性能，并解决读写冲突，和写写冲突导致的问题</p>
<h2 id="MVCC的实现原理"><a href="#MVCC的实现原理" class="headerlink" title="MVCC的实现原理"></a>MVCC的实现原理</h2><p>MVCC的目的就是多版本并发控制，在数据库中的实现，就是为了解决读写冲突，它的实现原理主要是依赖记录中的 3个隐式字段，undo日志 ，Read View 来实现的。所以我们先来看看这个三个point的概念</p>
<h3 id="隐式字段"><a href="#隐式字段" class="headerlink" title="隐式字段"></a>隐式字段</h3><p>每行记录除了我们自定义的字段外，还有数据库隐式定义的DB_TRX_ID,DB_ROLL_PTR,DB_ROW_ID等字段</p>
<ul>
<li>DB_TRX_ID<ul>
<li>6byte，最近修改(修改/插入)事务ID：记录创建这条记录/最后一次修改该记录的事务ID</li>
</ul>
</li>
<li>DB_ROLL_PTR<ul>
<li>7byte，回滚指针，指向这条记录的上一个版本（存储于rollback segment里）</li>
</ul>
</li>
<li>DB_ROW_ID<ul>
<li>6byte，隐含的自增ID（隐藏主键），如果数据表没有主键，InnoDB会自动以DB_ROW_ID产生一个聚簇索引</li>
</ul>
</li>
<li>实际还有一个删除flag隐藏字段, 既记录被更新或删除并不代表真的删除，而是删除flag变了</li>
</ul>
<p><img src="/2019/12/21/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/MySQL-MVCC/1.png" alt="1"></p>
<p>如上图，DB_ROW_ID是数据库默认为该行记录生成的唯一隐式主键，DB_TRX_ID是当前操作该记录的事务ID,而DB_ROLL_PTR是一个回滚指针，用于配合undo日志，指向上一个旧版本</p>
<h3 id="undo日志"><a href="#undo日志" class="headerlink" title="undo日志"></a>undo日志</h3><p>undo log主要分为两种：</p>
<ul>
<li>insert undo log<ul>
<li>代表事务在insert新记录时产生的undo log, 只在事务回滚时需要，并且在事务提交后可以被立即丢弃</li>
</ul>
</li>
<li>update undo log<ul>
<li>事务在进行update或delete时产生的undo log; 不仅在事务回滚时需要，在快照读时也需要；所以不能随便删除，只有在快速读或事务回滚不涉及该日志时，对应的日志才会被purge线程统一清除</li>
</ul>
</li>
</ul>
<blockquote>
<p>purge</p>
<ul>
<li>从前面的分析可以看出，为了实现InnoDB的MVCC机制，更新或者删除操作都只是设置一下老记录的deleted_bit，并不真正将过时的记录删除。</li>
<li>为了节省磁盘空间，InnoDB有专门的purge线程来清理deleted_bit为true的记录。为了不影响MVCC的正常工作，purge线程自己也维护了一个read view（这个read view相当于系统中最老活跃事务的read view）;如果某个记录的deleted_bit为true，并且DB_TRX_ID相对于purge线程的read view可见，那么这条记录一定是可以被安全清除的。</li>
</ul>
</blockquote>
<p>对MVCC有帮助的实质是update undo log ，undo log实际上就是存在rollback segment中旧记录链，它的执行流程如下：</p>
<p>一、 比如一个有个事务插入persion表插入了一条新记录，记录如下，name为Jerry, age为24岁，隐式主键是1，事务ID和回滚指针，我们假设为NULL<br><img src="/2019/12/21/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/MySQL-MVCC/2.png" alt="2"></p>
<p>二、 现在来了一个事务1对该记录的name做出了修改，改为Tom</p>
<ul>
<li>在事务1修改该行(记录)数据时，数据库会先对该行加排他锁</li>
<li>然后把该行数据拷贝到undo log中，作为旧记录，既在undo log中有当前行的拷贝副本</li>
<li>拷贝完毕后，修改该行name为Tom，并且修改隐藏字段的事务ID为当前事务1的ID, 我们默认从1开始，之后递增，回滚指针指向拷贝到undo log的副本记录，既表示我的上一个版本就是它</li>
<li>事务提交后，释放锁</li>
</ul>
<p><img src="/2019/12/21/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/MySQL-MVCC/3.png" alt="3"></p>
<p>三、 又来了个事务2修改person表的同一个记录，将age修改为30岁</p>
<ul>
<li>在事务2修改该行数据时，数据库也先为该行加锁</li>
<li>然后把该行数据拷贝到undo log中，作为旧记录，发现该行记录已经有undo log了，那么最新的旧数据作为链表的表头，插在该行记录的undo log最前面</li>
<li>修改该行age为30岁，并且修改隐藏字段的事务ID为当前事务2的ID, 那就是2，回滚指针指向刚刚拷贝到undo log的副本记录</li>
<li>事务提交，释放锁</li>
</ul>
<p><img src="/2019/12/21/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/MySQL-MVCC/4.png" alt="4"></p>
<p>从上面，我们就可以看出，不同事务或者相同事务的对同一记录的修改，会导致该记录的undo log成为一条记录版本线性表，既链表，undo log的链首就是最新的旧记录，链尾就是最早的旧记录（当然就像之前说的该undo log的节点可能是会purge线程清除掉，向图中的第一条insert undo log，其实在事务提交之后可能就被删除丢失了，不过这里为了演示，所以还放在这里）</p>
<h3 id="Read-View-读视图"><a href="#Read-View-读视图" class="headerlink" title="Read View(读视图)"></a>Read View(读视图)</h3><h4 id="什么是Read-View"><a href="#什么是Read-View" class="headerlink" title="什么是Read View?"></a>什么是Read View?</h4><p>什么是Read View，说白了Read View就是事务进行快照读操作的时候生产的读视图(Read View)，在该事务执行的快照读的那一刻，会生成数据库系统当前的一个快照，记录并维护系统当前活跃事务的ID(当每个事务开启时，都会被分配一个ID, 这个ID是递增的，所以最新的事务，ID值越大)</p>
<p>所以我们知道 Read View主要是用来做可见性判断的, 即当我们某个事务执行快照读的时候，对该记录创建一个Read View读视图，把它比作条件用来判断当前事务能够看到哪个版本的数据，既可能是当前最新的数据，也有可能是该行记录的undo log里面的某个版本的数据。</p>
<p>Read View遵循一个可见性算法，主要是将要被修改的数据的最新记录中的DB_TRX_ID（即当前事务ID）取出来，与系统当前其他活跃事务的ID去对比（由Read View维护），如果DB_TRX_ID跟Read View的属性做了某些比较，不符合可见性，那就通过DB_ROLL_PTR回滚指针去取出Undo Log中的DB_TRX_ID再比较，即遍历链表的DB_TRX_ID（从链首到链尾，即从最近的一次修改查起），直到找到满足特定条件的DB_TRX_ID, 那么这个DB_TRX_ID所在的旧记录就是当前事务能看见的最新老版本</p>
<p>那么这个判断条件是什么呢？</p>
<p><img src="/2019/12/21/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/MySQL-MVCC/5.png" alt="5"></p>
<p>如上，它是一段MySQL判断可见性的一段源码，即changes_visible方法（不完全哈，但能看出大致逻辑），该方法展示了我们拿DB_TRX_ID去跟Read View某些属性进行怎么样的比较</p>
<p>在展示之前，我先简化一下Read View，我们可以把Read View简单的理解成有三个全局属性</p>
<ul>
<li>trx_list（名字我随便取的）<ul>
<li>一个数值列表，用来维护Read View生成时刻系统正活跃的事务ID</li>
</ul>
</li>
<li>up_limit_id<ul>
<li>记录trx_list列表中事务ID最小的ID</li>
</ul>
</li>
<li>low_limit_id<ul>
<li>ReadView生成时刻系统尚未分配的下一个事务ID，也就是目前已出现过的事务ID的最大值+1</li>
</ul>
</li>
</ul>
<ol>
<li>首先比较DB_TRX_ID &lt; up_limit_id, 如果小于，则当前事务能看到DB_TRX_ID 所在的记录，如果大于等于进入下一个判断</li>
<li>接下来判断 DB_TRX_ID 大于等于 low_limit_id , 如果大于等于则代表DB_TRX_ID 所在的记录在Read View生成后才出现的，那对当前事务肯定不可见，如果小于则进入下一个判断</li>
<li>判断DB_TRX_ID 是否在活跃事务之中，trx_list.contains(DB_TRX_ID)，如果在，则代表我Read View生成时刻，你这个事务还在活跃，还没有Commit，你修改的数据，我当前事务也是看不见的；如果不在，则说明，你这个事务在Read View生成之前就已经Commit了，你修改的结果，我当前事务是能看见的</li>
</ol>
<h3 id="整体流程"><a href="#整体流程" class="headerlink" title="整体流程"></a>整体流程</h3><p>我们在了解了隐式字段，undo log， 以及Read View的概念之后，就可以来看看MVCC实现的整体流程是怎么样了</p>
<p>整体的流程是怎么样的呢？我们可以模拟一下</p>
<ul>
<li>当事务2对某行数据执行了快照读，数据库为该行数据生成一个Read View读视图，假设当前事务ID为2，此时还有事务1和事务3在活跃中，事务4在事务2快照读前一刻提交更新了，所以Read View记录了系统当前活跃事务1，3的ID，维护在一个列表上，假设我们称为trx_list</li>
</ul>
<p><img src="/2019/12/21/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/MySQL-MVCC/6.png" alt="6"></p>
<ul>
<li>Read View不仅仅会通过一个列表trx_list来维护事务2执行快照读那刻系统正活跃的事务ID，还会有两个属性up_limit_id（记录trx_list列表中事务ID最小的ID），low_limit_id(记录trx_list列表中事务ID最大的ID，也有人说快照读那刻系统尚未分配的下一个事务ID也就是目前已出现过的事务ID的最大值+1，我更倾向于后者；所以在这里例子中up_limit_id就是1，low_limit_id就是4 + 1 = 5，trx_list集合的值是1,3，Read View如下图</li>
</ul>
<p><img src="/2019/12/21/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/MySQL-MVCC/7.png" alt="7"></p>
<ul>
<li>我们的例子中，只有事务4修改过该行记录，并在事务2执行快照读前，就提交了事务，所以当前该行当前数据的undo log如下图所示；我们的事务2在快照读该行记录的时候，就会拿该行记录的DB_TRX_ID去跟up_limit_id,low_limit_id和活跃事务ID列表(trx_list)进行比较，判断当前事务2能看到该记录的版本是哪个。</li>
</ul>
<p><img src="/2019/12/21/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/MySQL-MVCC/8.png" alt="8"></p>
<ul>
<li>所以先拿该记录DB_TRX_ID字段记录的事务ID 4去跟Read View的的up_limit_id比较，看4是否小于up_limit_id(1)，所以不符合条件，继续判断 4 是否大于等于 low_limit_id(5)，也不符合条件，最后判断4是否处于trx_list中的活跃事务, 最后发现事务ID为4的事务不在当前活跃事务列表中, 符合可见性条件，所以事务4修改后提交的最新结果对事务2快照读时是可见的，所以事务2能读到的最新数据记录是事务4所提交的版本，而事务4提交的版本也是全局角度上最新的版本</li>
</ul>
<p><img src="/2019/12/21/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/MySQL-MVCC/9.png" alt="9"></p>
<p>也正是Read View生成时机的不同，从而造成RC,RR级别下快照读的结果的不同</p>
<h2 id="MVCC相关问题"><a href="#MVCC相关问题" class="headerlink" title="MVCC相关问题"></a>MVCC相关问题</h2><h3 id="RR是如何在RC级的基础上解决不可重复读的？"><a href="#RR是如何在RC级的基础上解决不可重复读的？" class="headerlink" title="RR是如何在RC级的基础上解决不可重复读的？"></a>RR是如何在RC级的基础上解决不可重复读的？</h3><p>当前读和快照读在RR级别下的区别：</p>
<p>表1:<br><img src="/2019/12/21/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/MySQL-MVCC/10.png" alt="10"></p>
<p>表2:<br><img src="/2019/12/21/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/MySQL-MVCC/11.png" alt="11"></p>
<p>而在表2这里的顺序中，事务B在事务A提交后的快照读和当前读都是实时的新数据400，这是为什么呢？</p>
<ul>
<li>这里与上表的唯一区别仅仅是表1的事务B在事务A修改金额前快照读过一次金额数据，而表2的事务B在事务A修改金额前没有进行过快照读。</li>
</ul>
<p>所以我们知道事务中快照读的结果是非常依赖该事务首次出现快照读的地方，即某个事务中首次出现快照读的地方非常关键，它有决定该事务后续快照读结果的能力</p>
<p>我们这里测试的是更新，同时删除和更新也是一样的，如果事务B的快照读是在事务A操作之后进行的，事务B的快照读也是能读取到最新的数据的</p>
<h3 id="RC-RR级别下的InnoDB快照读有什么不同？"><a href="#RC-RR级别下的InnoDB快照读有什么不同？" class="headerlink" title="RC,RR级别下的InnoDB快照读有什么不同？"></a>RC,RR级别下的InnoDB快照读有什么不同？</h3><p>正是Read View生成时机的不同，从而造成RC,RR级别下快照读的结果的不同</p>
<ul>
<li>在RR级别下的某个事务的对某条记录的第一次快照读会创建一个快照及Read View, 将当前系统活跃的其他事务记录起来，此后在调用快照读的时候，还是使用的是同一个Read View，所以只要当前事务在其他事务提交更新之前使用过快照读，那么之后的快照读使用的都是同一个Read View，所以对之后的修改不可见；</li>
<li>即RR级别下，快照读生成Read View时，Read View会记录此时所有其他活动事务的快照，这些事务的修改对于当前事务都是不可见的。而早于Read View创建的事务所做的修改均是可见</li>
<li>而在RC级别下的，事务中，每次快照读都会新生成一个快照和Read View, 这就是我们在RC级别下的事务中可以看到别的事务提交的更新的原因</li>
</ul>
<p>总之在RC隔离级别下，是每个快照读都会生成并获取最新的Read View；而在RR隔离级别下，则是同一个事务中的第一个快照读才会创建Read View, 之后的快照读获取的都是同一个Read View。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wetts.github.io/2019/12/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%81%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%A0%91%E3%80%81B%E6%A0%91%E3%80%81B+%E6%A0%91%E3%80%81B*%E6%A0%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Zhang Wetts">
      <meta itemprop="description" content="Stay Hungry, Stay Foolish. <br><br><p style="font-size:8px;">[build by hexo/next/gitalk/hexo-generator-search/LaTeX]</p>">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wetts's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/12/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%81%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%A0%91%E3%80%81B%E6%A0%91%E3%80%81B+%E6%A0%91%E3%80%81B*%E6%A0%91/" class="post-title-link" itemprop="url">二叉树、B树、B+树、B*树.md</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-12-13 02:05:01" itemprop="dateCreated datePublished" datetime="2019-12-13T02:05:01+08:00">2019-12-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-07-16 13:19:38" itemprop="dateModified" datetime="2021-07-16T13:19:38+08:00">2021-07-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" itemprop="url" rel="index"><span itemprop="name">数据结构</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>转自：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/27700617">https://zhuanlan.zhihu.com/p/27700617</a></p>
<h2 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>平衡二叉树是基于二分法的策略提高数据的查找速度的二叉树的数据结构；</p>
<h3 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h3><p>平衡二叉树是采用二分法思维把数据按规则组装成一个树形结构的数据，用这个树形结构的数据减少无关数据的检索，大大的提升了数据检索的速度；平衡二叉树的数据结构组装过程有以下规则：</p>
<ol>
<li>非叶子节点只能允许最多两个子节点存在。</li>
<li>每一个非叶子节点数据分布规则为左边的子节点小当前节点的值，右边的子节点大于当前节点的值(这里值是基于自己的算法规则而定的，比如hash值)；</li>
</ol>
<p><img src="/2019/12/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%81%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%A0%91%E3%80%81B%E6%A0%91%E3%80%81B+%E6%A0%91%E3%80%81B*%E6%A0%91/1.jpg" alt="1"></p>
<p>平衡树的层级结构：因为平衡二叉树查询性能和树的层级（h高度）成反比，h值越小查询越快、为了保证树的结构左右两端数据大致平衡降低二叉树的查询难度一般会采用一种算法机制实现节点数据结构的平衡，实现了这种算法的有比如Treap、红黑树，使用平衡二叉树能保证数据的左右两边的节点层级相差不会大于1.，通过这样避免树形结构由于删除增加变成线性链表影响查询效率，保证数据平衡的情况下查找数据的速度近于二分法查找；</p>
<p><img src="/2019/12/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%81%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%A0%91%E3%80%81B%E6%A0%91%E3%80%81B+%E6%A0%91%E3%80%81B*%E6%A0%91/2.jpg" alt="2"></p>
<p>总结平衡二叉树特点：</p>
<ol>
<li>非叶子节点最多拥有两个子节点；</li>
<li>非叶子节值大于左边子节点、小于右边子节点；</li>
<li>树的左右两边的层级数相差不会大于1;</li>
<li>没有值相等重复的节点;</li>
</ol>
<h2 id="B树-B-tree"><a href="#B树-B-tree" class="headerlink" title="B树(B-tree)"></a>B树(B-tree)</h2><p>注意:之前有看到有很多文章把B树和B-tree理解成了两种不同类别的树，其实这两个是同一种树;</p>
<h3 id="概念："><a href="#概念：" class="headerlink" title="概念："></a>概念：</h3><p>B树和平衡二叉树稍有不同的是B树属于多叉树又名平衡多路查找树（查找路径不只两个），数据库索引技术里大量使用者B树和B+树的数据结构，让我们来看看他有什么特点;</p>
<h3 id="规则："><a href="#规则：" class="headerlink" title="规则："></a>规则：</h3><ol>
<li>排序方式：所有节点关键字是按递增次序排列，并遵循左小右大原则；</li>
<li>子节点数：非叶节点的子节点数&gt;1，且&lt;=M ，且M&gt;=2，空树除外（注：M阶代表一个树节点最多有多少个查找路径，M=M路,当M=2则是2叉树,M=3则是3叉）；</li>
<li>关键字数：枝节点的关键字数量大于等于ceil(m/2)-1个且小于等于M-1个（注：ceil()是个朝正无穷方向取整的函数 如ceil(1.1)结果为2);</li>
<li>所有叶子节点均在同一层、叶子节点除了包含了关键字和关键字记录的指针外也有指向其子节点的指针只不过其指针地址都为null对应下图最后一层节点的空格子;</li>
</ol>
<p>最后我们用一个图和一个实际的例子来理解B树（这里为了理解方便我就直接用实际字母的大小来排列C&gt;B&gt;A）<br><img src="/2019/12/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%81%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%A0%91%E3%80%81B%E6%A0%91%E3%80%81B+%E6%A0%91%E3%80%81B*%E6%A0%91/3.jpg" alt="3"></p>
<h3 id="B树的查询流程："><a href="#B树的查询流程：" class="headerlink" title="B树的查询流程："></a>B树的查询流程：</h3><p>如上图我要从上图中找到E字母，查找流程如下</p>
<ol>
<li>获取根节点的关键字进行比较，当前根节点关键字为M，E&lt;M（26个字母顺序），所以往找到指向左边的子节点（二分法规则，左小右大，左边放小于当前节点值的子节点、右边放大于当前节点值的子节点）；</li>
<li>拿到关键字D和G，D&lt;E&lt;G 所以直接找到D和G中间的节点；</li>
<li>拿到E和F，因为E=E 所以直接返回关键字和指针信息（如果树结构里面没有包含所要查找的节点则返回null）；</li>
</ol>
<h3 id="B树的插入节点流程"><a href="#B树的插入节点流程" class="headerlink" title="B树的插入节点流程"></a>B树的插入节点流程</h3><p>定义一个5阶树（平衡5路查找树;），现在我们要把3、8、31、11、23、29、50、28 这些数字构建出一个5阶树出来;</p>
<p>遵循规则：</p>
<ol>
<li>节点拆分规则：当前是要组成一个5路查找树，那么此时m=5,关键字数必须&lt;=5-1（这里关键字数&gt;4就要进行节点拆分）；</li>
<li>排序规则：满足节点本身比左边节点大，比右边节点小的排序规则;</li>
</ol>
<p>先插入 3、8、31、11<br><img src="/2019/12/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%81%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%A0%91%E3%80%81B%E6%A0%91%E3%80%81B+%E6%A0%91%E3%80%81B*%E6%A0%91/4.jpg" alt="4"></p>
<p>再插入23、29<br><img src="/2019/12/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%81%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%A0%91%E3%80%81B%E6%A0%91%E3%80%81B+%E6%A0%91%E3%80%81B*%E6%A0%91/5.png" alt="5"></p>
<p>再插入50、28<br><img src="/2019/12/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%81%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%A0%91%E3%80%81B%E6%A0%91%E3%80%81B+%E6%A0%91%E3%80%81B*%E6%A0%91/6.png" alt="6"></p>
<h3 id="B树节点的删除"><a href="#B树节点的删除" class="headerlink" title="B树节点的删除"></a>B树节点的删除</h3><p>规则：</p>
<ol>
<li>节点合并规则：当前是要组成一个5路查找树，那么此时m=5,关键字数必须大于等于ceil（5/2）（这里关键字数&lt;2就要进行节点合并）；</li>
<li>满足节点本身比左边节点大，比右边节点小的排序规则;</li>
<li>关键字数小于二时先从子节点取，子节点没有符合条件时就向向父节点取，取中间值往父节点放；<br><img src="/2019/12/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%81%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%A0%91%E3%80%81B%E6%A0%91%E3%80%81B+%E6%A0%91%E3%80%81B*%E6%A0%91/7.png" alt="7"></li>
</ol>
<h3 id="特点：-1"><a href="#特点：-1" class="headerlink" title="特点："></a>特点：</h3><p>B树相对于平衡二叉树的不同是，每个节点包含的关键字增多了，特别是在B树应用到数据库中的时候，数据库充分利用了磁盘块的原理（磁盘数据存储是采用块的形式存储的，每个块的大小为4K，每次IO进行数据读取时，同一个磁盘块的数据可以一次性读取出来）把节点大小限制和充分使用在磁盘快大小范围；把树的节点关键字增多后树的层级比原来的二叉树少了，减少数据查找的次数和复杂度;</p>
<h2 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p>B+树是B树的一个升级版，相对于B树来说B+树更充分的利用了节点的空间，让查询速度更加稳定，其速度完全接近于二分法查找。为什么说B+树查找的效率要比B树更高、更稳定；我们先看看两者的区别</p>
<h3 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h3><ol>
<li>B+跟B树不同B+树的非叶子节点不保存关键字记录的指针，只进行数据索引，这样使得B+树每个非叶子节点所能保存的关键字大大增加；</li>
<li>B+树叶子节点保存了父节点的所有关键字记录的指针，所有数据地址必须要到叶子节点才能获取到。所以每次数据查询的次数都一样；</li>
<li>B+树叶子节点的关键字从小到大有序排列，左边结尾数据都会保存右边节点开始数据的指针。</li>
<li>非叶子节点的子节点数=关键字数（来源百度百科）（根据各种资料 这里有两种算法的实现方式，另一种为非叶节点的关键字数=子节点数-1（来源维基百科)，虽然他们数据排列结构不一样，但其原理还是一样的Mysql 的B+树是用第一种方式实现）;</li>
</ol>
<p><img src="/2019/12/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%81%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%A0%91%E3%80%81B%E6%A0%91%E3%80%81B+%E6%A0%91%E3%80%81B*%E6%A0%91/8.jpg" alt="8"><br>（百度百科算法结构示意图）</p>
<p><img src="/2019/12/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%81%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%A0%91%E3%80%81B%E6%A0%91%E3%80%81B+%E6%A0%91%E3%80%81B*%E6%A0%91/9.jpg" alt="9"><br>（维基百科算法结构示意图）</p>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ol>
<li>B+树的层级更少：相较于B树B+每个非叶子节点存储的关键字数更多，树的层级更少所以查询数据更快；</li>
<li>B+树查询速度更稳定：B+所有关键字数据地址都存在叶子节点上，所以每次查找的次数都相同所以查询速度要比B树更稳定;</li>
<li>B+树天然具备排序功能：B+树所有的叶子节点数据构成了一个有序链表，在查询大小区间的数据时候更方便，数据紧密性很高，缓存的命中率也会比B树高。</li>
<li>B+树全节点遍历更快：B+树遍历整棵树只需要遍历所有的叶子节点即可，，而不需要像B树一样需要对每一层进行遍历，这有利于数据库做全表扫描。</li>
</ol>
<p>B树相对于B+树的优点是，如果经常访问的数据离根节点很近，而B树的非叶子节点本身存有关键字其数据的地址，所以这种数据检索的时候会要比B+树快。</p>
<h2 id="B-树-1"><a href="#B-树-1" class="headerlink" title="B*树"></a>B*树</h2><h3 id="规则-1"><a href="#规则-1" class="headerlink" title="规则"></a>规则</h3><p>B*树是B+树的变种，相对于B+树他们的不同之处如下：</p>
<ol>
<li>首先是关键字个数限制问题，B+树初始化的关键字初始化个数是cei(m/2)，b<em>树的初始化个数为（cei(2/3</em>m)）</li>
<li>B+树节点满时就会分裂，而B*树节点满时会检查兄弟节点是否满（因为每个节点都有指向兄弟的指针），如果兄弟节点未满则向兄弟节点转移关键字，如果兄弟节点已满，则从当前节点和兄弟节点各拿出1/3的数据创建一个新的节点出来；</li>
</ol>
<h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><p>在B+树的基础上因其初始化的容量变大，使得节点空间使用率更高，而又存有兄弟节点的指针，可以向兄弟节点转移关键字的特性使得B*树额分解次数变得更少；</p>
<p><img src="/2019/12/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%81%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%A0%91%E3%80%81B%E6%A0%91%E3%80%81B+%E6%A0%91%E3%80%81B*%E6%A0%91/10.jpg" alt="10"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li><p>相同思想和策略</p>
<p> 从平衡二叉树、B树、B+树、B*树总体来看它们的贯彻的思想是相同的，都是采用二分法和数据平衡策略来提升查找数据的速度；</p>
</li>
<li><p>不同的方式的磁盘空间利用</p>
<p> 不同点是他们一个一个在演变的过程中通过IO从磁盘读取数据的原理进行一步步的演变，每一次演变都是为了让节点的空间更合理的运用起来，从而使树的层级减少达到快速查找数据的目的；</p>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/6/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><span class="page-number current">7</span><a class="page-number" href="/page/8/">8</a><span class="space">&hellip;</span><a class="page-number" href="/page/69/">69</a><a class="extend next" rel="next" href="/page/8/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Zhang Wetts"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">Zhang Wetts</p>
  <div class="site-description" itemprop="description">Stay Hungry, Stay Foolish. <br><br><p style="font-size:8px;">[build by hexo/next/gitalk/hexo-generator-search/LaTeX]</p></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">683</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">63</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">338</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/wetts" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;wetts" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:zhang.wetts@163.com" title="E-Mail → mailto:zhang.wetts@163.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Zhang Wetts</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

  


<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/hibiki.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"react":{"opacity":0.7}});</script></body>
</html>
