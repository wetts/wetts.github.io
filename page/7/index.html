<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"wetts.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="Stay Hungry, Stay Foolish. [build by hexo&#x2F;next&#x2F;gitalk&#x2F;hexo-generator-search&#x2F;LaTeX]">
<meta property="og:type" content="website">
<meta property="og:title" content="Wetts&#39;s blog">
<meta property="og:url" content="https://wetts.github.io/page/7/index.html">
<meta property="og:site_name" content="Wetts&#39;s blog">
<meta property="og:description" content="Stay Hungry, Stay Foolish. [build by hexo&#x2F;next&#x2F;gitalk&#x2F;hexo-generator-search&#x2F;LaTeX]">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Zhang Wetts">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://wetts.github.io/page/7/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Wetts's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Wetts's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Stay Hungry, Stay Foolish.</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/wetts" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wetts.github.io/2020/03/16/artificial_intelligence/deep_learning/%E6%A6%82%E5%BF%B5/DL-%E6%A6%82%E5%BF%B5-epochs%E3%80%81batch_size%E3%80%81iterations/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Zhang Wetts">
      <meta itemprop="description" content="Stay Hungry, Stay Foolish. <br><br><p style="font-size:8px;">[build by hexo/next/gitalk/hexo-generator-search/LaTeX]</p>">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wetts's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/16/artificial_intelligence/deep_learning/%E6%A6%82%E5%BF%B5/DL-%E6%A6%82%E5%BF%B5-epochs%E3%80%81batch_size%E3%80%81iterations/" class="post-title-link" itemprop="url">DL-概念-epochs、batch_size、iterations</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-03-16 15:35:31" itemprop="dateCreated datePublished" datetime="2020-03-16T15:35:31+08:00">2020-03-16</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">深度学习</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="batch"><a href="#batch" class="headerlink" title="batch"></a>batch</h3><p>深度学习的优化算法，说白了就是梯度下降。按照损失函数的计算规模和每次的参数更新分类有三种方式。</p>
<h4 id="批梯度下降（BGD——Batch-gradient-descent）"><a href="#批梯度下降（BGD——Batch-gradient-descent）" class="headerlink" title="批梯度下降（BGD——Batch gradient descent）"></a>批梯度下降（BGD——Batch gradient descent）</h4><p>损失函数计算：遍历全部数据集算一次损失函数，然后算函数对各个参数的梯度，更新梯度。</p>
<p>特点：每更新一次参数都要把数据集里的所有样本都看一遍，计算量开销大，计算速度慢，不支持在线学习。</p>
<h4 id="随机梯度下降（SGD——stochastic-gradient-descent）"><a href="#随机梯度下降（SGD——stochastic-gradient-descent）" class="headerlink" title="随机梯度下降（SGD——stochastic gradient descent）"></a>随机梯度下降（SGD——stochastic gradient descent）</h4><p>损失函数计算：每看一个数据就算一下损失函数，然后求梯度更新参数。</p>
<p>特点：速度比较快，但是收敛性能不太好，可能在最优点附近晃来晃去，hit 不到最优点。两次参数的更新也有可能互相抵消掉，造成目标函数震荡的比较剧烈。</p>
<h4 id="小批梯度下降（mini-batch-gradient-decent）"><a href="#小批梯度下降（mini-batch-gradient-decent）" class="headerlink" title="小批梯度下降（mini-batch gradient decent）"></a>小批梯度下降（mini-batch gradient decent）</h4><p>为了克服两种方法的缺点，现在一般采用的是一种折中手段。</p>
<p>损失函数计算：把数据分为若干个批，按批来更新参数，这样，一个批中的一组数据共同决定了本次梯度的方向，下降起来就不容易跑偏，减少了随机性。另一方面因为批的样本数与整个数据集相比小了很多，计算量也不是很大。</p>
<h3 id="iterations"><a href="#iterations" class="headerlink" title="iterations"></a>iterations</h3><p>iterations（迭代）：每一次迭代都是一次权重更新，每一次权重更新需要 batch_size 个数据进行 Forward 运算得到损失函数，再 BP 算法更新参数。1 个 iteration 等于使用 batchsize 个样本训练一次。</p>
<h3 id="epochs"><a href="#epochs" class="headerlink" title="epochs"></a>epochs</h3><p>epochs 被定义为向前和向后传播中所有批次的单次训练迭代。这意味着 1 个周期是整个输入数据的单次向前和向后传递。简单说，epochs 指的就是训练过程中数据将被“轮”多少次。</p>
<h3 id="三者之间的关系"><a href="#三者之间的关系" class="headerlink" title="三者之间的关系"></a>三者之间的关系</h3><p>训练集有 1000 个样本，batch_size = 10，那么训练完整个样本集需要： 100 次 iteration，1 次 epoch。</p>
<p>具体的计算公式为：<br>one epoch = numbers of iterations = N = 训练样本的数量 / batch_size</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wetts.github.io/2020/03/14/%E7%B3%BB%E7%BB%9F%E3%80%81%E6%9C%8D%E5%8A%A1%E5%99%A8/%E7%B3%BB%E7%BB%9F/Linux/Linux-%E7%8E%AF%E5%A2%83-profile%E5%92%8Crc%E7%9A%84%E5%8C%BA%E5%88%AB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Zhang Wetts">
      <meta itemprop="description" content="Stay Hungry, Stay Foolish. <br><br><p style="font-size:8px;">[build by hexo/next/gitalk/hexo-generator-search/LaTeX]</p>">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wetts's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/14/%E7%B3%BB%E7%BB%9F%E3%80%81%E6%9C%8D%E5%8A%A1%E5%99%A8/%E7%B3%BB%E7%BB%9F/Linux/Linux-%E7%8E%AF%E5%A2%83-profile%E5%92%8Crc%E7%9A%84%E5%8C%BA%E5%88%AB/" class="post-title-link" itemprop="url">Linux-环境-profile和rc的区别.md</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-03-14 21:40:06" itemprop="dateCreated datePublished" datetime="2020-03-14T21:40:06+08:00">2020-03-14</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">系统</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>转自：<a target="_blank" rel="noopener" href="https://blog.csdn.net/sch0120/article/details/70256318">https://blog.csdn.net/sch0120/article/details/70256318</a></p>
<h3 id="bash-的-startup-文件"><a href="#bash-的-startup-文件" class="headerlink" title="bash 的 startup 文件"></a>bash 的 startup 文件</h3><p>Linux shell 是用户与 Linux 系统进行交互的媒介，而 bash 作为目前 Linux 系统中最常用的 shell，它支持的 startup 文件也并不单一，甚至容易让人感到费解。本文以 CentOS7 系统为例，对 bash 的 startup 文件进行一些必要的梳理和总结。</p>
<p>根据bash手册上的描述：</p>
<ul>
<li>/etc/profile: The systemwide initialization file, executed for login shells</li>
<li>/etc/bash.bash_logout: The systemwide login shell cleanup file, executed when a login shell exits</li>
<li>~/.bash_profile: The personal initialization file, executed for login shells</li>
<li>~/.bashrc: The individual per-interactive-shell startup file</li>
<li>~/.bash_logout: The individual login shell cleanup file, executed when a login shell exits</li>
</ul>
<p>此外，bash 还支持 <code>~/.bash_login</code> 和 <code>~/.profile</code> 文件，作为对其他 shell 的兼容，它们与 <code>~/.bash_profile</code> 文件的作用是相同的。</p>
<p>备注：Debian系统会使用 <code>~/.profile</code> 文件取代 <code>~/.bash_profile</code>文件，因此在相关细节上，会与 CentOS 略有不同。</p>
<h3 id="“profile”与“rc”系列"><a href="#“profile”与“rc”系列" class="headerlink" title="“profile”与“rc”系列"></a>“profile”与“rc”系列</h3><p>通过名字的不同，我们可以直观地将 startup 文件分为“profile”与“rc”两个系列，其实他们的功能都很类似，但是使用的场景不同，这也是大家最容易忽略的地方。</p>
<p>所谓的不同场景，其实就是 shell 的运行模式。我们知道运行中的 bash 有“交互”和“登陆”两种属性，而执行“profile”系列还是“rc”系列，就与shell的这两个属性有关。</p>
<p>原理上讲，“登陆 shell”启动时会加载“profile”系列的 startup 文件，而“交互式非登陆 shell”启动时会加载“rc”系列的 startup 文件。</p>
<h3 id="“profile”系列的执行场景"><a href="#“profile”系列的执行场景" class="headerlink" title="“profile”系列的执行场景"></a>“profile”系列的执行场景</h3><p>根据 bash 手册上的描述：</p>
<blockquote>
When bash is invoked as an interactive login shell, or as a non-interactive shell with the --login option, it first reads and executes commands from the file /etc/profile, if that file exists. After reading that file, it looks for ~/.bash_profile, ~/.bash_login, and ~/.profile, in that order, and reads and executes commands from the first one that exists and is readable. The --noprofile option may be used when the shell is started to inhibit this behavior.

<p>When a login shell exits, bash reads and executes commands from the files ~/.bash_logout and /etc/bash.bash_logout, if the files exists.</p>
</blockquote>

<p>“profile”系列的代表文件为 <code>~/.bash_profile</code>，它用于“登录 shell”的环境加载，这个“登录 shell”既可以是“交互式”的，也可以是“非交互式”的。</p>
<p>通过 <code>--noprofile</code> 选项可以阻止系统加载“profile”系列的 startup 文件。</p>
<h4 id="交互式登陆-shell"><a href="#交互式登陆-shell" class="headerlink" title="交互式登陆 shell"></a>交互式登陆 shell</h4><p>对于交互式的登陆 shell 而言，CentOS 规定了 startup 文件的加载顺序如下：</p>
<p>登陆过程：</p>
<ol>
<li>读取并执行 /etc/profile 文件；</li>
<li>读取并执行 ~/.bash_profile 文件；<ul>
<li>若文件不存在，则读取并执行 ~/.bash_login 文件；</li>
<li>若文件不存在，则读取并执行 ~/.profile 文件；</li>
</ul>
</li>
</ol>
<p>登出过程：</p>
<ol>
<li>读取并执行 ~/.bash_logout 文件；</li>
<li>读取并执行 /etc/bash.bash_logout 文件；</li>
</ol>
<p>为了完成实验，我新建了一些系统默认没有提供的 startup 文件，例如 /etc/bash.bash_logout。然后在每个文件中打印了文件名，并将它们之间的显式调用语句注释掉，例如 ~/.bash_profile 对 ~/.bashrc 的显式调用。</p>
<p>“交互式登陆shell”的实验结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# su - chen</span><br><span class="line">Last login: Tue Apr 18 17:15:08 CST 2017 from 192.168.161.1 on pts/2</span><br><span class="line">execute /etc/profile</span><br><span class="line">execute ~/.bash_profile</span><br><span class="line">-bash-4.2$ exit</span><br><span class="line">logout</span><br><span class="line">execute ~/.bash_logout</span><br><span class="line">execute /etc/bash.bash_logout</span><br><span class="line">[root@localhost ~]# </span><br></pre></td></tr></table></figure>

<p>我们看到，因为执行了 <code>~/.bash_profile</code> 文件，所以优先级更低的 <code>~/.bash_login</code> 和 <code>~/.profile</code> 文件并没有被执行。</p>
<p>我们可以删除 <code>~/.bash_profile</code> 和 <code>~/.bash_login</code> 文件，这样系统就会找到并执行 <code>~/.profile</code> 文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# mv /home/chen/.bash_profile /home/chen/.bash_profile.bak</span><br><span class="line">[root@localhost ~]# mv /home/chen/.bash_login /home/chen/.bash_login.bak</span><br><span class="line">[root@localhost ~]# su - chen</span><br><span class="line">Last login: Tue Apr 18 17:27:21 CST 2017 on pts/1</span><br><span class="line">execute /etc/profile</span><br><span class="line">execute ~/.profile</span><br><span class="line">-bash-4.2$ exit</span><br><span class="line">logout</span><br><span class="line">execute ~/.bash_logout</span><br><span class="line">execute /etc/bash.bash_logout</span><br><span class="line">[root@localhost ~]# </span><br></pre></td></tr></table></figure>

<h4 id="非交互式登陆-shell"><a href="#非交互式登陆-shell" class="headerlink" title="非交互式登陆 shell"></a>非交互式登陆 shell</h4><p>对于非交互式的登陆 shell 而言，CentOS 规定了 startup 文件的加载顺序如下：</p>
<p>登陆过程：</p>
<ol>
<li>读取并执行 /etc/profile 文件；</li>
<li>读取并执行 ~/.bash_profile 文件；<ul>
<li>若文件不存在，则读取并执行 ~/.bash_login 文件；</li>
<li>若文件不存在，则读取并执行 ~/.profile 文件；</li>
</ul>
</li>
</ol>
<p>我们注意到，与“交互式登陆 shell”相比，“非交互式登陆 shell”并没有登出的过程，实验也证实了这一点：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-bash-4.2$ bash --login -c &quot;uname -r&quot;</span><br><span class="line">execute /etc/profile</span><br><span class="line">execute ~/.bash_profile</span><br><span class="line">3.10.0-514.el7.x86_64</span><br><span class="line">-bash-4.2$     # 此时非交互式shell已退出</span><br></pre></td></tr></table></figure>

<h3 id="“rc”系列的执行场景"><a href="#“rc”系列的执行场景" class="headerlink" title="“rc”系列的执行场景"></a>“rc”系列的执行场景</h3><p>根据 bash 手册上的描述：</p>
<blockquote>
<p>When an interactive shell that is not a login shell is started, bash reads and executes commands from ~/.bashrc, if that file exists. This may be inhibited by using the –norc option. The –rcfile file option will force bash to read and execute commands from file instead of ~/.bashrc.</p>
</blockquote>
<p>“rc”系列的代表文件为 <code>~/.bashrc</code>，它用于“交互式非登录 shell”的环境加载。</p>
<p>通过 <code>--norc</code> 选项可以阻止系统加载“rc”系列的 startup 文件；通过 <code>--rcfile</code> 选项可以使用指定的文件替代系统默认的 <code>~/.bashrc</code> 文件。</p>
<h4 id="交互式非登陆-shell"><a href="#交互式非登陆-shell" class="headerlink" title="交互式非登陆 shell"></a>交互式非登陆 shell</h4><p>对于交互式的非登陆 shell 而言，CentOS 规定了 startup 文件的加载顺序如下：</p>
<ol>
<li>读取并执行 <code>~/.bashrc</code> 或 <code>--rcfile</code> 选项指定的文件</li>
</ol>
<p>这里需要说明，其实“rc”系列 startup 文件还包括 /etc/bashrc。但是系统并不直接调用这个文件，而是通过 <code>~/.bashrc</code> 文件显式地调用它。</p>
<p>为了完成实验，我在每个 startup 文件中打印了文件名，并将它们之间的显式调用语句注释掉，例如 <code>~/.bashrc</code> 对 <code>/etc/bashrc</code> 的显式调用。</p>
<p>“交互式非登陆 shell”的实验结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# su chen</span><br><span class="line">execute ~/.bashrc</span><br><span class="line">bash-4.2$ exit</span><br><span class="line">exit</span><br><span class="line">[root@localhost ~]# </span><br></pre></td></tr></table></figure>

<h3 id="startup-文件的默认调用关系"><a href="#startup-文件的默认调用关系" class="headerlink" title="startup 文件的默认调用关系"></a>startup 文件的默认调用关系</h3><p>细心的用户会发现，startup 文件的加载并不像上面所述的那样简单。这是因为在 CentOS 中，startup 文件之间还存在着默认的显式调用关系，它们是：</p>
<ol>
<li><code>~/.bash_profile</code> 显式调用 <code>~/.bashrc</code> 文件；</li>
<li><code>~/.bashrc</code> 显式调用 <code>/etc/bashrc</code> 文件；</li>
</ol>
<h3 id="再看-startup-文件"><a href="#再看-startup-文件" class="headerlink" title="再看 startup 文件"></a>再看 startup 文件</h3><p>分别打开 <code>/etc/profile</code>和 <code>/etc/bashrc</code> 两个文件，我们可以看到：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# head /etc/profile</span><br><span class="line"># /etc/profile</span><br><span class="line"></span><br><span class="line"># System wide environment and startup programs, for login setup</span><br><span class="line"># Functions and aliases go in /etc/bashrc</span><br><span class="line"></span><br><span class="line"># It&#x27;s NOT a good idea to change this file unless you know what you</span><br><span class="line"># are doing. It&#x27;s much better to create a custom.sh shell script in</span><br><span class="line"># /etc/profile.d/ to make custom changes to your environment, as this</span><br><span class="line"># will prevent the need for merging in future updates.</span><br><span class="line"></span><br><span class="line">[root@localhost ~]# head /etc/bashrc</span><br><span class="line"># /etc/bashrc</span><br><span class="line"></span><br><span class="line"># System wide functions and aliases</span><br><span class="line"># Environment stuff goes in /etc/profile</span><br><span class="line"></span><br><span class="line"># It&#x27;s NOT a good idea to change this file unless you know what you</span><br><span class="line"># are doing. It&#x27;s much better to create a custom.sh shell script in</span><br><span class="line"># /etc/profile.d/ to make custom changes to your environment, as this</span><br><span class="line"># will prevent the need for merging in future updates.</span><br></pre></td></tr></table></figure>

<p>由此可见，“profile”系列文件的主要目的在于为“登录 shell”设置环境变量和启动程序；而“rc”系列文件的主要目的在于设置功能和别名。</p>
<p>顺便提一句，Linux 中“rc”是英文“run command”的缩写，表示文件中存放需要执行的命令。其实这也非常符合逻辑，设置功能就要执行 <code>shopt</code> 命令，而设置别名要执行 <code>alias</code> 命令。与“rc”系列互补，“profile”系列用来设置环境变量，它不会去调用这两个命令，但却经常需要使用 <code>export</code> 语句。不信你可以看一看这两个文件。</p>
<p>另外值得一提的是，这两个文件同时提到了一个位置：<code>/etc/profile.d</code> 目录。这个目录用于存放个性化配置脚本，你可以把自己需要的全局配置放入以 .sh 结尾的文件中，系统在执行 <code>/etc/profile</code>和 <code>/etc/bashrc</code> 文件时，都会择机调用它们。这样做最大的好处是便于维护，而且相对更加安全。</p>
<p>这些文件的编写方法，可以参考目录下已有的文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# ls /etc/profile.d/*.sh</span><br><span class="line">/etc/profile.d/256term.sh    /etc/profile.d/colorls.sh  /etc/profile.d/less.sh</span><br><span class="line">/etc/profile.d/colorgrep.sh  /etc/profile.d/lang.sh     /etc/profile.d/which2.sh</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>对于“登录 shell”而言<ul>
<li>“交互式”执行“登陆”和“登出”相关的“profile”系列 startup 文件</li>
<li>“非交互式”只执行“登陆”相关的“profile”系列 startup 文件</li>
</ul>
</li>
<li>对于“非登陆 shell”而言<ul>
<li>“交互式”执行“rc”系列的 startup 文件</li>
<li>而“非交互式”执行的配置文件由环境变量 BASH_ENV 指定。</li>
</ul>
</li>
</ul>
<p>Linux 中 startup 文件区分全局和个人：全局 startup 文件放在 /etc 目录下，用于设置所有用户共同的配置，除非你清楚地知道你在做的事情，否则不要轻易改动它们；个人 startup 文件放在 ~ 目录下，用于设置某个用户的个性化配置。</p>
<p><code>~/.bash_profile</code> 会显式调用 <code>~/.bashrc</code> 文件，而 <code>~/.bashrc</code> 又会显式调用 <code>/etc/bashrc</code> 文件，这是为了让所有交互式界面看起来一样。无论你是从远程登录（登陆 shell），还是从图形界面打开终端（非登陆 shell），你都拥有相同的提示符，因为环境变量 PS1 在 <code>/etc/bashrc</code> 文件中被统一设置过。</p>
<p>下面我来对startup文件进行一个完整的总结：</p>
<table>
<thead>
<tr>
<th align="center">startup 文件</th>
<th align="center">交互登陆</th>
<th align="center">非交互登陆</th>
<th align="center">交互非登陆</th>
<th align="center">非交互非登陆</th>
</tr>
</thead>
<tbody><tr>
<td align="center">/etc/profile</td>
<td align="center">直接执行1</td>
<td align="center">直接执行1</td>
<td align="center">-</td>
<td align="center">-</td>
</tr>
<tr>
<td align="center">~/.bash_profile</td>
<td align="center">直接执行2</td>
<td align="center">直接执行2</td>
<td align="center">-</td>
<td align="center">-</td>
</tr>
<tr>
<td align="center">~/.bash_login</td>
<td align="center">条件执行2</td>
<td align="center">条件执行2</td>
<td align="center">-</td>
<td align="center">-</td>
</tr>
<tr>
<td align="center">~/.profile</td>
<td align="center">条件执行2</td>
<td align="center">条件执行2</td>
<td align="center">-</td>
<td align="center">-</td>
</tr>
<tr>
<td align="center">~/.bash_logout</td>
<td align="center">直接执行3</td>
<td align="center">不执行</td>
<td align="center">-</td>
<td align="center">-</td>
</tr>
<tr>
<td align="center">/etc/bash.bash_logout</td>
<td align="center">直接执行4</td>
<td align="center">不执行</td>
<td align="center">-</td>
<td align="center">-</td>
</tr>
<tr>
<td align="center">~/.bashrc</td>
<td align="center">引用执行2.1</td>
<td align="center">引用执行2.1</td>
<td align="center">直接执行1</td>
<td align="center">-</td>
</tr>
<tr>
<td align="center">/etc/bashrc</td>
<td align="center">引用执行2.2</td>
<td align="center">引用执行2.2</td>
<td align="center">引用执行1.1</td>
<td align="center">-</td>
</tr>
</tbody></table>
<p>备注：</p>
<ol>
<li>“直接执行”表示此文件被系统直接调用，它的执行是无条件的；</li>
<li>“条件执行”表示此文件被系统调用是有先决条件的（没有优先级更高的文件可用）；</li>
<li>“引用执行”表示此文件不是被系统直接调用的，而是被其他文件显式调用的；</li>
<li>后面的数字表示文件被调用的顺序，数字越大调用越靠后；</li>
<li>“非交互非登陆” shell 的配置文件可以由 BASH_ENV 环境变量指定；</li>
</ol>
<p>最后我想说的是，知道 startup 文件何时被执行并不是关键，关键是要理解自己的情况应该去修改哪个 startup 文件。</p>
<p>如果你想对 bash 的功能进行设置或者是定义一些别名，推荐你修改 ~/.bashrc 文件，这样无论你以何种方式打开 shell，你的配置都会生效。而如果你要更改一些环境变量，推荐你修改 ~/.bash_profile 文件，因为考虑到 shell 的继承特性，这些更改确实只应该被执行一次（而不是多次）。针对所有用户进行全局设置，推荐你在 /etc/profile.d 目录下添加以 .sh 结尾的文件，而不是去修改全局 startup 文件。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wetts.github.io/2020/03/14/%E7%B3%BB%E7%BB%9F%E3%80%81%E6%9C%8D%E5%8A%A1%E5%99%A8/%E7%B3%BB%E7%BB%9F/Linux/Linux-%E5%91%BD%E4%BB%A4-%E4%BA%A4%E4%BA%92%E5%BC%8F_%E9%9D%9E%E4%BA%A4%E4%BA%92%E5%BC%8F_%E7%99%BB%E5%BD%95%E5%BC%8F_%E9%9D%9E%E7%99%BB%E5%BD%95%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Zhang Wetts">
      <meta itemprop="description" content="Stay Hungry, Stay Foolish. <br><br><p style="font-size:8px;">[build by hexo/next/gitalk/hexo-generator-search/LaTeX]</p>">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wetts's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/14/%E7%B3%BB%E7%BB%9F%E3%80%81%E6%9C%8D%E5%8A%A1%E5%99%A8/%E7%B3%BB%E7%BB%9F/Linux/Linux-%E5%91%BD%E4%BB%A4-%E4%BA%A4%E4%BA%92%E5%BC%8F_%E9%9D%9E%E4%BA%A4%E4%BA%92%E5%BC%8F_%E7%99%BB%E5%BD%95%E5%BC%8F_%E9%9D%9E%E7%99%BB%E5%BD%95%E5%BC%8F/" class="post-title-link" itemprop="url">Linux-命令-交互式_非交互式_登录式_非登录式.md</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-03-14 21:19:51" itemprop="dateCreated datePublished" datetime="2020-03-14T21:19:51+08:00">2020-03-14</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">系统</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>转自：<a target="_blank" rel="noopener" href="https://blog.csdn.net/sch0120/article/details/70226903">https://blog.csdn.net/sch0120/article/details/70226903</a></p>
<p>Linux shell 是用户与 Linux 系统进行交互的媒介，而 bash 作为目前 Linux 系统中最常用的 shell，它在运行时具有两种属性，即“交互”与“登陆”。</p>
<ul>
<li>按照 bash 是否与用户进行交互，可以将其分为“交互式”与“非交互式”；</li>
<li>而按照 bash 是否被用户登陆，又可将其分为“登陆 shell”与“非登陆 shell”。</li>
</ul>
<h3 id="“交互式”与“非交互式”"><a href="#“交互式”与“非交互式”" class="headerlink" title="“交互式”与“非交互式”"></a>“交互式”与“非交互式”</h3><h4 id="含义说明"><a href="#含义说明" class="headerlink" title="含义说明"></a>含义说明</h4><ul>
<li>交互式，是 shell 的一种运行模式，交互式 shell 等待你输入命令，并且立即执行，然后将结果反馈给你。这是每个 CLI 用户都非常熟悉的流程：登录、执行一些命令、登出。当你登出后，这个 shell 就终止了。</li>
<li>非交互式，是 shell 的另一种运行模式，它专门被用来执行预先设定的命令。在这种模式下，shell 不与用户进行交互，而是读取存放在脚本文件中的命令并执行它们。当它读到文件的结尾，这个 shell 就终止了。</li>
</ul>
<h4 id="启动方法"><a href="#启动方法" class="headerlink" title="启动方法"></a>启动方法</h4><p>根据bash手册上的描述：</p>
<blockquote>
<p>An interactive shell is one started without non-option arguments and without the -c option whose standard input and error are both connected to terminals (as determined by isatty(3)), or one started with the -i option.</p>
</blockquote>
<p>从上面的描述看，只要执行 bash 命令的时候，不带有“选项以外的参数”或者 -c 选项，就会启动一个交互式 shell。要理解这句话，就要弄懂“选项以外的参数”是什么意思，其实它指的就是 shell 的脚本文件；而 -c 选项将指定字符串作为命令读入 bash，也就相当于执行指定的命令，它和前者有些类似，只是不从脚本文件中读取罢了。请看例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[chen@localhost Temp]$ echo &quot;uname -r; date&quot; &gt; script.sh</span><br><span class="line">[chen@localhost Temp]$ bash ./script.sh </span><br><span class="line">3.10.0-514.el7.x86_64</span><br><span class="line">Tue Apr 18 14:43:50 CST 2017</span><br><span class="line">[chen@localhost Temp]$ </span><br><span class="line">[chen@localhost Temp]$ bash -c &quot;uname -r; date&quot;</span><br><span class="line">3.10.0-514.el7.x86_64</span><br><span class="line">Tue Apr 18 14:44:49 CST 2017</span><br><span class="line">[chen@localhost Temp]$ </span><br></pre></td></tr></table></figure>

<p>通常来说，用于执行脚本的 shell 都是“非交互式”的，但我们也有办法把它启动为“交互式” shell，方法就是在执行 bash 命令时，添加 -i 选项：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[chen@localhost Temp]$ bash -c &quot;echo \$-&quot;</span><br><span class="line">hBc</span><br><span class="line">[chen@localhost Temp]$ bash -i -c &quot;echo \$-&quot;</span><br><span class="line">himBHc</span><br></pre></td></tr></table></figure>

<p>我们看到，添加了 -i 选项的 bash -c 命令为我们启动了一个“交互式” shell。</p>
<h4 id="判别方法"><a href="#判别方法" class="headerlink" title="判别方法"></a>判别方法</h4><p>根据 bash 手册上的描述：</p>
<blockquote>
<p>PS1 is set and $- includes i if bash is interactive, allowing a shell script or a startup file to test this state.</p>
</blockquote>
<p>用于在 shell 脚本和 startup 文件中判断当前 shell“交互”属性的方法，就是判断变量 PS1 是否有值，或者判断变量 $- 是否包含 i，请看例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[chen@localhost Temp]$ cat ./test1.sh </span><br><span class="line">echo &quot;\$0   : $0&quot;</span><br><span class="line">echo &quot;\$-   : $-&quot;</span><br><span class="line">echo &quot;\$PS1 : $PS1&quot;</span><br><span class="line">[chen@localhost Temp]$ bash ./test1.sh     # 非交互式shell</span><br><span class="line">$0   : ./test1.sh</span><br><span class="line">$-   : hB</span><br><span class="line">$PS1 : </span><br><span class="line">[chen@localhost Temp]$ bash -i ./test1.sh  # 交互式shell</span><br><span class="line">$0   : ./test1.sh</span><br><span class="line">$-   : himB</span><br><span class="line">$PS1 : [\u@\h \W]\$ </span><br><span class="line">[chen@localhost Temp]$ </span><br></pre></td></tr></table></figure>

<h3 id="“登陆-shell”与“非登陆-shell”"><a href="#“登陆-shell”与“非登陆-shell”" class="headerlink" title="“登陆 shell”与“非登陆 shell”"></a>“登陆 shell”与“非登陆 shell”</h3><h4 id="含义说明-1"><a href="#含义说明-1" class="headerlink" title="含义说明"></a>含义说明</h4><p>“登陆 shell”通常指的是：</p>
<ol>
<li>用户通过输入用户名/密码（或证书认证）后启动的 shell；</li>
<li>通过带有 <code>-l|--login</code> 参数的 bash 命令启动的 shell。</li>
</ol>
<p>例如，系统启动、远程登录、使用 <code>su -</code> 切换用户、通过 <code>bash --login</code> 命令启动 bash 等。</p>
<p>而其他情况启动的 shell 基本上就都是“非登陆 shell”了。</p>
<p>例如，从图形界面启动终端、使用 <code>su</code> 切换用户、通过 <code>bash</code> 命令启动 bash 等。</p>
<h4 id="判别方法-1"><a href="#判别方法-1" class="headerlink" title="判别方法"></a>判别方法</h4><p>根据 bash 手册上的描述：</p>
<blockquote>
<p>A login shell is one whose first character of argument zero is a <code>-</code>, or one started with the <code>--login</code> option.</p>
</blockquote>
<p>我们可以通过在 shell 中 <code>echo $0</code> 查看，显示 <code>-bash</code> 的一定是“登陆 shell”，反之显示 bash 的则不好说。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[chen@localhost ~]$ bash --login</span><br><span class="line">[chen@localhost ~]$ echo $0</span><br><span class="line">bash</span><br><span class="line">[chen@localhost ~]$ </span><br></pre></td></tr></table></figure>

<p>可以看出，使用 <code>bash --login</code> 启动的“登陆 shell”，其 <code>$0</code> 也并非以 <code>-</code> 开头，这也就是为什么手册上的描述里使用“or”的原因。</p>
<p>另外，当我们执行 exit 命令退出 shell 时，也可以观察到它们的不同之处：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[chen@localhost ~]$ bash --login</span><br><span class="line">[chen@localhost ~]$ exit   # 退出登陆shell</span><br><span class="line">logout</span><br><span class="line">[chen@localhost ~]$ bash</span><br><span class="line">[chen@localhost ~]$ exit   # 退出非登陆shell</span><br><span class="line">exit</span><br><span class="line">[chen@localhost ~]$</span><br></pre></td></tr></table></figure>

<p>原则上讲，我们使用 logout 退出“登陆 shell”，使用 exit 退出“非登录 shell”。但其实 exit 命令会判断当前 shell 的“登陆”属性，并分别调用 logout 或 exit 指令，因此使用起来相对方便。</p>
<h4 id="主要区别"><a href="#主要区别" class="headerlink" title="主要区别"></a>主要区别</h4><p>对于用户而言，“登录 shell”和“非登陆 shell”的主要区别在于启动 shell 时所执行的 startup 文件不同。</p>
<p>简单来说，“登录 shell”执行的 startup 文件为 <code>~/.bash_profile</code>，而“非登陆 shell”执行的 startup 文件为 <code>~/.bashrc</code>。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wetts.github.io/2020/03/14/%E7%B3%BB%E7%BB%9F%E3%80%81%E6%9C%8D%E5%8A%A1%E5%99%A8/%E7%B3%BB%E7%BB%9F/Linux/Linux-%E7%8E%AF%E5%A2%83-%E8%B7%AF%E5%BE%84%E7%9A%84%E6%84%8F%E4%B9%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Zhang Wetts">
      <meta itemprop="description" content="Stay Hungry, Stay Foolish. <br><br><p style="font-size:8px;">[build by hexo/next/gitalk/hexo-generator-search/LaTeX]</p>">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wetts's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/14/%E7%B3%BB%E7%BB%9F%E3%80%81%E6%9C%8D%E5%8A%A1%E5%99%A8/%E7%B3%BB%E7%BB%9F/Linux/Linux-%E7%8E%AF%E5%A2%83-%E8%B7%AF%E5%BE%84%E7%9A%84%E6%84%8F%E4%B9%89/" class="post-title-link" itemprop="url">Linux-环境-路径的意义</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-03-14 16:33:30" itemprop="dateCreated datePublished" datetime="2020-03-14T16:33:30+08:00">2020-03-14</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">系统</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="boot"><a href="#boot" class="headerlink" title="/boot"></a>/boot</h3><p>引导程序，内核等存放的目录。</p>
<p>这个目录，包括了在引导过程中所必需的文件，引导程序的相关文件（例如 grub、lilo 以及相应的配置文件以及 Linux 操作系统内核相关文件（例如 vmlinuz 等一般都存放在这里。在最开始的启动阶段，通过引导程序将内核加载到内存，完成内核的启动（这个时候，虚拟文件系统还不存在，加载的内核虽然是从硬盘读取的，但是没经过 Linux 的虚拟文件系统，这是比较底层的东西来实现的。然后内核自己创建好虚拟文件系统，并且从虚拟文件系统的其他子目录中（例如 /sbin 和 /etc 加载需要在开机启动的其他程序或者服务或者特定的动作（部分可以由用户自己在相应的目录中修改相应的文件来配制。如果我们的机器中包含多个操作系统，那么可以通过修改这个目录中的某个配置文件（例如 grub.conf 来调整启动的默认操作系统，系统启动的择菜单，以及启动延迟等参数）。</p>
<h3 id="sbin"><a href="#sbin" class="headerlink" title="/sbin"></a>/sbin</h3><p>超级用户可以使用的命令的存放目录。</p>
<p>存放大多涉及系统管理的命令（例如引导系统的 init 程序，是超级权限用户 root 的可执行命令存放地，普通用户无权限执行这个目录下的命令（但是时普通用户也可能会用到。这个目录和 /usr/sbin; /usr/X11R6/sbin 或 /usr/local/sbin 等目录是相似的，我们要记住，凡是目录 sbin 中包含的都是 root 权限才能执行的，这样就行了。后面会具体区分）。</p>
<h3 id="bin"><a href="#bin" class="headerlink" title="/bin"></a>/bin</h3><p>普通用户可以使用的命令的存放目录。</p>
<p>系统所需要的那些命令位于此目录，比如 ls、cp、mkdir 等命令；类似的目录还 /usr/bin，/usr/local/bin 等等。这个目录中的文件都是可执行的、普通用户都可以使用的命令。作为基础系统所需要的最基础的命令就是放在这里。</p>
<h3 id="lib"><a href="#lib" class="headerlink" title="/lib"></a>/lib</h3><p>根目录下的所程序的共享库目录。</p>
<p>此目录下包含系统引导和在根用户执行命令时候所必需用到的共享库。做个不太好但是比较形象的比喻，点类似于 Windows 上面的 system32 目录。理说，这里存放的文件应该是 /bin 目录下程序所需要的库文件的存放地，也不排除一些例外的情况。类似的目录还 /usr/lib，/usr/local/lib 等等。</p>
<h3 id="dev"><a href="#dev" class="headerlink" title="/dev"></a>/dev</h3><p>设备文件目录。</p>
<p>在 Linux 中设备都是以文件形式出现，这里的设备可以是硬盘，键盘，鼠标，网卡，终端，等设备，通过访问这些文件可以访问到相应的设备。设备文件可以使用 mknod 命令来创建，具体参见相应的命令；而为了将对这些设备文件的访问转化为对设备的访问，需要向相应的设备提供设备驱动模块（一般将设备驱动编译之后，生成的结果是一个 *.ko 类型的二进制文件），在内核启动之后，再通过 insmod 等命令加载相应的设备驱动之后，我们就可以通过设备文件来访问设备了。一般来说，想要 Linux 系统支持某个设备，只要个东西：相应的硬件设备，支持硬件的驱动模块，以及相应的设备文件。</p>
<h3 id="home"><a href="#home" class="headerlink" title="/home"></a>/home</h3><p>普通用户的家目录（$HOME 目录）。</p>
<p>在 Linux 机器上，用户主目录通常直接或间接地置在此目录下。其结构通常由本地机的管理员来决定。通常而言，系统的每个用户都自己的家目录，目录以用户名作为名字存放在 /home 下面（例如 quietheart 用户，其家目录的名字为 /home/quietheart。该目录中保存了绝大多数的用户文件（用户自己的配置文件，定制文件，文档，数据等），root 用户除外（参见后面的 /root 目录。由于这个目录包含了用户实际的数据，通常系统管理员为这个目录单独挂载一个独立的磁盘分区，这样这个目录的文件系统格式就可能和其他目录不一样了（尽管表面上看，这个目录还是属于根目录的一棵子树上），有利于数据的维护。</p>
<h3 id="root"><a href="#root" class="headerlink" title="/root"></a>/root</h3><p>用户 root 的 $HOME 目录。</p>
<p>系统管理员（就是 root 用户或超级用户）的主目录比较特殊，不存放在 /home 中，而是直接放在 /root 目录下了。</p>
<h3 id="etc"><a href="#etc" class="headerlink" title="/etc"></a>/etc</h3><p>全局的配置文件存放目录。</p>
<p>系统和程序一般都可以通过修改相应的配置文件，来进行配置。例如，要配置系统开机的时候启动那些程序，配置某个程序启动的时候显示什么样的风格等等。通常这些配置文件都集中存放在 /etc 目录中，所以想要配置什么东西的话，可以在 /etc 下面寻找我们可能需要修改的文件。一些大型套件，如 X11，在 /etc 下它们自己的子目录。系统配置文件可以放在这里或在 /usr/etc。 不过所程序总是在 /etc 目录下查找所需的配置文件，你也可以将这些文件链接到目录 /usr/etc。另外，还一个需要注意的常见现象就是，当某个程序在某个用户下运行的时候，可能会在该用户的家目录中生成一个配置文件（一般这个文件最开始就是 /etc 下相应配置文件的拷贝），存放相应于“当前用户”的配置，这样当前用户可以通过配置这个家目录的配置文件，来改变程序的行为，并且这个行为只是该用户特定的。原因就是：一般来说一个程序启动，如果需要读取一些配置文件的话，它会首先读取当前用户家目录的配置文件，如果存在就使用；如果不存在它就到 /etc 下读取全局的配置文件进而启动程序。就是这个配置文件不自动生成，我们手动在自己的家目录中创建一个文件的话，也有许多程序会首先读取到这个家目录的文件并且以它的配置作为启动的选项（例如我们可以在家目录中创建 vim 程序的配置文件 .vimrc，来配置自己的 vim 程序）。</p>
<h3 id="usr"><a href="#usr" class="headerlink" title="/usr"></a>/usr</h3><p>这个目录中包含了命令库文件和在通常操作中不会修改的文件。</p>
<p>这个目录对于系统来说也是一个非常重要的目录，其地位类似 Windows 上面的”Program Files”目录。安装程序的时候，默认就是安装在此文件内部某个子文件夹内。输入命令后系统默认执行 /usr/bin 下的程序（当然，前提是这个目录的路径已经被添加到了系统的环境变量中）。此目录通常也会挂载一个独立的磁盘分区，它应保存共享只读类文件，这样它可以被运行 Linux 的不同主机挂载。</p>
<h3 id="usr-lib"><a href="#usr-lib" class="headerlink" title="/usr/lib"></a>/usr/lib</h3><p>目标库文件，包括动态连接库加上一些通常不是直接调用的可执行文件的存放位置。</p>
<p>这个目录功能类似 /lib 目录，按理说，这里存放的文件应该是 /bin 目录下程序所需要的库文件的存放地，也不排除一些例外的情况。</p>
<h3 id="usr-bin"><a href="#usr-bin" class="headerlink" title="/usr/bin"></a>/usr/bin</h3><p>一般使用者使用并且不是系统自检等所必需可执行文件的目录。</p>
<p>此目录相当于根文件系统下的对应目录（/bin），非启动系统，非修复系统以及非本地安装的程序一般都放在此目录下。</p>
<h3 id="usr-sbin"><a href="#usr-sbin" class="headerlink" title="/usr/sbin"></a>/usr/sbin</h3><p>管理员使用的非系统必须的可执行文件存放目录。</p>
<p>此目录相当于根文件系统下的对应目录（/sbin），保存系统管理程序的二进制文件，并且这些文件不是系统启动或文件系统挂载 /usr 目录或修复系统所必需的。</p>
<h3 id="usr-share"><a href="#usr-share" class="headerlink" title="/usr/share"></a>/usr/share</h3><p>存放共享文件的目录。</p>
<p>在此目录下不同的子目录中保存了同一个操作系统在不同构架下工作时特定应用程序的共享数据（例如程序文档信息）。使用者可以找到通常放在 /usr/doc 或 /usr/lib 或 /usr/man 目录下的这些类似数据。</p>
<h3 id="usr-include"><a href="#usr-include" class="headerlink" title="/usr/include"></a>/usr/include</h3><p>C 程序语言编译使用的头文件。</p>
<p>linux 下开发和编译应用程序所需要的头文件一般都存放在这里，通过头文件来使用某些库函数。默认来说这个路径被添加到了环境变量中，这样编译开发程序的时候编译器会自动搜索这个路径，从中找到你的程序中可能包含的头文件。</p>
<h3 id="usr-local"><a href="#usr-local" class="headerlink" title="/usr/local"></a>/usr/local</h3><p>安装本地程序的一般默认路径。</p>
<p>当我们下载一个程序源代码，编译并且安装的时候，如果不特别指定安装的程序路径，那么默认会将程序相关的文件安装到这个目录的对应目录下。例如，安装的程序可执行文件被安装（安装实质就是复制到了 /usr/local/bin 下面，此程序可执行文件所需要依赖的库文件被安装到了/usr/local/lib目录下），被安装的软件如果是某个开发库（例如 Qt，Gtk 等）那么相应的头文件可能就被安装到了 /usr/local/include 中等等。也就是说，这个目录存放的内容，一般都是我们后来自己安装的软件的默认路径，如果择了这个默认路径作为软件的安装路径，被安装的软件的所文件都限制在这个目录中，其中的子目录就相应于根目录的子目录。</p>
<h3 id="proc"><a href="#proc" class="headerlink" title="/proc"></a>/proc</h3><p>特殊文件目录。</p>
<p>这个目录采用一种特殊的文件系统格式（proc 格式，内核支持这种格式。其中包含了全部虚拟文件。它们并不保存在磁盘中，也不占据磁盘空间（尽管命令 ls -c 会显示它们的大小）。当您查看它们时，您实际上看到的是内存里的信息，这些文件助于我们了解系统内部信息。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">├1/ 关于进程1的信息目录。每个进程在/proc 下一个名为其进程号的目录。</span><br><span class="line">├cpuinfo 处理器信息，如类型、制造商、型号和性能。</span><br><span class="line">├devices 当前运行的核心配置的设备驱动的列表。</span><br><span class="line">├dma 显示当前使用的DMA通道。</span><br><span class="line">├filesystems 核心配置的文件系统。</span><br><span class="line">├interrupts 显示使用的中断，and how many of each there have been.</span><br><span class="line">├ioports 当前使用的I/O端口。</span><br><span class="line">├kcore 系统物理内存映象。与物理内存大小一样，但实际不占这么多内存；</span><br><span class="line">├kmsg 核心输出的消息。也被送到syslog 。</span><br><span class="line">├ksyms 核心符号表。</span><br><span class="line">├loadavg 系统”平均负载”；3个没意义的指示器指出系统当前的工作量。</span><br><span class="line">├meminfo 存储器使用信息，包括物理内存和swap。</span><br><span class="line">├modules 当前加载了哪些核心模块。</span><br><span class="line">├net 网络协议状态信息。</span><br><span class="line">├self 到查看/proc 的程序的进程目录的符号连接。</span><br><span class="line">├stat 系统的不同状态</span><br><span class="line">├uptime 系统启动的时间长度。</span><br><span class="line">└version 核心版本。</span><br></pre></td></tr></table></figure>

<h3 id="opt"><a href="#opt" class="headerlink" title="/opt"></a>/opt</h3><p>可择的文件目录。</p>
<p>这个目录表示的是可择的意思，些自定义软件包或者第方工具，就可以安装在这里。比如在 Fedora Core 5.0 中，OpenOffice 就是安装在这里。些我们自己编译的软件包，就可以安装在这个目录中；通过源码包安装的软件，可以把它们的安装路径设置成 /opt 这样来安装。这个目录的作用一点类似 /usr/local。</p>
<h3 id="mnt"><a href="#mnt" class="headerlink" title="/mnt"></a>/mnt</h3><p>临时挂载目录。</p>
<p>这个目录一般是用于存放挂载储存设备的挂载目录的，比如磁盘，光驱，网络文件系统等，当我们需要挂载某个磁盘设备的时候，可以把磁盘设备挂载到这个目录上去，这样我们可以直接通过访问这个目录来访问那个磁盘了。一般来说，我们最好在 /mnt 目录下面多建立几个子目录，挂载的时候挂载到这些子目录上面，因为通常我们可能不仅仅是挂载一个设备吧。</p>
<h3 id="media"><a href="#media" class="headerlink" title="/media"></a>/media</h3><p>挂载的媒体设备目录。</p>
<p>挂载的媒体设备目录，一般外部设备挂载到这里，例如 cdrom 等。比如我们插入一个 U 盘，我们一般会发现，Linux 自动在这个目录下建立一个 disk 目录，然后把U盘挂载到这个 disk 目录上，通过访问这个 disk 来访问 U 盘。</p>
<h3 id="var"><a href="#var" class="headerlink" title="/var"></a>/var</h3><p>内容经常变化的目录。</p>
<p>此目录下文件的大小可能会改变，如缓冲文件，日志文件，缓存文件，等一般都存放在这里。</p>
<h3 id="tmp"><a href="#tmp" class="headerlink" title="/tmp"></a>/tmp</h3><p>临时文件目录。</p>
<p>该目录存放系统中的一些临时文件，文件可能会被系统自动清空。系统直接把 tmpfs 类型的文件系统挂载到这个目录上，tmpfs 文件系统由 Linux 内核支持，在这个文件系统中的数据，实际上是内存中的，由于内存的数据断电易失，当系统重新启动的时候我们就会发现这个目录被清空了。</p>
<h3 id="lost-found"><a href="#lost-found" class="headerlink" title="/lost+found"></a>/lost+found</h3><p>恢复文件存放的位置。</p>
<p>当系统崩溃的时候，在系统修复过程中需要恢复的文件，可能就会在这里被找到了，这个目录一般为空。</p>
<p>另外，有些目录初学者容易混淆，这里简单区分一下：</p>
<p>/bin，/sbin 与 /usr/bin，/usr/sbin：</p>
<ul>
<li>/bin：一般存放对于用户和系统来说“必须”的程序（二进制文件）。</li>
<li>/sbin：一般存放用于系统管理的“必需”的程序（二进制文件），一般普通用户不会使用，根用户使用。</li>
<li>/usr/bin：一般存放的只是对用户和系统来说“不是必需的”程序（二进制文件）。</li>
<li>/usr/sbin：一般存放用于系统管理的系统管理的不是必需的程序（二进制文件）。</li>
</ul>
<p>/lib 与 /usr/lib（/lib 和 /usr/lib 的区别类似 /bin，/sbin 与 /usr/bin，/usr/sbin）：</p>
<ul>
<li>/lib：一般存放对于用户和系统来说“必须”的库（二进制文件）。</li>
<li>/usr/lib：一般存放的只是对用户和系统来说“不是必需的”库（二进制文件）。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wetts.github.io/2020/03/14/%E7%B3%BB%E7%BB%9F%E3%80%81%E6%9C%8D%E5%8A%A1%E5%99%A8/%E7%B3%BB%E7%BB%9F/VM/VM-%E4%B8%89%E7%A7%8D%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Zhang Wetts">
      <meta itemprop="description" content="Stay Hungry, Stay Foolish. <br><br><p style="font-size:8px;">[build by hexo/next/gitalk/hexo-generator-search/LaTeX]</p>">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wetts's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/14/%E7%B3%BB%E7%BB%9F%E3%80%81%E6%9C%8D%E5%8A%A1%E5%99%A8/%E7%B3%BB%E7%BB%9F/VM/VM-%E4%B8%89%E7%A7%8D%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%BC%8F/" class="post-title-link" itemprop="url">VM-三种网络模式</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-03-14 14:57:32" itemprop="dateCreated datePublished" datetime="2020-03-14T14:57:32+08:00">2020-03-14</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/VM/" itemprop="url" rel="index"><span itemprop="name">VM</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>虚拟机有三种网络模式，分别是 Bridged（桥接模式）、NAT（网络地址转换模式）、Host-only（主机模式）。</p>
<h3 id="NAT（网络地址转换模式）"><a href="#NAT（网络地址转换模式）" class="headerlink" title="NAT（网络地址转换模式）"></a>NAT（网络地址转换模式）</h3><p>使用 NAT 模式，就是让虚拟系统借助 NAT 的功能，通过宿主机所在的网络来访问公网。在这种模式下宿主机成为双网卡主机，同时参与现有的宿主局域网和新建的虚拟局域网，但由于加设了一个虚拟的 NAT 服务器，使得虚拟局域网内的虚拟机在对外访问时，使用的则是宿主机的IP地址，这样从外部网络来看，只能看到宿主机，完全看不到新建的虚拟局域网。</p>
<p>这种情况下虚拟机可以上网可以 ping 通主机，但是主机 ping 不通虚拟机。</p>
<p>优点：利用 Virtualbox 安装一个新的虚拟系统，在虚拟系统中不用进行任何手工配置就能直接访问互联网，只要宿主机器能访问互联网即可。</p>
<h3 id="Bridged（桥接模式）"><a href="#Bridged（桥接模式）" class="headerlink" title="Bridged（桥接模式）"></a>Bridged（桥接模式）</h3><p>在这种模式下，Virtualbox 虚拟出来的操作系统就像是局域网中的一台独立的主机，它可以访问网内任何一台机器，需要手工为虚拟系统配置 IP 地址、网掩码，而且还要和宿主机器处于同一网段，这样虚拟系统才能和宿主机器进行通信，虚拟系统和宿主机器的关系，就像连接在同一个 Hub 上的两台电脑。从网络技术上理解相当于在宿主机前端加设了一个虚拟交换机，然后宿主机和所有虚拟机共享这个交换机。</p>
<p>这种情况下主机和虚拟机可以互相通信，虚拟机也可以上外网。</p>
<p>优点：利用 Virtualbox 在局域网内新建一个虚拟服务器，为局域网用户提供网络服务。</p>
<h3 id="Host-only（主机模式）"><a href="#Host-only（主机模式）" class="headerlink" title="Host-only（主机模式）"></a>Host-only（主机模式）</h3><p>在某些特殊的网络调试环境中，要求将真实环境和虚拟环境隔离开，这时就可采用 host-only 模式，在这种模式下宿主机上的所有虚拟机是可以相互通信的，但虚拟机和真实的网络是被隔离开的。</p>
<p>在这种模式下新建了一个由所有虚拟机与宿主机所构成的局域网，但该局域网与宿主机本身所处的现有局域网是相互独立的，如果不做额外路由设置，这两个局域网之间不会连通，因此新建的局域网可以认为是一个单独从属于当前宿主机的私有网络，其成员为当前宿主机和相关的所有虚拟机。</p>
<p>从网络技术上讲相当于为宿主机增添了一个虚拟网卡，让宿主机变成一台双网卡主机（宿主网卡+虚拟网卡）。同时在宿主机后端加设一个虚拟交换机，让宿主机和所有虚拟机构成另一个虚拟的局域网。由于具备双网卡，宿主机可同时参与两个局域网（现有的宿主局域网+新建的虚拟局域网），只不过缺省情况下两个局域网不连通。</p>
<p>优点：利用 Virtualbox 创建一个与网内其他机器相隔离的虚拟系统，进行某些特殊的网络调试工作。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wetts.github.io/2020/03/14/%E7%B3%BB%E7%BB%9F%E3%80%81%E6%9C%8D%E5%8A%A1%E5%99%A8/%E7%B3%BB%E7%BB%9F/vagrant/vagrant-%E7%BD%91%E7%BB%9C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Zhang Wetts">
      <meta itemprop="description" content="Stay Hungry, Stay Foolish. <br><br><p style="font-size:8px;">[build by hexo/next/gitalk/hexo-generator-search/LaTeX]</p>">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wetts's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/14/%E7%B3%BB%E7%BB%9F%E3%80%81%E6%9C%8D%E5%8A%A1%E5%99%A8/%E7%B3%BB%E7%BB%9F/vagrant/vagrant-%E7%BD%91%E7%BB%9C/" class="post-title-link" itemprop="url">vagrant-网络</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-03-14 14:37:41" itemprop="dateCreated datePublished" datetime="2020-03-14T14:37:41+08:00">2020-03-14</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/vagrant/" itemprop="url" rel="index"><span itemprop="name">vagrant</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>vagrant 中一共提供了三种网络配置。</p>
<h3 id="端口映射（Forwarded-port）"><a href="#端口映射（Forwarded-port）" class="headerlink" title="端口映射（Forwarded port）"></a>端口映射（Forwarded port）</h3><p>这种方式，就是把本机和虚拟机的端口进行映射。比如：我配置本机计算机的8080端口为虚拟机的 80 端口，这样我访问该机器的 8080 端口，vagrant 会把请求转发到虚拟机的 80 端口是那个去处理。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">config.vm.forwarded_port 80, 8080</span><br></pre></td></tr></table></figure>

<p>通过这种方式，我们可以有针对性的把虚拟机的某些端口公布到外网让其他人去访问。</p>
<p>端口转发隐含着一个 provider 的 NAT 网络将被首先创建。所以，如果你单独定义一条端口转发的配置语句的话，VM 将会自动建立 NAT 网络环境。</p>
<h3 id="私有网络（Private-network）"><a href="#私有网络（Private-network）" class="headerlink" title="私有网络（Private network）"></a>私有网络（Private network）</h3><p>这种方式是只允许主机访问虚拟机。如果多个虚拟机设定在同一个网段，那么几个虚拟机之间也可以互相访问。这种方式，就好像是搭建了一个私有的 linux 集群。而且只有一个出口，那就是该主机。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">config.vm.network &quot;private_network&quot;, ip: &quot;192.168.21.4&quot;</span><br></pre></td></tr></table></figure>

<p>使用这种方式，非常安全，因为只有一个出口，但是你的虚拟机只允许你自己进行操作。团队成员不能操作，那你的电脑就成服务器主机了。</p>
<p>值得注意的是，ip 地址“192.168.21.4”不是随便指定的。首先你可以不指定，这表示虚机启动时会 DHCP 到一个可用的 IP 地址（例如：192.168.33.101），这是 vagrant 通过 virtualbox 私有网络的 DHCP 机制获得的。如果你要自行指定明确的 IP 地址，要保证该地址是在恰当的网段中，例如 192.168.33.71。</p>
<p>多台虚拟机在私有网络模式下也可以互相访问，只要设置为相同的网段就可以。本质上说，这是使用 provider 的 HostOnly 模式。</p>
<h3 id="公有网络（Public-network）"><a href="#公有网络（Public-network）" class="headerlink" title="公有网络（Public network）"></a>公有网络（Public network）</h3><p>虚拟机享受实体机器一样的待遇，一样的网络配置，vagrant1.3 版本之后也可以设定静态 IP。设定语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">config.vm.network &quot;public_network&quot;, ip: &quot;192.168.1.120&quot;</span><br></pre></td></tr></table></figure>

<p>这种网络配置方式，方便团队开发，别人也可以访问你的虚拟机。当然，你和你的虚拟机必须在同一个网段中。</p>
<p>可以不指定ip，也可以指定 LAN 网段中的一个可用的地址，但需要注意不要和 LAN 中已有的主机或者保留的 IP 地址相冲突。</p>
<p>本质上说，这是使用 provider 的桥接网络模式。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wetts.github.io/2020/03/14/%E7%B3%BB%E7%BB%9F%E3%80%81%E6%9C%8D%E5%8A%A1%E5%99%A8/%E7%B3%BB%E7%BB%9F/Linux/Linux-%E5%91%BD%E4%BB%A4-su/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Zhang Wetts">
      <meta itemprop="description" content="Stay Hungry, Stay Foolish. <br><br><p style="font-size:8px;">[build by hexo/next/gitalk/hexo-generator-search/LaTeX]</p>">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wetts's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/14/%E7%B3%BB%E7%BB%9F%E3%80%81%E6%9C%8D%E5%8A%A1%E5%99%A8/%E7%B3%BB%E7%BB%9F/Linux/Linux-%E5%91%BD%E4%BB%A4-su/" class="post-title-link" itemprop="url">Linux-命令-su</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-03-14 12:24:24" itemprop="dateCreated datePublished" datetime="2020-03-14T12:24:24+08:00">2020-03-14</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">系统</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>su 是用户切换的命令。```</p>
<ul>
<li><code>su [user]</code>：切换到其他用户，但是不切换环境变量</li>
<li><code>su - [user]</code>：则是完整的切换到新的用户环境</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wetts.github.io/2020/03/14/%E7%B3%BB%E7%BB%9F%E3%80%81%E6%9C%8D%E5%8A%A1%E5%99%A8/%E7%B3%BB%E7%BB%9F/Linux/Linux-%E5%91%BD%E4%BB%A4-apt%E4%B8%8Eapt-get%E7%9A%84%E5%8C%BA%E5%88%AB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Zhang Wetts">
      <meta itemprop="description" content="Stay Hungry, Stay Foolish. <br><br><p style="font-size:8px;">[build by hexo/next/gitalk/hexo-generator-search/LaTeX]</p>">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wetts's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/14/%E7%B3%BB%E7%BB%9F%E3%80%81%E6%9C%8D%E5%8A%A1%E5%99%A8/%E7%B3%BB%E7%BB%9F/Linux/Linux-%E5%91%BD%E4%BB%A4-apt%E4%B8%8Eapt-get%E7%9A%84%E5%8C%BA%E5%88%AB/" class="post-title-link" itemprop="url">Linux-命令-apt与apt-get的区别</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-03-14 00:50:21" itemprop="dateCreated datePublished" datetime="2020-03-14T00:50:21+08:00">2020-03-14</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">系统</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>参考：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.sysgeek.cn/apt-vs-apt-get/">https://www.sysgeek.cn/apt-vs-apt-get/</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/c58de6f018fa">https://www.jianshu.com/p/c58de6f018fa</a></li>
</ul>
<hr>
<p>Ubuntu 16.04 发布时，一个引人注目的新特性便是 <code>apt</code> 命令的引入。其实早在 2014 年，apt 命令就已经发布了第一个稳定版，只是直到 2016 年的 Ubuntu 16.04 系统发布时才开始引人关注。</p>
<p>随着 <code>apt install package</code> 命令的使用频率和普遍性逐步超过 <code>apt-get install package</code>，越来越多的其它 Linux 发行版也开始遵循 Ubuntu 的脚步，开始鼓励用户使用 <code>apt</code> 而不是 <code>apt-get</code>。</p>
<p>那么，<code>apt-get</code> 与 <code>apt</code> 命令之间到底有什么区别呢？如果它们有类似的命令结构，为什么还需要新的 <code>apt</code> 命令呢？是否 <code>apt</code> 真的比 <code>apt-get</code> 更好？普通用户应该使用新的 <code>apt</code> 命令还是坚持旧有习惯继续使用 <code>apt-get</code> 呢？</p>
<h3 id="apt-与-apt-get"><a href="#apt-与-apt-get" class="headerlink" title="apt 与 apt-get"></a>apt 与 apt-get</h3><p>在开始对比 <code>apt</code> 与 <code>apt-get</code> 命令的区别之前，我们先来看看这两个命令的背景，以及它们要试图达到的目的。</p>
<p>Debian 作为 Ubuntu、Linux Mint 和 elementary OS 等 Linux 操作系统的母板，其具有强健的「包管理」系统，它的每个组件和应用程序都内置在系统中安装的软件包中。Debian 使用一套名为 Advanced Packaging Tool（APT）的工具来管理这种包系统，不过请不要把它与 <code>apt</code> 命令混淆，它们之间是其实不是同一个东西。</p>
<p>在基于 Debian 的 Linux 发行版中，有各种工具可以与 APT 进行交互，以方便用户安装、删除和管理的软件包。<code>apt-get</code> 便是其中一款广受欢迎的命令行工具，另外一款较为流行的是 Aptitude 这一命令行与 GUI 兼顾的小工具。</p>
<p>如果你已阅读过我们的 <code>apt-get</code> 命令指南，可能已经遇到过许多类似的命令，如 <code>apt-cache</code>、<code>apt-config</code> 等。如你所见，这些命令都比较低级又包含众多功能，普通的 Linux 用户也许永远都不会使用到。换种说法来说，就是最常用的 Linux 包管理命令都被分散在了 <code>apt-get</code>、<code>apt-cache</code> 和 <code>apt-config</code> 这三条命令当中。</p>
<p><code>apt</code> 命令的引入就是为了解决命令过于分散的问题，它包括了 <code>apt-get</code> 命令出现以来使用最广泛的功能选项，以及 <code>apt-cache</code> 和 <code>apt-config</code> 命令中很少用到的功能。</p>
<p>在使用 <code>apt</code> 命令时，用户不必再由 <code>apt-get</code> 转到 <code>apt-cache</code> 或 <code>apt-config</code>，而且 <code>apt</code> 更加结构化，并为用户提供了管理软件包所需的必要选项。</p>
<blockquote>
<p>简单来说就是：<code>apt</code> = <code>apt-get</code>、<code>apt-cache</code> 和 <code>apt-config</code> 中最常用命令选项的集合。</p>
</blockquote>
<h3 id="apt-与-apt-get-之间的区别"><a href="#apt-与-apt-get-之间的区别" class="headerlink" title="apt 与 apt-get 之间的区别"></a>apt 与 apt-get 之间的区别</h3><p>通过 <code>apt</code> 命令，用户可以在同一地方集中得到所有必要的工具，<code>apt</code> 的主要目的是提供一种以「让终端用户满意」的方式来处理 Linux 软件包的有效方式。</p>
<p><code>apt</code> 具有更精减但足够的命令选项，而且参数选项的组织方式更为有效。除此之外，它默认启用的几个特性对最终用户也非常有帮助。例如，可以在使用 <code>apt</code> 命令安装或删除程序时看到进度条。</p>
<p><code>apt</code> 还会在更新存储库数据库时提示用户可升级的软件包个数。</p>
<p>如果你使用 <code>apt</code> 的其它命令选项，也可以实现与使用 <code>apt-get</code> 时相同的操作。</p>
<h4 id="apt-和-apt-get-命令之间的区别"><a href="#apt-和-apt-get-命令之间的区别" class="headerlink" title="apt 和 apt-get 命令之间的区别"></a>apt 和 apt-get 命令之间的区别</h4><p>虽然 <code>apt</code> 与 <code>apt-get</code> 有一些类似的命令选项，但它并不能完全向下兼容 <code>apt-get</code> 命令。也就是说，可以用 <code>apt</code> 替换部分 <code>apt-get</code> 系列命令，但不是全部。</p>
<table>
<thead>
<tr>
<th align="center">apt 命令</th>
<th align="center">取代的命令</th>
<th align="center">命令的功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center">apt install</td>
<td align="center">apt-get install</td>
<td align="center">安装软件包</td>
</tr>
<tr>
<td align="center">apt remove</td>
<td align="center">apt-get remove</td>
<td align="center">移除软件包</td>
</tr>
<tr>
<td align="center">apt purge</td>
<td align="center">apt-get purge</td>
<td align="center">移除软件包及配置文件</td>
</tr>
<tr>
<td align="center">apt update</td>
<td align="center">apt-get update</td>
<td align="center">刷新存储库索引</td>
</tr>
<tr>
<td align="center">apt upgrade</td>
<td align="center">apt-get upgrade</td>
<td align="center">升级所有可升级的软件包</td>
</tr>
<tr>
<td align="center">apt autoremove</td>
<td align="center">apt-get autoremove</td>
<td align="center">自动删除不需要的包</td>
</tr>
<tr>
<td align="center">apt full-upgrade</td>
<td align="center">apt-get dist-upgrade</td>
<td align="center">在升级软件包时自动处理依赖关系</td>
</tr>
<tr>
<td align="center">apt search</td>
<td align="center">apt-cache search</td>
<td align="center">搜索应用程序</td>
</tr>
<tr>
<td align="center">apt show</td>
<td align="center">apt-cache show</td>
<td align="center">显示装细节</td>
</tr>
</tbody></table>
<p>当然，<code>apt</code> 还有一些自己的命令：</p>
<table>
<thead>
<tr>
<th align="center">新的apt命令</th>
<th align="center">命令的功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center">apt list</td>
<td align="center">列出包含条件的包（已安装，可升级等）</td>
</tr>
<tr>
<td align="center">apt edit-sources</td>
<td align="center">编辑源列表</td>
</tr>
</tbody></table>
<p>需要大家注意的是：<code>apt</code> 命令也还在不断发展，因此，你可能会在将来的版本中看到新的选项。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wetts.github.io/2020/03/12/%E5%A4%A7%E6%95%B0%E6%8D%AE/HBase/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Zhang Wetts">
      <meta itemprop="description" content="Stay Hungry, Stay Foolish. <br><br><p style="font-size:8px;">[build by hexo/next/gitalk/hexo-generator-search/LaTeX]</p>">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wetts's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/12/%E5%A4%A7%E6%95%B0%E6%8D%AE/HBase/" class="post-title-link" itemprop="url">HBase.md</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-03-12 18:59:31" itemprop="dateCreated datePublished" datetime="2020-03-12T18:59:31+08:00">2020-03-12</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Hadoop/" itemprop="url" rel="index"><span itemprop="name">Hadoop</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>HBase 利用 Hadoop MapReduce 来处理 HBase 中的海量数据，实现高性能计算；利用 Zookeeper 作为协同服务，实现稳定服务和失败恢复；使用 HDFS 作为高可靠的底层存储，利用廉价集群提供海量数据存储能力。当然，HBase 也可以直接使用本地文件系统而不用 HDFS 作为底层数据存储方式，不过，为了提高数据可靠性和系统的健壮性，发挥 HBase 处理大数据量等功能，一般都使用 HDFS 作为 HBase 的底层数据存储方式。此外，为了方便在 HBase 上进行数据处理，Sqoop 为 HBase 提供了高效、便捷的 RDBMS 数据导人功能，Pig 和 Hive 为 HBase 提供了高层语言支持。HBase 是 BigTable 的开源实现。</p>
<p><img src="/2020/03/12/%E5%A4%A7%E6%95%B0%E6%8D%AE/HBase/HBase%E4%B8%8E%E5%85%B6%E4%BB%96%E9%83%A8%E5%88%86%E7%9A%84%E5%85%B3%E7%B3%BB.png" alt="HBase与其他部分的关系"></p>
<p><img src="/2020/03/12/%E5%A4%A7%E6%95%B0%E6%8D%AE/HBase/HBase%E4%B8%8EBigTable.png" alt="HBase与BigTable"></p>
<h2 id="HBase-数据模型"><a href="#HBase-数据模型" class="headerlink" title="HBase 数据模型"></a>HBase 数据模型</h2><h3 id="数据模型概述"><a href="#数据模型概述" class="headerlink" title="数据模型概述"></a>数据模型概述</h3><p>HBase 是一个稀疏、多维度、排序的映射表，这张表的索引是行键、列族、列限定符和时间戳。每个值是一个未经解释的字符串，没有数据类型。用户在表中存储数据，每一行都有一个可排序的行键和任意多的列。表在水平方向由一个或者多个列族组成，同一个列族中可以包含任意多个列，同一个列族里面的数据存储在一起。列族支持动态扩展，可以很轻松地添加-个列族或列，无需预先定义列的数量以及类型，所有列均以字符串形式存储，用户需要自行进行数据类型转换。由于同-张表里面的每一行数据都可以有截然不同的列，因此对于整个映射表的每行数据而言，有些列的值就是空的，所以说 HBase 是稀疏的。</p>
<p>在 HBase 中执行更新操作时，并不会删除数据旧的版本，而是生成一个新的版本，旧有的版本仍然保留，HBase 可以对允许保留的版本的数量进行设置。客户端可以选择获取距离某个时间最近的版本，或者一次获取所有版本。如果在查询的时候不提供时间戳，那么会返回距离现在最近的那一个版本的数据，因为在存储的时候，数据会按照时间戳排序。</p>
<p>HBase 提供了两种数据版本回收方式：</p>
<ul>
<li>一是保存数据的最后 n 个版本；</li>
<li>二是保存最近一段时间内的版本(如最近7天)。</li>
</ul>
<h3 id="数据模型的相关概念"><a href="#数据模型的相关概念" class="headerlink" title="数据模型的相关概念"></a>数据模型的相关概念</h3><p><img src="/2020/03/12/%E5%A4%A7%E6%95%B0%E6%8D%AE/HBase/HBase%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B%E5%AE%9E%E4%BE%8B.png" alt="HBase数据模型实例"></p>
<h4 id="表"><a href="#表" class="headerlink" title="表"></a>表</h4><p>HBase 采用表来组织数据，表由行和列组成，列划分为若千个列族。</p>
<h4 id="行"><a href="#行" class="headerlink" title="行"></a>行</h4><p>每个 HBase 表都由若干行组成，每个行由行键（Row Key）来标识。访问表中的行只有 3 种方式：</p>
<ol>
<li>通过单个行键访问；</li>
<li>通过一个行键的区间来访问；</li>
<li>全表扫描。</li>
</ol>
<p>行键可以是任意字符串（最大长度是 64 KB，实际应用中长度一般为 10~100 字节），在 HBase 内部，行键保存为字节数组。存储时，数据按照行键的字典序排序存储。在设计行键时，要充分考虑这个特性，将经常一起读取的行存储在一起。</p>
<h4 id="列族"><a href="#列族" class="headerlink" title="列族"></a>列族</h4><p>一个 HBase 表被分组成许多“列族”的集合，它是基本的访问控制单元。列族需要在表创建时就定义好，数量不能太多（HBase 的一些缺陷使得列族数量只限于几十个），而且不要频繁修改。</p>
<p>存储在一个列族当中的所有数据，通常都属于同一种数据类型，这通常意味着具有更高的压缩率。表中的每个列都归属于某个列族，数据可以被存放到列族的某个列下面，但是在把数据存放到这个列族的某个列下面之前，必须首先创建这个列族。在创建完成一个列族以后，就可以使用同一个列族当中的列。列名都以列族作为前缀。例如，courses:history 和 courses:math 这两个列都属于 courses 这个列族。</p>
<p>在 HBase 中，访问控制、磁盘和内存的使用统计都是在列族层面进行的。实际应用中，我们可以借助列族上的控制权限帮助实现特定的目的。比如，我们可以允许一些应用能够向表中添加新的数据，而另一些应用则只允许浏览数据。HBase 列族还可以被配置成支持不同类型的访问模式。比如，一个列族也可以被设置成放入内存当中，以消耗内存为代价，从而换取更好的响应性能。</p>
<h4 id="列限定符"><a href="#列限定符" class="headerlink" title="列限定符"></a>列限定符</h4><p>列族里的数据通过列限定符（或列）来定位。列限定符不用事先定义，也不需要在不同行之间保持一致。列限定符没有数据类型，总被视为字节数组 byte[]。</p>
<h4 id="单元格"><a href="#单元格" class="headerlink" title="单元格"></a>单元格</h4><p>在 HBase 表中，通过行、列族和列限定符确定一个“单元格”(Cell)。单元格中存储的数据没有数据类型，总被视为字节数组 bytel]。每个单元格中可以保存一个数据的多个版本，每个版本对应一个不同的时间戳。</p>
<h4 id="时间戳"><a href="#时间戳" class="headerlink" title="时间戳"></a>时间戳</h4><p>每个单元格都保存着同一份数据的多个版本，这些版本采用时间戳进行索引。每次对一个单元格执行操作（新建、修改、删除）时，HBase 都会隐式地自动生成并存储一个时间戳。时间戳一般是 64 位整型，可以由用户自己赋值（自己生成唯一时间戳可以避免应用程序中出现数据版本冲突），也可以由 HBase 在数据写入时自动赋值。一个单元格的不同版本是根据时间戳降序的顺序进行存储的，这样，最新的版本可以被最先读取。</p>
<h3 id="数据坐标"><a href="#数据坐标" class="headerlink" title="数据坐标"></a>数据坐标</h3><p>HBase 使用坐标来定位表中的数据，也就是说，每个值都是通过坐标来访问的。对于我们熟悉的关系数据库而言，数据定位可以理解为采用“二维坐标”，即根据行和列就可以确定表中一个具体的值。但是，HBase中需要根据行键、列族、列限定符和时间戳来确定一个单元格，因此可以视为一个“四维坐标”，即 [行键，列族，列限定符，时间戳]。</p>
<h3 id="概念视图"><a href="#概念视图" class="headerlink" title="概念视图"></a>概念视图</h3><p>在 HBase 的概念视图中，一个表可以视为一个稀疏、多维的映射关系。</p>
<p><img src="/2020/03/12/%E5%A4%A7%E6%95%B0%E6%8D%AE/HBase/HBase%E6%95%B0%E6%8D%AE%E7%9A%84%E6%A6%82%E5%BF%B5%E8%A7%86%E5%9B%BE.png" alt="HBase数据的概念视图"></p>
<p>上图行键是一个反向 URL（即 com.cnn.www），之所以这样存放，是因为 HBase 是按照行键的字典序来排序存储数据的，采用反向 URL 的方式，可以让来自同一个网站的数据内容都保存在相邻的位置，在按照行键的值进行水平分区时，就可以尽量把来自同一个网站的数据划分到同一个分区（Region）中。</p>
<h3 id="物理视图"><a href="#物理视图" class="headerlink" title="物理视图"></a>物理视图</h3><p>从概念视图层面，HBase 中的每个表是由许多行组成的，但是在物理存储层面，它是采用了基于列的存储方式，而不是像传统关系数据库那样采用基于行的存储方式，这也是 HBase 和传统关系数据库的重要区别。</p>
<p><img src="/2020/03/12/%E5%A4%A7%E6%95%B0%E6%8D%AE/HBase/HBase%E6%95%B0%E6%8D%AE%E7%9A%84%E7%89%A9%E7%90%86%E8%A7%86%E5%9B%BE.png" alt="HBase数据的物理视图"></p>
<h3 id="面向列的存储"><a href="#面向列的存储" class="headerlink" title="面向列的存储"></a>面向列的存储</h3><p>行式数据库使用 NSM（N-ary Storage Model）存储模型，一个元组（或行）会被连续地存储在磁盘页中，也就是说，数据是一行一行被存储的，第一行写人磁盘页后，再继续写人第二行，依此类推。在从磁盘中读取数据时，需要从磁盘中顺序扫描每个元组的完整内容，然后从每个元组中筛选出查询所需要的属性。如果每个元组只有少量属性的值对于查询是有用的，那么 NSM 就会浪费许多磁盘空间和内存带宽。</p>
<p>列式数据库采用 DSM（Decomposition Storage Model）存储模型，它是在 1985 年提出来的，目的是最小化无用的 I/O。DSM 采用了不同于 NSM 的思路，对于采用 DSM 存储模型的关系数据库而言，DSM 会对关系进行垂直分解，并为每个属性分配一个子关系。因此，一个具有 n 个属性的关系会被分解成 n 个子关系，每个子关系单独存储，每个子关系只有当其相应的属性被请求时才会被访问。也就是说，DSM 是以关系数据库中的属性或列为单位进行存储，关系中多个元组的同一属性值（或同一列值）会被存储在一起，而一个元组中不同属性值则通常会被分别存放于不同的磁盘页中。</p>
<p><img src="/2020/03/12/%E5%A4%A7%E6%95%B0%E6%8D%AE/HBase/%E8%A1%8C%E5%BC%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E5%92%8C%E5%88%97%E5%BC%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84.png" alt="行式存储结构和列式存储结构"></p>
<ul>
<li>行式数据库主要适合于小批量的数据处理，如联机事务型数据处理，我们平时熟悉的 Oracle 和 MySQL 等关系数据库都属于行式数据库。</li>
<li>列式数据库主要适合于批量数据处理和即席查询（Ad-Hoc Query）。</li>
</ul>
<p>列式存储的优点是：</p>
<ul>
<li>可以降低 IO 开销，支持大量并发用户查询，其数据处理速度比传统方法快 100 倍，因为仅需要处理可以回答这些查询的列，而不是分类整理与特定查询无关的数据行；</li>
<li>具有较高的数据压缩比，较传统的行式数据库更加有效，甚至能达到 5 倍的效果。</li>
</ul>
<p>列式数据库主要用于数据挖掘、决策支持和地理信息系统等查询密集型系统中，因为一次查询就可以得出结果，而不必每次都要遍历所有的数据库。所以，列式数据库大多都是应用在人口统计调查、医疗分析等行业中，这种行业需要处理大量的数据统计分析，假如采用行式数据库，势必导致消耗的时间会无限放大。</p>
<p>DSM 存储模型的缺陷是：</p>
<ul>
<li>执行连接操作时需要昂贵的元组重构代价，因为一个元组的不同属性被分散到不同磁盘页中存储，当需要一个完整的元组时，就要从多个磁盘页中读取相应字段的值来重新组合得到原来的一个元组。</li>
<li>对于联机事务型数据处理而言，需要频繁对一些元组进行修改（如百货商场售出一件衣服后要立即修改库存数据），如果采用DSM存储模型，就会带来高昂的开销。</li>
</ul>
<h2 id="HBase-的实现原理"><a href="#HBase-的实现原理" class="headerlink" title="HBase 的实现原理"></a>HBase 的实现原理</h2><h3 id="HBase-的功能组件"><a href="#HBase-的功能组件" class="headerlink" title="HBase 的功能组件"></a>HBase 的功能组件</h3><p>HBase 的实现包括3个主要的功能组件：</p>
<ul>
<li>库函数，链接到每个客户端；</li>
<li>一个 Master 主服务器；</li>
<li>许多个 Region 服务器。</li>
</ul>
<hr>
<ul>
<li>Region 服务器负责存储和维护分配给自己的 Region，处理来自客户端的读写请求。</li>
<li>主服务器 Master 负责管理和维护 HBase 表的分区信息，比如，一个表被分成了哪些 Region，每个 Region 被存放在哪台 Region 服务器上，同时也负责维护 Region 服务器列表。</li>
</ul>
<p>因此，如果 Master 主服务器死机，那么整个系统都会无效。Master 会实时监测集群中的 Region 服务器，把特定的 Region 分配到可用的 Region 服务器上，并确保整个集群内部不同 Region 服务器之间的负载均衡，当某个 Region 服务器因出现故障而失效时，Master 会把该故障服务器上存储的 Region 重新分配给其他可用的 Region 服务器。除此以外，Master 还处理模式变化，如表和列族的创建。同客户端并不是直接从 Master 主服务器上读取数据，而是在获得 Region 的存储位置信息后，直接从 Region 服务器上读取数据。尤其需要指出的是，HBase 客户端并不依赖于 Master 而是借助于 Zookeeper 来获得 Region 的位置信息的，所以大多数客户端从来不和主服务器 Master 通信，这种设计方式使 Master 的负载很小。</p>
<h3 id="表和-Region"><a href="#表和-Region" class="headerlink" title="表和 Region"></a>表和 Region</h3><p>在一个 HBase 中，存储了许多表。对于每个 HBase 表而言，表中的行是根据行键的值的字典序进行维护的，表中包含的行的数量可能非常庞大，无法存储在一台机器上，需要分布存储到多台机器上。因此，需要根据行键的值对表中的行进行分区，每个行区间构成一个分区，被称为”Region”，包含了位于某个值域区间内的所有数据，它是负载均衡和数据分发的基本单位，这些 Region 会被分发到不同的 Region 服务器上。</p>
<p><img src="/2020/03/12/%E5%A4%A7%E6%95%B0%E6%8D%AE/HBase/%E4%B8%80%E4%B8%AAHBase%E8%A1%A8%E8%A2%AB%E5%88%92%E5%88%86%E6%88%90%E5%A4%9A%E4%B8%AARegion.png" alt="一个HBase表被划分成多个Region"></p>
<p>初始时，每个表只包含一个Region，随着数据的不断插入，Region 会持续增大，当一个 Region 中包含的行数量达到一个阈值时，就会被自动等分成两个新的 Region。随着表中行的数量继续增加，就会分裂出越来越多的 Region。</p>
<p><img src="/2020/03/12/%E5%A4%A7%E6%95%B0%E6%8D%AE/HBase/%E4%B8%80%E4%B8%AARegion%E5%88%86%E8%A3%82%E6%88%90%E5%A4%9A%E4%B8%AA%E6%96%B0%E7%9A%84Region.png" alt="一个Region分裂成多个新的Region"></p>
<p>每个 Region 的默认大小是 100MB 到 200MB，是 HBase 中负载均衡和数据分发的基本单位。Master 主服务器会把不同的 Region 分配到不同的 Region 服务器上，但是同一个 Region 是不会被拆分到多个 Region 服务器上的。每个 Region 服务器负责管理-个 Region 集合，通常在每个 Region 服务器上会放置 10~1000 个 Region。</p>
<p><img src="/2020/03/12/%E5%A4%A7%E6%95%B0%E6%8D%AE/HBase/%E4%B8%8D%E5%90%8CRegion%E5%88%86%E5%B8%83%E5%9C%A8%E4%B8%8D%E5%90%8CRegion%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A.png" alt="不同Region分布在不同Region服务器上"></p>
<h3 id="Region-的定位"><a href="#Region-的定位" class="headerlink" title="Region 的定位"></a>Region 的定位</h3><p>每个 Region 都有一个 RegionID 来标识它的唯一性，这样，一个 Region 标识符就可以表示成“表名 + 开始主键 + RegionID”。</p>
<p>有了 Region 标识符，就可以唯一标识每个 Region。为了定位每个 Region 所在的位置，就可以构建一张映射表，映射表的每个条目（或每行）包含两项内容，一个是 Region 标识符，另一个是 Region 服务器标识，这个条目就表示 Region 和 Region 服务器之间的对应关系，从而就可以知道某个 Region 被保存在哪个 Region 服务器中。这个映射表包含了关于 Region 的元数据（即 Region 和 Region 服务器之间的对应关系），因此也被称为“元数据表”，又名“.META.表”。</p>
<p>当一个 HBase 表中的 Region 数量非常庞大的时候，.META.表的条目就会非常多，一个服务器保存不下，也需要分区存储到不同的服务器上，因此.META.表也会被分裂成多个 Region，这时，为了定位这些 Region，就需要再构建一个新的映射表，记录所有元数据的具体位置，这个新的映射表就是“根数据表”，又名“-ROOT-表”。-ROOT-表是不能被分割的，永远只存在一个 Region 用于存放-ROOT-表，因此这个用来存放-ROOT-表的唯一一个 Region, 它的名字是在程序中被写死的，Master 主服务器永远知道它的位置。</p>
<p>综上所述，HBase 使用类似 B+树的三层结构来保存 Region 位置信息。</p>
<p><img src="/2020/03/12/%E5%A4%A7%E6%95%B0%E6%8D%AE/HBase/HBase%E7%9A%84%E4%B8%89%E5%B1%82%E7%BB%93%E6%9E%84.png" alt="HBase的三层结构"></p>
<p><img src="/2020/03/12/%E5%A4%A7%E6%95%B0%E6%8D%AE/HBase/HBase%E4%B8%89%E5%B1%82%E7%BB%93%E6%9E%84%E7%9A%84%E5%90%8D%E7%A7%B0%E5%92%8C%E4%BD%9C%E7%94%A8.png" alt="HBase三层结构的名称和作用"></p>
<p>为了加快访问速度，.META.表的全部 Region 都会被保存在内存中。假设.META.表的每行（一个映射条目）在内存中大约占用 1KB，并且每个 Region 限制为 128MB，那么，上面的三层结构可以保存的用户数据表的 Region 数目的计算方法是：(-ROOT-表能够寻址的.META.表的 Region 个数) x (每个.META.表的 Region 可以寻址的用户数据表的 Region 个数)。一个-ROOT-表最多只能有一个 Region，也就是最多只能有 128MB，按照每行（一个映射条目）占用 1KB 内存计算，128MB 空间可以容纳 128MB/1KB=2^17 行，也就是说，一个-ROOT表可以寻址 2^17 个.META.表的 Region。同理，每个.META.表的 Region 可以寻址的用户数据表的 Region 个数是 128MB/1KB=2^17。最终，三层结构可以保存的 Region 数目是 (128MB/1KB) * (128MB/1KB) = 234 个 Region。可以看出，这种数量已经足够可以满足实际应用中的用户数据存储需求。</p>
<p>客户端访问用户数据之前，需要首先访问 Zookeeper，获取-ROOT-表的位置信息，然后访问-ROOT-表，获得.META.表的信息，接着访问.META.表，找到所需的 Region 具体位于哪个 Region 服务器，最后才会到该 Region 服务器读取数据。该过程需要多次网络操作，为了加速寻址过程，一般会在客户端做缓存，把查询过的位置信息缓存起来，这样以后访问相同的数据时，就可以直接从客户端缓存中获取 Region 的位置信息，而不需要每次都经历一个“三级寻址”过程。需要注意的是，随着 HBase 中表的不断更新，Region 的位置信息可能会发生变化，但是客户端缓存并不会自己检测 Region 位置信息是否失效，而是在需要访问数据时，从缓存中获取 Region 位置信息却发现不存在的时候，才会判断出缓存失效，这时，就需要再次经历上述的“三级寻址”过程，重新获取最新的 Region 位置信息去访问数据，并用最新的 Region 位置信息替换缓存中失效的信息。</p>
<p>当一个客户端从 Zookeeper 服务器上拿到-ROOT-表的地址以后，就可以通过“三级寻址”找到用户数据表所在的 Region 服务器，并直接访问该 Region 服务器获得数据，没有必要再连接主服务器 Master。因此，主服务器的负载相对就小了很多。</p>
<h2 id="HBase-运行机制"><a href="#HBase-运行机制" class="headerlink" title="HBase 运行机制"></a>HBase 运行机制</h2><h3 id="HBase-系统架构"><a href="#HBase-系统架构" class="headerlink" title="HBase 系统架构"></a>HBase 系统架构</h3><p>HBase 的系统架构包括客户端、Zookeeper 服务器、Master 主服务器、Region 服务器。需要说明的是，HBase 一般采用 HDFS 作为底层数据存储。</p>
<p><img src="/2020/03/12/%E5%A4%A7%E6%95%B0%E6%8D%AE/HBase/HBase%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84.png" alt="HBase的系统架构"></p>
<h4 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h4><p>客户端包含访问 HBase 的接口，同时在缓存中维护着已经访问过的 Region 位置信息，用来加快后续数据访问过程。HBase 客户端使用 HBase 的 RPC 机制与 Master 和 Region 服务器进行通信。其中，对于管理类操作，客户端与 Master 进行 RPC；而对于数据读写类操作，客户端则会与 Region 服务器进行 RPC。</p>
<h4 id="Zookeeper-服务器"><a href="#Zookeeper-服务器" class="headerlink" title="Zookeeper 服务器"></a>Zookeeper 服务器</h4><p>Zookeeper 服务器并非一台单一的机器，可能是由多台机器构成的集群来提供稳定可靠的协同服务。Zookeeper 能够很容易地实现集群管理的功能，如果有多台服务器组成一个服务器集群，那么必须有一个“总管”知道当前集群中每台机器的服务状态，一旦某台机器不能提供服务，集群中其他机器必须知道，从而做出调整重新分配服务策略。同样，当增加集群的服务能力时，就会增加一台或多台服务器，同样也必须让“总管”知道。</p>
<p>在 HBase 服务器集群中，包含了一个 Master 和多个 Region 服务器，Master 就是这个 HBase 集群的“总管”，它必须知道 Region 服务器的状态。Zookeeper 就可以轻松做到这一点，每个 Region 服务器都需要到 Zookeeper 中进行注册，Zookeeper 会实时监控每个 Region 服务器的状态并通知给 Master，这样，Master 就可以通过 Zookeeper 随时感知到各个 Region 服务器的工作状态。</p>
<p>Zookeeper 不仅能够帮助维护当前的集群中机器的服务状态，而且能够帮助选出一个“总管”，让这个总管来管理集群。HBase 中可以启动多个 Master，但是 Zookeeper 可以帮助选举出一个 Master 作为集群的总管，并保证在任何时刻总有唯一一个 Master 在运行，这就避免了 Master 的“单点失效”问题。</p>
<p>Zookeeper 中保存了-ROOT-表的地址和 Master 的地址，客户端可以通过访问 Zookeeper 获得-ROOT-表的地址，并最终通过“三级寻址”找到所需的数据。Zookeeper 中还存储了 HBase 的模式，包括有哪些表，每个表有哪些列族。</p>
<h4 id="Master"><a href="#Master" class="headerlink" title="Master"></a>Master</h4><p>主服务器 Master 主要负责表和 Region 的管理工作。</p>
<ul>
<li>管理用户对表的增加、删除、修改、查询等操作。</li>
<li>实现不同 Region 服务器之间的负载均衡。</li>
<li>在 Region 分裂或合并后，负责重新调整 Region 的分布。</li>
<li>对发生故障失效的 Region 服务器上的 Region 进行迁移。</li>
</ul>
<p>客户端访问 HBase 上数据的过程并不需要 Master 的参与，客户端可以访问 Zookeeper 获取-ROOT-表的地址，并最终到达相应的 Region 服务器进行数据读写，Master 仅仅维护着表和 Region 的元数据信息，因此负载很低。</p>
<p>任何时刻，一个 Region 只能分配给一个 Region 服务器。Master 维护了当前可用的 Region 服务器列表，以及当前哪些 Region 分配给了哪些 Region 服务器，哪些 Region 还未被分配。当存在未被分配的 Region，并且有一个 Region 服务器上有可用空间时，Master 就给这个 Region 服务器发送一个请求，把该 Region 分配给它。Region 服务器接受请求并完成数据加载后，就开始负责管理该 Region 对象，并对外提供服务。</p>
<h4 id="Region-服务器"><a href="#Region-服务器" class="headerlink" title="Region 服务器"></a>Region 服务器</h4><p>Region 服务器是 HBase 中最核心的模块，负责维护分配给自己的 Region，并响应用户的读写请求。HBase 一般采用 HDFS 作为底层存储文件系统，因此 Region 服务器需要向 HDFS 文件系统中读写数据。采用 HDFS 作为底层存储，可以为 HBase 提供可靠稳定的数据存储，HBase 自身并不具备数据复制和维护数据副本的功能，而HDFS可以为 HBase 提供这些支持。当然，HBase 也可以不采用 HDFS，而是使用其他任何支持 Hadoop 接口的文件系统作为底层存储，比如本地文件系统或云计算环境中的 AmazonS3(Simple Storage Service)。</p>
<h3 id="Region-服务器的工作原理"><a href="#Region-服务器的工作原理" class="headerlink" title="Region 服务器的工作原理"></a>Region 服务器的工作原理</h3><p>Region 服务器是 HBase 中最核心的模块，Region 服务器内部管理了一系列 Region 对象和一个 HLog 文件，其中 HLog 是磁盘上面的记录文件，它记录着所有的更新操作。每个 Region 对象又是由多个 Store 组成的，每个 Store 对应了表中的一个列族的存储。每个 Store 又包含了一个 MemStore 和若千个 StoreFile。</p>
<ul>
<li>MemStore 是在内存中的缓存，保存最近更新的数据; </li>
<li>StoreFile 是磁盘中的文件，这些文件都是 B 树结构的，方便快速读取。StoreFile 在底层的实现方式是 HDFS 文件系统的 HFile, HFile 的数据块通常采用压缩方式存储，压缩之后可以大大减少网络 I/0 和磁盘 I/O。</li>
</ul>
<p><img src="/2020/03/12/%E5%A4%A7%E6%95%B0%E6%8D%AE/HBase/Region%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%90%91HDFS%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E4%B8%AD%E8%AF%BB%E5%86%99%E6%95%B0%E6%8D%AE.png" alt="Region服务器向HDFS文件系统中读写数据"></p>
<h4 id="用户读写数据的过程"><a href="#用户读写数据的过程" class="headerlink" title="用户读写数据的过程"></a>用户读写数据的过程</h4><p>当用户写入数据时，会被分配到相应的 Region 服务器去执行操作。用户数据首先被写人到 MemStore 和 HLog 中，当操作写入 HLog 之后，commit() 调用才会将其返回给客户端。</p>
<p>当用户读取数据时，Region 服务器会首先访问 MemStore 缓存，如果数据不在缓存中，才会到磁盘上面的 StoreFile 中去寻找。</p>
<h4 id="缓存的刷新"><a href="#缓存的刷新" class="headerlink" title="缓存的刷新"></a>缓存的刷新</h4><p>MemStore 缓存的容量有限，系统会周期性地调用 Region.flushcache() 把 MemStore 缓存里面的内容写到磁盘的 StoreFile 文件中，清空缓存，并在 HLog 文件中写入一个标记，用来表示缓存中<br>的内容已经被写人 StoreFile 文件中。每次缓存刷新操作都会在磁盘上生成一个新的 StoreFile 文件，因此每个 Store 会包含多个 StoreFile 文件。</p>
<p>每个 Region 服务器都有一个自己的 HLog 文件，在启动的时候，每个 Region 服务器都会检查自己的 HLog 文件，确认最近一次执行缓存刷新操作之后是否发生新的写人操作。如果没有更新，说明所有数据已经被永久保存到磁盘的 StoreFile 文件中；如果发现更新，就先把这些更新写人 MemStore，然后再刷新缓存，写人到磁盘的 StoreFile 文件中。最后，删除旧的 HLog 文件，并开始为用户提供数据访问服务。</p>
<h4 id="StoreFile-的合并"><a href="#StoreFile-的合并" class="headerlink" title="StoreFile 的合并"></a>StoreFile 的合并</h4><p>每次 MemStore 缓存的刷新操作都会在磁盘上生成一个新的 StoreFile 文件，这样，系统中的每个 Store 就会存在多个 StoreFile 文件。当需要访问某个 Store 中的某个值时，就必须查找所有这些 StoreFile 文件，非常耗费时间。因此，为了减少查找时间，系统一般会调用 Store.compact() 把多个 StoreFile 文件合并成一个大文件。由于合并操作比较耗费资源，因此只会在 StoreFile 文件的数量达到一个阈值的时候才会触发合并操作。</p>
<h3 id="Store-的工作原理"><a href="#Store-的工作原理" class="headerlink" title="Store 的工作原理"></a>Store 的工作原理</h3><p>Region 服务器是 HBase 的核心模块，而 Store 则是 Region 服务器的核心。每个 Store 对应了表中的一个列族的存储。每个 Store 包含一个 MemStore 缓存和若于个 StoreFile 文件。MemStore 是排序的内存缓冲区，当用户写入数据时，系统首先把数据放人 MemStore 缓存，当 MemStore 缓存满时，就会刷新到磁盘中的一个 StoreFile 文件中。随着 StoreFile 文件数量的不断增加，当达到事先设定的数量时，就会触发文件合并操作，多个 StoreFile 文件会被合并成一个大的 StoreFile 文件。当多个 StoreFile 文件合并后，会逐步形成越来越大的 StoreFile 文件，当单个 StoreFile 文件大小超过一定阈值时，就会触发文件分裂操作。同时，当前的 1 个父 Region 会被分裂成 2 个子 Region, 父 Region 会下线，新分裂出的 2 个子 Region 会被 Master 分配到相应的 Region 服务器上。</p>
<p><img src="/2020/03/12/%E5%A4%A7%E6%95%B0%E6%8D%AE/HBase/StoreFile%E7%9A%84%E5%90%88%E5%B9%B6%E5%92%8C%E5%88%86%E8%A3%82%E8%BF%87%E7%A8%8B.png" alt="StoreFile的合并和分裂过程"></p>
<h3 id="HLog-的工作原理"><a href="#HLog-的工作原理" class="headerlink" title="HLog 的工作原理"></a>HLog 的工作原理</h3><p>在分布式环境下，必须要考虑到系统出错的情形，比如当 Region 服务器发生故障时，MemStore 缓存中的数据（还没有被写人文件）会全部丢失。因此，HBase 采用 HLog 来保证系统发生故障时能够恢复到正确的状态。</p>
<p>HBase 系统为每个 Region 服务器配置了一个 HLog 文件，它是一种预写式日志（Write Ahead Log），也就是说，用户更新数据必须首先被记人日志后才能写人 MemStore 缓存，并且直到 MemStore 缓存内容对应的日志已经被写入磁盘之后，该缓存内容才会被刷新写入磁盘。</p>
<p>Zookeeper 会实时监测每个 Region 服务器的状态，当某个 Region 服务器发生故障时，Zookeeper 会通知 Master。Master 首先会处理该故障 Region 服务器上面遗留的 HLog 文件，由于一个 Region 服务器上面可能会维护着多个 Region 对象，这些 Region 对象共用一个HLog文件，因此这个遗留的 HLog 文件中包含了来自多个 Region 对象的日志记录。系统会根据每条日志记录所属的 Region 对象对 HLog 数据进行拆分，分别放到相应 Region 对象的目录下，然后再将失效的 Region 重新分配到可用的 Region 服务器中，并把与该 Region 对象相关的 HLog 日志记录也发送给相应的 Region 服务器。Region 服务器领取到分配给自己的 Region 对象以及与之相关的 HLog 日志记录以后，会重新做一遍日志记录中的各种操作，把日志记录中的数据写人 MemStore 缓存，然后刷新到磁盘的 StoreFile 文件中，完成数据恢复。</p>
<p>需要特别指出的是，HBase 系统中，每个 Region 服务器只需要维护一个 HLog 文件，所有 Region 对象共用一个 HLog，而不是每个 Region 使用一个 HLog。在这种 Region 对象共用一个 HLog 的方式中，多个 Region 对象的更新操作所发生的日志修改，只需要不断把日志记录追加到单个日志文件中，而不需要同时打开、写入到多个日志文件中，因此可以减少磁盘寻址次数，提高对表的写操作性能。这种方式的缺点是，如果个 Region 服务器发生故障，为了恢复其上的 Region 对象，需要将 Region 服务器上的 HLog 按照其所属的 Region 对象进行拆分，然后分发到其他 Region 服务器上执行恢复操作。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wetts.github.io/2020/03/12/%E5%A4%A7%E6%95%B0%E6%8D%AE/HDFS/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Zhang Wetts">
      <meta itemprop="description" content="Stay Hungry, Stay Foolish. <br><br><p style="font-size:8px;">[build by hexo/next/gitalk/hexo-generator-search/LaTeX]</p>">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wetts's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/12/%E5%A4%A7%E6%95%B0%E6%8D%AE/HDFS/" class="post-title-link" itemprop="url">HDFS</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-03-12 14:21:34" itemprop="dateCreated datePublished" datetime="2020-03-12T14:21:34+08:00">2020-03-12</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Hadoop/" itemprop="url" rel="index"><span itemprop="name">Hadoop</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>HDFS（Hadoop Distributed File System，Hadoop 分布式文件系统）</p>
<h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><h3 id="块"><a href="#块" class="headerlink" title="块"></a>块</h3><p>在传统的文件系统中，为了提高磁盘读写效率，一般以数据块为单位，而不是以字节为单位。比如，机械式硬盘（磁盘的一种）包含了磁头和转动部件，在读取数据时有一个寻道的过程，通过转动盘片和移动磁头的位置，来找到数据在机械式硬盘中的存储位置，然后才能进行读写。在 I/O 开销中，机械式硬盘的寻址时间是最耗时的部分，一旦找到第条记录，剩下的顺序读取效率是非常高的。因此，以块为单位读写数据，可以把磁盘寻道时间分摊到大量数据中。</p>
<p>HDFS 也同样采用了块的概念，默认的一个块大小是 64 MB。</p>
<p>当客户端需要访问一个文件时，首先从名称节点获得组成这个文件的数据块的位置列表，然后根据位置列表获取实际存储各个数据块的数据节点的位置，最后数据节点根据数据块信息在本地 Linux 文件系统中找到对应的文件，并把数据返回给客户端。</p>
<h3 id="名称节点"><a href="#名称节点" class="headerlink" title="名称节点"></a>名称节点</h3><p>名称节点（NameNode）负责管理分布式文件系统的命名空间（Namespace），保存了两个核心的数据结构，即 FsImage 和 EditLog。</p>
<ul>
<li>FsImage：维护文件系统树以及文件树中所有的文件和文件夹的元数据。</li>
<li>EditLog：记录了所有针对文件的创建、删除、重命名等操作。</li>
</ul>
<p><img src="/2020/03/12/%E5%A4%A7%E6%95%B0%E6%8D%AE/HDFS/%E5%90%8D%E7%A7%B0%E8%8A%82%E7%82%B9%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png" alt="名称节点的数据结构"></p>
<p>名称节点记录了每个文件中各个块所在的数据节点的位置信息，但是并不持久化存储这些信息，而是在系统每次启动时扫描所有数据节点重构得到这些信息。</p>
<h3 id="数据节点"><a href="#数据节点" class="headerlink" title="数据节点"></a>数据节点</h3><p>数据节点（DataNode）是分布式文件系统HDFS的工作节点，负责数据的存储和读取，会根据客户端或者名称节点的调度来进行数据的存储和检索，并且向名称节点定期发送自己所存储的块的列表。每个数据节点中的数据会被保存在各自节点的本地Linux文件系统中。</p>
<h3 id="第二名称节点"><a href="#第二名称节点" class="headerlink" title="第二名称节点"></a>第二名称节点</h3><p>在名称节点运行期间，HDFS会不断发生更新操作，这些更新操作都是直接被写人到 EditLog 文件，因此 EditLog 文件也会逐渐变大。在名称节点运行期间，不断变大的 EditLog 文件通常对于系统性能不会产生显著影响，但是当名称节点重启时，需要将 FsImage 加载到内存中，然后逐条执行 EditLog 中的记录，使得 FsImage 保持最新。可想而知，如果 EditLog 很大，就会导致整个过程变得非常缓慢，使得名称节点在启动过程中长期处于“安全模式”，无法正常对外提供写操作，影响了用户的使用。</p>
<p>为了有效解决 EditLog 逐渐变大带来的问题，HDFS 在设计中采用了第二名称节点（Secondary NameNode）。第二名称节点是 HDFS 架构的一个重要组成部分，具有两个方面的功能：</p>
<ul>
<li>首先，可以完成 EditLog 与 Fslmage 的合并操作，减小 EditLog 文件大小，缩短名称节点重启时间；</li>
<li>其次，可以作为名称节点的“检查点”，保存名称节点中的元数据信息。</li>
</ul>
<p>具体如下：</p>
<ol>
<li>EditLog 与 Fslmage 的合并操作。每隔一段时间，第二名称节点会和名称节点通信，请求其停止使用 EditLog 文件（这里假设这个时刻为 t），暂时将新到达的写操作添加到一个新的文件 EditLog.new 中。然后，第二名称节点把名称节点中的 FsImage 文件和 EditLog 文件拉回到本地，再加载到内存中；对二者执行合并操作，即在内存中逐条执行 EditLog 中的操作，使得 FsImage 保持最新。合并结束后，第二名称节点会把合并后得到的最新的 FsImage 文件发送到名称节点。名称节点收到后，会用最新的 FsImage 文件去替换旧的 FsImage 文件，同时用 EditLog.new 文件去替换 EditLog 文件（这里假设这个时刻为 t2），从而减小了，EditLog 文件的大小。</li>
<li>作为名称节点的“检查点”。从上面的合并过程可以看出，第二名称节点会定期和名称节点通信，从名称节点获取 FsImage 文件和 EditLog 文件，执行合并操作得到新的 FsImage 文件。从这个角度来讲，第二名称节点相当于为名称节点设置了一个“检查点”，周期性地备份名称节点中的元数据信息，当名称节点发生故障时，就可以用第二名称节点中记录的元数据信息进行系统恢复。但是，在第二名称节点上合并操作得到的新的 FsImage 文件是合并操作发生时（即 t1 时刻）HDFS 记录的元数据信息，并没有包含 t1 时刻和 t2 时刻期间发生的更新操作，如果名称节点在 t1 时刻和 t2 时刻期间发生故障，系统就会丢失部分元数据信息，在 HDFS 的设计中，也并不支持把系统直接切换到第二名称节点，因此从这个角度来讲，第二名称节点只是起到了名称节点的“检查点”作用，并不能起到“热备份”作用。即使有了第二名称节点的存在，当名称节点发生故障时，系统还是有可能会丢失部分元数据信息的。</li>
</ol>
<p><img src="/2020/03/12/%E5%A4%A7%E6%95%B0%E6%8D%AE/HDFS/%E7%AC%AC%E4%BA%8C%E5%90%8D%E7%A7%B0%E8%8A%82%E7%82%B9%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="第二名称节点工作过程示意图"></p>
<h2 id="HDFS-体系结构"><a href="#HDFS-体系结构" class="headerlink" title="HDFS 体系结构"></a>HDFS 体系结构</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p><img src="/2020/03/12/%E5%A4%A7%E6%95%B0%E6%8D%AE/HDFS/HDFS%E7%9A%84%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.png" alt="HDFS的体系结构"></p>
<h3 id="HDFS-命名控件管理"><a href="#HDFS-命名控件管理" class="headerlink" title="HDFS 命名控件管理"></a>HDFS 命名控件管理</h3><p>HDFS 的命名空间包含目录、文件和块。命名空间管理是指命名空间支持对 HDFS 中的目录、文件和块做类似文件系统的创建、修改、删除等基本操作。在当前的 HDFS 体系结构中，在整个 HDFS 集群中只有一个命名空间，并且只有唯一一个名称节点，该节点负责对这个命名空间进行管理。</p>
<p>HDFS 使用的是传统的分级文件体系，因此用户可以像使用普通文件系统样，创建、删除目录和文件，在目录间转移文件、重命名文件等。但是，HDFS 还没有实现磁盘配额和文件访问权限等功能，也不支持文件的硬连接和软连接（快捷方式）。</p>
<h3 id="通信协议"><a href="#通信协议" class="headerlink" title="通信协议"></a>通信协议</h3><p>HDFS 是一个部署在集群上的分布式文件系统，因此很多数据需要通过网络进行传输。所有的 HDFS 通信协议都是构建在 TCP/IP 协议基础之上的。客户端通过一个可配置的端口向名称节点主动发起 TCP 连，并使用客户端协议与名称节点进行交互。名称节点和数据节点之间则使用数据节点协议进行交互。客户端与数据节点的交互是通过 RPC（Remote Procedure Call）来实现的。在设计上，名称节点不会主动发起 RPC，而是响应来自客户端和数据节点的 RPC 请求。</p>
<h3 id="HDFS-体系结构的局限性"><a href="#HDFS-体系结构的局限性" class="headerlink" title="HDFS 体系结构的局限性"></a>HDFS 体系结构的局限性</h3><p>HDFS只设置唯一一个名称节点，这样做虽然大大简化了系统设计，但也带来了一些明显的局限性，具体如下。</p>
<ol>
<li>命名空间的限制。名称节点是保存在内存中的，因此名称节点能够容纳对象（文件、块）的个数会受到内存空间大小的限制。</li>
<li>性能的瓶颈。整个分布式文件系统的吞吐量受限于单个名称节点的吞吐量。</li>
<li>隔离问题。由于集群中只有一个名称节点，只有一个命名空间，因此无法对不同应用程序进行隔离。</li>
<li>集群的可用性。一旦这个唯一的名称节点发生故障，会导致整个集群变得不可用。</li>
</ol>
<h2 id="HDFS-的存储原理"><a href="#HDFS-的存储原理" class="headerlink" title="HDFS 的存储原理"></a>HDFS 的存储原理</h2><h3 id="数据的冗余存储"><a href="#数据的冗余存储" class="headerlink" title="数据的冗余存储"></a>数据的冗余存储</h3><p>HDFS 采用了多副本方式对数据进行冗余存储，通常一个数据块的多个副本会被分布到不同的数据节点上。</p>
<p><img src="/2020/03/12/%E5%A4%A7%E6%95%B0%E6%8D%AE/HDFS/HDFS%E6%95%B0%E6%8D%AE%E5%9D%97%E5%A4%9A%E5%89%AF%E6%9C%AC%E5%AD%98%E5%82%A8.png" alt="HDFS数据块多副本存储"></p>
<p>多副本方式具有以下 3 个优点：</p>
<ol>
<li>加快数据传输速度。当多个客户端需要同时访问同个文件时，可以让各个客户端分别从不同的数据块副本中读取数据，这就大大加快了数据传输速度。</li>
<li>容易检查数据错误。HDFS 的数据节点之间通过网络传输数据，采用多个副本可以很容易判断数据传输是否出错。</li>
<li>保证数据的可靠性。即使某个数据节点出现故障失效，也不会造成数据丢失。</li>
</ol>
<h3 id="数据存取策略"><a href="#数据存取策略" class="headerlink" title="数据存取策略"></a>数据存取策略</h3><h4 id="数据存放"><a href="#数据存放" class="headerlink" title="数据存放"></a>数据存放</h4><p>HDFS 默认的冗余复制因子是 3，每一个文件块会被同时保存到 3 个地方，其中，有两份副本放在同一个机架的不同机器上面，第三个副本放在不同机架的机器上面，这样既可以保证机架发生异常时的数据恢复，也可以提高数据读写性能（同机架内带宽高）。一般而言，HDFS 副本的放置策略如下：</p>
<ol>
<li>如果是在集群内发起写操作请求，则把第一个副本放置在发起写操作请求的数据节点上，实现就近写入数据。如果是来自集群外部的写操作请求，则从集群内部挑选一台磁盘不太满、CPU 不太忙的数据节点，作为第一个副本的存放地。</li>
<li>第二个副本会被放置在与第一个副本不同的机架的数据节点上。</li>
<li>第三个副本会被放置在与第一个副本相同的机架的其他节点上。</li>
<li>如果还有更多的副本，则继续从集群中随机选择数据节点进行存放。</li>
</ol>
<h4 id="数据读取"><a href="#数据读取" class="headerlink" title="数据读取"></a>数据读取</h4><p>HDFS 提供了一个 API 可以确定一个数据节点所属的机架 ID，客户端也可以调用 API 获取自已所属的机架 ID。当客户端读取数据时，从名称节点获得数据块不同副本的存放位置列表，列表中包含了副本所在的数据节点，可以调用 API 来确定客户端和这些数据节点所属的机架 ID。当发现某个数据块副本对应的机架 ID 和客户端对应的机架 ID 相同时，就优先选择该副本读取数据，如果没有发现，就随机选择-个副本读取数据。</p>
<h4 id="数据复制"><a href="#数据复制" class="headerlink" title="数据复制"></a>数据复制</h4><p>HDFS 的数据复制采用了流水线复制的策略，大大提高了数据复制过程的效率。当客户端要往 HDFS 中写入一个文件时，这个文件会首先被写入本地，并被切分成若千个块，每个块的大小是由 HDFS 的设定值来决定的。每个块都向 HDFS 集群中的名称节点发起写请求，名称节点会根据系统中各个数据节点的使用情况，选择一个数据节点列表返回给客户端，然后客户端就把数据首先写入列表中的第一个数据节点，同时把列表传给第一个数据节点，当第一个数据节点接收到 4 KB 数据的时候，写入本地，并且向列表中的第二个数据节点发起连接请求，把自己已经接收到的 4 KB 数据和列表传给第二个数据节点，当第二个数据节点接收到 4 KB 数据的时候，写人本地，并且向列表中的第三个数据节点发起连接请求，依次类推，列表中的多个数据节点形成一条数据复制的流水线。最后，当文件写完的时候，数据复制也同时完成。</p>
<h3 id="数据错误与恢复"><a href="#数据错误与恢复" class="headerlink" title="数据错误与恢复"></a>数据错误与恢复</h3><h4 id="名称节点出错"><a href="#名称节点出错" class="headerlink" title="名称节点出错"></a>名称节点出错</h4><p>Hadoop 采用两种机制来确保名称节点的安全：</p>
<ul>
<li>第一，把名称节点上的元数据信息同步存储到其他文件系统（比如远程挂载的网络文件系统 NFS）中；</li>
<li>第二，运行一个第二名称节点，当名称节点宕机以后，可以把第二名称节点作为一种弥补措施，利用第二名称节点中的元数据信息进行系统恢复。</li>
</ul>
<h4 id="数据节点出错"><a href="#数据节点出错" class="headerlink" title="数据节点出错"></a>数据节点出错</h4><p>每个数据节点会定期向名称节点发送“心跳”信息，向名称节点报告自己的状态。当数据节点发生故障，或者网络发生断网时，名称节点就无法收到来自一些数据节点的“心跳”信息，这时这些数据节点就会被标记为“宕机”，节点上面的所有数据都会被标记为“不可读”，名称节点不会再给它们发送任何 IO 请求。</p>
<p>这时，有可能出现一种情形，即由于些数据节点的不可用，会导致一些数据块的副本数量小于冗余因子。名称节点会定期检查这种情况，一旦发现某个数据块的副本数量小于冗余因子，就会启动数据冗余复制，为它生成新的副本。HDFS 与其他分布式文件系统的最大区别就是可以调整冗余数据的位置。</p>
<h4 id="数据出错"><a href="#数据出错" class="headerlink" title="数据出错"></a>数据出错</h4><p>网络传输和磁盘错误等因素都会造成数据错误。客户端在读取到数据后，会采用 md5 和 sha1 对数据块进行校验，以确定读取到正确的数据。在文件被创建时，客户端就会对每一个文件块进行信息摘录，并把这些信息写人同一个路径的隐藏文件里面。当客户端读取文件的时候，会先读取该信息文件，然后利用该信息文件对每个读取的数据块进行校验，如果校验出错，客户端就会请求到另外一个数据节点读取该文件块，并且向名称节点报告这个文件块有错误，名称节点会定期检查并且重新复制这个块。</p>
<h2 id="HDFS-的数据读写过程"><a href="#HDFS-的数据读写过程" class="headerlink" title="HDFS 的数据读写过程"></a>HDFS 的数据读写过程</h2><h3 id="读数据的过程"><a href="#读数据的过程" class="headerlink" title="读数据的过程"></a>读数据的过程</h3><p><img src="/2020/03/12/%E5%A4%A7%E6%95%B0%E6%8D%AE/HDFS/HDFS%E8%AF%BB%E6%95%B0%E6%8D%AE%E7%9A%84%E8%BF%87%E7%A8%8B.png" alt="HDFS读数据的过程"></p>
<h3 id="写数据的过程"><a href="#写数据的过程" class="headerlink" title="写数据的过程"></a>写数据的过程</h3><p><img src="/2020/03/12/%E5%A4%A7%E6%95%B0%E6%8D%AE/HDFS/HDFS%E5%86%99%E6%95%B0%E6%8D%AE%E7%9A%84%E8%BF%87%E7%A8%8B.png" alt="HDFS写数据的过程"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/6/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><span class="page-number current">7</span><a class="page-number" href="/page/8/">8</a><span class="space">&hellip;</span><a class="page-number" href="/page/69/">69</a><a class="extend next" rel="next" href="/page/8/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Zhang Wetts"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">Zhang Wetts</p>
  <div class="site-description" itemprop="description">Stay Hungry, Stay Foolish. <br><br><p style="font-size:8px;">[build by hexo/next/gitalk/hexo-generator-search/LaTeX]</p></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">682</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">67</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">350</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/wetts" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;wetts" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:zhang.wetts@163.com" title="E-Mail → mailto:zhang.wetts@163.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Zhang Wetts</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

  


<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/hibiki.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"react":{"opacity":0}});</script></body>
</html>
