<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"wetts.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="Stay Hungry, Stay Foolish. [build by hexo&#x2F;next&#x2F;gitalk&#x2F;hexo-generator-search&#x2F;LaTeX]">
<meta property="og:type" content="website">
<meta property="og:title" content="Wetts&#39;s blog">
<meta property="og:url" content="https://wetts.github.io/page/10/index.html">
<meta property="og:site_name" content="Wetts&#39;s blog">
<meta property="og:description" content="Stay Hungry, Stay Foolish. [build by hexo&#x2F;next&#x2F;gitalk&#x2F;hexo-generator-search&#x2F;LaTeX]">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Zhang Wetts">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://wetts.github.io/page/10/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Wetts's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Wetts's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Stay Hungry, Stay Foolish.</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/wetts" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wetts.github.io/2019/10/11/%E5%B7%A5%E5%85%B7/VSCode/VSCode%E4%B8%AD%E6%B7%BB%E5%8A%A0%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Zhang Wetts">
      <meta itemprop="description" content="Stay Hungry, Stay Foolish. <br><br><p style="font-size:8px;">[build by hexo/next/gitalk/hexo-generator-search/LaTeX]</p>">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wetts's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/10/11/%E5%B7%A5%E5%85%B7/VSCode/VSCode%E4%B8%AD%E6%B7%BB%E5%8A%A0%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5/" class="post-title-link" itemprop="url">VSCode中添加代码片段</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-10-11 21:02:16" itemprop="dateCreated datePublished" datetime="2019-10-11T21:02:16+08:00">2019-10-11</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/VSCode/" itemprop="url" rel="index"><span itemprop="name">VSCode</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>在 Mac 环境下配置：菜单栏 Code -&gt; 首选项 -&gt; 用户代码片段</p>
<p>自行按需添加如下文件<br><img src="/2019/10/11/%E5%B7%A5%E5%85%B7/VSCode/VSCode%E4%B8%AD%E6%B7%BB%E5%8A%A0%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5/1.png" alt="1"></p>
<p>例如 Python 的头文件可设置为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&quot;PY_HEADER&quot;: &#123;</span><br><span class="line">    &quot;prefix&quot;: &quot;header&quot;,</span><br><span class="line">    &quot;body&quot;: [</span><br><span class="line">        &quot;# -*- encoding: utf-8 -*-&quot;,</span><br><span class="line">        &quot;&#x27;&#x27;&#x27;&quot;,</span><br><span class="line">        &quot;@File    :   $TM_FILENAME&quot;,</span><br><span class="line">        &quot;@Time    :   $CURRENT_YEAR/$CURRENT_MONTH/$CURRENT_DATE $CURRENT_HOUR:$CURRENT_MINUTE:$CURRENT_SECOND&quot;,</span><br><span class="line">        &quot;@Author  :   Zhang Wensong&quot;,</span><br><span class="line">        &quot;@Version :   1.0&quot;,</span><br><span class="line">        &quot;@Contact :   zhang.wetts@163.com&quot;,</span><br><span class="line">        &quot;@Desc    :   $1&quot;,</span><br><span class="line">        &quot;&#x27;&#x27;&#x27;&quot;,</span><br><span class="line">        &quot;&quot;,</span><br><span class="line">        &quot;# here put the import lib&quot;,</span><br><span class="line">        &quot;$0&quot;</span><br><span class="line">    ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Markdown 的头文件可设置为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&quot;MD_HEADER&quot;: &#123;</span><br><span class="line">    &quot;prefix&quot;: &quot;header&quot;,</span><br><span class="line">    &quot;body&quot;: [</span><br><span class="line">        &quot;title: $TM_FILENAME&quot;,</span><br><span class="line">        &quot;date: $CURRENT_YEAR/$CURRENT_MONTH/$CURRENT_DATE $CURRENT_HOUR:$CURRENT_MINUTE:$CURRENT_SECOND&quot;,</span><br><span class="line">        &quot;tags:&quot;,</span><br><span class="line">        &quot;- $1&quot;,</span><br><span class="line">        &quot;categories:&quot;,</span><br><span class="line">        &quot;- $2&quot;,</span><br><span class="line">        &quot;&quot;,</span><br><span class="line">        &quot;---&quot;,</span><br><span class="line">        &quot;&quot;,</span><br><span class="line">        &quot;$0&quot;</span><br><span class="line">    ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>可能遇到的问题：在 Markdown 文件中无法使用代码片段</p>
<p>在 settings.json 中添加如下配置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;[markdown]&quot;: &#123;</span><br><span class="line">    &quot;editor.quickSuggestions&quot;: true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wetts.github.io/2019/10/11/%E8%AF%AD%E8%A8%80/Java/%E6%A1%86%E6%9E%B6%E3%80%81%E7%9B%B8%E5%85%B3%E6%8A%80%E6%9C%AF/Mybatis/Mybatis-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Zhang Wetts">
      <meta itemprop="description" content="Stay Hungry, Stay Foolish. <br><br><p style="font-size:8px;">[build by hexo/next/gitalk/hexo-generator-search/LaTeX]</p>">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wetts's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/10/11/%E8%AF%AD%E8%A8%80/Java/%E6%A1%86%E6%9E%B6%E3%80%81%E7%9B%B8%E5%85%B3%E6%8A%80%E6%9C%AF/Mybatis/Mybatis-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/" class="post-title-link" itemprop="url">Mybatis-实现原理-动态代理.md</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-10-11 19:01:29" itemprop="dateCreated datePublished" datetime="2019-10-11T19:01:29+08:00">2019-10-11</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Mybatis/" itemprop="url" rel="index"><span itemprop="name">Mybatis</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>转自：<a target="_blank" rel="noopener" href="https://blog.csdn.net/zzti_erlie/article/details/94396113">https://blog.csdn.net/zzti_erlie/article/details/94396113</a></p>
<p>mybatis 利用动态代理帮我们生成了接口的实现类，这个类就是 org.apache.ibatis.binding.MapperProxy</p>
<h2 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h2><p>又是一年毕业季，很多小伙伴开始去大城市打拼。来大城市第一件事就是租房，免不了和中介打交道，因为很多房东很忙，你根本找不到他。从这个场景中就可以抽象出来代理模式</p>
<ul>
<li>ISubject: 被访问者资源的抽象</li>
<li>SubjectImpl: 被访问者具体实现类（房东）</li>
<li>SubjectProxy: 被访问者的代理实现类（中介）</li>
</ul>
<p>UML图如下</p>
<p><img src="/2019/10/11/%E8%AF%AD%E8%A8%80/Java/%E6%A1%86%E6%9E%B6%E3%80%81%E7%9B%B8%E5%85%B3%E6%8A%80%E6%9C%AF/Mybatis/Mybatis-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/1.png" alt="1"></p>
<p>举个例子来理解一下这个设计模式</p>
<p>老板让记录一下用户服务的响应时间，用代理模式来实现这个功能。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface IUserService &#123;</span><br><span class="line">    public void request();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class UserServiceImpl implements IUserService &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void request() &#123;</span><br><span class="line">        System.out.println(&quot;this is userService&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class UserServiceProxy implements IUserService &#123;</span><br><span class="line"></span><br><span class="line">    private IUserService userService;</span><br><span class="line"></span><br><span class="line">    public UserServiceProxy(IUserService userService) &#123;</span><br><span class="line">        this.userService = userService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void request() &#123;</span><br><span class="line">        long startTime = System.currentTimeMillis();</span><br><span class="line">        userService.request();</span><br><span class="line">        System.out.println(&quot;reques cost :&quot; + (System.currentTimeMillis() - startTime));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        IUserService userService = new UserServiceImpl();</span><br><span class="line">        UserServiceProxy userServiceProxy = new UserServiceProxy(userService);</span><br><span class="line">        // this is userService</span><br><span class="line">        // reques cost :0</span><br><span class="line">        userServiceProxy.request();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一切看起来都非常的美好，老板又发话了，把产品服务的响应时间也记录一下吧。又得写如下 3 个类</p>
<ul>
<li>IProductService </li>
<li>ProductServiceImpl </li>
<li>ProductServiceProxy </li>
</ul>
<p>UserServiceProxy 和 ProductServiceProxy 这两个代理类的逻辑都差不多，却还得写 2 次。其实这个还好，如果老板说，把现有系统的几十个服务的响应时间都记录一下吧，你是不是要疯了？这得写多少代理类啊？</p>
<h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><blockquote>
<p>黑暗总是暂时的，终究会迎来黎明，在 JDK1.3 之后引入了一种称之为动态代理（Dynamic Proxy）的机制。使用该机制，我们可以为指定的接口在系统运行期间动态地生成代理对象，从而帮助我们走出最初使用静态代理实现 AOP 的窘境</p>
</blockquote>
<p>动态代理的实现主要由一个类和一个接口组成，即 java.lang.reflect.Proxy 类和 java.lang.reflect.InvocationHandler 接口。</p>
<p>让我们用动态代理来改造一下上面记录系统响应时间的功能。虽然要为 IUserService 和 IProductService 两种服务提供代理对象，但因为代理对象中要添加的横切逻辑是一样的。所以我们只需要实现一个 InvocationHandler 就可以了。代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">public class RequestCostInvocationHandler implements InvocationHandler &#123;</span><br><span class="line"></span><br><span class="line">    private Object target;</span><br><span class="line"></span><br><span class="line">    public RequestCostInvocationHandler(Object target) &#123;</span><br><span class="line">        this.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	/** 被代理对象的任何方法被执行时，都会先进入这个方法 */</span><br><span class="line">    @Override</span><br><span class="line">    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">        if (method.getName().equals(&quot;request&quot;)) &#123;</span><br><span class="line">            long startTime = System.currentTimeMillis();</span><br><span class="line">            // 执行目标对象的方法</span><br><span class="line">            method.invoke(target, args);</span><br><span class="line">            System.out.println(&quot;reques cost :&quot; + (System.currentTimeMillis() - startTime));</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        // 3个参数解释如下</span><br><span class="line">        // classloader,生成代理类</span><br><span class="line">        // 代理类应该实现的接口</span><br><span class="line">        // 实现InvocationHandler的切面类</span><br><span class="line">        IUserService userService = (IUserService) Proxy.newProxyInstance(IUserService.class.getClassLoader(),</span><br><span class="line">                new Class[]&#123;IUserService.class&#125;, new RequestCostInvocationHandler(new UserServiceImpl()));</span><br><span class="line"></span><br><span class="line">        IProductService productService = (IProductService) Proxy.newProxyInstance(IProductService.class.getClassLoader(),</span><br><span class="line">                new Class[]&#123;IProductService.class&#125;, new RequestCostInvocationHandler(new ProductServiceImpl()));</span><br><span class="line"></span><br><span class="line">        // this is userService</span><br><span class="line">        // reques cost :0</span><br><span class="line">        userService.request();</span><br><span class="line"></span><br><span class="line">        // this is productService</span><br><span class="line">        // reques cost :0</span><br><span class="line">        productService.request();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>UML 图如下。恭喜你，你现在已经理解了 Spring AOP 是怎么回事了，就是这么简单，今天先不展开谈 Spring</p>
<p><img src="/2019/10/11/%E8%AF%AD%E8%A8%80/Java/%E6%A1%86%E6%9E%B6%E3%80%81%E7%9B%B8%E5%85%B3%E6%8A%80%E6%9C%AF/Mybatis/Mybatis-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/2.png" alt="2"></p>
<p>先简单谈谈动态代理在 Mybatis 中是如何被大佬玩的出神入化的</p>
<h2 id="Mybatis-核心设计思路"><a href="#Mybatis-核心设计思路" class="headerlink" title="Mybatis 核心设计思路"></a>Mybatis 核心设计思路</h2><p>相信用过 mybatis 的小伙伴都能理解下面这段代码，通过 roleMapper 这个接口直接从数据库中拿到一个对象</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Role role = roleMapper.getRole(3L);</span><br></pre></td></tr></table></figure>

<p>直觉告诉我，一个接口是不能运行的啊，一定有接口的实现类，可是这个实现类我自己没写啊，难道 mybatis 帮我们生成了？你猜的没错，mybatis 利用动态代理帮我们生成了接口的实现类，这个类就是 org.apache.ibatis.binding.MapperProxy，我先画一下 UML 图，MapperProxy 就是下图中的 SubjectProxy 类</p>
<p><img src="/2019/10/11/%E8%AF%AD%E8%A8%80/Java/%E6%A1%86%E6%9E%B6%E3%80%81%E7%9B%B8%E5%85%B3%E6%8A%80%E6%9C%AF/Mybatis/Mybatis-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/3.png" alt="3"><br>和上面的 UML 类图对比一下，发现不就少了一个 SubjectImpl 类吗？那应该就是 SubjectProxy 类把 SubjectImple 类要做的事情做了呗，猜对了。SubjectProxy 通过 SubjectImple 和 SubjectImple.xml 之间的映射关系知道自己应该执行什么 SQL。所以 mybatis 最核心的思路就是这么个意思，细节之类的可以看源码，理清最主要的思路，看源码就能把握住重点。</p>
<h2 id="Mybatis插件原理"><a href="#Mybatis插件原理" class="headerlink" title="Mybatis插件原理"></a>Mybatis插件原理</h2><p>mybatis 的插件也用到了动态代理，还用到了责任链模式，我就不从源码角度分析了。说一下大概实现，我们用插件肯定是为了在原先的基础上增加新功能。增加一个插件，mybatis 就在原先类的基础上用动态代理生成一个代理对象，如果有多个插件，就在代理对象的基础上再生成代理对象，形式和如下函数差不多</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plugin2( plugin1( start() ) )</span><br></pre></td></tr></table></figure>
<p>我再给你写个例子，你再看看相关的源码分析文章（也许我以后会写），很快就能理解了。</p>
<p>在 mybatis 中要想用插件，有如下 2 个步骤</p>
<ol>
<li>在 mybatis-config.xml 中配置插件，如下所示<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;plugins&gt;</span><br><span class="line">	&lt;plugin interceptor=&quot;org.xrq.mybatis.plugin.FirstInterceptor&quot; /&gt;</span><br><span class="line">	&lt;plugin interceptor=&quot;org.xrq.mybatis.plugin.SecondInterceptor&quot; /&gt;</span><br><span class="line">&lt;/plugins&gt;</span><br></pre></td></tr></table></figure></li>
<li>插件类还得实现 Interceptor 接口</li>
</ol>
<p>我现在给一个需求，一个应用返回字符串 0，我加一个插件在字符串的左右两边加 plugin1，再加一个插件在字符串的左右两边加 plugin2，开写</p>
<p>返回字符串的接口</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public interface IGetStr &#123;</span><br><span class="line">    public String getStrZero();</span><br><span class="line">    public String getStrOne();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>返回字符串的实现类</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class GetStrImpl implements IGetStr &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String getStrZero() &#123;</span><br><span class="line">        return &quot;0&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String getStrOne() &#123;</span><br><span class="line">        return &quot;1&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义拦截器接口</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public interface Interceptor &#123;</span><br><span class="line"></span><br><span class="line">    /** 执行拦截逻辑的方法 */</span><br><span class="line">    Object intercept(Invocation invocation);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * target是被拦截的对象，它的作用是给被拦截对象生成一个代理对象，并返回它。</span><br><span class="line">     * 为了方便，可以直接使用Mybatis中org.apache.ibatis.plugin类的wrap方法（是静态方法）生成代理对象</span><br><span class="line">     * 我这里也写了一个Plugin方法</span><br><span class="line">     */</span><br><span class="line">    Object plugin(Object target);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看到一个不认识的类Invocation，定义如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class Invocation &#123;</span><br><span class="line"></span><br><span class="line">    private final Object target;</span><br><span class="line">    private final Method method;</span><br><span class="line">    private final Object[] args;</span><br><span class="line"></span><br><span class="line">    public Invocation(Object target, Method method, Object[] args) &#123;</span><br><span class="line">        this.target = target;</span><br><span class="line">        this.method = method;</span><br><span class="line">        this.args = args;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Object proceed() throws InvocationTargetException, IllegalAccessException &#123;</span><br><span class="line">        return method.invoke(target, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>就是简单的封装了一下目标对象，目标方法和目标方法的参数。proceed方法就是执行目标对象的目标方法</p>
<p>Plugin 算是一个工具类，生成代理对象</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public class Plugin implements InvocationHandler &#123;</span><br><span class="line"></span><br><span class="line">    /** 目标对象 */</span><br><span class="line">    private final Object target;</span><br><span class="line">    /** Interceptor对象 */</span><br><span class="line">    private final Interceptor interceptor;</span><br><span class="line"></span><br><span class="line">    public Plugin(Object target, Interceptor interceptor) &#123;</span><br><span class="line">        this.target = target;</span><br><span class="line">        this.interceptor = interceptor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	/** 生成代理对象 */</span><br><span class="line">    public static Object wrap(Object target, Interceptor interceptor) &#123;</span><br><span class="line">        return Proxy.newProxyInstance(target.getClass().getClassLoader(),</span><br><span class="line">                new Class[]&#123;IGetStr.class&#125;,</span><br><span class="line">                new Plugin(target, interceptor));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	/** 被代理对象的方法执行时，这个方法会被执行 */</span><br><span class="line">    @Override</span><br><span class="line">    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">    	// 只为方法getStrZero生成代理对象</span><br><span class="line">        if (method.getName().equals(&quot;getStrZero&quot;)) &#123;</span><br><span class="line">            return interceptor.intercept(new Invocation(target, method, args));</span><br><span class="line">        &#125;</span><br><span class="line">        return method.invoke(target, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>写第一个插件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class FirstInterceptor implements Interceptor &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /** 执行拦截逻辑的方法 */</span><br><span class="line">    @Override</span><br><span class="line">    public Object intercept(Invocation invocation) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            return &quot;plugin1 &quot; + invocation.proceed() + &quot; plugin1&quot;;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /** 为原先的类生成代理对象 */</span><br><span class="line">    @Override</span><br><span class="line">    public Object plugin(Object target) &#123;</span><br><span class="line">        return Plugin.wrap(target, this);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有 2 个方法</p>
<p>plugin 是为插件生成代理对象，用了我自己写的 Plugin 工具类<br>intercept 是增加拦截逻辑，invocation.proceed() 是执行目标对象的目标方法，前文说过了哈，这里我们只对输出做了改变</p>
<p>第二个插件和第一个插件类似</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class SecondInterceptor implements Interceptor &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object intercept(Invocation invocation) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            return &quot;plugin2 &quot; + invocation.proceed() + &quot; plugin2&quot;;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object plugin(Object target) &#123;</span><br><span class="line">        return Plugin.wrap(target, this);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用一个容器保存插件，这里用到了责任链模式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class InterceptorChain &#123;</span><br><span class="line"></span><br><span class="line">    /** 放拦截器 */</span><br><span class="line">    private final List&lt;Interceptor&gt; interceptors = new ArrayList&lt;Interceptor&gt;();</span><br><span class="line"></span><br><span class="line">    public Object pluginAll(Object target) &#123;</span><br><span class="line">        for (Interceptor interceptor : interceptors) &#123;</span><br><span class="line">            target = interceptor.plugin(target);</span><br><span class="line">        &#125;</span><br><span class="line">        return target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void addInterceptor(Interceptor interceptor) &#123;</span><br><span class="line">        interceptors.add(interceptor);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>pluginAll 方法是精髓，为每个插件一层一层的生成代理对象，就像套娃娃一样。</p>
<p>验证一下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        // 配置插件</span><br><span class="line">        InterceptorChain interceptorChain = new InterceptorChain();</span><br><span class="line">        interceptorChain.addInterceptor(new FirstInterceptor());</span><br><span class="line">        interceptorChain.addInterceptor(new SecondInterceptor());</span><br><span class="line"></span><br><span class="line">        // 获得代理对象</span><br><span class="line">        IGetStr getStr = new GetStrImpl();</span><br><span class="line">        getStr = (IGetStr) interceptorChain.pluginAll(getStr);</span><br><span class="line"></span><br><span class="line">        String result = getStr.getStrZero();</span><br><span class="line">        // plugin2 plugin1 0 plugin1 plugin2</span><br><span class="line">        System.out.println(result);</span><br><span class="line"></span><br><span class="line">        result = getStr.getStrOne();</span><br><span class="line">        // 1</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>大功告成，可以看到先定义的插件先执行。</p>
<p>类有点多，如果看的有点晕，多看几次，你就很容易理解了，我这里还是精简了很多。</p>
<p>一个 InvocationHandler 接口被大佬玩出了新境界，果然编程这件事还得靠想象力</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wetts.github.io/2019/10/06/%E6%95%B0%E5%AD%A6/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/A%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Zhang Wetts">
      <meta itemprop="description" content="Stay Hungry, Stay Foolish. <br><br><p style="font-size:8px;">[build by hexo/next/gitalk/hexo-generator-search/LaTeX]</p>">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wetts's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/10/06/%E6%95%B0%E5%AD%A6/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/A%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/" class="post-title-link" itemprop="url">A基本概念</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-10-06 13:40:08" itemprop="dateCreated datePublished" datetime="2019-10-06T13:40:08+08:00">2019-10-06</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/" itemprop="url" rel="index"><span itemprop="name">线性代数</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <ul>
<li><p>双线性映射：在数论中，一个双线性映射是由两个向量空间上的元素，生成第三个向量空间上一个元素之函数，并且该函数对每个参数都是线性的。例如矩阵乘法就是一个例子。</p>
<ul>
<li>矩阵乘法是双线性映射 ${\displaystyle M(m,n)\times M(n,p)\rightarrow M(m,p)}$。</li>
<li>如果在实数 ${\displaystyle \mathbb {R} }$ 上的向量空间 ${\displaystyle V}$ 承载了内积，则内积是双线性映射 ${\displaystyle V\times V\rightarrow \mathbb {R} }$。</li>
</ul>
</li>
<li><p>行列式表示空间线性变换后面积缩放的比例。</p>
</li>
<li><p>秩表示变换后的空间维数。更精确的定义是列空间的维数。</p>
</li>
<li><p>变换后落在原点的向量集合被称为所选矩阵的“零空间“（Null space）或”核“（Kernel）。</p>
</li>
<li><p>一个多维空间到一维空间的线性变换的对偶是多维空间中的某个特定向量。</p>
</li>
<li></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wetts.github.io/2019/10/03/%E5%B7%A5%E7%A8%8B/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81-%E5%9F%BA%E4%BA%8EMySQL%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Zhang Wetts">
      <meta itemprop="description" content="Stay Hungry, Stay Foolish. <br><br><p style="font-size:8px;">[build by hexo/next/gitalk/hexo-generator-search/LaTeX]</p>">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wetts's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/10/03/%E5%B7%A5%E7%A8%8B/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81-%E5%9F%BA%E4%BA%8EMySQL%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/" class="post-title-link" itemprop="url">分布式锁-基于MySQL的分布式锁.md</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-10-03 18:39:08" itemprop="dateCreated datePublished" datetime="2019-10-03T18:39:08+08:00">2019-10-03</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/" itemprop="url" rel="index"><span itemprop="name">分布式</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>转自：<a target="_blank" rel="noopener" href="https://blog.csdn.net/zzti_erlie/article/details/102769447">https://blog.csdn.net/zzti_erlie/article/details/102769447</a></p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>在分布式系统中，分布锁是一个最基础的工具类。例如，部署了2个有付款功能的微服务中，用户有可能对一个订单发起2次付款操作，而这2次请求可能被发到2个服务中，所以必须得用分布式锁防止重复提交，获取到锁的服务正常进行付款操作，获取不到锁的服务提示重复操作。</p>
<p>我司封装了大量的基础工具类，当我们想使用分布式锁的时候只要做3件事情</p>
<ol>
<li>在数据库中建globallocktable表</li>
<li>引入相应的jar包</li>
<li>在代码中写上@Autowired GlobalLockComponent globalLockComponent即可使用这个组件</li>
</ol>
<p>看完这篇文章你也可以用springboot-starter的方式实现一个同样的功能。</p>
<h2 id="建表"><a href="#建表" class="headerlink" title="建表"></a>建表</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `globallocktable` (</span><br><span class="line">  `id` int(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `lockKey` varchar(60) NOT NULL COMMENT &#x27;锁名称&#x27;,</span><br><span class="line">  `createTime` datetime NOT NULL COMMENT &#x27;创建时间&#x27;,</span><br><span class="line">  PRIMARY KEY (`id`),</span><br><span class="line">  UNIQUE KEY `lockKey` (`lockKey`)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8 ROW_FORMAT=DYNAMIC COMMENT=&#x27;全局锁&#x27;;</span><br></pre></td></tr></table></figure>

<h2 id="让别人使用的组件"><a href="#让别人使用的组件" class="headerlink" title="让别人使用的组件"></a>让别人使用的组件</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class GlobalLockComponent &#123;</span><br><span class="line">  </span><br><span class="line">  @Resource</span><br><span class="line">  private GlobalLockTableDAO globalLockDAO;</span><br><span class="line">  </span><br><span class="line">  /**</span><br><span class="line">   * 尝试获得锁，成功为true，失败为false</span><br><span class="line">   */</span><br><span class="line">  public boolean tryLock(String key) &#123;</span><br><span class="line">    return GlobalLockUtil.tryLock(this.globalLockDAO, key);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  /**</span><br><span class="line">   * 如果已经有其他程序占用该锁，并且超过timeoutMs（毫秒）时间，就强制清除这个锁占用</span><br><span class="line">   * 即根据key先删除记录，再添加记录</span><br><span class="line">   */</span><br><span class="line">  public boolean tryLockWithClear(String key, Long timeoutMs) &#123;</span><br><span class="line">    return GlobalLockUtil.tryLockWithClear(this.globalLockDAO, key, timeoutMs);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * 释放锁，根据key删除记录</span><br><span class="line">   */</span><br><span class="line">  public void releasLock(String key) &#123;</span><br><span class="line">    GlobalLockUtil.releasLock(this.globalLockDAO, key);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>锁对象定义如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class GlobalLockTable &#123;</span><br><span class="line"></span><br><span class="line">  private Integer id;</span><br><span class="line">  private String lockKey;</span><br><span class="line">  private Date createTime;</span><br><span class="line">  // 省略get和set方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>GlobalLockTableDAO定义如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public interface GlobalLockTableDAO &#123;</span><br><span class="line"></span><br><span class="line">  int deleteByPrimaryKey(Integer id);</span><br><span class="line">  </span><br><span class="line">  int deleteByLockKey(String lockKey);</span><br><span class="line"></span><br><span class="line">  GlobalLockTable selectByLockKey(String key);</span><br><span class="line"></span><br><span class="line">  int insertSelectiveWithTest(GlobalLockTable record);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="具体加锁和解锁逻辑"><a href="#具体加锁和解锁逻辑" class="headerlink" title="具体加锁和解锁逻辑"></a>具体加锁和解锁逻辑</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">public class GlobalLockUtil &#123;</span><br><span class="line"></span><br><span class="line">  private static Logger logger = LoggerFactory.getLogger(GlobalLockUtil.class);</span><br><span class="line"></span><br><span class="line">  private static GlobalLockTable tryLockInternal(GlobalLockTableDAO lockDAO, String key) &#123;</span><br><span class="line">    GlobalLockTable insert = new GlobalLockTable();</span><br><span class="line">    insert.setCreateTime(new Date());</span><br><span class="line">    insert.setLockKey(key);</span><br><span class="line">    // 注意的地方1</span><br><span class="line">    int count = lockDAO.insertSelectiveWithTest(insert);</span><br><span class="line">    if (count == 0) &#123;</span><br><span class="line">      GlobalLockTable ready = lockDAO.selectByLockKey(key);</span><br><span class="line">      logger.warn(&quot;can not lock the key: &#123;&#125;, &#123;&#125;, &#123;&#125;&quot;, insert.getLockKey(), ready.getCreateTime(),</span><br><span class="line">          ready.getId());</span><br><span class="line">      return ready;</span><br><span class="line">    &#125;</span><br><span class="line">    logger.info(&quot;yes got the lock by key: &#123;&#125;&quot;, insert.getId(), insert.getLockKey());</span><br><span class="line">    return null;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /** 超时清除锁占用，并重新加锁 **/</span><br><span class="line">  public static boolean tryLockWithClear(GlobalLockTableDAO lockDAO, String key, Long timeoutMs) &#123;</span><br><span class="line">    GlobalLockTable lock = tryLockInternal(lockDAO, key);</span><br><span class="line">    if (lock == null) return true;</span><br><span class="line">    if (System.currentTimeMillis() - lock.getCreateTime().getTime() &lt;= timeoutMs) &#123;</span><br><span class="line">      logger.warn(&quot;sorry, can not get the key. : &#123;&#125;, &#123;&#125;, &#123;&#125;&quot;, key, lock.getId(), lock.getCreateTime());</span><br><span class="line">      return false;</span><br><span class="line">    &#125;</span><br><span class="line">    logger.warn(&quot;the key already timeout wthin : &#123;&#125;, &#123;&#125;, will clear&quot;, key, timeoutMs);</span><br><span class="line">    // 注意的地方2</span><br><span class="line">    int count = lockDAO.deleteByPrimaryKey(lock.getId());</span><br><span class="line">    if (count == 0) &#123;</span><br><span class="line">      logger.warn(&quot;sorry, the key already preemptived by others: &#123;&#125;, &#123;&#125;&quot;, lock.getId(), lock.getLockKey());</span><br><span class="line">      return false;</span><br><span class="line">    &#125;</span><br><span class="line">    lock = tryLockInternal(lockDAO, key);</span><br><span class="line">    return lock != null ? false : true;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  /** 加锁 **/</span><br><span class="line">  public static boolean tryLock(GlobalLockTableDAO lockDAO, String key) &#123;</span><br><span class="line">    return tryLockInternal(lockDAO, key) == null ? true : false;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  /** 解锁 **/</span><br><span class="line">  public static void releasLock(GlobalLockTableDAO lockDAO, String key) &#123;</span><br><span class="line">    lockDAO.deleteByLockKey(key);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个工具类有2个特别有意思的地方，先看注意的地方2（上面代码中标识了）</p>
<ol>
<li>为了避免锁长时间不释放，用Redis实现的话可以设置锁超时时间，超时自动释放（后面会写用Redis实现分布式锁）用MySQL实现的话可以先删除后添加。可以看到删除的时候使用id删的，不是用name删的。为啥呢？先自己想一下</li>
</ol>
<p>因为如果是通过name删的话，有可能别人删了这个锁后，又通过name加了锁，还没到超时时间，结果你却根据name删除了。通过id删的话，当返回的id=0时，说明别人已经重新加锁了，你需要重新获取。</p>
<ol start="2">
<li>GlobalLockTable 对象dao层的其他方法都见名知意，来看一个这个方法。即代码中的注意点1<br>可以看到每次尝试加锁的时候，并不是先select，而是直接insertSelectiveWithTest，这样就少了一个查询时间，提高了效率</li>
</ol>
<p>insertSelectiveWithTest的作用是当lockKey存在时不进行插入操作，返回0。当lockKey不存在时进行插入操作，返回1</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;insert id=&quot;insertSelectiveWithTest&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot; parameterType=&quot;com.javashitang.middleware.lock.mysql.pojo.GlobalLockTable&quot;&gt;</span><br><span class="line">  insert into `globallocktable` (`id`,</span><br><span class="line">  `lockKey`, `createTime` )</span><br><span class="line">   select #&#123;id,jdbcType=INTEGER&#125;, #&#123;lockKey,jdbcType=VARCHAR&#125;, #&#123;createTime,jdbcType=TIMESTAMP&#125;</span><br><span class="line">   from dual where not exists</span><br><span class="line">    (select 1 from globallocktable where lockKey = #&#123;lockKey,jdbcType=VARCHAR&#125;)</span><br><span class="line">&lt;/insert&gt;</span><br></pre></td></tr></table></figure>

<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>当我们想使用时，就只写业务逻辑就行了，非常方便</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">if (!globalLockComponent.tryLock(name)) &#123;</span><br><span class="line">  // 没有获取到锁返回</span><br><span class="line">  return;</span><br><span class="line">&#125;</span><br><span class="line">try &#123;</span><br><span class="line">  // 这里写业务逻辑</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">  globalLockComponent.releasLock(name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wetts.github.io/2019/09/30/%E6%95%B0%E5%AD%A6/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%8D%8F%E6%96%B9%E5%B7%AE%E7%9F%A9%E9%98%B5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Zhang Wetts">
      <meta itemprop="description" content="Stay Hungry, Stay Foolish. <br><br><p style="font-size:8px;">[build by hexo/next/gitalk/hexo-generator-search/LaTeX]</p>">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wetts's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/09/30/%E6%95%B0%E5%AD%A6/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%8D%8F%E6%96%B9%E5%B7%AE%E7%9F%A9%E9%98%B5/" class="post-title-link" itemprop="url">协方差矩阵</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-09-30 22:54:29" itemprop="dateCreated datePublished" datetime="2019-09-30T22:54:29+08:00">2019-09-30</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E5%AD%A6/" itemprop="url" rel="index"><span itemprop="name">数学</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>转自：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/37609917">https://zhuanlan.zhihu.com/p/37609917</a></p>
<blockquote>
<p>协方差矩阵在统计学和机器学习中随处可见，一般而言，可视作方差和协方差两部分组成，即方差构成了对角线上的元素，协方差构成了非对角线上的元素。本文旨在从几何角度介绍我们所熟知的协方差矩阵。</p>
</blockquote>
<h2 id="方差和协方差的定义"><a href="#方差和协方差的定义" class="headerlink" title="方差和协方差的定义"></a>方差和协方差的定义</h2><p>在统计学中，方差是用来度量单个随机变量的离散程度，而协方差则一般用来刻画两个随机变量的相似程度，其中，<strong>方差</strong> 的计算公式为<br>$$<br>\sigma_{x}^{2}=\frac{1}{n-1} \sum_{i=1}^{n}\left(x_{i}-\overline{x}\right)^{2}<br>$$<br>其中，$n$ 表示样本量，符号 $\overline{x}$ 表示观测样本的均值，这个定义在初中阶段就已经开始接触了。</p>
<p>在此基础上，<strong>协方差</strong> 的计算公式被定义为<br>$$<br>\sigma(x, y)=\frac{1}{n-1} \sum_{i=1}^{n}\left(x_{i}-\overline{x}\right)\left(y_{i}-\overline{y}\right)<br>$$<br>在公式中，符号 $\overline{x}, \overline{y}$ 分别表示两个随机变量所对应的观测样本均值，据此，我们发现：方差 $\sigma^2$ 可视作随机变量 $x$ 关于其自身的协方差 $\sigma(x, x)$ .</p>
<h2 id="从方差-协方差到协方差矩阵"><a href="#从方差-协方差到协方差矩阵" class="headerlink" title="从方差/协方差到协方差矩阵"></a>从方差/协方差到协方差矩阵</h2><p>根据方差的定义，给定 $d$ 个随机变量 $x_k, k=1, 2,…,d$ ，则这些随机变量的方差为<br>$$<br>\sigma\left(x_{k}, x_{k}\right)=\frac{1}{n-1} \sum_{i=1}^{n}\left(x_{k i}-\overline{x}<em>{k}\right)^{2}, k=1,2, \ldots, d<br>$$<br>其中，为方便书写，$x</em>{ki}$ 表示随机变量 $x_k$ 中的第 $i$ 个观测样本，$n$ 表示样本量，每个随机变量所对应的观测样本数量均为 $n$。</p>
<p>对于这些随机变量，我们还可以根据协方差的定义，求出 <em><em>两两之间的协方差__，即<br>$$<br>\sigma\left(x</em>{m}, x</em>{k}\right)=\frac{1}{n-1} \sum_{i=1}^{n}\left(x_{m i}-\overline{x}<em>{m}\right)\left(x</em>{k i}-\overline{x}<em>{k}\right)<br>$$<br>因此，__协方差矩阵</em>_ 为<br>$$<br>\Sigma=\left[\begin{array}{ccc}{\sigma\left(x_{1}, x_{1}\right)} &amp; {\cdots} &amp; {\sigma\left(x_{1}, x_{d}\right)} \ {\vdots} &amp; {\ddots} &amp; {\vdots} \ {\sigma\left(x_{d}, x_{1}\right)} &amp; {\cdots} &amp; {\sigma\left(x_{d}, x_{d}\right)}\end{array}\right] \in \mathbb{R}^{d \times d}<br>$$<br>其中，对角线上的元素为各个随机变量的方差，非对角线上的元素为两两随机变量之间的协方差，根据协方差的定义，我们可以认定：矩阵 $\Sigma$ 为对称矩阵(symmetric matrix)，其大小为 $d \times d$ 。</p>
<h2 id="多元正态分布与线性变换"><a href="#多元正态分布与线性变换" class="headerlink" title="多元正态分布与线性变换"></a>多元正态分布与线性变换</h2><p>假设一个向量 $x$ 服从均值向量为 $\mu$ 、协方差矩阵为 $\Sigma$ 的多元正态分布(multi-variate Gaussian distribution)，则<br>$$<br>p(\boldsymbol{x})=|2 \pi \Sigma|^{-1 / 2} \exp \left(-\frac{1}{2}(\boldsymbol{x}-\boldsymbol{\mu})^{T} \Sigma^{-1}(\boldsymbol{x}-\boldsymbol{\mu})\right)<br>$$<br>令该分布的均值向量为 $\mu = 0$，由于指数项外面的系数 $|2 \pi \Sigma|^{-1 / 2}$ 通常作为常数，故可将多元正态分布简化为<br>$$<br>p(\boldsymbol{x}) \propto \exp \left(-\frac{1}{2} \boldsymbol{x}^{T} \Sigma^{-1} \boldsymbol{x}\right)<br>$$<br>再令 $\boldsymbol{x}=(y, z)^{T}$，包含两个随机变量 $y$ 和 $z$，则协方差矩阵可写成如下形式：<br>$$<br>\Sigma=\left[\begin{array}{ll}{\sigma(y, y)} &amp; {\sigma(y, z)} \ {\sigma(z, y)} &amp; {\sigma(z, z)}\end{array}\right] \in \mathbb{R}^{2 \times 2}<br>$$<br>用单位矩阵(identity matrix) $I$ 作为协方差矩阵，随机变量 $y$ 和 $x$ 的方差均为1，则生成如干个随机数如图1所示。</p>
<p><img src="/2019/09/30/%E6%95%B0%E5%AD%A6/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%8D%8F%E6%96%B9%E5%B7%AE%E7%9F%A9%E9%98%B5/1.png" alt="1">（图1 标准的二元正态分布）</p>
<p>在生成的若干个随机数中，每个点的似然为<br>$$<br>\mathcal{L}(\boldsymbol{x}) \propto \exp \left(-\frac{1}{2} \boldsymbol{x}^{T} \boldsymbol{x}\right)<br>$$<br>对图1中的所有点考虑一个线性变换(linear transformation)： $t = Ax$，我们能够得到图2.<br><img src="/2019/09/30/%E6%95%B0%E5%AD%A6/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%8D%8F%E6%96%B9%E5%B7%AE%E7%9F%A9%E9%98%B5/2.png" alt="2">（图1 标准的二元正态分布）<br>图2 经过线性变换的二元正态分布，先将图1的纵坐标压缩0.5倍，再将所有点逆时针旋转30°得到。</p>
<p>在线性变换中，矩阵 $A$ 被称为变换矩阵(transformation matrix)，为了将图1中的点经过线性变换得到我们想要的图2，其实我们需要构造两个矩阵：</p>
<ul>
<li>尺度矩阵(scaling matrix)：<br>$$<br>S=\left[\begin{array}{ll}{s_{y}} &amp; {0} \ {0} &amp; {s_{z}}\end{array}\right]<br>$$</li>
<li>旋转矩阵(rotation matrix)<br>$$<br>R=\left[\begin{array}{cc}{\cos (\theta)} &amp; {-\sin (\theta)} \ {\sin (\theta)} &amp; {\cos (\theta)}\end{array}\right]<br>$$<br>其中，$\theta$ 为顺时针旋转的度数。</li>
</ul>
<blockquote>
<p>变换矩阵、尺度矩阵和旋转矩阵三者的关系式：$A = RS$</p>
</blockquote>
<p>在这个例子中，尺度矩阵为 $S=\left[\begin{array}{cc}{1} &amp; {0} \ {0} &amp; {\frac{1}{2}}\end{array}\right]$  ，旋转矩阵为 $R=\left[\begin{array}{cc}{\cos \left(-\frac{\pi}{6}\right)} &amp; {-\sin \left(-\frac{\pi}{6}\right)} \ {\sin \left(-\frac{\pi}{6}\right)} &amp; {\cos \left(-\frac{\pi}{6}\right)}\end{array}\right]=\left[\begin{array}{cc}{\frac{\sqrt{3}}{2}} &amp; {\frac{1}{2}} \ {-\frac{1}{2}} &amp; {\frac{\sqrt{3}}{2}}\end{array}\right]$ ，故变换矩阵为 $A=R S=\left[\begin{array}{cc}{\frac{\sqrt{3}}{2}} &amp; {\frac{1}{4}} \ {-\frac{1}{2}} &amp; {\frac{\sqrt{3}}{4}}\end{array}\right]$</p>
<p>另外，需要考虑的是，经过了线性变换，$t$ 的分布是什么样子呢？</p>
<p>将 $x = A^{-1}t$ 带入前面给出的似然 $\mathcal{L}(\boldsymbol{t})$ ，有</p>
<p>$$<br>\begin{array}{l}{\mathcal{L}(\boldsymbol{t}) \propto \exp \left(-\frac{1}{2}\left(A^{-1} \boldsymbol{t}\right)^{T}\left(A^{-1} \boldsymbol{t}\right)\right)} \ {=\exp \left(-\frac{1}{2} \boldsymbol{t}^{T}\left(\boldsymbol{A} \boldsymbol{A}^{T}\right)^{-1} \boldsymbol{t}\right)}\end{array}<br>$$</p>
<p>由此可以得到，多元正态分布的协方差矩阵为<br>$$<br>\Sigma=A A^{T}=\left[\begin{array}{cc}{\frac{\sqrt{3}}{2}} &amp; {\frac{1}{4}} \ {-\frac{1}{2}} &amp; {\frac{\sqrt{3}}{4}}\end{array}\right]\left[\begin{array}{cc}{\frac{\sqrt{3}}{2}} &amp; {-\frac{1}{2}} \ {\frac{1}{4}} &amp; {\frac{\sqrt{3}}{4}}\end{array}\right]=\left[\begin{array}{cc}{\frac{13}{16}} &amp; {-\frac{3 \sqrt{3}}{16}} \ {-\frac{3 \sqrt{3}}{16}} &amp; {\frac{7}{16}}\end{array}\right]<br>$$</p>
<h2 id="协方差矩阵的特征值分解"><a href="#协方差矩阵的特征值分解" class="headerlink" title="协方差矩阵的特征值分解"></a>协方差矩阵的特征值分解</h2><p>回到我们已经学过的线性代数内容，对于任意对称矩阵 $\Sigma$，存在一个特征值分解(eigenvalue decomposition, EVD)：$\Sigma = U\Lambda U^T$</p>
<p>其中，$U$ 的每一列都是相互正交的特征向量，且是单位向量，满足 $U^TU=I$，$\Lambda$ 对角线上的元素是从大到小排列的特征值，非对角线上的元素均为0。</p>
<p>当然，这条公式在这里也可以很容易地写成如下形式：<br>$$<br>\Sigma=\left(U \Lambda^{1 / 2}\right)\left(U \Lambda^{1 / 2}\right)^{T}=A A^{T}<br>$$<br>其中， $A = U\Lambda^{1/2}$ ，因此，通俗地说，任意一个协方差矩阵都可以视为线性变换的结果。</p>
<p>在上面的例子中，特征向量构成的矩阵为<br>$$<br>U=R=\left[\begin{array}{cc}{\cos (\theta)} &amp; {-\sin (\theta)} \ {\sin (\theta)} &amp; {\cos (\theta)}\end{array}\right]=\left[\begin{array}{cc}{\frac{\sqrt{3}}{2}} &amp; {\frac{1}{2}} \ {-\frac{1}{2}} &amp; {\frac{\sqrt{3}}{2}}\end{array}\right]<br>$$<br>特征值构成的矩阵为<br>$$<br>\Lambda=S S^{T}=\left[\begin{array}{cc}{s_{y}^{2}} &amp; {0} \ {0} &amp; {s_{z}^{2}}\end{array}\right]=\left[\begin{array}{cc}{1} &amp; {0} \ {0} &amp; {\frac{1}{4}}\end{array}\right]<br>$$<br>到这里，我们发现：多元正态分布的概率密度是由协方差矩阵的特征向量控制旋转(rotation)，特征值控制尺度(scale)，除了协方差矩阵，均值向量会控制概率密度的位置，在图1和图2中，均值向量为 $0$，因此，概率密度的中心位于坐标原点。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wetts.github.io/2019/09/21/%E6%95%B0%E5%AD%A6/%E5%85%B6%E4%BB%96/%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%A9%BA%E9%97%B4%E4%B8%8E%E5%B8%8C%E5%B0%94%E4%BC%AF%E7%89%B9%E7%A9%BA%E9%97%B4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Zhang Wetts">
      <meta itemprop="description" content="Stay Hungry, Stay Foolish. <br><br><p style="font-size:8px;">[build by hexo/next/gitalk/hexo-generator-search/LaTeX]</p>">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wetts's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/09/21/%E6%95%B0%E5%AD%A6/%E5%85%B6%E4%BB%96/%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%A9%BA%E9%97%B4%E4%B8%8E%E5%B8%8C%E5%B0%94%E4%BC%AF%E7%89%B9%E7%A9%BA%E9%97%B4/" class="post-title-link" itemprop="url">欧几里得空间与希尔伯特空间</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-09-21 13:54:12" itemprop="dateCreated datePublished" datetime="2019-09-21T13:54:12+08:00">2019-09-21</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E5%AD%A6/" itemprop="url" rel="index"><span itemprop="name">数学</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><img src="/2019/09/21/%E6%95%B0%E5%AD%A6/%E5%85%B6%E4%BB%96/%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%A9%BA%E9%97%B4%E4%B8%8E%E5%B8%8C%E5%B0%94%E4%BC%AF%E7%89%B9%E7%A9%BA%E9%97%B4/%E9%9B%86%E5%90%88and%E7%A9%BA%E9%97%B4.png" alt="集合and空间"> </p>
<hr>
<p>以下转自知乎</p>
<p><img src="/2019/09/21/%E6%95%B0%E5%AD%A6/%E5%85%B6%E4%BB%96/%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%A9%BA%E9%97%B4%E4%B8%8E%E5%B8%8C%E5%B0%94%E4%BC%AF%E7%89%B9%E7%A9%BA%E9%97%B4/%E7%A9%BA%E9%97%B4.png" alt="空间"><br><img src="/2019/09/21/%E6%95%B0%E5%AD%A6/%E5%85%B6%E4%BB%96/%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%A9%BA%E9%97%B4%E4%B8%8E%E5%B8%8C%E5%B0%94%E4%BC%AF%E7%89%B9%E7%A9%BA%E9%97%B4/%E7%A9%BA%E9%97%B4-%E8%A1%A8.png" alt="空间-表"> </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">作者：qang pan</span><br><span class="line">链接：https://www.zhihu.com/question/19967778/answer/28403912</span><br><span class="line">来源：知乎</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>

<p>什么是赋范线性空间、内积空间，度量空间，希尔伯特空间？</p>
<p>现代数学的一个特点就是以集合为研究对象，这样的好处就是可以将很多不同问题的本质抽象出来，变成同一个问题，当然这样的坏处就是描述起来比较抽象，很多人就难以理解了。既然是研究集合，每个人感兴趣的角度不同，研究的方向也就不同。为了能有效地研究集合，必须给集合赋予一些“结构”（从一些具体问题抽象出来的结构）。</p>
<p>从数学的本质来看，最基本的集合有两类：线性空间（有线性结构的集合）、度量空间（有度量结构的集合）。</p>
<p>对线性空间而言，主要研究集合的描述，直观地说就是如何清楚地告诉地别人这个集合是什么样子。为了描述清楚，就引入了基（相当于三维空间中的坐标系）的概念，所以对于一个 <strong>线性空间</strong> 来说，只要知道其 <strong>基</strong> 即可，集合中的元素只要知道其在给定基下的坐标即可。</p>
<p>但线性空间中的元素没有“长度”（相当于三维空间中线段的长度），为了量化线性空间中的元素，所以又在线性空间引入特殊的“长度”，即范数。赋予了 <strong>范数</strong> 的线性空间即称为 __赋犯线性空间__。</p>
<p>但赋范线性空间中两个元素之间没有角度的概念，为了解决该问题，所以在线性空间中又引入了内积的概念。</p>
<p>因为有度量，所以可以在度量空间、赋范线性空间以及内积空间中引入极限，但抽象空间中的极限与实数上的极限有一个很大的不同就是，极限点可能不在原来给定的集合中，所以又引入了完备的概念，<strong>完备的内积空间</strong> 就称为 __Hilbert 空间__。</p>
<p>这几个空间之间的关系是：线性空间与度量空间是两个不同的概念，没有交集。</p>
<ul>
<li>赋范线性空间就是赋予了范数的线性空间，也是度量空间（具有线性结构的度量空间）</li>
<li>内积空间是赋范线性空间</li>
<li>希尔伯特空间就是完备的内积空间。</li>
</ul>
<p>（线性空间 + 范数 = 赋范空间 + 线性结构） + 内积 = 内积空间 + 完备性 = 希尔伯特空间。</p>
<hr>
<ul>
<li>线性完备内积空间称作希尔伯特空间</li>
<li>线性完备赋范空间称作巴拿赫空间</li>
<li>有限维线性内积空间称作欧几里得空间</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wetts.github.io/2019/09/21/%E9%98%85%E8%AF%BB/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/%E5%85%B6%E4%BB%96/%E7%AE%80%E7%A7%B0%E7%9A%84%E5%90%AB%E4%B9%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Zhang Wetts">
      <meta itemprop="description" content="Stay Hungry, Stay Foolish. <br><br><p style="font-size:8px;">[build by hexo/next/gitalk/hexo-generator-search/LaTeX]</p>">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wetts's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/09/21/%E9%98%85%E8%AF%BB/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/%E5%85%B6%E4%BB%96/%E7%AE%80%E7%A7%B0%E7%9A%84%E5%90%AB%E4%B9%89/" class="post-title-link" itemprop="url">e.g.\etc.\et al.\i.e.\viz.含义</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-09-21 13:54:12" itemprop="dateCreated datePublished" datetime="2019-09-21T13:54:12+08:00">2019-09-21</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%8B%B1%E8%AF%AD/" itemprop="url" rel="index"><span itemprop="name">英语</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="e-g"><a href="#e-g" class="headerlink" title="e.g."></a>e.g.</h3><p>这是 exampli gratia(“for example; for instance;such as”: 举例如) 的缩写。</p>
<p>例句1: Buy some vegetables, e.g., carrots.</p>
<p>使用中，不仅e后的“.”常常被漏掉（如写成eg.），而且也经常与下面的缩写混淆。</p>
<p>为了方便记忆，你可把 “e.g.” 与 “example given” 联想起来。</p>
<p>最好把 e.g. 连同它的例子放在括号中，如</p>
<p>例句2：I like quiet activities (e.g., reading)</p>
<h3 id="etc"><a href="#etc" class="headerlink" title="etc."></a>etc.</h3><p>这是 et cetera (“and so forth; and the others; and other things; and the rest; and so on”:等等) 的缩写。它放在列表的最后，表示前面的例子还没列举完，最后加个词“等等”。</p>
<p>例句3: I need to go to the store and buy some pie, milk, cheese, etc.</p>
<p>etc. 常常被误写为 ect.，这是因为很多英语的c在t前(c在t后的很少)。etc. 前面要有逗号。</p>
<p>不要在 e.g. 的列表最后用 etc( 在including后的列表后也不宜使用etc)，这是因为 e.g. 表示泛泛的举几个例子，并没有囊括所有的实例，其中就已经包含“等等”，如果再加一个 etc. 就多余了，例如这是错的： Writing instructors focus on a number of complex skills that require extensive practice (e.g., organization, clear expression, logical thinking, etc.)</p>
<h3 id="et-al"><a href="#et-al" class="headerlink" title="et al."></a>et al.</h3><p>这是et alia(“and others; and co-workers”:等它人) 的缩写。它几乎都是在列文献作者时使用，即把主要作者列出后，其它作者全放在et al. 里面。</p>
<p>例句4: These results agree with the ones published by Pelon et al. (2002).</p>
<p>人的场合用 et al，而无生命的场合用 etc.(et cetera)。</p>
<p>et 后不要加“.”,因为 et 不是缩写。另外，与 etc. 不同，et al. 的前面不要逗号。</p>
<h3 id="i-e"><a href="#i-e" class="headerlink" title="i.e."></a>i.e.</h3><p>这是id est(“that is” , “in other words”:也就是) 的缩写。目的是用来进一步解释前面所说的观点（不是像e.g.那样引入实例来形象化），意思是“那就是说，换句话说”。</p>
<p>例句5：In 2005, American had the lowest personal saving rate since 1933. In fact it was outright negavetive—i.e., consumers spent more money that they made.</p>
<p>例句6：There are three meals in the day (i.e., breakfast, lunch, and dinner)</p>
<p>使用中，i.e.的第一个”.”也常常被错误地漏掉了。它后面紧跟着一个逗号，再跟一个解释。</p>
<p>如同e.g.,  i.e.也最好放入括号中，如同例句6那样。</p>
<p>比较下面两个例句。</p>
<p>例句7：I like to eat boardwalk food, i.e., funnel cake and french fries.</p>
<p>例句8：I like to eat boardwalk food, e.g., funnel cake and french fries.</p>
<p>例句7表示只有 funnel cake and french fries这两样boardwalk食物，我喜欢。例句8表示我喜欢boardwalk食物，比如 funnel cake and french fries；其实snow cones and corn dogs等其他类型，我也喜欢。</p>
<p>为了方便记忆，你可把”i.e.” 与 “in essence” 联想起来。</p>
<h3 id="viz"><a href="#viz" class="headerlink" title="viz."></a>viz.</h3><p>这是 videlicet(“namely”, “towit”, “precisely”, “that is to say”：即) 的缩写，与 e.g. 不同，viz. 位于同位列表之前，要把它前面单词所包含的项目全部列出。</p>
<p>例句9：“Each symbol represents one of the four elements, viz. earth, air, fire, and water.”(每个符号代表如下四个元素之一，即： 地球，空气，火焰和水)。</p>
<p>例句10: The noble gases, viz. helium, neon, argon, xenon, krypton and radon, show a non-expected behaviour when exposed to this new element.</p>
<p>注意 viz.后面无逗号。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wetts.github.io/2019/09/20/artificial_intelligence/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E7%AE%80%E4%BB%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Zhang Wetts">
      <meta itemprop="description" content="Stay Hungry, Stay Foolish. <br><br><p style="font-size:8px;">[build by hexo/next/gitalk/hexo-generator-search/LaTeX]</p>">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wetts's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/09/20/artificial_intelligence/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E7%AE%80%E4%BB%8B/" class="post-title-link" itemprop="url">知识图谱简介</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-09-20 16:17:27" itemprop="dateCreated datePublished" datetime="2019-09-20T16:17:27+08:00">2019-09-20</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1/" itemprop="url" rel="index"><span itemprop="name">知识图谱</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>知识图谱（Knowledge Graph），在图书情报界称为知识域可视化或知识领域映射地图，是显示知识发展进程与结构关系的一系列各种不同的图形，用可视化技术描述知识资源及其载体，挖掘、分析、构建、绘制和显示知识及它们之间的相互联系。</p>
<p>A KG is a multi-relational graph composed of entities (nodes) and relations (different types of edges). Each edge is represented as a triple of the form (head entity, relation, tail entity), also called a fact, indicating that two entities are connected by a specific relation, e.g., (AlfredHitchcock, DirectorOf, Psycho). Although effective in representing structured data, the underlying symbolic nature of such triples usually makes KGs hard to manipulate.</p>
<p>To tackle this issue, a new research direction known as knowledge graph embedding has been proposed and quickly gained massive attention.</p>
<p>Knowledge graph (KG) embedding is to embed components of a KG including entites and relations into continuous vector spaces, so as to simplify the manipulation while preserving the inherent structure of the KG. Those entity and relation embeddings can further be used to benefit all kinds of tasks, such as KG completion, relation extraction, entity classification, and entity resolution.</p>
<h2 id="technique"><a href="#technique" class="headerlink" title="technique"></a>technique</h2><p>A typical KG embedding technique generally consists of three steps:</p>
<ol>
<li>representing entities and relations, </li>
<li>defining a scoring function, and</li>
<li>learning entity and relation representations.</li>
</ol>
<p>We roughly categorize such embedding techniques into two groups: translational distance models and semantic matching models. The former use distance-based scoring functions, and the latter similarity-based ones.</p>
<h3 id="Translational-Distance-Models"><a href="#Translational-Distance-Models" class="headerlink" title="Translational Distance Models"></a>Translational Distance Models</h3><p>Translational distance models exploit distance-based scoring functions. They measure the plausibility of a fact as the distance between the two entities, usually after a translation carried out by the relation.</p>
<h4 id="TransE-and-Its-Extensions"><a href="#TransE-and-Its-Extensions" class="headerlink" title="TransE and Its Extensions"></a>TransE and Its Extensions</h4><p><img src="/2019/09/20/artificial_intelligence/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E7%AE%80%E4%BB%8B/TransE.png" alt="TransE"> </p>
<p>Despite its simplicity and efficiency, TransE has flaws in dealing with 1-to-N, N-to-1, and N-to-N relations.</p>
<p>To overcome the disadvantages of TransE in dealing with 1-to-N, N-to-1, and N-to-N relations, an effective strategy is to allow an entity to have distinct representations when involved in different relations.</p>
<h4 id="TransH"><a href="#TransH" class="headerlink" title="TransH"></a>TransH</h4><p>TransH follows this general idea, by introducing relation-specific hyperplanes.</p>
<p>Knowledge Graph Embedding: A Survey of Approaches and Applications<br>Quan Wang , Zhendong Mao , Bin Wang, and Li Guo</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wetts.github.io/2019/09/15/%E6%95%B0%E5%AD%A6/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/%E5%85%88%E9%AA%8C%E5%88%86%E5%B8%83%E3%80%81%E5%90%8E%E9%AA%8C%E5%88%86%E5%B8%83%E3%80%81%E4%BC%BC%E7%84%B6%E4%BC%B0%E8%AE%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Zhang Wetts">
      <meta itemprop="description" content="Stay Hungry, Stay Foolish. <br><br><p style="font-size:8px;">[build by hexo/next/gitalk/hexo-generator-search/LaTeX]</p>">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wetts's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/09/15/%E6%95%B0%E5%AD%A6/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/%E5%85%88%E9%AA%8C%E5%88%86%E5%B8%83%E3%80%81%E5%90%8E%E9%AA%8C%E5%88%86%E5%B8%83%E3%80%81%E4%BC%BC%E7%84%B6%E4%BC%B0%E8%AE%A1/" class="post-title-link" itemprop="url">先验分布、后验分布、似然估计</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-09-15 08:21:37" itemprop="dateCreated datePublished" datetime="2019-09-15T08:21:37+08:00">2019-09-15</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E5%AD%A6/" itemprop="url" rel="index"><span itemprop="name">数学</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>转自：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_23947237/article/details/78265026">https://blog.csdn.net/qq_23947237/article/details/78265026</a></p>
<h2 id="一个例子搞清楚（先验分布-后验分布-似然估计）"><a href="#一个例子搞清楚（先验分布-后验分布-似然估计）" class="headerlink" title="一个例子搞清楚（先验分布/后验分布/似然估计）"></a>一个例子搞清楚（先验分布/后验分布/似然估计）</h2><h3 id="preface："><a href="#preface：" class="headerlink" title="preface："></a>preface：</h3><p>无论是《通信原理》、《信息论》、《信道编码》还是《概率与统计理论》，或者在现在流行的《模式识别》和《Machine Learning》中总会遇到这么几个概念：先验分布/后验分布/似然估计。</p>
<p>如果大家不熟悉这几个词，相信大家熟知贝叶斯公式，该公式涉及到了以上几个概念。但是学完本科课程，也会算题，就是在实际情境中总感觉理不清这几个概念的关系，最近上课老被老师讲的先验、后验搞得晕头转向。因此，如果您和我遇到类似的囧事，这篇文章很适合您。</p>
<p>声明：本文主要内容修改整理于知乎回答。</p>
<h3 id="本文目标："><a href="#本文目标：" class="headerlink" title="本文目标："></a>本文目标：</h3><ul>
<li>一个隔壁小哥的故事</li>
<li>故事中的因果和三个概念</li>
<li>贝叶斯公式的角色</li>
<li>最大似然估计和贝叶斯的关系</li>
</ul>
<h3 id="隔壁小哥的故事"><a href="#隔壁小哥的故事" class="headerlink" title="隔壁小哥的故事"></a>隔壁小哥的故事</h3><p>隔壁小哥要去15公里外的一个公园，他可以选择步行走路，骑自行车或者开辆车，然后通过其中一种方式花了一段时间到达公园。</p>
<p>首先在这个事里边，大家不要关注隔壁小哥去干嘛，也许去送外卖吧：) 。言归正传，这件事中 __采用哪种交通方式是因，花了多长时间是果__。俗话说瓜熟蒂落，皆是因果；因果循环，报应不爽。要理解即将提到的概念，何为因何为果先要搞清楚。</p>
<h3 id="三个概念之后验（知果求因）"><a href="#三个概念之后验（知果求因）" class="headerlink" title="三个概念之后验（知果求因）"></a>三个概念之后验（知果求因）</h3><p>隔壁小哥去公园的故事才刚刚开始，假设在这里您已经牢记住这个故事的因和果。故事仍然要接着讲，顺便带出我们的概念。</p>
<p>假设我们 __已经知道小哥花了1个小时到了公园__，那么你猜他是怎么去的（走路or坐车or自行车），事实上我们 __不能百分百确定他的交通方式__，我们正常人的思路是他 <strong>很大可能</strong> 是骑车过去的，当然也不排除开车过去却由于堵车严重花了很长时间，当然还有可能他是个赛跑的运动员自己一路飞跑过去的。</p>
<p>假设 __已经知道小哥花了3个小时才到公园__，这个时候我们猜的时候会觉得他 <strong>很大可能</strong> 是静静地走路过去的。但是假设已经 __知道小哥只花了20分钟才到公园__，那么正常人会觉得他 <strong>最大可能</strong> 是开车奔驰而去。</p>
<p>这种预先 __已知结果__（路上花的时间），然后根据结果 __估计（猜）原因__（交通方式）的概率分布即 __后验概率__。</p>
<p>例子问题公式化：<em>P(交通方式∣花费的时间)</em></p>
<p>修改成一般的公式：<em>P(因∣果)</em></p>
<p>公式正规化：<em>P(θ∣x)</em></p>
<p>（公式中的 “∣|∣”读作 _given_，即给定的意思。如 <em>P(A∣B)</em> 即 A given B 的概率）</p>
<blockquote>
<p>[解释]：看到这里估计大家很奇怪为什么要用 x、 θ 这样的字母表示，而不是熟悉的 x、 y。这样表示自然是有原因的。在这里大家只需要先暂时记住 θ 代表因、 x 代表果，后面的贝叶斯我们将会具体介绍这些字母的含义。</p>
</blockquote>
<h3 id="三个概念之先验概率（由历史求因）"><a href="#三个概念之先验概率（由历史求因）" class="headerlink" title="三个概念之先验概率（由历史求因）"></a>三个概念之先验概率（由历史求因）</h3><p>换个情景，我们 <strong>不再考虑</strong> 隔壁小哥去公园的 <strong>结果</strong> 了。假设隔壁小哥还没去，大早上刚起床，打算吃完早饭再去。</p>
<p>假设我们比较了解小哥的个人习惯，别管怎么了解的：) 。小哥是个健身爱好者就喜欢跑步运动，这个时候我们可以猜测他更可能倾向于走路过去。</p>
<p>当然我的隔壁小哥是个大死肥宅，懒得要命！这个时候我们猜测他更可能倾向于坐车，连骑自行车的可能性都不大。</p>
<p>这个情景中隔壁小哥的交通工具选择与花费时间不再相关。因为我们是 <strong>在结果发生前</strong> 就开始猜的，<strong>根据历史规律确定</strong> 原因 （交通方式）的概率分布即 __先验概率__。</p>
<p>例子问题公式化：<em>P(交通方式)</em></p>
<p>一般化：<em>P(因)</em></p>
<p>正规化：<em>P(θ)</em></p>
<h3 id="三个概念之似然估计（由因求果）"><a href="#三个概念之似然估计（由因求果）" class="headerlink" title="三个概念之似然估计（由因求果）"></a>三个概念之似然估计（由因求果）</h3><p>换个情景，我们先重新考虑隔壁小哥去公园的交通方式。</p>
<p>假设隔壁小哥步行走路去，15公里的路到公园，一般情况下小哥大概要用2个多小时，当然很小的可能性是小哥是飞毛腿，跑步过去用了1个小时左右，极为小的可能是小哥是隐藏的高手，10分钟就轻功跑酷到了。</p>
<p>小哥决定开车，到公园半个小时是非常可能的，非常小的概率是小哥因为途径的路上有车祸堵了3个小时。</p>
<p>这种 __先定下来原因__，根据原因来 <strong>估计结果</strong> 的概率分布即 __似然估计__。根据原因来统计各种可能结果的概率即似然函数。</p>
<p>似然函数问题公式化：<em>P(时间∣交通方式)</em></p>
<p>一般化：<em>P(果∣因)</em></p>
<p>正规化：<em>P(x∣θ)</em></p>
<h3 id="贝叶斯公式"><a href="#贝叶斯公式" class="headerlink" title="贝叶斯公式"></a>贝叶斯公式</h3><p>我们熟知的贝叶斯公式是这样的：<img src="/2019/09/15/%E6%95%B0%E5%AD%A6/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/%E5%85%88%E9%AA%8C%E5%88%86%E5%B8%83%E3%80%81%E5%90%8E%E9%AA%8C%E5%88%86%E5%B8%83%E3%80%81%E4%BC%BC%E7%84%B6%E4%BC%B0%E8%AE%A1/%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%85%AC%E5%BC%8F%E5%8E%9F%E5%A7%8B.png" alt="贝叶斯公式原始"> </p>
<p>但在这里我们采用如下形式：<img src="/2019/09/15/%E6%95%B0%E5%AD%A6/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/%E5%85%88%E9%AA%8C%E5%88%86%E5%B8%83%E3%80%81%E5%90%8E%E9%AA%8C%E5%88%86%E5%B8%83%E3%80%81%E4%BC%BC%E7%84%B6%E4%BC%B0%E8%AE%A1/%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%85%AC%E5%BC%8F%E5%8F%98%E6%8D%A2.png" alt="贝叶斯公式变换"> </p>
<p><img src="/2019/09/15/%E6%95%B0%E5%AD%A6/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/%E5%85%88%E9%AA%8C%E5%88%86%E5%B8%83%E3%80%81%E5%90%8E%E9%AA%8C%E5%88%86%E5%B8%83%E3%80%81%E4%BC%BC%E7%84%B6%E4%BC%B0%E8%AE%A1/%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%85%AC%E5%BC%8F%E6%96%87%E5%AD%97.png" alt="贝叶斯公式文字"> </p>
<blockquote>
<p>[注]：<em>P(x)</em> 即 evidence。隔壁小哥去公园很多次，忽略交通方式是什么，只统计每次到达公园的时间 x，于是得到了一组时间的概率分布。这种不考虑原因，只看结果的概率分布即 evidence，它也称为样本发生的概率分布的证据。</p>
</blockquote>
<p>evidence 在故事中如下表示：<em>P(时间)</em> 或 <em>P(果)</em></p>
<h3 id="深入贝叶斯推断"><a href="#深入贝叶斯推断" class="headerlink" title="深入贝叶斯推断"></a>深入贝叶斯推断</h3><p>在这里相信大多数人已经很好地理解了先验概率，后验概率，证据以及和似然估计的概念了。接下来我们将接着讲故事，隔壁小哥到公园以后去做一个游戏，游戏内容如下：</p>
<p>在小哥面前有两个一模一样的宝箱，一号箱子里面有3颗水果糖和1颗巧克力糖；二号箱子里面有2颗水果糖和2颗巧克力糖。</p>
<ol>
<li>现在小哥将随机选择一个箱子，从中摸出一颗糖。请问小哥选择一号箱子的概率有多大？</li>
<li>现在小哥将随机选择一个箱子，从中摸出一颗糖发现是水果糖。请问这颗水果糖来自一号箱子的概率有多大？</li>
</ol>
<p><img src="/2019/09/15/%E6%95%B0%E5%AD%A6/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/%E5%85%88%E9%AA%8C%E5%88%86%E5%B8%83%E3%80%81%E5%90%8E%E9%AA%8C%E5%88%86%E5%B8%83%E3%80%81%E4%BC%BC%E7%84%B6%E4%BC%B0%E8%AE%A1/%E7%90%83.png" alt="球"> </p>
<p>暂且不去算这道题，在这个看似无聊的事情中，从哪个箱子去抓是 因；抓到的糖是什么糖为 结果。再去回顾我们之前的贝叶斯公式：<img src="/2019/09/15/%E6%95%B0%E5%AD%A6/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/%E5%85%88%E9%AA%8C%E5%88%86%E5%B8%83%E3%80%81%E5%90%8E%E9%AA%8C%E5%88%86%E5%B8%83%E3%80%81%E4%BC%BC%E7%84%B6%E4%BC%B0%E8%AE%A1/%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%85%AC%E5%BC%8F%E5%8F%98%E6%8D%A2.png" alt="贝叶斯公式变换"> </p>
<p>[解释]：其中 x 是观测得到的结果数据。<em>P(x)</em> 是观测结果数据的概率分布。如下表：</p>
<table>
<thead>
<tr>
<th align="center">x</th>
<th align="center">水果糖</th>
<th align="center">巧克力糖</th>
</tr>
</thead>
<tbody><tr>
<td align="center">P(x)</td>
<td align="center">5/8</td>
<td align="center">3/8</td>
</tr>
</tbody></table>
<p>[解释]：其中 θ 是决定观测结果数据分布的参数。<em>P(θ)</em> 是先验概率，没有观测数据的支持下 θ 发生的概率。如下表：</p>
<table>
<thead>
<tr>
<th align="center">θ</th>
<th align="center">一号箱</th>
<th align="center">二号箱</th>
</tr>
</thead>
<tbody><tr>
<td align="center">P(θ)</td>
<td align="center">1/2</td>
<td align="center">1/2</td>
</tr>
</tbody></table>
<p>[解释]：<em>P(θ∣x)</em> 是后验概率，有观测数据的支持下 θ 发生的概率。在上面的故事中第二问是小哥随机选择一个箱子，从中摸出一颗糖发现是水果糖。这颗水果糖来自一号箱子的概率就是后验概率：<em>P(θ=一号箱∣x=水果糖)</em></p>
<p>[解释]：<em>P(x∣θ)</em> 是似然函数，给定某参数 θ 时结果数据的概率分布。</p>
<p>其中，<em>P(θ=一号箱)</em> 就是先验概率，根据贝叶斯公式，需求证据 <em>P(x=水果糖)</em> 和似然函数 _P(x=水果糖∣θ=一号箱)_。</p>
<p><img src="/2019/09/15/%E6%95%B0%E5%AD%A6/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/%E5%85%88%E9%AA%8C%E5%88%86%E5%B8%83%E3%80%81%E5%90%8E%E9%AA%8C%E5%88%86%E5%B8%83%E3%80%81%E4%BC%BC%E7%84%B6%E4%BC%B0%E8%AE%A1/%E9%A2%98%E7%9B%AE1.png" alt="题目1"> </p>
<p>我们再考虑上面的计算：</p>
<p>(1) 现在小哥将随机选择一个箱子，从中摸出一颗糖。请问小哥选择一号箱子的概率。根据明显的先验知识我们就可以知道<br><img src="/2019/09/15/%E6%95%B0%E5%AD%A6/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/%E5%85%88%E9%AA%8C%E5%88%86%E5%B8%83%E3%80%81%E5%90%8E%E9%AA%8C%E5%88%86%E5%B8%83%E3%80%81%E4%BC%BC%E7%84%B6%E4%BC%B0%E8%AE%A1/%E9%A2%98%E7%9B%AE2.png" alt="题目2"> </p>
<p>(2) 现在小哥将随机选择一个箱子，从中摸出一颗糖发现是水果糖。请问这颗水果糖来自一号箱子的概率。后验概率为<br><img src="/2019/09/15/%E6%95%B0%E5%AD%A6/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/%E5%85%88%E9%AA%8C%E5%88%86%E5%B8%83%E3%80%81%E5%90%8E%E9%AA%8C%E5%88%86%E5%B8%83%E3%80%81%E4%BC%BC%E7%84%B6%E4%BC%B0%E8%AE%A1/%E9%A2%98%E7%9B%AE3.png" alt="题目3"> </p>
<p>我们为什么要在这里连续计算两道题呢，并不是为了单纯的计算，而是去比较计算结果得到贝叶斯推断的意义。</p>
<p>大家可以看到：没有做实验之前我们推断 <em>P(θ=一号箱)=1/2</em> 这个先验概率；而有了参考结果数据“从中摸出一颗糖发现是水果糖“，我们便可以得到 <em>P(θ=一号箱∣x=水果糖)=3/5</em> 这个后验概率。也就是说推断是一号箱的概率，在取出水果糖前和后，【θ=一号箱】事件的可能性得到了增强（1/2&lt;3/5）。</p>
<p>我们可以用小哥在公园的第二个奇遇来解释【贝叶斯估计】的意义：</p>
<p>小哥在公园里玩飞镖，附近有个陌生人说他是一个专业的飞镖玩家，假设你现在是小哥，你可能最开始会假设这家伙在开玩笑忽悠我吧。</p>
<p>首先你对这个人几乎什么都不了解，但遇到一个真正的专业飞镖玩家的概率是很小的。 因为澳大利亚的专业飞镖玩家也不过大约15个。</p>
<p>如果这个陌生人为了证明自己，开始扔飞镖并且第一次正中靶心，但这个数据可能还是不能令你非常信服，因为你觉得这可能只是运气。</p>
<p>但如果这个人连续十次都正中靶心，多个观测样本让你会倾向于接受他的专业说法。</p>
<p>在这件事当中，你对【陌生人是专业玩家】的先验置信度就被累积的实验数据所覆盖而增强变大，贝叶斯定理起作用了。</p>
<h3 id="MAP-ML-贝叶斯估计"><a href="#MAP-ML-贝叶斯估计" class="headerlink" title="MAP/ML/贝叶斯估计"></a>MAP/ML/贝叶斯估计</h3><p>给定一些数据样本 x，假定我们知道样本是从某一种分布中随机取出的，但我们不知道这个分布具体的参数 θ。</p>
<p>最大似然估计（ML，Maximum Likelihood）可以估计模型的参数。其目标是找出一组参数 θ，使得模型产生出观测数据 x 的概率最大：<img src="/2019/09/15/%E6%95%B0%E5%AD%A6/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/%E5%85%88%E9%AA%8C%E5%88%86%E5%B8%83%E3%80%81%E5%90%8E%E9%AA%8C%E5%88%86%E5%B8%83%E3%80%81%E4%BC%BC%E7%84%B6%E4%BC%B0%E8%AE%A1/%E6%9C%80%E5%A4%A7%E4%BC%BC%E7%84%B6%E4%BC%B0%E8%AE%A11.png" alt="最大似然估计1"> </p>
<p>假如这个参数有一个先验概率，那么参数该怎么估计呢？这就是MAP要考虑的问题。 最大后验估计（MAP－Maxaposterior）。MAP优化的是一个后验概率，即给定了观测值后使概率最大：<img src="/2019/09/15/%E6%95%B0%E5%AD%A6/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/%E5%85%88%E9%AA%8C%E5%88%86%E5%B8%83%E3%80%81%E5%90%8E%E9%AA%8C%E5%88%86%E5%B8%83%E3%80%81%E4%BC%BC%E7%84%B6%E4%BC%B0%E8%AE%A1/%E6%9C%80%E5%A4%A7%E5%90%8E%E9%AA%8C%E6%A6%82%E7%8E%871.png" alt="最大后验概率1"> </p>
<p>前两种都是假设参数是个确定值，但贝叶斯估计假设参数是个随机数。</p>
<p>贝叶斯估计，假定把待估计的参数看成是符合某种先验概率分布的随机变量，而不是确定数值。在样本分布上，计算参数所有可能的情况，并通过计算参数的期望，得到后验概率密度。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wetts.github.io/2019/09/11/%E9%98%85%E8%AF%BB/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/%E7%AC%AC7%E7%AB%A0-%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Zhang Wetts">
      <meta itemprop="description" content="Stay Hungry, Stay Foolish. <br><br><p style="font-size:8px;">[build by hexo/next/gitalk/hexo-generator-search/LaTeX]</p>">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wetts's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/09/11/%E9%98%85%E8%AF%BB/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/%E7%AC%AC7%E7%AB%A0-%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/" class="post-title-link" itemprop="url">统计学系方法-支持向量机</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-09-11 22:03:12" itemprop="dateCreated datePublished" datetime="2019-09-11T22:03:12+08:00">2019-09-11</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">读书笔记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>支持向量机（support vector machines, SVM）是一种二类分类模型。它的基本模型是定义在特征空间上的间隔最大的线性分类器，间隔最大使它有别于感知机；支持向量机还包括核技巧，这使它成为实质上的非线性分类器。支持向量机的学习策略就是间隔最大化，可形式化为一个求解凸二次规划（convex quadratic programming）的问题，也等价于正则化的合页损失函数的最小化问题。支持向量机的学习算法是求解凸二次规划的最优化算法。</p>
<p>支持向量机学习方法包含构建由简至繁的模型：线性可分支持向量机（linear support vector machine in linearly separable case）、线性支持向量机（linear support vector machine）及非线性支持向量机（non-linear support vector machine）。当训练数据线性可分时，通过硬间隔最大化（hard margin maximization），学习一个线性的分类器，即线性可分支持向量机，又称为硬间隔支持向量机；当训练数据近似线性可分时，通过软间隔最大化（soft margin maximization），也学习一个线性的分类器，即线性支持向量机，又称为软间隔支持向量机；当训练数据线性不可分时，通过使用核技巧（kernel trick）及软间隔足底阿花，学习非线性支持向量机。</p>
<p>当输入空间为欧氏空间或离散集合、特征空间为希尔伯特空间时，核函数（kernel funciton）表示将输入从输入空间映射到特征空间得到的特征向量之间的内积。通过使用核函数可以学习非线性支持向量机，等价于隐式地在高维的特征空间中学习线性支持向量机。这样的方法成为核技巧。核方法（kernel method）是比支持向量机更为一般的机器学习方法。</p>
<h2 id="线性可分支持向量机与硬间隔最大化"><a href="#线性可分支持向量机与硬间隔最大化" class="headerlink" title="线性可分支持向量机与硬间隔最大化"></a>线性可分支持向量机与硬间隔最大化</h2><h3 id="线性可分支持向量机"><a href="#线性可分支持向量机" class="headerlink" title="线性可分支持向量机"></a>线性可分支持向量机</h3><p>学习的目标是在特征空间中找到一个分离超平面，能将实例分到不同的类。分离超平面对应于方程 <code>wx+b=0</code>，它由法向量 w 和 截距 b 决定，可用 (w, b) 来表示。分离超平面将特征空间划分为两部分，一部分是正类，一部分是负类。法向量指向的一侧为正类，另一侧为负类。</p>
<p>一般地，当训练数据集线性可分时，存在无穷个分离超平面可将两类数据正确分开。感知机利用误分类最小策略，求得分离超平面，不过这时的解有无穷多个。线性可分支持向量机利用间隔最大化求最优分离超平面，这时，解是唯一的。</p>
<p><img src="/2019/09/11/%E9%98%85%E8%AF%BB/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/%E7%AC%AC7%E7%AB%A0-%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/%E7%BA%BF%E6%80%A7%E5%8F%AF%E5%88%86%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA.png" alt="线性可分支持向量机"> </p>
<h3 id="函数间隔和几何间隔"><a href="#函数间隔和几何间隔" class="headerlink" title="函数间隔和几何间隔"></a>函数间隔和几何间隔</h3><p><img src="/2019/09/11/%E9%98%85%E8%AF%BB/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/%E7%AC%AC7%E7%AB%A0-%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/%E5%87%BD%E6%95%B0%E9%97%B4%E9%9A%94.png" alt="函数间隔"> </p>
<p>函数间隔可以表示分类预测的正确性及确信度。但是选择分离超平面时，只有函数间隔还不够。因为只要成比例地改变 w 和 b，例如将它们改为 2w 和 2b，超平面并没有改变，但函数间隔却成为原来的 2 倍。</p>
<p>可以对分离超平面的法向量 w 加某些约束，如规范化，<code>||w||=1</code>，使得间隔是确定的。这时函数间隔成为几何间隔（geometric margin）。</p>
<p><img src="/2019/09/11/%E9%98%85%E8%AF%BB/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/%E7%AC%AC7%E7%AB%A0-%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/%E5%87%A0%E4%BD%95%E9%97%B4%E9%9A%94.png" alt="几何间隔"> </p>
<p>函数间隔和几何间隔有下面的关系：<br><img src="/2019/09/11/%E9%98%85%E8%AF%BB/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/%E7%AC%AC7%E7%AB%A0-%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/%E5%87%BD%E6%95%B0%E9%97%B4%E9%9A%94%E5%92%8C%E5%87%A0%E4%BD%95%E9%97%B4%E9%9A%94%E5%85%B3%E7%B3%BB.png" alt="函数间隔和几何间隔关系"> </p>
<h3 id="间隔最大化"><a href="#间隔最大化" class="headerlink" title="间隔最大化"></a>间隔最大化</h3><p>支持向量机学习的基本想法是求解能够正确划分训练数据集并且几何间隔最大的分离超平面。对线性可分的训练数据集而言，线性可分分离超平面有无穷多个（等价于感知机），但是几何间隔最大的分离超平面是唯一的。这里的间隔最大化又称为硬间隔最大化（与将要讨论的训练数据集近似线性可分时的软间隔最大化相对应）。</p>
<p>间隔最大化的直观解释是：对训练数据集找到几何间隔最大的超平面意味着以充分大的确信度对训练数据进行分类。也就是说，不仅将正负实例点分开，而且对最难分的实例点（离超平面最近的点）也有足够大的确信度将它们分开。这样的超平面应该对未知的新实例有很好的分类预测能力。</p>
<h4 id="最大间隔分离超平面"><a href="#最大间隔分离超平面" class="headerlink" title="最大间隔分离超平面"></a>最大间隔分离超平面</h4><p><img src="/2019/09/11/%E9%98%85%E8%AF%BB/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/%E7%AC%AC7%E7%AB%A0-%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/%E6%9C%80%E5%A4%A7%E9%97%B4%E9%9A%94%E6%9C%80%E4%BC%98%E5%8C%96%E9%97%AE%E9%A2%981.png" alt="最大间隔最优化问题1"> </p>
<p>考虑几何间隔和函数间隔的关系式，可将这个问题改写为：<br><img src="/2019/09/11/%E9%98%85%E8%AF%BB/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/%E7%AC%AC7%E7%AB%A0-%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/%E6%9C%80%E5%A4%A7%E9%97%B4%E9%9A%94%E6%9C%80%E4%BC%98%E5%8C%96%E9%97%AE%E9%A2%982.png" alt="最大间隔最优化问题2"> </p>
<p><img src="/2019/09/11/%E9%98%85%E8%AF%BB/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/%E7%AC%AC7%E7%AB%A0-%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/%E6%9C%80%E5%A4%A7%E9%97%B4%E9%9A%94%E6%9C%80%E4%BC%98%E5%8C%96%E9%97%AE%E9%A2%983.png" alt="最大间隔最优化问题3"> </p>
<p>这是一个凸二次规划（convex quadratic programming）问题。</p>
<p><img src="/2019/09/11/%E9%98%85%E8%AF%BB/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/%E7%AC%AC7%E7%AB%A0-%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/%E5%87%B8%E4%BC%98%E5%8C%96%E9%97%AE%E9%A2%98.png" alt="凸优化问题"> </p>
<p><img src="/2019/09/11/%E9%98%85%E8%AF%BB/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/%E7%AC%AC7%E7%AB%A0-%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/%E6%9C%80%E5%A4%A7%E9%97%B4%E9%9A%94%E6%B3%95.png" alt="最大间隔法"> </p>
<h4 id="最大间隔分离超平面的存在唯一性"><a href="#最大间隔分离超平面的存在唯一性" class="headerlink" title="最大间隔分离超平面的存在唯一性"></a>最大间隔分离超平面的存在唯一性</h4><p><img src="/2019/09/11/%E9%98%85%E8%AF%BB/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/%E7%AC%AC7%E7%AB%A0-%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/%E6%9C%80%E5%A4%A7%E9%97%B4%E9%9A%94%E5%88%86%E7%A6%BB%E8%B6%85%E5%B9%B3%E9%9D%A2%E7%9A%84%E5%AD%98%E5%9C%A8%E5%94%AF%E4%B8%80%E6%80%A7.png" alt="最大间隔分离超平面的存在唯一性"> </p>
<h4 id="支持向量与间隔边界"><a href="#支持向量与间隔边界" class="headerlink" title="支持向量与间隔边界"></a>支持向量与间隔边界</h4><p>在线性可分情况下，训练数据集的样本点中与分离超平面距离最近的样本点的实例称为支持向量（support vector）。支持向量是使约束条件式（7.14）等号成立的点。</p>
<p><img src="/2019/09/11/%E9%98%85%E8%AF%BB/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/%E7%AC%AC7%E7%AB%A0-%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F.png" alt="支持向量"> </p>
<p>在决定分离超平面时只有支持向量起作用，而其他实例点并不起作用。如果移动支持向量将改变所求的解；但是如果在间隔边界以外移动其他实例点，甚至去掉这些点，则解是不会改变的。由于支持向量在确定分离超平面中起着决定性作用，所以将这种分类模型称为支持向量机。支持向量的个数一般很少，所以支持向量机由很少的“重要的”训练样本确定。</p>
<h3 id="学习的对偶算法"><a href="#学习的对偶算法" class="headerlink" title="学习的对偶算法"></a>学习的对偶算法</h3><p>为了求解线性可分支持向量机的最优化问题，将它作为原始最优化问题，应用拉格朗日对偶性，通过求解对有问题（dual problem）得到原始问题（primal problem）的最优解，这就是线性可分支持向量机的对偶算法（dual algorithm）。这样做的优点，一是对偶问题往往更容易求解；二是自然引入核函数，进而推广到非线性分类问题。</p>
<p><img src="/2019/09/11/%E9%98%85%E8%AF%BB/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/%E7%AC%AC7%E7%AB%A0-%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A51.png" alt="拉格朗日1"><br><img src="/2019/09/11/%E9%98%85%E8%AF%BB/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/%E7%AC%AC7%E7%AB%A0-%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A52.png" alt="拉格朗日2"> </p>
<p><img src="/2019/09/11/%E9%98%85%E8%AF%BB/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/%E7%AC%AC7%E7%AB%A0-%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/%E5%AF%B9%E5%81%B6%E6%B1%82%E8%A7%A31.png" alt="对偶求解1"><br><img src="/2019/09/11/%E9%98%85%E8%AF%BB/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/%E7%AC%AC7%E7%AB%A0-%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/%E5%AF%B9%E5%81%B6%E6%B1%82%E8%A7%A32-1.png" alt="对偶求解2-1"><br><img src="/2019/09/11/%E9%98%85%E8%AF%BB/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/%E7%AC%AC7%E7%AB%A0-%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/%E5%AF%B9%E5%81%B6%E6%B1%82%E8%A7%A32-2.png" alt="对偶求解2-2"><br><img src="/2019/09/11/%E9%98%85%E8%AF%BB/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/%E7%AC%AC7%E7%AB%A0-%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/%E5%AF%B9%E5%81%B6%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3.png" alt="对偶问题的解"><br><img src="/2019/09/11/%E9%98%85%E8%AF%BB/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/%E7%AC%AC7%E7%AB%A0-%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F.png" alt="支持向量"></p>
<h2 id="线性支持向量机与软间隔最大化"><a href="#线性支持向量机与软间隔最大化" class="headerlink" title="线性支持向量机与软间隔最大化"></a>线性支持向量机与软间隔最大化</h2><h3 id="线性支持向量机"><a href="#线性支持向量机" class="headerlink" title="线性支持向量机"></a>线性支持向量机</h3><p>假设训练数据集不是线性可分的，通常情况是，训练数据中有一些特异点（outlier），将这些特异点除去后，剩下大部分的样本点组成的集合是线性可分的。</p>
<p>线性不可分意味着某些样本点不能满足函数间隔大于等于 1 的约束条件。为了解决这个问题，可以对每个样本点引进一个松弛变量 <img src="/2019/09/11/%E9%98%85%E8%AF%BB/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/%E7%AC%AC7%E7%AB%A0-%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/%E6%9D%BE%E5%BC%9B%E5%8F%98%E9%87%8F.png" alt="松弛变量">，使函数间隔加上松弛变量大于等于 1.这样，约束条件变为 <img src="/2019/09/11/%E9%98%85%E8%AF%BB/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/%E7%AC%AC7%E7%AB%A0-%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/%E5%8A%A0%E5%85%A5%E6%9D%BE%E5%BC%9B%E5%8F%98%E9%87%8F%E5%90%8E%E7%9A%84%E7%BA%A6%E6%9D%9F%E6%9D%A1%E4%BB%B6.png" alt="加入松弛变量后的约束条件"></p>
<p>同时，对每个松弛变量 <img src="/2019/09/11/%E9%98%85%E8%AF%BB/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/%E7%AC%AC7%E7%AB%A0-%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/%E6%9D%BE%E5%BC%9B%E5%8F%98%E9%87%8F.png" alt="松弛变量">，支付一个代价 <img src="/2019/09/11/%E9%98%85%E8%AF%BB/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/%E7%AC%AC7%E7%AB%A0-%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/%E6%9D%BE%E5%BC%9B%E5%8F%98%E9%87%8F.png" alt="松弛变量">。表表函数由原来的 <img src="/2019/09/11/%E9%98%85%E8%AF%BB/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/%E7%AC%AC7%E7%AB%A0-%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/SVM%E7%9B%AE%E6%A0%87%E5%87%BD%E6%95%B0.png" alt="SVM目标函数"> 变成 <img src="/2019/09/11/%E9%98%85%E8%AF%BB/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/%E7%AC%AC7%E7%AB%A0-%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/%E5%8A%A0%E5%85%A5%E6%9D%BE%E5%BC%9B%E5%8F%98%E9%87%8F%E7%9A%84%E7%9B%AE%E6%A0%87%E5%87%BD%E6%95%B0.png" alt="加入松弛变量的目标函数"></p>
<p>这里，C&gt;0 称为惩罚参数，一般由应用问题决定，C 值大时对误分类的惩罚增大，C 值小时对误分类的惩罚减小。最小化目标函数包含两层含义：使 <img src="/2019/09/11/%E9%98%85%E8%AF%BB/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/%E7%AC%AC7%E7%AB%A0-%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/SVM%E7%9B%AE%E6%A0%87%E5%87%BD%E6%95%B0.png" alt="SVM目标函数"> 尽量小即间隔尽量大，同时使误分类点的个数尽量小，C 是调和两者的系数。</p>
<p>有了上面的思路，可以和训练数据集线性可分时一样来考虑训练数据集线性不可分时的线性支持向量机学习问题。相应于硬间隔最大化，它称为软间隔最大化。</p>
<p>线性不可分的线性支持向量机的学习问题变成如下凸二次规划（convex quadratic programming）问题（原始问题）：<br><img src="/2019/09/11/%E9%98%85%E8%AF%BB/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/%E7%AC%AC7%E7%AB%A0-%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/%E7%BA%BF%E6%80%A7%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA%E5%8E%9F%E5%A7%8B%E9%97%AE%E9%A2%98.png" alt="线性支持向量机原始问题"></p>
<p><img src="/2019/09/11/%E9%98%85%E8%AF%BB/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/%E7%AC%AC7%E7%AB%A0-%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/%E7%BA%BF%E6%80%A7%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA.png" alt="线性支持向量机"></p>
<h3 id="学习的对偶算法-1"><a href="#学习的对偶算法-1" class="headerlink" title="学习的对偶算法"></a>学习的对偶算法</h3><p><img src="/2019/09/11/%E9%98%85%E8%AF%BB/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/%E7%AC%AC7%E7%AB%A0-%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/%E7%BA%BF%E6%80%A7%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95.png" alt="线性支持向量机学习算法"></p>
<h3 id="支持向量"><a href="#支持向量" class="headerlink" title="支持向量"></a>支持向量</h3><p><img src="/2019/09/11/%E9%98%85%E8%AF%BB/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/%E7%AC%AC7%E7%AB%A0-%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/%E7%BA%BF%E6%80%A7%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F.png" alt="线性支持向量机支持向量"></p>
<h3 id="合页损失函数"><a href="#合页损失函数" class="headerlink" title="合页损失函数"></a>合页损失函数</h3><p><img src="/2019/09/11/%E9%98%85%E8%AF%BB/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/%E7%AC%AC7%E7%AB%A0-%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/%E7%BB%8F%E9%AA%8C%E9%A3%8E%E9%99%A9.png" alt="经验风险"></p>
<p><img src="/2019/09/11/%E9%98%85%E8%AF%BB/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/%E7%AC%AC7%E7%AB%A0-%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/%E5%90%88%E9%A1%B5%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0.png" alt="合页损失函数"></p>
<h2 id="非线性支持向量机与核函数"><a href="#非线性支持向量机与核函数" class="headerlink" title="非线性支持向量机与核函数"></a>非线性支持向量机与核函数</h2><h3 id="核技巧"><a href="#核技巧" class="headerlink" title="核技巧"></a>核技巧</h3><h4 id="非线性分类问题"><a href="#非线性分类问题" class="headerlink" title="非线性分类问题"></a>非线性分类问题</h4><p>用线性分类方法求解非线性分类问题分为两步：首先使用一个变换将原空间的数据映射到新空间；然后在新空间里用线性分类学习方法从训练数据中学习分类模型。核技巧就属于这样的方法。</p>
<h4 id="核函数的定义"><a href="#核函数的定义" class="headerlink" title="核函数的定义"></a>核函数的定义</h4>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/9/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><span class="page-number current">10</span><a class="page-number" href="/page/11/">11</a><span class="space">&hellip;</span><a class="page-number" href="/page/69/">69</a><a class="extend next" rel="next" href="/page/11/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Zhang Wetts"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">Zhang Wetts</p>
  <div class="site-description" itemprop="description">Stay Hungry, Stay Foolish. <br><br><p style="font-size:8px;">[build by hexo/next/gitalk/hexo-generator-search/LaTeX]</p></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">682</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">67</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">350</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/wetts" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;wetts" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:zhang.wetts@163.com" title="E-Mail → mailto:zhang.wetts@163.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Zhang Wetts</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

  


<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/hibiki.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"react":{"opacity":0}});</script></body>
</html>
