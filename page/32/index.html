<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"wetts.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="Stay Hungry, Stay Foolish. [build by hexo&#x2F;next&#x2F;gitalk&#x2F;hexo-generator-search&#x2F;LaTeX]">
<meta property="og:type" content="website">
<meta property="og:title" content="Wetts&#39;s blog">
<meta property="og:url" content="https://wetts.github.io/page/32/index.html">
<meta property="og:site_name" content="Wetts&#39;s blog">
<meta property="og:description" content="Stay Hungry, Stay Foolish. [build by hexo&#x2F;next&#x2F;gitalk&#x2F;hexo-generator-search&#x2F;LaTeX]">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Zhang Wetts">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://wetts.github.io/page/32/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Wetts's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Wetts's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Stay Hungry, Stay Foolish.</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/wetts" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wetts.github.io/2016/12/10/%E9%98%85%E8%AF%BB/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA/Java%20RESTful%20Web%20Service%E5%AE%9E%E6%88%98%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%89%88%EF%BC%89/%E7%AC%AC2%E7%AB%A0-REST%20API%E8%AE%BE%E8%AE%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Zhang Wetts">
      <meta itemprop="description" content="Stay Hungry, Stay Foolish. <br><br><p style="font-size:8px;">[build by hexo/next/gitalk/hexo-generator-search/LaTeX]</p>">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wetts's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2016/12/10/%E9%98%85%E8%AF%BB/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA/Java%20RESTful%20Web%20Service%E5%AE%9E%E6%88%98%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%89%88%EF%BC%89/%E7%AC%AC2%E7%AB%A0-REST%20API%E8%AE%BE%E8%AE%A1/" class="post-title-link" itemprop="url">第2章-REST API设计</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2016-12-10 15:21:09" itemprop="dateCreated datePublished" datetime="2016-12-10T15:21:09+08:00">2016-12-10</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">读书笔记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>REST服务和RPC服务的接口定义上的区别是：REST使用HTTP协议的通用方法作为统一接口的标准词汇，REST服务所提供的方法信息都在HTTP方法里，而RPC服务所提供的方法信息在SOAP/HTTP信封里（其封装的格式通常是HTTP或SOAP），每一个RPC式的Web服务都会发布一套符合自己商业逻辑的方法词汇。</p>
<p>每一种HTTP请求方法都可以从安全性和幂等性两方面考虑，这对正确理解HTTP请求方法和设计统一接口具有决定性的意义。</p>
<p>安全性是指外系统对该接口的访问，不会使服务器端资源的状态发生改变；幂等性（idempotence）是指外系统对同一REST接口的多次访问，得到的资源状态是相同的。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wetts.github.io/2016/12/10/%E9%98%85%E8%AF%BB/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA/Java%20RESTful%20Web%20Service%E5%AE%9E%E6%88%98%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%89%88%EF%BC%89/%E7%AC%AC1%E7%AB%A0-JAX-RS2%E5%85%A5%E9%97%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Zhang Wetts">
      <meta itemprop="description" content="Stay Hungry, Stay Foolish. <br><br><p style="font-size:8px;">[build by hexo/next/gitalk/hexo-generator-search/LaTeX]</p>">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wetts's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2016/12/10/%E9%98%85%E8%AF%BB/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA/Java%20RESTful%20Web%20Service%E5%AE%9E%E6%88%98%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%89%88%EF%BC%89/%E7%AC%AC1%E7%AB%A0-JAX-RS2%E5%85%A5%E9%97%A8/" class="post-title-link" itemprop="url">第1章-JAX-RS2入门</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2016-12-10 14:17:21" itemprop="dateCreated datePublished" datetime="2016-12-10T14:17:21+08:00">2016-12-10</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">读书笔记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>REST（Representational State Transfer）翻译为表述性状态转移。</p>
<p>Roy Thomas Fielding博士在2000年就读加州大学欧文分校期间发表的一篇学术论文《Architectural Styles and the Design of Network-based Software Architectures》，该文中提出了REST的6个特点，分别是：客户端<br>-服务端的、无状态的、可缓存的、统一接口、分层系统和按需编码。</p>
<p>REST是一种架构风格。在这种架构风格中，对象被视为一种资源（resource），通常使用概念清晰的名词命名。</p>
<p>REST的资源是可寻址的，通过HTTP1.1协议（RFC 2616）定义的通用动词方法（比如GET、PUT、DELETE、POST），使用URI协议（RFC 3305）来唯一表示某个资源公布出来的接口。</p>
<h4 id="解读JAX-RS标准"><a href="#解读JAX-RS标准" class="headerlink" title="解读JAX-RS标准"></a>解读JAX-RS标准</h4><p>JAX-RS是Java领域的REST式的Web服务的标准规范，是使用Java完成REST服务的基本约定。</p>
<p>Java领域中的Web Service是指实现SOAP协议的JAX-WS。直到Java EE 6（发布于2008年9月）通过JCP（Java Community Process）组织定义的JSR311，才将REST在Java领域标准化。</p>
<p>JSR311名为The Java API for RESTful Web Service，即JAX-RS。此后，JSR311进行了一次升级（2009年9月），即JAX-RS1.1。JAX-RS诞生后，时隔5年（2013年5月）发布的Java EE 7包含了JSR339，将JAX-RS升级到JAX-RS2。JAX-RS2在前面版本的基础上增加了很多实用性的功能。比如对REST客户端API的定义，异步REST等，对REST的支持更加完善和强大。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wetts.github.io/2016/12/09/%E8%AF%AD%E8%A8%80/Java/API/reflection/Java-Reflection-12.%E5%8A%A8%E6%80%81%E7%B1%BB%E5%8A%A0%E8%BD%BD%E4%B8%8E%E9%87%8D%E8%BD%BD/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Zhang Wetts">
      <meta itemprop="description" content="Stay Hungry, Stay Foolish. <br><br><p style="font-size:8px;">[build by hexo/next/gitalk/hexo-generator-search/LaTeX]</p>">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wetts's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2016/12/09/%E8%AF%AD%E8%A8%80/Java/API/reflection/Java-Reflection-12.%E5%8A%A8%E6%80%81%E7%B1%BB%E5%8A%A0%E8%BD%BD%E4%B8%8E%E9%87%8D%E8%BD%BD/" class="post-title-link" itemprop="url">Java-Reflection-12.动态类加载与重载</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2016-12-09 17:59:30" itemprop="dateCreated datePublished" datetime="2016-12-09T17:59:30+08:00">2016-12-09</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>转自：<a target="_blank" rel="noopener" href="http://ifeve.com/dynamic-class-loading-reloading/">http://ifeve.com/dynamic-class-loading-reloading/</a></p>
<p>Java允许你在运行期动态加载和重载类，但是这个功能并没有像人们希望的那么简单直接。这篇文章将阐述在Java中如何加载以及重载类。</p>
<p>你可能会质疑为什么Java动态类加载特性是Java反射机制的一部分而不是Java核心平台的一部分。不管怎样，这篇文章被放到了Java反射系列里面而且也没有更好的系列来包含它了。</p>
<h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><p>所有Java应用中的类都是被java.lang.ClassLoader类的一系列子类加载的。因此要想动态加载类的话也必须使用java.lang.ClassLoader的子类。</p>
<p>一个类一旦被加载时，这个类引用的所有类也同时会被加载。类加载过程是一个递归的模式，所有相关的类都会被加载。但并不一定是一个应用里面所有类都会被加载，与这个被加载类的引用链无关的类是不会被加载的，直到有引用关系的时候它们才会被加载。</p>
<h2 id="类加载体系"><a href="#类加载体系" class="headerlink" title="类加载体系"></a>类加载体系</h2><p>在Java中类加载是一个有序的体系。当你新创建一个标准的Java类加载器时你必须提供它的父加载器。当一个类加载器被调用来加载一个类的时候，首先会调用这个加载器的父加载器来加载。如果父加载器无法找到这个类，这时候这个加载器才会尝试去加载这个类。</p>
<h2 id="类加载"><a href="#类加载" class="headerlink" title="类加载"></a>类加载</h2><p>类加载器加载类的顺序如下：</p>
<ol>
<li>检查这个类是否已经被加载。</li>
<li>如果没有被加载，则首先调用父加载器加载。</li>
<li>如果父加载器不能加载这个类，则尝试加载这个类。</li>
</ol>
<p>当你实现一个有重载类功能的类加载器，它的顺序与上述会有些不同。类重载不会请求的他的父加载器来进行加载。在后面的段落会进行讲解。</p>
<h2 id="动态类加载"><a href="#动态类加载" class="headerlink" title="动态类加载"></a>动态类加载</h2><p>动态加载一个类十分简单。你要做的就是获取一个类加载器然后调用它的loadClass()方法。下面是个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class MainClass &#123;</span><br><span class="line"></span><br><span class="line">  public static void main(String[] args)&#123;</span><br><span class="line">    ClassLoader classLoader = MainClass.class.getClassLoader();</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        Class aClass = classLoader.loadClass(&quot;com.jenkov.MyClass&quot;);</span><br><span class="line">        System.out.println(&quot;aClass.getName() = &quot; + aClass.getName());</span><br><span class="line">    &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="动态类重载"><a href="#动态类重载" class="headerlink" title="动态类重载"></a>动态类重载</h2><p>动态类重载有一点复杂。Java内置的类加载器在加载一个类之前会检查它是否已经被加载。因此重载一个类是无法使用Java内置的类加载器的，如果想要重载一个类你需要手动继承ClassLoader。</p>
<p>在你定制ClassLoader的子类之后，你还有一些事需要做。所有被加载的类都需要被链接。这个过程是通过ClassLoader.resolve()方法来完成的。由于这是一个final方法，因此这个方法在ClassLoader的子类中是无法被重写的。resolve()方法是不会允许给定的ClassLoader实例链接一个类两次。所以每当你想要重载一个类的时候你都需要使用一个新的ClassLoader的子类。你在设计类重载功能的时候这是必要的条件。</p>
<h2 id="自定义类重载"><a href="#自定义类重载" class="headerlink" title="自定义类重载"></a>自定义类重载</h2><p>在前面已经说过你不能使用已经加载过类的类加载器来重载一个类。因此你需要其他的ClassLoader实例来重载这个类。但是这又带来了一些新的挑战。</p>
<p>所有被加载到Java应用中的类都以类的全名（包名 + 类名）作为一个唯一标识来让ClassLoader实例来加载。这意味着，类MyObject被类加载器A加载，如果类加载器B又加载了MyObject类，那么两个加载器加载出来的类是不同的。看看下面的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyObject object = (MyObject)myClassReloadingFactory.newInstance(&quot;com.jenkov.MyObject&quot;);</span><br></pre></td></tr></table></figure>
<p>MyObject类在上面那段代码中被引用，它的变量名是object。这就导致了MyObject这个类会被这段代码所在类的类加载器所加载。</p>
<p>如果myClassReloadingFactory工厂对象使用不同的类加载器重载MyObject类，你不能把重载的MyObject类的实例转换（cast）到类型为MyObject的对象变量。一旦MyObject类分别被两个类加载器加载，那么它就会被认为是两个不同的类，尽管它们的类的全名是完全一样的。你如果尝试把这两个类的实例进行转换就会报ClassCastException。</p>
<p>你可以解决这个限制，不过你需要从以下两个方面修改你的代码：</p>
<ol>
<li>标记这个变量类型为一个接口，然后只重载这个接口的实现类。</li>
<li>标记这个变量类型为一个超类，然后只重载这个超类的子类。</li>
</ol>
<p>请看下面这两个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyObjectInterface object = (MyObjectInterface)myClassReloadingFactory.newInstance(&quot;com.jenkov.MyObject&quot;);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyObjectSuperclass object = (MyObjectSuperclass)myClassReloadingFactory.newInstance(&quot;com.jenkov.MyObject&quot;);</span><br></pre></td></tr></table></figure>
<p>只要保证变量的类型是超类或者接口，这两个方法就可以正常运行，当它们的子类或是实现类被重载的时候超类跟接口是不会被重载的。</p>
<p>为了保证这种方式可以运行你需要手动实现类加载器然后使得这些接口或超类可以被它的父加载器加载。当你的类加载器加载MyObject类时，超类MyObjectSuperclass或者接口MyObjectSuperclass也会被加载，因为它们是MyObject的依赖。你的类加载器必须要代理这些类的加载到同一个类加载器，这个类加载器加载这个包括接口或者超类的类。</p>
<h2 id="类加载-重载示例"><a href="#类加载-重载示例" class="headerlink" title="类加载/重载示例"></a>类加载/重载示例</h2><p>光说不练假把式。让我们看看一个简单的例子。下面这个例子是一个类加载器的子类。注意在这个类不想被重载的情况下它是如何把对一个类的加载代理到它的父加载器上的。如果一个类被它的父加载器加载，这个类以后将不能被重载。记住，一个类只能被同一个ClassLoader实例加载一次。</p>
<p>就像我之前说的那样，这仅仅是一个简单的例子，通过这个例子会向你展示类加载器的基本行为。这并不是一个可以让你直接用于设计你项目中类加载器的模板。你自己设计的类加载器应该不仅仅只有一个，如果你想用来重载类的话你可能会设计很多加载器。并且你也不会像下面这样将需要加载的类的路径硬编码（hardcore）到你的代码中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">public class MyClassLoader extends ClassLoader&#123;</span><br><span class="line"></span><br><span class="line">    public MyClassLoader(ClassLoader parent) &#123;</span><br><span class="line">        super(parent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Class loadClass(String name) throws ClassNotFoundException &#123;</span><br><span class="line">        if(!&quot;reflection.MyObject&quot;.equals(name))</span><br><span class="line">                return super.loadClass(name);</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            String url = &quot;file:C:/data/projects/tutorials/web/WEB-INF/&quot; +</span><br><span class="line">                            &quot;classes/reflection/MyObject.class&quot;;</span><br><span class="line"></span><br><span class="line">            URL myUrl = new URL(url);</span><br><span class="line">            URLConnection connection = myUrl.openConnection();</span><br><span class="line">            InputStream input = connection.getInputStream();</span><br><span class="line">            ByteArrayOutputStream buffer = new ByteArrayOutputStream();</span><br><span class="line">            int data = input.read();</span><br><span class="line"></span><br><span class="line">            while(data != -1)&#123;</span><br><span class="line">                buffer.write(data);</span><br><span class="line">                data = input.read();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            input.close();</span><br><span class="line"></span><br><span class="line">            byte[] classData = buffer.toByteArray();</span><br><span class="line"></span><br><span class="line">            return defineClass(&quot;reflection.MyObject&quot;,</span><br><span class="line">                    classData, 0, classData.length);</span><br><span class="line">        &#125; catch (MalformedURLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面是使用MyClassLoader的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws ClassNotFoundException, IllegalAccessException, InstantiationException &#123;</span><br><span class="line"></span><br><span class="line">    ClassLoader parentClassLoader = MyClassLoader.class.getClassLoader();</span><br><span class="line">    MyClassLoader classLoader = new MyClassLoader(parentClassLoader);</span><br><span class="line">    Class myObjectClass = classLoader.loadClass(&quot;reflection.MyObject&quot;);</span><br><span class="line"></span><br><span class="line">    AnInterface2 object1 = (AnInterface2) myObjectClass.newInstance();</span><br><span class="line"></span><br><span class="line">    MyObjectSuperClass object2 =(MyObjectSuperClass) myObjectClass.newInstance();</span><br><span class="line"></span><br><span class="line">    //create new class loader so classes can be reloaded.</span><br><span class="line">    classLoader = new MyClassLoader(parentClassLoader);</span><br><span class="line">    myObjectClass = classLoader.loadClass(&quot;reflection.MyObject&quot;);</span><br><span class="line"></span><br><span class="line">    object1 = (AnInterface2) myObjectClass.newInstance();</span><br><span class="line">    object2 = (MyObjectSuperClass) myObjectClass.newInstance();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面这个就是被加载的reflection.MyObject类。注意它既继承了一个超类并且也实现了一个接口。这样做仅仅是为了通过例子演示这个特性。在你自定义的情况下你可能仅会实现一个类或者继承一两个接口。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public class MyObject extends MyObjectSuperClass implements AnInterface2&#123;</span><br><span class="line">    //... body of class ... override superclass methods</span><br><span class="line">    //    or implement interface methods</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wetts.github.io/2016/12/09/%E8%AF%AD%E8%A8%80/Java/API/reflection/Java-Reflection-11.%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Zhang Wetts">
      <meta itemprop="description" content="Stay Hungry, Stay Foolish. <br><br><p style="font-size:8px;">[build by hexo/next/gitalk/hexo-generator-search/LaTeX]</p>">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wetts's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2016/12/09/%E8%AF%AD%E8%A8%80/Java/API/reflection/Java-Reflection-11.%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/" class="post-title-link" itemprop="url">Java-Reflection-11.动态代理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2016-12-09 17:53:42" itemprop="dateCreated datePublished" datetime="2016-12-09T17:53:42+08:00">2016-12-09</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>转自：<a target="_blank" rel="noopener" href="http://ifeve.com/java-reflection-11-dynamic-proxies/">http://ifeve.com/java-reflection-11-dynamic-proxies/</a></p>
<p>利用Java反射机制你可以在运行期动态的创建接口的实现。java.lang.reflect.Proxy类就可以实现这一功能。这个类的名字（译者注：Proxy意思为代理）就是为什么把动态接口实现叫做动态代理。动态的代理的用途十分广泛，比如数据库连接和事物管理（transaction management）还有单元测试时用到的动态mock对象以及AOP中的方法拦截功能等等都使用到了动态代理。</p>
<h2 id="创建代理"><a href="#创建代理" class="headerlink" title="创建代理"></a>创建代理</h2><p>你可以通过使用Proxy.newProxyInstance()方法创建动态代理。newProxyInstance()方法有三个参数：</p>
<ol>
<li>类加载器（ClassLoader）用来加载动态代理类。</li>
<li>一个要实现的接口的数组。</li>
<li>一个InvocationHandler把所有方法的调用都转到代理上。</li>
</ol>
<p>如下例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">InvocationHandler handler = new MyInvocationHandler();</span><br><span class="line">MyInterface proxy = (MyInterface) Proxy.newProxyInstance(</span><br><span class="line">                            MyInterface.class.getClassLoader(),</span><br><span class="line">                            new Class[] &#123; MyInterface.class &#125;,</span><br><span class="line">                            handler);</span><br></pre></td></tr></table></figure>
<p>在执行完这段代码之后，变量proxy包含一个MyInterface接口的的动态实现。所有对proxy的调用都被转向到实现了InvocationHandler接口的handler上。有关InvocationHandler的内容会在下一段介绍。</p>
<h2 id="InvocationHandler接口"><a href="#InvocationHandler接口" class="headerlink" title="InvocationHandler接口"></a>InvocationHandler接口</h2><p>在前面提到了当你调用Proxy.newProxyInstance()方法时，你必须要传入一个InvocationHandler接口的实现。所有对动态代理对象的方法调用都会被转向到InvocationHandler接口的实现上，下面是InvocationHandler接口的定义：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public interface InvocationHandler&#123;</span><br><span class="line"></span><br><span class="line">  Object invoke(Object proxy, Method method, Object[] args) throws Throwable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面是它的实现类的定义：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class MyInvocationHandler implements InvocationHandler&#123;</span><br><span class="line"></span><br><span class="line">  public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">    //do something &quot;dynamic&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>传入invoke()方法中的proxy参数是实现要代理接口的动态代理对象。通常你是不需要他的。</p>
<p>invoke()方法中的Method对象参数代表了被动态代理的接口中要调用的方法，从这个method对象中你可以获取到这个方法名字，方法的参数，参数类型等等信息。关于这部分内容可以查阅之前有关Method的文章。</p>
<p>Object数组参数包含了被动态代理的方法需要的方法参数。注意：原生数据类型（如int，long等等）方法参数传入等价的包装对象（如Integer， Long等等）。</p>
<h2 id="常见用例"><a href="#常见用例" class="headerlink" title="常见用例"></a>常见用例</h2><p>动态代理常被应用到以下几种情况中</p>
<ul>
<li>数据库连接以及事物管理</li>
<li>单元测试中的动态Mock对象</li>
<li>自定义工厂与依赖注入（DI）容器之间的适配器</li>
<li>类似AOP的方法拦截器</li>
</ul>
<h3 id="数据库连接以及事物管理"><a href="#数据库连接以及事物管理" class="headerlink" title="数据库连接以及事物管理"></a>数据库连接以及事物管理</h3><p>Spring框架中有一个事物代理可以让你提交/回滚一个事物。它的具体原理在 <a target="_blank" rel="noopener" href="http://tutorials.jenkov.com/java-persistence/advanced-connection-and-transaction-demarcation-and-propagation.html">Advanced Connection and Transaction Demarcation and Propagation</a>一文中有详细描述，所以在这里我就简短的描述一下，方法调用序列如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">web controller --&gt; proxy.execute(...);</span><br><span class="line"></span><br><span class="line">  proxy --&gt; connection.setAutoCommit(false);</span><br><span class="line">  proxy --&gt; realAction.execute();</span><br><span class="line">    realAction does database work</span><br><span class="line">  proxy --&gt; connection.commit();</span><br></pre></td></tr></table></figure>

<h3 id="单元测试中的动态Mock对象"><a href="#单元测试中的动态Mock对象" class="headerlink" title="单元测试中的动态Mock对象"></a>单元测试中的动态Mock对象</h3><p><a target="_blank" rel="noopener" href="http://butterfly.jenkov.com/">Butterfly Testing</a>工具通过动态代理来动态实现桩（stub），mock和代理类来进行单元测试。在测试类A的时候如果用到了接口B，你可以传给A一个实现了B接口的mock来代替实际的B接口实现。所有对接口B的方法调用都会被记录，你可以自己来设置B的mock中方法的返回值。</p>
<p>而且Butterfly Testing工具可以让你在B的mock中包装真实的B接口实现，这样所有调用mock的方法都会被记录，然后把调用转向到真实的B接口实现。这样你就可以检查B中方法真实功能的调用情况。例如：你在测试DAO时你可以把真实的数据库连接包装到mock中。这样的话就与真实的情况一样，DAO可以在数据库中读写数据，mock会把对数据库的读写操作指令都传给数据库，你可以通过mock来检查DAO是不是以正确的方式来使用数据库连接，比如你可以检查是否调用了connection.close()方法。这种情况是不能简单的依靠调用DAO方法的返回值来判断的。</p>
<h3 id="自定义工厂与依赖注入（DI）容器之间的适配器"><a href="#自定义工厂与依赖注入（DI）容器之间的适配器" class="headerlink" title="自定义工厂与依赖注入（DI）容器之间的适配器"></a>自定义工厂与依赖注入（DI）容器之间的适配器</h3><p>依赖注入容器<a target="_blank" rel="noopener" href="http://butterfly.jenkov.com/">Butterfly Container</a>有一个非常强大的特性可以让你把整个容器注入到这个容器生成的bean中。但是，如果你不想依赖这个容器的接口，这个容器可以适配你自己定义的工厂接口。你仅仅需要这个接口而不是接口的实现，这样这个工厂接口和你的类看起来就像这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public interface IMyFactory &#123;</span><br><span class="line"></span><br><span class="line">  Bean bean1();</span><br><span class="line">  Person person();</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class MyAction&#123;</span><br><span class="line"></span><br><span class="line">  protected IMyFactory myFactory= null;</span><br><span class="line"></span><br><span class="line">  public MyAction(IMyFactory factory)&#123;</span><br><span class="line">    this.myFactory = factory;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void execute()&#123;</span><br><span class="line">    Bean bean = this.myFactory.bean();</span><br><span class="line">    Person person = this.myFactory.person();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当MyAction类调用通过容器注入到构造方法中的IMyFactory实例的方法时，这个方法调用实际先调用了IContainer.instance()方法，这个方法可以让你从容器中获取实例。这样这个对象可以把Butterfly Container容器在运行期当成一个工厂使用，比起在创建这个类的时候进行注入，这种方式显然更好。而且这种方法没有依赖到Butterfly Container中的任何接口。</p>
<h3 id="类似AOP的方法拦截器"><a href="#类似AOP的方法拦截器" class="headerlink" title="类似AOP的方法拦截器"></a>类似AOP的方法拦截器</h3><p>Spring框架可以拦截指定bean的方法调用，你只需提供这个bean继承的接口。Spring使用动态代理来包装bean。所有对bean中方法的调用都会被代理拦截。代理可以判断在调用实际方法之前是否需要调用其他方法或者调用其他对象的方法，还可以在bean的方法调用完毕之后再调用其他的代理方法。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wetts.github.io/2016/12/09/%E8%AF%AD%E8%A8%80/Java/API/reflection/Java-Reflection-10.%E6%95%B0%E7%BB%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Zhang Wetts">
      <meta itemprop="description" content="Stay Hungry, Stay Foolish. <br><br><p style="font-size:8px;">[build by hexo/next/gitalk/hexo-generator-search/LaTeX]</p>">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wetts's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2016/12/09/%E8%AF%AD%E8%A8%80/Java/API/reflection/Java-Reflection-10.%E6%95%B0%E7%BB%84/" class="post-title-link" itemprop="url">Java-Reflection-10.数组</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2016-12-09 17:45:59" itemprop="dateCreated datePublished" datetime="2016-12-09T17:45:59+08:00">2016-12-09</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>转自：<a target="_blank" rel="noopener" href="http://ifeve.com/java-reflection-10-arrays/">http://ifeve.com/java-reflection-10-arrays/</a></p>
<p>利用反射机制来处理数组会有点棘手。尤其是当你想要获得一个数组的Class对象，比如int[]等等。本节会讨论通过反射机制创建数组和如何获取数组的Class对象。</p>
<p>注意：在阅读Eyal Lupu的博客文章“<a target="_blank" rel="noopener" href="http://jroller.com/eyallupu/entry/two_side_notes_about_arrays">Two Side Notes About Arrays and Reflection</a>”之后对本文的内容做了更新。目前这个版本参考了这篇博文里面的内容。</p>
<h2 id="java-lang-reflect-Array"><a href="#java-lang-reflect-Array" class="headerlink" title="java.lang.reflect.Array"></a>java.lang.reflect.Array</h2><p>Java反射机制通过java.lang.reflect.Array这个类来处理数组。不要把这个类与Java集合套件（Collections suite）中的java.util.Arrays混淆，java.util.Arrays是一个提供了遍历数组，将数组转化为集合等工具方法的类。</p>
<h3 id="创建一个数组"><a href="#创建一个数组" class="headerlink" title="创建一个数组"></a>创建一个数组</h3><p>Java反射机制通过java.lang.reflect.Array类来创建数组。下面是一个如何创建数组的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int[] intArray = (int[]) Array.newInstance(int.class, 3);</span><br></pre></td></tr></table></figure>
<p>这个例子创建一个int类型的数组。Array.newInstance()方法的第一个参数表示了我们要创建一个什么类型的数组。第二个参数表示了这个数组的空间是多大。</p>
<h3 id="访问一个数组"><a href="#访问一个数组" class="headerlink" title="访问一个数组"></a>访问一个数组</h3><p>通过Java反射机制同样可以访问数组中的元素。具体可以使用Array.get(…)和Array.set(…)方法来访问。下面是一个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int[] intArray = (int[]) Array.newInstance(int.class, 3);</span><br><span class="line"></span><br><span class="line">Array.set(intArray, 0, 123);</span><br><span class="line">Array.set(intArray, 1, 456);</span><br><span class="line">Array.set(intArray, 2, 789);</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;intArray[0] = &quot; + Array.get(intArray, 0));</span><br><span class="line">System.out.println(&quot;intArray[1] = &quot; + Array.get(intArray, 1));</span><br><span class="line">System.out.println(&quot;intArray[2] = &quot; + Array.get(intArray, 2));</span><br></pre></td></tr></table></figure>
<p>这个例子会输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">intArray[0] = 123</span><br><span class="line">intArray[1] = 456</span><br><span class="line">intArray[2] = 789</span><br></pre></td></tr></table></figure>

<h3 id="获取数组的Class对象"><a href="#获取数组的Class对象" class="headerlink" title="获取数组的Class对象"></a>获取数组的Class对象</h3><p>在我编写<a target="_blank" rel="noopener" href="http://butterfly.jenkov.com/">Butterfly DI Container</a>的脚本语言时，当我想通过反射获取数组的Class对象时遇到了一点麻烦。如果不通过反射的话你可以这样来获取数组的Class对象：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class stringArrayClass = String[].class;</span><br></pre></td></tr></table></figure>
<p>如果使用Class.forName()方法来获取Class对象则不是那么简单。比如你可以像这样来获得一个原生数据类型（primitive）int数组的Class对象：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class intArray = Class.forName(&quot;[I&quot;);</span><br></pre></td></tr></table></figure>
<p>在JVM中字母I代表int类型，左边的‘[’代表我想要的是一个int类型的数组，这个规则同样适用于其他的原生数据类型。<br>对于普通对象类型的数组有一点细微的不同：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class stringArrayClass = Class.forName(&quot;[Ljava.lang.String;&quot;);</span><br></pre></td></tr></table></figure>
<p>注意‘[L’的右边是类名，类名的右边是一个‘;’符号。这个的含义是一个指定类型的数组。</p>
<p>需要注意的是，你不能通过Class.forName()方法获取一个原生数据类型的Class对象。下面这两个例子都会报ClassNotFoundException：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class intClass1 = Class.forName(&quot;I&quot;);</span><br><span class="line">Class intClass2 = Class.forName(&quot;int&quot;);</span><br></pre></td></tr></table></figure>
<p>我通常会用下面这个方法来获取普通对象以及原生对象的Class对象：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public Class getClass(String className)&#123;</span><br><span class="line"></span><br><span class="line">  if(&quot;int&quot; .equals(className)) return int .class;</span><br><span class="line">  if(&quot;long&quot;.equals(className)) return long.class;</span><br><span class="line">  ...</span><br><span class="line">  return Class.forName(className);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一旦你获取了类型的Class对象，你就有办法轻松的获取到它的数组的Class对象，你可以通过指定的类型创建一个空的数组，然后通过这个空的数组来获取数组的Class对象。这样做有点讨巧，不过很有效。如下例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class theClass = getClass(theClassName);</span><br><span class="line">Class stringArrayClass = Array.newInstance(theClass, 0).getClass();</span><br></pre></td></tr></table></figure>
<p>这是一个特别的方式来获取指定类型的指定数组的Class对象。无需使用类名或其他方式来获取这个Class对象。</p>
<p>为了确保Class对象是不是代表一个数组，你可以使用Class.isArray()方法来进行校验：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class stringArrayClass = Array.newInstance(String.class, 0).getClass();</span><br><span class="line">System.out.println(&quot;is array: &quot; + stringArrayClass.isArray());</span><br></pre></td></tr></table></figure>

<h3 id="获取数组的成员类型"><a href="#获取数组的成员类型" class="headerlink" title="获取数组的成员类型"></a>获取数组的成员类型</h3><p>一旦你获取了一个数组的Class对象，你就可以通过Class.getComponentType()方法获取这个数组的成员类型。成员类型就是数组存储的数据类型。例如，数组int[]的成员类型就是一个Class对象int.class。String[]的成员类型就是java.lang.String类的Class对象。</p>
<p>下面是一个访问数组成员类型的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String[] strings = new String[3];</span><br><span class="line">Class stringArrayClass = strings.getClass();</span><br><span class="line">Class stringArrayComponentType = stringArrayClass.getComponentType();</span><br><span class="line">System.out.println(stringArrayComponentType);</span><br></pre></td></tr></table></figure>
<p>下面这个例子会打印“java.lang.String”代表这个数组的成员类型是字符串。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wetts.github.io/2016/12/09/%E8%AF%AD%E8%A8%80/Java/API/reflection/Java-Reflection-8.%E6%B3%A8%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Zhang Wetts">
      <meta itemprop="description" content="Stay Hungry, Stay Foolish. <br><br><p style="font-size:8px;">[build by hexo/next/gitalk/hexo-generator-search/LaTeX]</p>">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wetts's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2016/12/09/%E8%AF%AD%E8%A8%80/Java/API/reflection/Java-Reflection-8.%E6%B3%A8%E8%A7%A3/" class="post-title-link" itemprop="url">Java-Reflection-8.注解</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2016-12-09 17:16:02" itemprop="dateCreated datePublished" datetime="2016-12-09T17:16:02+08:00">2016-12-09</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>转自：<a target="_blank" rel="noopener" href="http://ifeve.com/java-reflection-8-annotation/">http://ifeve.com/java-reflection-8-annotation/</a></p>
<p>利用Java反射机制可以在运行期获取Java类的注解信息。</p>
<h2 id="什么是注解"><a href="#什么是注解" class="headerlink" title="什么是注解"></a>什么是注解</h2><p>注解是Java 5的一个新特性。注解是插入你代码中的一种注释或者说是一种元数据（meta data）。这些注解信息可以在编译期使用预编译工具进行处理（pre-compiler tools），也可以在运行期使用Java反射机制进行处理。下面是一个类注解的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@MyAnnotation(name=&quot;someName&quot;,  value = &quot;Hello World&quot;)</span><br><span class="line">public class TheClass &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>在TheClass类定义的上面有一个@MyAnnotation的注解。注解的定义与接口的定义相似，下面是MyAnnotation注解的定义：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Target(ElementType.TYPE)</span><br><span class="line">public @interface MyAnnotation &#123;</span><br><span class="line"></span><br><span class="line">  public String name();</span><br><span class="line"></span><br><span class="line">  public String value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在interface前面的@符号表名这是一个注解，一旦你定义了一个注解之后你就可以将其应用到你的代码中，就像之前我们的那个例子那样。</p>
<p>在注解定义中的两个指示<code>@Retention(RetentionPolicy.RUNTIME)</code>和<code>@Target(ElementType.TYPE)</code>，说明了这个注解该如何使用。</p>
<p><code>@Retention(RetentionPolicy.RUNTIME)</code>表示这个注解可以在运行期通过反射访问。如果你没有在注解定义的时候使用这个指示那么这个注解的信息不会保留到运行期，这样反射就无法获取它的信息。</p>
<p><code>@Target(ElementType.TYPE)</code>表示这个注解只能用在类型上面（比如类跟接口）。你同样可以把Type改为Field或者Method，或者你可以不用这个指示，这样的话你的注解在类，方法和变量上就都可以使用了。</p>
<p>关于Java注解更详细的讲解可以访问<a target="_blank" rel="noopener" href="http://tutorials.jenkov.com/java/annotations.html">Java Annotations tutorial</a>。</p>
<h2 id="类注解"><a href="#类注解" class="headerlink" title="类注解"></a>类注解</h2><p>你可以在运行期访问类，方法或者变量的注解信息，下是一个访问类注解的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Class aClass = TheClass.class;</span><br><span class="line">Annotation[] annotations = aClass.getAnnotations();</span><br><span class="line"></span><br><span class="line">for(Annotation annotation : annotations)&#123;</span><br><span class="line">    if(annotation instanceof MyAnnotation)&#123;</span><br><span class="line">        MyAnnotation myAnnotation = (MyAnnotation) annotation;</span><br><span class="line">        System.out.println(&quot;name: &quot; + myAnnotation.name());</span><br><span class="line">        System.out.println(&quot;value: &quot; + myAnnotation.value());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你还可以像下面这样指定访问一个类的注解：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Class aClass = TheClass.class;</span><br><span class="line">Annotation annotation = aClass.getAnnotation(MyAnnotation.class);</span><br><span class="line"></span><br><span class="line">if(annotation instanceof MyAnnotation)&#123;</span><br><span class="line">    MyAnnotation myAnnotation = (MyAnnotation) annotation;</span><br><span class="line">    System.out.println(&quot;name: &quot; + myAnnotation.name());</span><br><span class="line">    System.out.println(&quot;value: &quot; + myAnnotation.value());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="方法注解"><a href="#方法注解" class="headerlink" title="方法注解"></a>方法注解</h2><p>下面是一个方法注解的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class TheClass &#123;</span><br><span class="line"></span><br><span class="line">  @MyAnnotation(name=&quot;someName&quot;,  value = &quot;Hello World&quot;)</span><br><span class="line">  public void doSomething()&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你可以像这样访问方法注解：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Method method = ... //获取方法对象</span><br><span class="line">Annotation[] annotations = method.getDeclaredAnnotations();</span><br><span class="line"></span><br><span class="line">for(Annotation annotation : annotations)&#123;</span><br><span class="line">    if(annotation instanceof MyAnnotation)&#123;</span><br><span class="line">        MyAnnotation myAnnotation = (MyAnnotation) annotation;</span><br><span class="line">        System.out.println(&quot;name: &quot; + myAnnotation.name());</span><br><span class="line">        System.out.println(&quot;value: &quot; + myAnnotation.value());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你可以像这样访问指定的方法注解：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Method method = ... // 获取方法对象</span><br><span class="line">Annotation annotation = method.getAnnotation(MyAnnotation.class);</span><br><span class="line"></span><br><span class="line">if(annotation instanceof MyAnnotation)&#123;</span><br><span class="line">    MyAnnotation myAnnotation = (MyAnnotation) annotation;</span><br><span class="line">    System.out.println(&quot;name: &quot; + myAnnotation.name());</span><br><span class="line">    System.out.println(&quot;value: &quot; + myAnnotation.value());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参数注解"><a href="#参数注解" class="headerlink" title="参数注解"></a>参数注解</h2><p>方法参数也可以添加注解，就像下面这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class TheClass &#123;</span><br><span class="line"></span><br><span class="line">  public static void doSomethingElse(@MyAnnotation(name=&quot;aName&quot;, value=&quot;aValue&quot;) String parameter)&#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你可以通过Method对象来访问方法参数注解：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Method method = ... //获取方法对象</span><br><span class="line">Annotation[][] parameterAnnotations = method.getParameterAnnotations();</span><br><span class="line">Class[] parameterTypes = method.getParameterTypes();</span><br><span class="line"></span><br><span class="line">int i=0;</span><br><span class="line">for(Annotation[] annotations : parameterAnnotations)&#123;</span><br><span class="line">  Class parameterType = parameterTypes[i++];</span><br><span class="line"></span><br><span class="line">  for(Annotation annotation : annotations)&#123;</span><br><span class="line">    if(annotation instanceof MyAnnotation)&#123;</span><br><span class="line">        MyAnnotation myAnnotation = (MyAnnotation) annotation;</span><br><span class="line">        System.out.println(&quot;param: &quot; + parameterType.getName());</span><br><span class="line">        System.out.println(&quot;name : &quot; + myAnnotation.name());</span><br><span class="line">        System.out.println(&quot;value: &quot; + myAnnotation.value());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要注意的是Method.getParameterAnnotations()方法返回一个注解类型的二维数组，每一个方法的参数包含一个注解数组。</p>
<h2 id="变量注解"><a href="#变量注解" class="headerlink" title="变量注解"></a>变量注解</h2><p>下面是一个变量注解的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class TheClass &#123;</span><br><span class="line"></span><br><span class="line">  @MyAnnotation(name=&quot;someName&quot;,  value = &quot;Hello World&quot;)</span><br><span class="line">  public String myField = null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你可以像这样来访问变量的注解：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Field field = ... //获取方法对象&lt;/pre&gt;</span><br><span class="line">Annotation[] annotations = field.getDeclaredAnnotations();</span><br><span class="line"></span><br><span class="line">for(Annotation annotation : annotations)&#123;</span><br><span class="line">  if(annotation instanceof MyAnnotation)&#123;</span><br><span class="line">    MyAnnotation myAnnotation = (MyAnnotation) annotation;</span><br><span class="line">    System.out.println(&quot;name: &quot; + myAnnotation.name());</span><br><span class="line">    System.out.println(&quot;value: &quot; + myAnnotation.value());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你可以像这样访问指定的变量注解：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Field field = ...//获取方法对象&lt;/pre&gt;</span><br><span class="line">Annotation annotation = field.getAnnotation(MyAnnotation.class);</span><br><span class="line"></span><br><span class="line">if(annotation instanceof MyAnnotation)&#123;</span><br><span class="line">  MyAnnotation myAnnotation = (MyAnnotation) annotation;</span><br><span class="line">  System.out.println(&quot;name: &quot; + myAnnotation.name());</span><br><span class="line">  System.out.println(&quot;value: &quot; + myAnnotation.value());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wetts.github.io/2016/12/09/%E8%AF%AD%E8%A8%80/Java/API/reflection/Java-Reflection-9.%E6%B3%9B%E5%9E%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Zhang Wetts">
      <meta itemprop="description" content="Stay Hungry, Stay Foolish. <br><br><p style="font-size:8px;">[build by hexo/next/gitalk/hexo-generator-search/LaTeX]</p>">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wetts's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2016/12/09/%E8%AF%AD%E8%A8%80/Java/API/reflection/Java-Reflection-9.%E6%B3%9B%E5%9E%8B/" class="post-title-link" itemprop="url">Java-Reflection-9.泛型</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2016-12-09 17:16:02" itemprop="dateCreated datePublished" datetime="2016-12-09T17:16:02+08:00">2016-12-09</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>转自：<a target="_blank" rel="noopener" href="http://ifeve.com/java-reflection-9-generics/">http://ifeve.com/java-reflection-9-generics/</a></p>
<p>我常常在一些文章以及论坛中读到说Java泛型信息在编译期被擦除（erased）所以你无法在运行期获得有关泛型的信息。其实这种说法并不完全正确的，在一些情况下是可以在运行期获取到泛型的信息。这些情况其实覆盖了一些我们需要泛型信息的需求。在本节中我们会演示一下这些情况。</p>
<h2 id="运用泛型反射的经验法则"><a href="#运用泛型反射的经验法则" class="headerlink" title="运用泛型反射的经验法则"></a>运用泛型反射的经验法则</h2><p>下面是两个典型的使用泛型的场景：</p>
<ol>
<li>声明一个需要被参数化（parameterizable）的类/接口。</li>
<li>使用一个参数化类。</li>
</ol>
<p>当你声明一个类或者接口的时候你可以指明这个类或接口可以被参数化，java.util.List接口就是典型的例子。你可以运用泛型机制创建一个标明存储的是String类型list，这样比你创建一个Object的list要更好。</p>
<p>当你想在运行期参数化类型本身，比如你想检查java.util.List类的参数化类型，你是没有办法能知道他具体的参数化类型是什么。这样一来这个类型就可以是一个应用中所有的类型。但是，当你检查一个使用了被参数化的类型的变量或者方法，你可以获得这个被参数化类型的具体参数。总之：</p>
<p>你不能在运行期获知一个被参数化的类型的具体参数类型是什么，但是你可以在用到这个被参数化类型的方法以及变量中找到他们，换句话说就是获知他们具体的参数化类型。（意思是，虽然我们不能在运行期获取到一个泛型类的参数类型信息,但是可以通过一些有用到这个泛型类的方法或者变量中来找到他们的参数类型信息）</p>
<p>在下面的段落中会向你演示这类情况。</p>
<h2 id="泛型方法返回类型"><a href="#泛型方法返回类型" class="headerlink" title="泛型方法返回类型"></a>泛型方法返回类型</h2><p>如果你获得了java.lang.reflect.Method对象，那么你就可以获取到这个方法的泛型返回类型信息。如果方法是在一个被参数化类型之中（译者注：如T fun()）那么你无法获取他的具体类型，但是如果方法返回一个泛型类（译者注：如List fun()）那么你就可以获得这个泛型类的具体参数化类型。你可以在“<a target="_blank" rel="noopener" href="http://tutorials.jenkov.com/java-reflection/generics.html">Java Reflection: Methods</a>”中阅读到有关如何获取Method对象的相关内容。下面这个例子定义了一个类这个类中的方法返回类型是一个泛型类型：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class MyClass &#123;</span><br><span class="line"></span><br><span class="line">  protected List&lt;String&gt; stringList = ...;</span><br><span class="line"></span><br><span class="line">  public List&lt;String&gt; getStringList()&#123;</span><br><span class="line">    return this.stringList;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以获取getStringList()方法的泛型返回类型，换句话说，我们可以检测到getStringList()方法返回的是List而不仅仅只是一个List。如下例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Method method = MyClass.class.getMethod(&quot;getStringList&quot;, null);</span><br><span class="line">Type returnType = method.getGenericReturnType();</span><br><span class="line"></span><br><span class="line">if(returnType instanceof ParameterizedType)&#123;</span><br><span class="line">  ParameterizedType type = (ParameterizedType) returnType;</span><br><span class="line">  Type[] typeArguments = type.getActualTypeArguments();</span><br><span class="line">  for(Type typeArgument : typeArguments)&#123;</span><br><span class="line">    Class typeArgClass = (Class) typeArgument;</span><br><span class="line">    System.out.println(&quot;typeArgClass = &quot; + typeArgClass);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码会打印出 “typeArgClass = java.lang.String”，Type[]数组typeArguments只有一个结果 – 一个代表java.lang.String的Class类的实例。Class类实现了Type接口。</p>
<h2 id="泛型方法参数类型"><a href="#泛型方法参数类型" class="headerlink" title="泛型方法参数类型"></a>泛型方法参数类型</h2><p>你同样可以通过反射来获取方法参数的泛型类型，下面这个例子定义了一个类，这个类中的方法的参数是一个被参数化的List：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class MyClass &#123;</span><br><span class="line"></span><br><span class="line">  protected List&lt;String&gt; stringList = ...;</span><br><span class="line"></span><br><span class="line">  public void setStringList(List&lt;String&gt; list)&#123;</span><br><span class="line">    this.stringList = list;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你可以像这样来获取方法的泛型参数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">method = Myclass.class.getMethod(&quot;setStringList&quot;, List.class);</span><br><span class="line">Type[] genericParameterTypes = method.getGenericParameterTypes();</span><br><span class="line"></span><br><span class="line">for(Type genericParameterType : genericParameterTypes)&#123;</span><br><span class="line">  if(genericParameterType instanceof ParameterizedType)&#123;</span><br><span class="line">    ParameterizedType aType = (ParameterizedType) genericParameterType;</span><br><span class="line">    Type[] parameterArgTypes = aType.getActualTypeArguments();</span><br><span class="line"></span><br><span class="line">    for(Type parameterArgType : parameterArgTypes)&#123;</span><br><span class="line">      Class parameterArgClass = (Class) parameterArgType;</span><br><span class="line">      System.out.println(&quot;parameterArgClass = &quot; + parameterArgClass);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码会打印出”parameterArgType = java.lang.String”。Type[]数组parameterArgTypes只有一个结果 – 一个代表java.lang.String的Class类的实例。Class类实现了Type接口。</p>
<h2 id="泛型变量类型"><a href="#泛型变量类型" class="headerlink" title="泛型变量类型"></a>泛型变量类型</h2><p>同样可以通过反射来访问公有（Public）变量的泛型类型，无论这个变量是一个类的静态成员变量或是实例成员变量。你可以在“<a target="_blank" rel="noopener" href="http://tutorials.jenkov.com/java-reflection/fields.html">Java Reflection: Fields</a>”中阅读到有关如何获取Field对象的相关内容。这是之前的一个例子，一个定义了一个名为stringList的成员变量的类。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public class MyClass &#123;</span><br><span class="line"></span><br><span class="line">  public List&lt;String&gt; stringList = ...;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Field field = MyClass.class.getField(&quot;stringList&quot;);</span><br><span class="line">Type genericFieldType = field.getGenericType();</span><br><span class="line"></span><br><span class="line">if(genericFieldType instanceof ParameterizedType)&#123;</span><br><span class="line">  ParameterizedType aType = (ParameterizedType) genericFieldType;</span><br><span class="line">  Type[] fieldArgTypes = aType.getActualTypeArguments();</span><br><span class="line"></span><br><span class="line">  for(Type fieldArgType : fieldArgTypes)&#123;</span><br><span class="line">    Class fieldArgClass = (Class) fieldArgType;</span><br><span class="line">    System.out.println(&quot;fieldArgClass = &quot; + fieldArgClass);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码会打印出”fieldArgClass = java.lang.String”。Type[]数组fieldArgClass只有一个结果 – 一个代表java.lang.String的Class类的实例。Class类实现了Type接口。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wetts.github.io/2016/12/09/%E8%AF%AD%E8%A8%80/Java/API/reflection/Java-Reflection-7.%E7%A7%81%E6%9C%89%E5%8F%98%E9%87%8F%E5%92%8C%E7%A7%81%E6%9C%89%E6%96%B9%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Zhang Wetts">
      <meta itemprop="description" content="Stay Hungry, Stay Foolish. <br><br><p style="font-size:8px;">[build by hexo/next/gitalk/hexo-generator-search/LaTeX]</p>">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wetts's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2016/12/09/%E8%AF%AD%E8%A8%80/Java/API/reflection/Java-Reflection-7.%E7%A7%81%E6%9C%89%E5%8F%98%E9%87%8F%E5%92%8C%E7%A7%81%E6%9C%89%E6%96%B9%E6%B3%95/" class="post-title-link" itemprop="url">Java-Reflection-7.私有变量和私有方法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2016-12-09 17:08:47" itemprop="dateCreated datePublished" datetime="2016-12-09T17:08:47+08:00">2016-12-09</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>转自：<a target="_blank" rel="noopener" href="http://ifeve.com/java-reflection-7/">http://ifeve.com/java-reflection-7/</a></p>
<p>在通常的观点中从对象的外部访问私有变量以及方法是不允许的，但是Java反射机制可以做到这一点。使用这个功能并不困难，在进行单元测试时这个功能非常有效。本节会向你展示如何使用这个功能。</p>
<p>注意：这个功能只有在代码运行在单机Java应用(standalone Java application)中才会有效,就像你做单元测试或者一些常规的应用程序一样。如果你在Java Applet中使用这个功能，那么你就要想办法去应付SecurityManager对你限制了。但是一般情况下我们是不会这么做的，所以在本节里面我们不会探讨这个问题。</p>
<h2 id="访问私有变量"><a href="#访问私有变量" class="headerlink" title="访问私有变量"></a>访问私有变量</h2><p>要想获取私有变量你可以调用<code>Class.getDeclaredField(String name)</code>方法或者<code>Class.getDeclaredFields()</code>方法。<code>Class.getField(String name)</code>和<code>Class.getFields()</code>只会返回公有的变量，无法获取私有变量。下面例子定义了一个包含私有变量的类，在它下面是如何通过反射获取私有变量的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class PrivateObject &#123;</span><br><span class="line">  private String privateString = null;</span><br><span class="line"></span><br><span class="line">  public PrivateObject(String privateString) &#123;</span><br><span class="line">    this.privateString = privateString;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PrivateObject privateObject = new PrivateObject(&quot;The Private Value&quot;);</span><br><span class="line">Field privateStringField = PrivateObject.class.getDeclaredField(&quot;privateString&quot;);</span><br><span class="line">privateStringField.setAccessible(true);</span><br><span class="line">String fieldValue = (String) privateStringField.get(privateObject);</span><br><span class="line">System.out.println(&quot;fieldValue = &quot; + fieldValue);</span><br></pre></td></tr></table></figure>
<p>这个例子会输出<code>fieldValue = The Private Value</code>，The Private Value是PrivateObject实例的privateString私有变量的值，注意调用<code>PrivateObject.class.getDeclaredField(“privateString”)</code>方法会返回一个私有变量，这个方法返回的变量是定义在PrivateObject类中的而不是在它的父类中定义的变量。</p>
<p>注意<code>privateStringField.setAccessible(true)</code>这行代码，通过调用<code>setAccessible()</code>方法会关闭指定类Field实例的反射访问检查，这行代码执行之后不论是私有的、受保护的以及包访问的作用域，你都可以在任何地方访问，即使你不在他的访问权限作用域之内。但是你如果你用一般代码来访问这些不在你权限作用域之内的代码依然是不可以的，在编译的时候就会报错。</p>
<h2 id="访问私有方法"><a href="#访问私有方法" class="headerlink" title="访问私有方法"></a>访问私有方法</h2><p>访问一个私有方法你需要调用 <code>Class.getDeclaredMethod(String name, Class[] parameterTypes)</code>或者<code>Class.getDeclaredMethods()</code> 方法。 <code>Class.getMethod(String name, Class[] parameterTypes)</code>和<code>Class.getMethods()</code>方法，只会返回公有的方法，无法获取私有方法。下面例子定义了一个包含私有方法的类，在它下面是如何通过反射获取私有方法的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class PrivateObject &#123;</span><br><span class="line">  private String privateString = null;</span><br><span class="line"></span><br><span class="line">  public PrivateObject(String privateString) &#123;</span><br><span class="line">    this.privateString = privateString;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private String getPrivateString()&#123;</span><br><span class="line">    return this.privateString;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PrivateObject privateObject = new PrivateObject(&quot;The Private Value&quot;);</span><br><span class="line">Method privateStringMethod = PrivateObject.class.getDeclaredMethod(&quot;getPrivateString&quot;, null);</span><br><span class="line">privateStringMethod.setAccessible(true);</span><br><span class="line">String returnValue = (String)privateStringMethod.invoke(privateObject, null);</span><br><span class="line">System.out.println(&quot;returnValue = &quot; + returnValue);</span><br></pre></td></tr></table></figure>
<p>这个例子会输出<code>returnValue = The Private Value</code>，The Private Value是PrivateObject实例的<code>getPrivateString()</code>方法的返回值。</p>
<p><code>PrivateObject.class.getDeclaredMethod(“privateString”)</code>方法会返回一个私有方法，这个方法是定义在PrivateObject类中的而不是在它的父类中定义的。</p>
<p>同样的，注意<code>Method.setAcessible(true)</code>这行代码，通过调用<code>setAccessible()</code>方法会关闭指定类的Method实例的反射访问检查，这行代码执行之后不论是私有的、受保护的以及包访问的作用域，你都可以在任何地方访问，即使你不在他的访问权限作用域之内。但是你如果你用一般代码来访问这些不在你权限作用域之内的代码依然是不可以的，在编译的时候就会报错。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wetts.github.io/2016/12/09/%E8%AF%AD%E8%A8%80/Java/API/reflection/Java-Reflection-6.Getters%20and%20Setters/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Zhang Wetts">
      <meta itemprop="description" content="Stay Hungry, Stay Foolish. <br><br><p style="font-size:8px;">[build by hexo/next/gitalk/hexo-generator-search/LaTeX]</p>">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wetts's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2016/12/09/%E8%AF%AD%E8%A8%80/Java/API/reflection/Java-Reflection-6.Getters%20and%20Setters/" class="post-title-link" itemprop="url">Java-Reflection-6.Getters and Setters</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2016-12-09 17:05:51" itemprop="dateCreated datePublished" datetime="2016-12-09T17:05:51+08:00">2016-12-09</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>转自：<a target="_blank" rel="noopener" href="http://ifeve.com/java-reflection%E5%85%ADgetters-and-setters/">http://ifeve.com/java-reflection%E5%85%ADgetters-and-setters/</a></p>
<p>使用Java反射你可以在运行期检查一个方法的信息以及在运行期调用这个方法，使用这个功能同样可以获取指定类的getters和setters，你不能直接寻找getters和setters，你需要检查一个类所有的方法来判断哪个方法是getters和setters。</p>
<p>首先让我们来规定一下getters和setters的特性：</p>
<h3 id="Getter"><a href="#Getter" class="headerlink" title="Getter"></a>Getter</h3><p>Getter方法的名字以get开头，没有方法参数，返回一个值。</p>
<h3 id="Setter"><a href="#Setter" class="headerlink" title="Setter"></a>Setter</h3><p>Setter方法的名字以set开头，有一个方法参数。</p>
<p>setters方法有可能会有返回值也有可能没有，一些Setter方法返回void，一些用来设置值，有一些对象的setter方法在方法链中被调用（译者注：这类的setter方法必须要有返回值），因此你不应该妄自假设setter方法的返回值，一切应该视情况而定。</p>
<p>下面是一个获取getter方法和setter方法的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public static void printGettersSetters(Class aClass)&#123;</span><br><span class="line">  Method[] methods = aClass.getMethods();</span><br><span class="line">  for(Method method : methods)&#123;</span><br><span class="line">    if(isGetter(method)) System.out.println(&quot;getter: &quot; + method);</span><br><span class="line">    if(isSetter(method)) System.out.println(&quot;setter: &quot; + method);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static boolean isGetter(Method method)&#123;</span><br><span class="line">  if(!method.getName().startsWith(&quot;get&quot;))      return false;</span><br><span class="line">  if(method.getParameterTypes().length != 0)   return false;</span><br><span class="line">  if(void.class.equals(method.getReturnType()) return false;</span><br><span class="line">  return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static boolean isSetter(Method method)&#123;</span><br><span class="line">  if(!method.getName().startsWith(&quot;set&quot;)) return false;</span><br><span class="line">  if(method.getParameterTypes().length != 1) return false;</span><br><span class="line">  return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wetts.github.io/2016/12/09/%E8%AF%AD%E8%A8%80/Java/API/reflection/Java-Reflection-5.%E6%96%B9%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Zhang Wetts">
      <meta itemprop="description" content="Stay Hungry, Stay Foolish. <br><br><p style="font-size:8px;">[build by hexo/next/gitalk/hexo-generator-search/LaTeX]</p>">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wetts's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2016/12/09/%E8%AF%AD%E8%A8%80/Java/API/reflection/Java-Reflection-5.%E6%96%B9%E6%B3%95/" class="post-title-link" itemprop="url">Java-Reflection-5.方法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2016-12-09 17:01:32" itemprop="dateCreated datePublished" datetime="2016-12-09T17:01:32+08:00">2016-12-09</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>转自：<a target="_blank" rel="noopener" href="http://ifeve.com/java-reflection%E4%BA%94%E6%96%B9%E6%B3%95/">http://ifeve.com/java-reflection%E4%BA%94%E6%96%B9%E6%B3%95/</a></p>
<p>使用Java反射你可以在运行期检查一个方法的信息以及在运行期调用这个方法，通过使用java.lang.reflect.Method类就可以实现上述功能。在本节会带你深入了解Method对象的信息。</p>
<h2 id="获取Method对象"><a href="#获取Method对象" class="headerlink" title="获取Method对象"></a>获取Method对象</h2><p>可以通过Class对象获取Method对象，如下例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class aClass = ...//获取Class对象</span><br><span class="line">Method[] methods = aClass.getMethods();</span><br></pre></td></tr></table></figure>
<p>返回的Method对象数组包含了指定类中声明为公有的(public)的所有变量集合。</p>
<p>如果你知道你要调用方法的具体参数类型，你就可以直接通过参数类型来获取指定的方法，下面这个例子中返回方法对象名称是“doSomething”，他的方法参数是String类型：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class  aClass = ...//获取Class对象</span><br><span class="line">Method method = aClass.getMethod(&quot;doSomething&quot;, new Class[]&#123;String.class&#125;);</span><br></pre></td></tr></table></figure>
<p>如果根据给定的方法名称以及参数类型无法匹配到相应的方法，则会抛出NoSuchMethodException。</p>
<p>如果你想要获取的方法没有参数，那么在调用getMethod()方法时第二个参数传入null即可，就像这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class  aClass = ...//获取Class对象</span><br><span class="line">Method method = aClass.getMethod(&quot;doSomething&quot;, null);</span><br></pre></td></tr></table></figure>

<h2 id="方法参数以及返回类型"><a href="#方法参数以及返回类型" class="headerlink" title="方法参数以及返回类型"></a>方法参数以及返回类型</h2><p>你可以获取指定方法的方法参数是哪些：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Method method = ... //获取Class对象</span><br><span class="line">Class[] parameterTypes = method.getParameterTypes();</span><br></pre></td></tr></table></figure>
<p>你可以获取指定方法的返回类型：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Method method = ... //获取Class对象</span><br><span class="line">Class returnType = method.getReturnType();</span><br></pre></td></tr></table></figure>

<h2 id="通过Method对象调用方法"><a href="#通过Method对象调用方法" class="headerlink" title="通过Method对象调用方法"></a>通过Method对象调用方法</h2><p>你可以通过如下方式来调用一个方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//获取一个方法名为doSomesthing，参数类型为String的方法</span><br><span class="line">Method method = MyObject.class.getMethod(&quot;doSomething&quot;, String.class);</span><br><span class="line">Object returnValue = method.invoke(null, &quot;parameter-value1&quot;);</span><br></pre></td></tr></table></figure>
<p>传入的null参数是你要调用方法的对象，如果是一个静态方法调用的话则可以用null代替指定对象作为invoke()的参数，在上面这个例子中，如果doSomething不是静态方法的话，你就要传入有效的MyObject实例而不是null。</p>
<p>Method.invoke(Object target, Object … parameters)方法的第二个参数是一个可变参数列表，但是你必须要传入与你要调用方法的形参一一对应的实参。就像上个例子那样，方法需要String类型的参数，那我们必须要传入一个字符串。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/31/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/31/">31</a><span class="page-number current">32</span><a class="page-number" href="/page/33/">33</a><span class="space">&hellip;</span><a class="page-number" href="/page/70/">70</a><a class="extend next" rel="next" href="/page/33/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Zhang Wetts"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">Zhang Wetts</p>
  <div class="site-description" itemprop="description">Stay Hungry, Stay Foolish. <br><br><p style="font-size:8px;">[build by hexo/next/gitalk/hexo-generator-search/LaTeX]</p></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">694</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">65</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">343</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/wetts" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;wetts" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:zhang.wetts@163.com" title="E-Mail → mailto:zhang.wetts@163.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Zhang Wetts</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

  


<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/hibiki.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"react":{"opacity":0.7}});</script></body>
</html>
