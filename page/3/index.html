<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"wetts.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="Stay Hungry, Stay Foolish. [build by hexo&#x2F;next&#x2F;gitalk&#x2F;hexo-generator-search&#x2F;LaTeX]">
<meta property="og:type" content="website">
<meta property="og:title" content="Wetts&#39;s blog">
<meta property="og:url" content="https://wetts.github.io/page/3/index.html">
<meta property="og:site_name" content="Wetts&#39;s blog">
<meta property="og:description" content="Stay Hungry, Stay Foolish. [build by hexo&#x2F;next&#x2F;gitalk&#x2F;hexo-generator-search&#x2F;LaTeX]">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Zhang Wetts">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://wetts.github.io/page/3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Wetts's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Wetts's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Stay Hungry, Stay Foolish.</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/wetts" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wetts.github.io/2020/07/19/%E8%AF%AD%E8%A8%80/Java/%E8%99%9A%E6%8B%9F%E6%9C%BA/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/%E5%B8%B8%E8%A7%81%E7%9A%84%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%8F%8A%E5%85%B6%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Zhang Wetts">
      <meta itemprop="description" content="Stay Hungry, Stay Foolish. <br><br><p style="font-size:8px;">[build by hexo/next/gitalk/hexo-generator-search/LaTeX]</p>">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wetts's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/07/19/%E8%AF%AD%E8%A8%80/Java/%E8%99%9A%E6%8B%9F%E6%9C%BA/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/%E5%B8%B8%E8%A7%81%E7%9A%84%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%8F%8A%E5%85%B6%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF/" class="post-title-link" itemprop="url">常见的垃圾收集器及其适用场景.md</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-07-19 01:44:26" itemprop="dateCreated datePublished" datetime="2020-07-19T01:44:26+08:00">2020-07-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-07-12 03:30:56" itemprop="dateModified" datetime="2021-07-12T03:30:56+08:00">2021-07-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/zzti_erlie/article/details/104585411%E3%80%81https://www.jianshu.com/p/8bd15969a641%E3%80%81https://www.cnblogs.com/chenpt/p/9803298.html">https://blog.csdn.net/zzti_erlie/article/details/104585411、https://www.jianshu.com/p/8bd15969a641、https://www.cnblogs.com/chenpt/p/9803298.html</a></p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><img src="/2020/07/19/%E8%AF%AD%E8%A8%80/Java/%E8%99%9A%E6%8B%9F%E6%9C%BA/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/%E5%B8%B8%E8%A7%81%E7%9A%84%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%8F%8A%E5%85%B6%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF/1.png" alt="1"></p>
<p>图中展示了七种作用于不同分代的收集器，如果两个收集器之间存在连线，就说明它们可以搭配使用。在JDK8时将 Serial+CMS，ParNew+Serial Old 这两个组合声明为废弃，并在 JDK9 中完全取消了这些组合的支持</p>
<ul>
<li>新生代收集器：Serial、ParNew、Parallel Scavenge</li>
<li>老年代收集器：CMS、Serial Old、Parallel Old</li>
<li>整堆收集器： G1</li>
</ul>
<p>先明确一些概念</p>
<ul>
<li><p>串行（Serial）</p>
</li>
<li><p>并行（Parallel）：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态</p>
</li>
<li><p>暂停式（Stop the world）</p>
</li>
<li><p>并发（Concurrent）：指用户线程与垃圾收集线程同时执行</p>
</li>
</ul>
<p>压缩（Compacting）和非压缩（Non-Compacting）：这一组概念是指，在垃圾回收结束之后，是否需要把所有的存活对象挪到一起，占据一个连续空间。在Compacting之后，也意味着可用内存占据了一个连续的空间，这个时候就可以使用bump-the-pointer的分配内存技术。在这种技术中，只需要持有一个指针指向已分配内存的尾部。每次分配的时候只需要检查剩余空闲空间能否容纳新的对象，而后分配内存并且将指针指向新的尾部。这种Compacting的计数，在一些算法中需要付出额外的代价，这个代价要么是需要额外的内存空间，要么是额外的回收时间。</p>
<p>并发和并行是一对比较容易搞混的概念。并发是指，垃圾回收和应用可以在一段时间内同时运行，这个概念和操作系统上的概念是一致的。在HotSpot中，并发垃圾回收算法中大部分垃圾回收的工作都是在并发的情况下完成的，但是并不能完全免除Stop-the-world。并行是指利用多个CPU，多个线程同时进行垃圾回收。</p>
<p>在衡量一个垃圾回收算法上，最为主要的两个度量是：</p>
<ul>
<li>暂停时间（pause time）：是指在一次垃圾回收中，Stop-the-world状态下占用的时间。暂停时间主要受到算法和堆大小的影响。相同条件下，堆越小，暂停时间就越短。但是堆越小，那么回收频率就越高。</li>
<li>吞吐量（throughput）：一般而言，堆越大，吞吐量越高，回收频率越低。</li>
</ul>
<p>可以看到一个有趣的地方：暂停时间和吞吐量对堆的大小要求是不一样的。暂停时间要想短，那么应该有更小堆；而吞吐量要大，需要更大的堆。</p>
<h2 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h2><p>新生代，标记-复制算法，单线程。进行垃圾收集时，必须暂停其他所有工作线程，直到它收集结束<br><img src="/2020/07/19/%E8%AF%AD%E8%A8%80/Java/%E8%99%9A%E6%8B%9F%E6%9C%BA/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/%E5%B8%B8%E8%A7%81%E7%9A%84%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%8F%8A%E5%85%B6%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF/Serial%E6%94%B6%E9%9B%86%E5%99%A8.png" alt="Serial收集器"></p>
<h2 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h2><p>ParNew 本质上是 Serial 收集器的多线程并行版本<br><img src="/2020/07/19/%E8%AF%AD%E8%A8%80/Java/%E8%99%9A%E6%8B%9F%E6%9C%BA/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/%E5%B8%B8%E8%A7%81%E7%9A%84%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%8F%8A%E5%85%B6%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF/ParNew%E6%94%B6%E9%9B%86%E5%99%A8.png" alt="ParNew收集器"></p>
<h2 id="Parallel-Scavenge-收集器"><a href="#Parallel-Scavenge-收集器" class="headerlink" title="Parallel Scavenge 收集器"></a>Parallel Scavenge 收集器</h2><p>新生代，标记复制算法，多线程，主要关注吞吐量</p>
<p><code>吞吐量=运行用户代码时间/(运行用户代码时间+运行垃圾收集时间)</code></p>
<h2 id="Serial-Old收集器"><a href="#Serial-Old收集器" class="headerlink" title="Serial Old收集器"></a>Serial Old收集器</h2><p>老年代，标记-整理算法，单线程，是 Serial 收集器的老年代版本</p>
<p>用处有如下 2 个</p>
<ul>
<li>在 JDK5 以及之前的版本中与 Parallel Scavenge 收集器搭配使用</li>
<li>作为 CMS 收集器发生失败时的后备预案，在并发收集发生 Concurrent Mode Failure 时使用</li>
</ul>
<h2 id="Parallel-Old收集器"><a href="#Parallel-Old收集器" class="headerlink" title="Parallel Old收集器"></a>Parallel Old收集器</h2><p>老年代，标记-整理算法，多线程，是 Parallel Scavenge 收集器的老年代版本</p>
<p>在注重吞吐量或者处理器资源较为稀缺的场合，都可以优先考虑 Parallel Scavenge 加 Parallel Old 收集器这个组合</p>
<p><img src="/2020/07/19/%E8%AF%AD%E8%A8%80/Java/%E8%99%9A%E6%8B%9F%E6%9C%BA/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/%E5%B8%B8%E8%A7%81%E7%9A%84%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%8F%8A%E5%85%B6%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF/Parallel%20Old%E6%94%B6%E9%9B%86%E5%99%A8.png" alt="Parallel Old收集器"></p>
<h2 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h2><p>老年代，标记-清除算法，多线程，主要关注延迟</p>
<p>运作过程分为4个步骤</p>
<ol>
<li>初始标记（CMS initial mark）</li>
<li>并发标记（CMS concurrent mark）</li>
<li>重新标记（CMS remark）</li>
<li>并发清除（CMS concurrent sweep）</li>
</ol>
<p><img src="/2020/07/19/%E8%AF%AD%E8%A8%80/Java/%E8%99%9A%E6%8B%9F%E6%9C%BA/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/%E5%B8%B8%E8%A7%81%E7%9A%84%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%8F%8A%E5%85%B6%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF/CMS%E6%94%B6%E9%9B%86%E5%99%A8.png" alt="CMS收集器"></p>
<ol>
<li>初始标记：标记一下GC Roots能直接关联到的对象，速度很快，需要“Stop The World”</li>
<li>并发标记：从GC Roots的直接关联对象开始遍历整个对象图的过程，这个过程耗时较长但是不需要停顿用户线程，可以与垃圾收集一起并发运行</li>
<li>重新标记：为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记的时间短。此阶段也需要“Stop The World”</li>
<li>并发清除：清理删除掉标记阶段判断的已经死亡的对象，由于不需要移动存活对象，所以看这个阶段也是可以与用户线程同时并发的</li>
</ol>
<h2 id="Garbage-First收集器（G1）"><a href="#Garbage-First收集器（G1）" class="headerlink" title="Garbage First收集器（G1）"></a>Garbage First收集器（G1）</h2><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><table>
<thead>
<tr>
<th>收集器</th>
<th>收集对象和算法</th>
<th>收集器类型</th>
<th>说明</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td>Serial</td>
<td>新生代，复制算法</td>
<td>单线程</td>
<td></td>
<td>简单高效；适合内存不大的情况</td>
</tr>
<tr>
<td>ParNew</td>
<td>新生代，复制算法</td>
<td>并行的多线程收集器</td>
<td>ParNew垃圾收集器是Serial收集器的多线程版本</td>
<td>搭配CMS垃圾回收器的首选</td>
</tr>
<tr>
<td>Parallel Scavenge吞吐量优先收集器</td>
<td>新生代，复制算法</td>
<td>并行的多线程收集器</td>
<td>类似ParNew，更加关注吞吐量，达到一个可控制的吞吐量</td>
<td>本身是Server级别多CPU机器上的默认GC方式，主要适合后台运算不需要太多交互的任务</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>收集器</th>
<th>收集对象和算法</th>
<th>收集器类型</th>
<th>说明</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td>Serial Old</td>
<td>老年代，标记整理算法</td>
<td>单线程</td>
<td></td>
<td>Client模式下虚拟机使用</td>
</tr>
<tr>
<td>Parallel Old</td>
<td>老年代，标记整理算法</td>
<td>并行的多线程收集器</td>
<td>Paraller Scavenge收集器的老年代版本，为了配置Parallel Svavenge的面向吞吐量的特性而开发的对应组合</td>
<td>在注重吞吐量以及CPU资源敏感的场合采用</td>
</tr>
<tr>
<td>CMS</td>
<td>老年代，标记清除算法</td>
<td>并行与并发收集器</td>
<td>尽可能的缩短垃圾收集时用户线程停止时间；缺点在于，1.内存碎片，2.需要更多CPU资源，3.浮动垃圾问题，需要更大的堆空间</td>
<td>重视服务的相应速度，系统停顿时间和用户体验的互联网网站或者B/S系统。互联网后端目前cms是主流的垃圾回收器</td>
</tr>
<tr>
<td>G1</td>
<td></td>
<td>跨新生代和老年代；标记整理+化整为零</td>
<td>并行与并发收集器</td>
<td>JDK1.7才正式引入，采用分区回收的思维，基本不牺牲吞吐量的前提下完成低停顿的内存回收；可预测的停顿是其最大的优势</td>
</tr>
</tbody></table>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wetts.github.io/2020/06/29/artificial_intelligence/%E6%9C%80%E4%BC%98%E8%A7%A3%E7%AE%97%E6%B3%95/BeanSearch/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Zhang Wetts">
      <meta itemprop="description" content="Stay Hungry, Stay Foolish. <br><br><p style="font-size:8px;">[build by hexo/next/gitalk/hexo-generator-search/LaTeX]</p>">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wetts's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/29/artificial_intelligence/%E6%9C%80%E4%BC%98%E8%A7%A3%E7%AE%97%E6%B3%95/BeanSearch/" class="post-title-link" itemprop="url">BeanSearch.md</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-06-29 16:34:09 / 修改时间：16:51:47" itemprop="dateCreated datePublished" datetime="2020-06-29T16:34:09+08:00">2020-06-29</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>使用一个模型来进行机器翻译时，并不是从得到的分布中进行随机取样，而是你要找到一个句子，使得条件概率最大化。</p>
<p>贪心搜索是一种来自计算机科学的算法，生成第一个词的分布以后，它将会根据你的条件语言模型挑选出最有可能的第一个词进入你的机器翻译模型中，在挑选出第一个词之后它将会继续挑选出最有可能的第二个词，然后继续挑选第三个最有可能的词，这种算法就叫做贪心搜索。这种方法得到的有可能是局部最优解，而不是全局最优解。</p>
<p>然而全排列所有组合，由于排列数量过于巨大，也没有可行性。</p>
<p>集束搜索（beam search）算法可以应用到寻找全局最优解上。</p>
<h3 id="集束搜索（Beam-Search）"><a href="#集束搜索（Beam-Search）" class="headerlink" title="集束搜索（Beam Search）"></a>集束搜索（Beam Search）</h3><p>贪婪算法只会挑出最可能的那一个单词，然后继续。而集束搜索则会考虑多个选择，集束搜索算法会有一个参数 B，叫做集束宽（beam width）。例如：把这个集束宽设成 3，这样就意味着集束搜索不会只考虑一个可能结果，而是一次会考虑 3 个。</p>
<p><img src="/2020/06/29/artificial_intelligence/%E6%9C%80%E4%BC%98%E8%A7%A3%E7%AE%97%E6%B3%95/BeanSearch/BeamSearch1.png" alt="BeamSearch1"></p>
<p><img src="/2020/06/29/artificial_intelligence/%E6%9C%80%E4%BC%98%E8%A7%A3%E7%AE%97%E6%B3%95/BeanSearch/BeamSearch2.png" alt="BeamSearch2"></p>
<p><img src="/2020/06/29/artificial_intelligence/%E6%9C%80%E4%BC%98%E8%A7%A3%E7%AE%97%E6%B3%95/BeanSearch/BeamSearch3.png" alt="BeamSearch3"></p>
<p><img src="/2020/06/29/artificial_intelligence/%E6%9C%80%E4%BC%98%E8%A7%A3%E7%AE%97%E6%B3%95/BeanSearch/BeamSearch4.png" alt="BeamSearch4"></p>
<h3 id="Beam-Search-改进"><a href="#Beam-Search-改进" class="headerlink" title="Beam Search 改进"></a>Beam Search 改进</h3><p>概率公式可表示为：$P(y^{&lt;1&gt;}|X)$ $P(y^{&lt; 2 &gt;}|X,y^{&lt; 1 &gt;})$ $P(y^{&lt; 3 &gt;}|X,y^{&lt; 1 &gt;},y^{&lt; 2&gt;})$…$P(y^{&lt; T_{y} &gt;}|X,y^{&lt;1 &gt;},y^{&lt;2 &gt;}\ldots y^{&lt; T_{y} - 1 &gt;})$。</p>
<p>这些概率值都是小于 1 的，通常远小于 1。很多小于 1 的数乘起来，会得到很小很小的数字，会造成数值下溢（<strong>numerical underflow</strong>）。数值下溢就是数值太小了，导致电脑的浮点表示不能精确地储存，因此在实践中,我们不会最大化这个乘积，而是取 $log$ 值。如果在这加上一个 $log$，最大化这个 $log$ 求和的概率值，在选择最可能的句子 $y$ 时，你会得到同样的结果。</p>
<p>如果参照原来的目标函数（<strong>this original objective</strong>），如果有一个很长的句子，那么这个句子的概率会很低，因为乘了很多项小于 1 的数字来估计句子的概率。所以如果乘起来很多小于 1 的数字，那么就会得到一个更小的概率值，所以这个目标函数有一个缺点，它可能不自然地倾向于简短的翻译结果，它更偏向短的输出，因为短句子的概率是由更少数量的小于 1 的数字乘积得到的，所以这个乘积不会那么小。顺便说一下，这里也有同样的问题，概率的 $log$ 值通常小于等于 1，实际上在 $log$ 的这个范围内，所以加起来的项越多，得到的结果越负，所以对这个算法另一个改变也可以使它表现的更好，也就是我们不再最大化这个目标函数了，我们可以把它归一化，通过除以翻译结果的单词数量（<strong>normalize this by the number of words in your translation</strong>）。这样就是取每个单词的概率对数值的平均了，这样很明显地减少了对输出长的结果的惩罚（**this significantly reduces the penalty for outputting longer translations.**）。</p>
<p>在实践中，有个探索性的方法，相比于直接除 $T_{y}$，也就是输出句子的单词总数，我们有时会用一个更柔和的方法（<strong>a softer approach</strong>），在 $T_{y}$ 上加上指数 $a$，$a$ 可以等于 0.7。如果 $a$ 等于 1，就相当于完全用长度来归一化，如果 $a$ 等于 0，$T_{y}$ 的 0 次幂就是 1，就相当于完全没有归一化，这就是在完全归一化和没有归一化之间。$a$ 就是算法另一个超参数（<strong>hyper parameter</strong>），需要调整大小来得到最好的结果。</p>
<h3 id="Beam-Search-误差分析"><a href="#Beam-Search-误差分析" class="headerlink" title="Beam Search 误差分析"></a>Beam Search 误差分析</h3><p><img src="/2020/06/29/artificial_intelligence/%E6%9C%80%E4%BC%98%E8%A7%A3%E7%AE%97%E6%B3%95/BeanSearch/BeamSearch%E8%AF%AF%E5%B7%AE%E5%88%86%E6%9E%901.png" alt="BeamSearch误差分析1"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wetts.github.io/2020/06/23/%E8%AF%AD%E8%A8%80/Python/%E7%8E%AF%E5%A2%83/Python-%E6%96%87%E4%BB%B6%E6%9C%8D%E5%8A%A1%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Zhang Wetts">
      <meta itemprop="description" content="Stay Hungry, Stay Foolish. <br><br><p style="font-size:8px;">[build by hexo/next/gitalk/hexo-generator-search/LaTeX]</p>">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wetts's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/23/%E8%AF%AD%E8%A8%80/Python/%E7%8E%AF%E5%A2%83/Python-%E6%96%87%E4%BB%B6%E6%9C%8D%E5%8A%A1%E5%99%A8/" class="post-title-link" itemprop="url">Python-文件服务器.md</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-06-23 11:22:12 / 修改时间：11:24:33" itemprop="dateCreated datePublished" datetime="2020-06-23T11:22:12+08:00">2020-06-23</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Python/" itemprop="url" rel="index"><span itemprop="name">Python</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h3><ul>
<li>Python2: <code>python -m SimpleHTTPServer 2019</code></li>
<li>Python3: <code>python3 -m http.server 2019</code></li>
</ul>
<h3 id="FTP"><a href="#FTP" class="headerlink" title="FTP"></a>FTP</h3><p>首先是安装这个模块</p>
<ul>
<li>python2: <code>pip install pyftpdlib</code></li>
<li>python3: <code>pip3 install pyftpdlib</code></li>
</ul>
<p>启动</p>
<ul>
<li>python2: <code>python -m pyftpdlib -p 2019</code></li>
<li>python3: <code>python -m pyftpdlib -p 2019</code></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wetts.github.io/2020/06/12/%E5%A4%A7%E6%95%B0%E6%8D%AE/Hadoop/Storm/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Zhang Wetts">
      <meta itemprop="description" content="Stay Hungry, Stay Foolish. <br><br><p style="font-size:8px;">[build by hexo/next/gitalk/hexo-generator-search/LaTeX]</p>">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wetts's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/12/%E5%A4%A7%E6%95%B0%E6%8D%AE/Hadoop/Storm/" class="post-title-link" itemprop="url">Storm.md</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-06-12 16:46:00 / 修改时间：17:46:05" itemprop="dateCreated datePublished" datetime="2020-06-12T16:46:00+08:00">2020-06-12</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Hadoop/" itemprop="url" rel="index"><span itemprop="name">Hadoop</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="流计算概述"><a href="#流计算概述" class="headerlink" title="流计算概述"></a>流计算概述</h2><h3 id="静态数据和流数据"><a href="#静态数据和流数据" class="headerlink" title="静态数据和流数据"></a>静态数据和流数据</h3><p>科从概念上而言，流数据（或数据流）是指在时间分布和数量上无限的一系列动态数据集合体；数据记录是流数据的最小组成单元。流数据具有如下特征：</p>
<ol>
<li>数据快速持续到达，潜在大小也许是无穷无尽的。</li>
<li>数据来源众多，格式复杂。</li>
<li>数据量大，但是不十分关注存储，一旦流数据中的某个元素经过处理，要么被丢弃，要么被归档存储。</li>
<li>注重数据的整体价值，不过分关注个别数据。</li>
<li>数据顺序颠倒，或者不完整，系统无法控制将要处理的新到达的数据元素的顺序。</li>
</ol>
<h3 id="批量计算和实时计算"><a href="#批量计算和实时计算" class="headerlink" title="批量计算和实时计算"></a>批量计算和实时计算</h3><p>对静态数据和流数据的处理，对应着两种截然不同的计算模式：批量计算和实时计算。</p>
<p>批量计算以“静态数据”为对象，可以在很充裕的时间内对海量数据进行批量处理，计算得到有价值的信息。Hadoop就是典型的批处理模型，由 HDFS 和 HBase 存放大量的静态数据，由 MapReduce 负贵对海量数据执行批量计算。</p>
<p>流数据则不适合采用批量计算，因为流数据不适合用传统的关系模型建模，不能把源源不断的流数据保存到数据库中，流数据被处理后，一部分进入数据库成为静态数据，其他部分则直接被丢弃。传统的关系数据库通常用于满足信息实时交互处理需求，比如零售系统和银行系统，每次有一笔业务发生，用户通过和关系数据库系统进行交互，就可以把相应记录写人磁盘，并支持对记录进行随机读写操作。但是，关系数据库并不是为存储快速、连续到达的流数据而设计的，不支持连续处理，把这类数据库用于流数据处理，不仅成本高，而且效率低。</p>
<p>流数据必须采用实时计算，实时计算最重要的一个需求是能够实时得到计算结果，一般要求响应时间为秒级。当只需要处理少量数据时，实时计算并不是问题；但是，在大数据时代，不仅数据格式复杂、来源众多，而且数据量巨大，这就对实时计算提出了很大的挑战。因此，针对流数据的实时计算-流计算，应运而生。</p>
<h3 id="流计算的概念"><a href="#流计算的概念" class="headerlink" title="流计算的概念"></a>流计算的概念</h3><p>总的来说，流计算秉承一个基本理念，即数据的价值随着时间的流逝而降低。因此，当事件出现时就应该立即进行处理，而不是缓存起来进行批量处理。为了及时处理流数据，就需要一个低延迟、可扩展、高可靠的处理引擎。对于一个流计算系统来说，它应达到如下需求。</p>
<ol>
<li>高性能。处理大数据的基本要求，如每秒处理几十万条数据。</li>
<li>海量式。支持 TB 级甚至是 PB 级的数据规模。</li>
<li>实时性。必须保证一个较低的延迟时间，达到秒级别，甚至是毫秒级别。</li>
<li>分布式。支持大数据的基本架构，必须能够平滑扩展。</li>
<li>易用性。能够快速进行开发和部署。</li>
<li>可靠性。能可靠地处理流数据。</li>
</ol>
<p>针对不同的应用场景，相应的流计算系统会有不同的需求，但是针对海量数据的流计算，无论在数据采集、数据处理中都应达到秒级别的要求。</p>
<h3 id="流计算与-Hadoop"><a href="#流计算与-Hadoop" class="headerlink" title="流计算与 Hadoop"></a>流计算与 Hadoop</h3><p>Hadoop 设计的初衷是面向大规模数据的批量处理，在使用 MapReduce 处理大规模文件时，一个大文件会被分解成许多个块分发到不同的机器上，每台机器并行运行 MapReduce 任务，最后对结果进行汇总输出。有时候，完成一个任务甚至要经过多轮的迭代。很显然，这种批量任务处理方式在时间延迟方面是无法满足流计算的实时响应需求的。这时，我们可能很自然地会想到一种“变通”的方案来降低批处理的时间延迟-将基于 MapReduce 的批量处理转为小批量处理，将输人数据切成小的片段，每隔一个周期就启动一次 MapReduce 作业。但是这种方案会存在以下问题。</p>
<ol>
<li>切分成小的片段，虽然可以降低延迟，但是也增加了任务处理的附加开销，而且还要处理片段之间的依赖关系，因为一个片段可能需要用到前一个片段的计算结果。</li>
<li>需要对 MapReduce 进行改造以支持流式处理，Reduce 阶段的结果不能直接输出，而是保存在内存中。这种做法会大大增加 MapReduce 框架的复杂度，导致系统难以维护和扩展。</li>
<li>降低了用户程序的可伸缩性，因为用户必须要使用 MapReduce 接口来定义流式作业。</li>
</ol>
<p>总之，流数据处理和批量数据处理是两种截然不同的数据处理模式，MapReduce 是专门面向静态数据的批量处理的，内部各种实现机制都为批处理做了高度优化，不适合用于处理持续到达的动态数据。</p>
<h2 id="流计算的处理流程"><a href="#流计算的处理流程" class="headerlink" title="流计算的处理流程"></a>流计算的处理流程</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p><img src="/2020/06/12/%E5%A4%A7%E6%95%B0%E6%8D%AE/Hadoop/Storm/%E4%BC%A0%E7%BB%9F%E7%9A%84%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B.png" alt="传统的数据处理流程"></p>
<p><img src="/2020/06/12/%E5%A4%A7%E6%95%B0%E6%8D%AE/Hadoop/Storm/%E6%B5%81%E8%AE%A1%E7%AE%97%E7%9A%84%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B.png" alt="流计算的数据处理流程"></p>
<h3 id="数据实时采集"><a href="#数据实时采集" class="headerlink" title="数据实时采集"></a>数据实时采集</h3><p><img src="/2020/06/12/%E5%A4%A7%E6%95%B0%E6%8D%AE/Hadoop/Storm/%E6%95%B0%E6%8D%AE%E9%87%87%E9%9B%86%E7%B3%BB%E7%BB%9F%E5%9F%BA%E6%9C%AC%E6%9E%B6%E6%9E%84.png" alt="数据采集系统基本架构"></p>
<ul>
<li>Agent：主动采集数据，并把数据推送到 Colletor 部分。</li>
<li>Collector：接收多个 Agent 的数据，并实现有序、可靠、高性能的转发。</li>
<li>Store：存储 Collecter 转发过来的数据。</li>
</ul>
<p>但对于流计算，一般在 Store 部分不进行数据的存储，而是将采集的数据直接发送给流计算平台进行实时计算。</p>
<h3 id="数据实时计算"><a href="#数据实时计算" class="headerlink" title="数据实时计算"></a>数据实时计算</h3><p><img src="/2020/06/12/%E5%A4%A7%E6%95%B0%E6%8D%AE/Hadoop/Storm/%E6%95%B0%E6%8D%AE%E5%AE%9E%E6%97%B6%E8%AE%A1%E7%AE%97%E7%9A%84%E6%B5%81%E7%A8%8B.png" alt="数据实时计算的流程"></p>
<h3 id="实时查询服务"><a href="#实时查询服务" class="headerlink" title="实时查询服务"></a>实时查询服务</h3><p>流计算的第三个阶段是实时查询服务，经由流计算框架得出的结果可供用户进行实时查询、展示或储存。传统的数据处理流程，用户需要主动发出查询才能获得想要的结果。而在流处理流程中，实时查询服务可以不断更新结果，并将用户所需的结果实时推送给用户。虽然通过对传统的数据处理系统进行定时查询也可以实现不断更新结果和结果推送，但通过这样的方式获取的结果仍然是根据过去某一时 刻的数据得到的结果，与实时结果有着本质的区别。</p>
<p>由此可见，流处理系统与传统的数据处理系统有如下不同之处。</p>
<ol>
<li>流处理系统处理的是实时的数据，而传统的数据处理系统处理的是预先存储好的静态数据。</li>
<li>用户通过流处理系统获取的是实时结果，而通过传统的数据处理系统获取的是过去某时刻的结果。并且，流处理系统无需用户主动发出查询，实时查询服务可以主动将实时结果推送给用户。</li>
</ol>
<h2 id="开源流计算框架-Storm"><a href="#开源流计算框架-Storm" class="headerlink" title="开源流计算框架 Storm"></a>开源流计算框架 Storm</h2><h3 id="Storm-的设计思想"><a href="#Storm-的设计思想" class="headerlink" title="Storm 的设计思想"></a>Storm 的设计思想</h3><h4 id="Streams"><a href="#Streams" class="headerlink" title="Streams"></a>Streams</h4><p>在 Storm 对流数据 Streams 的抽象描述中，流数据是一个无限的 Tuple 序列（Tuple 即元组，是元素的有序列表，每一个 Tuple 就是一个值列表，列表中的每个值都有一个名称，并且该值可以是基本类型、字符类型、字节数组等，也可以是其他可序列化的类型）。这些 Tuple 序列会以分布式的方式并行地创建和处理。</p>
<p><img src="/2020/06/12/%E5%A4%A7%E6%95%B0%E6%8D%AE/Hadoop/Storm/Streams.png" alt="Streams"></p>
<h4 id="Spouts"><a href="#Spouts" class="headerlink" title="Spouts"></a>Spouts</h4><p>Storm 认为每个 Stream 都有一个源头，并把这个源头抽象为 Spouts。Spouts 会从外部读取流数据并持续发出 Tuple。</p>
<p><img src="/2020/06/12/%E5%A4%A7%E6%95%B0%E6%8D%AE/Hadoop/Storm/Spouts.png" alt="Spouts"></p>
<h4 id="Bolts"><a href="#Bolts" class="headerlink" title="Bolts"></a>Bolts</h4><p>Storm 将 Streams 的状态转换过程抽象为 Bolts。Bolts 既可以处理 Tuple，也可以将处理后的 Tuple 作为新的 Streams 发送给其他 Bolts 对 Tuple 的处理逻辑都被封装 在Bolts中，可执行过滤、聚合、查询等操作。</p>
<p><img src="/2020/06/12/%E5%A4%A7%E6%95%B0%E6%8D%AE/Hadoop/Storm/Bolts.png" alt="Bolts"></p>
<h4 id="Topology"><a href="#Topology" class="headerlink" title="Topology"></a>Topology</h4><p>Storm 将 Spouts 和 Bolts 组成的网络抽象成 Topology。Topology 是 Storm 中最高层次的抽象概念，它可以被提交到 Storm 集群执行。一个 Topology 就是一个流转换图，图中节点是一个 Spout 或 Bolt，图中的边则表示 Bolt 订阅了哪个 Stream。当 Spout 或者 Bolt 发送元组时，它会把元组发送到每个订阅了该 Stream 的 Bolt 上进行处理。</p>
<p>在 Topology 的具体实现上，Storm 中的 Topology 定义仅仅是一些 Thrift 结构体（Thrift 是基于二进制的高性能的通信中间件），而 Thrift 支持各种编程语言进行定义，这样一来就可以使用各种编程语言来创建、提交 Topology。</p>
<p><img src="/2020/06/12/%E5%A4%A7%E6%95%B0%E6%8D%AE/Hadoop/Storm/Topology.png" alt="Topology"></p>
<h4 id="Stream-Groupings"><a href="#Stream-Groupings" class="headerlink" title="Stream Groupings"></a>Stream Groupings</h4><p>Storm 中的 Stream Groupings 用于告知 Topology 如何在两个组件间（如 Spout 和 Bolt 之间，或者不同的 Bolt 之间）进行 Tuple 的传送。一个 Topology 中 Tuple 的流向中，箭头表示 Tuple 的流向，而圆圈则表示任务，每一个 Spout 和 Bolt 都可以有多个分布式任务，一个任务在什么时候、以什么方式发送 Tuple 就是由 Stream Groupings 来决定的。</p>
<p><img src="/2020/06/12/%E5%A4%A7%E6%95%B0%E6%8D%AE/Hadoop/Storm/Stream_Groupings.png" alt="Stream_Groupings"></p>
<p>目前，Storm 中的 Stream Groupings 有如下 6 种方式。</p>
<ol>
<li>ShuffleGrouping：随机分组，随机分发 Stream 中的 Tuple，保证每个 Bolt 的 Task 接收 Tuple数量大致一致。</li>
<li>FieldsGrouping：按照字段分组，保证相同字段的 Tuple 分配到同一个 Task 中。</li>
<li>AllGrouping：广播发送，每一个 Task 都会收到所有的 Tuple。</li>
<li>GlobalGrouping：全局分组，所有的 Tuple 都发送到同一个 Task 中。</li>
<li>NonGrouping：不分组，和 ShuffleGrouping 类似，当前 Task 的执行会和它的被订阅者在同一个线程中执行。</li>
<li>DireetGrouping：直接分组，直接指定由某个 Task 来执行 Tuple 的处理。</li>
</ol>
<h3 id="Storm-的框架设计"><a href="#Storm-的框架设计" class="headerlink" title="Storm 的框架设计"></a>Storm 的框架设计</h3><p>Storm 运行在分布式集群中，其运行任务的方式与 Hadoop 类似：在 Hadoop 上运行的是 MapReduce 作业，而在 Storm 上运行的是”Topology”。但两者的任务大不相同，其中主要的不同是一个 MapReduce 作业最终会完成计算并结束运行，而一个 Topology 将持续处理消息（直到入为终止）。</p>
<p><img src="/2020/06/12/%E5%A4%A7%E6%95%B0%E6%8D%AE/Hadoop/Storm/Storm%E9%9B%86%E7%BE%A4%E6%9E%B6%E6%9E%84%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="Storm集群架构示意图"></p>
<p>Storm 集群采用”Mater-Worker”的节点方式，其中 Master 节点运行名为”Nimbus”的后台程序（类似 Hadoop 中的”JobTracker”）, 负责在集群范围内分发代码、为 Worker 分配任务和监测故障。而每个 Worker 节点运行名为”Supervisor”的后台程序，负责监听分配给它所在机器的工作，即根据 Nimbus 分配的任务来决定启动或停止 Worker 进程。</p>
<p>Storm 采用了 Zookeeper 来作为分布式协调组件，负责 Nimbus 和多个 Supervisor 之间的所有协调工作（一个完整的拓扑可能被分为多个子拓扑，并由多个 Supervisor 完成）。</p>
<p>此外，Nimbus 后台进程和 Supervisor 后台进程都是快速失败（Fail-fast）和无状态（Stateless）的，Master 节点并没有直接和 Worker 节点通信，而是借助 Zookeeper 将状态信息存放在 Zookeeper 中或本地磁盘中，以便节点故障时进行快速恢复。这意味着，若 Nimbus 进程或 Supervisor 进程终止后，一旦进程重启，它们将恢复到之前的状态并继续工作。这种设计使 Storm 极其稳定。</p>
<p>基于这样的架构设计，Storm 的工作流程包含4个过程。</p>
<ol>
<li>客户端提交 Topology 到 Storm 集群中。</li>
<li>Nimbus 将分配给 Supervisor 的任务写人 Zookeeper。</li>
<li>Supervisor 从 Zookeeper 中获取所分配的任务，并启动 Worker 进程。</li>
<li>Worker 进程执行具体的任务。</li>
</ol>
<p><img src="/2020/06/12/%E5%A4%A7%E6%95%B0%E6%8D%AE/Hadoop/Storm/Storm%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="Storm工作流程示意图"></p>
<h2 id="Spark-Streaming"><a href="#Spark-Streaming" class="headerlink" title="Spark Streaming"></a>Spark Streaming</h2><p>Spark Streaming 是构建在 Spark 上的实时计算框架，它扩展了 Spark 处理大规模流式数据的能力。Spark Streaming 可结合批处理和交互查询，适合一些需要对历史数据和实时数据进行结合分析的应用场景。</p>
<h3 id="Spark-Streaming-设计"><a href="#Spark-Streaming-设计" class="headerlink" title="Spark Streaming 设计"></a>Spark Streaming 设计</h3><p>Spark Streaming 是 Spark 的核心组件之一，为 Spark 提供了可拓展、高吞吐、容错的流计算能力。Spark Streaming 可整合多种输人数据源，如 Kafka、Flume、HDFS，甚至是普通的 TCP 套接字。经处理后的数据可存储至文件系统、数据库，或显示在仪表盘里。</p>
<p><img src="/2020/06/12/%E5%A4%A7%E6%95%B0%E6%8D%AE/Hadoop/Storm/Spark_Streaming%E6%94%AF%E6%8C%81%E7%9A%84%E8%BE%93%E5%85%A5%E3%80%81%E8%BE%93%E5%87%BA%E6%95%B0%E6%8D%AE%E6%BA%90.png" alt="Spark_Streaming支持的输入、输出数据源"></p>
<p>Spark Streaming 的基本原理是将实时输人数据流以时间片（秒级）为单位进行拆分，然后经 Spark 引擎以类似批处理的方式处理每个时间片数据。</p>
<p><img src="/2020/06/12/%E5%A4%A7%E6%95%B0%E6%8D%AE/Hadoop/Storm/Spark_Streaming%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.png" alt="Spark_Streaming执行流程"></p>
<p>Spark Streaming 最主要的抽象是 DStream（Discretized Stream，离散化数据流），表示连续不断的数据流。在内部实现上，Spark Streaming 的输人数据按照时间片（如 1s）分成一段一段的 DStream，每一段数据转换为 Spark 中的 RDD，并且对 DStream 的操作都最终转变为对相应的 RDD的操作。</p>
<p>例如，进行单词统计时，每个时间片的数据（存储句子的 RDD）经 flatMap 操作，生成了存储单词的 RDD。整个流式计算可根据业务的需求对这些中间的结果进一步处理，或者存储到外部设备中。</p>
<p><img src="/2020/06/12/%E5%A4%A7%E6%95%B0%E6%8D%AE/Hadoop/Storm/DStream.png" alt="DStream"></p>
<h3 id="Spark-Streaming-与-Storm-的对比"><a href="#Spark-Streaming-与-Storm-的对比" class="headerlink" title="Spark Streaming 与 Storm 的对比"></a>Spark Streaming 与 Storm 的对比</h3><p>Spark Streaming 和 Storm 最大的区别在于，Spark Streaming 无法实现毫秒级的流计算，而 Storm 则可以实现毫秒级响应。</p>
<p>Spark Streaming 无法实现毫秒级的流计算，是因为其将流数据按批处理窗口大小（通常在 0.5~2s 之间）分解为一系列批处理作业，在这个过程中会产生多个 Spark 作业，且每一段数据的处理都会经过 Spark DAG 图分解、任务调度过程，因此无法实现毫秒级相应。Spark Streaming 难以满足对实时性要求非常高（如高频实时交易）的场景，但足以胜任其他流式准实时计算场景。</p>
<p>相比之下，Storm 处理的单位为 Tuple，只需要极小的延迟。Spark Streaming 构建在 Spark 上，一方面是因为 Spark 的低延迟执行引擎（100ms 左右）可以用于实时计算，另一方面，相比于 Storm，RDD 数据集更容易做高效的容错处理。此外，Spark Streaming 采用的小批量处理的方式使得它可以同时兼容批量和实时数据处理的逻辑和算法，因此方便了一些需要历史数据和实时数据联合分析的特定应用场合。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wetts.github.io/2020/05/26/artificial_intelligence/%E6%9C%BA%E5%99%A8%E8%A7%86%E8%A7%89/%E7%A5%9E%E7%BB%8F%E9%A3%8E%E6%A0%BC%E8%BF%81%E7%A7%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Zhang Wetts">
      <meta itemprop="description" content="Stay Hungry, Stay Foolish. <br><br><p style="font-size:8px;">[build by hexo/next/gitalk/hexo-generator-search/LaTeX]</p>">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wetts's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/26/artificial_intelligence/%E6%9C%BA%E5%99%A8%E8%A7%86%E8%A7%89/%E7%A5%9E%E7%BB%8F%E9%A3%8E%E6%A0%BC%E8%BF%81%E7%A7%BB/" class="post-title-link" itemprop="url">神经风格迁移.md</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-26 18:36:28" itemprop="dateCreated datePublished" datetime="2020-05-26T18:36:28+08:00">2020-05-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-05-27 00:02:47" itemprop="dateModified" datetime="2020-05-27T00:02:47+08:00">2020-05-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%9C%BA%E5%99%A8%E8%A7%86%E8%A7%89/" itemprop="url" rel="index"><span itemprop="name">机器视觉</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><img src="/2020/05/26/artificial_intelligence/%E6%9C%BA%E5%99%A8%E8%A7%86%E8%A7%89/%E7%A5%9E%E7%BB%8F%E9%A3%8E%E6%A0%BC%E8%BF%81%E7%A7%BB/%E7%A5%9E%E7%BB%8F%E9%A3%8E%E6%A0%BC%E8%BF%81%E7%A7%BB.png" alt="神经风格迁移"></p>
<p><img src="/2020/05/26/artificial_intelligence/%E6%9C%BA%E5%99%A8%E8%A7%86%E8%A7%89/%E7%A5%9E%E7%BB%8F%E9%A3%8E%E6%A0%BC%E8%BF%81%E7%A7%BB/%E7%A5%9E%E7%BB%8F%E9%A3%8E%E6%A0%BC%E8%BF%81%E7%A7%BB2.png" alt="神经风格迁移2"></p>
<p>$J_{\text{content}}(C,G)$</p>
<p>第一部分被称作内容代价，这是一个关于内容图片和生成图片的函数，它是用来度量生成图片$G$的内容与内容图片$C$的内容有多相似。</p>
<p>$J_{\text{style}}(S,G)$</p>
<p>然后我们会把结果加上一个风格代价函数，也就是关于$S$和$G$的函数，用来度量图片$G$的风格和图片$S$的风格的相似度。</p>
<p>$J( G) = a J_{\text{content}}( C,G) + \beta J_{\text{style}}(S,G)$</p>
<h3 id="内容代价函数（Content-cost-function）"><a href="#内容代价函数（Content-cost-function）" class="headerlink" title="内容代价函数（Content cost function）"></a>内容代价函数（Content cost function）</h3><p><img src="/2020/05/26/artificial_intelligence/%E6%9C%BA%E5%99%A8%E8%A7%86%E8%A7%89/%E7%A5%9E%E7%BB%8F%E9%A3%8E%E6%A0%BC%E8%BF%81%E7%A7%BB/%E5%86%85%E5%AE%B9%E4%BB%A3%E4%BB%B7%E5%87%BD%E6%95%B0.png" alt="内容代价函数"></p>
<p>假如说，你用隐含层$l$来计算内容代价，如果$l$是个很小的数，比如用隐含层1，这个代价函数就会使你的生成图片像素上非常接近你的内容图片。然而如果你用很深的层，那么那就会问，内容图片里是否有狗，然后它就会确保生成图片里有一个狗。所以在实际中，这个层$l$在网络中既不会选的太浅也不会选的太深。因为你要自己做这周结束的编程练习，我会让你获得一些直觉，在编程练习中的具体例子里通常$l$会选择在网络的中间层，既不太浅也不很深，然后用一个预训练的卷积模型，可以是<strong>VGG网络</strong>或者其他的网络也可以。</p>
<p><img src="/2020/05/26/artificial_intelligence/%E6%9C%BA%E5%99%A8%E8%A7%86%E8%A7%89/%E7%A5%9E%E7%BB%8F%E9%A3%8E%E6%A0%BC%E8%BF%81%E7%A7%BB/%E5%86%85%E5%AE%B9%E4%BB%A3%E4%BB%B7%E5%87%BD%E6%95%B02.png" alt="内容代价函数2"></p>
<p>现在你需要衡量假如有一个内容图片和一个生成图片他们在内容上的相似度，我们令这个$a^{[l][C]}$和$a^{[l][G]}$，代表这两个图片$C$和$G$的$l$层的激活函数值。如果这两个激活值相似，那么就意味着两个图片的内容相似。</p>
<p>$J_{\text{content}}( C,G) = \frac{1}{2}|| a^{[l][C]} - a^{[l][G]}||^{2}$</p>
<p>为两个激活值不同或者相似的程度，我们取$l$层的隐含单元的激活值，按元素相减，内容图片的激活值与生成图片相比较，然后取平方，也可以在前面加上归一化或者不加，比如$\frac{1}{2}$或者其他的，都影响不大,因为这都可以由这个超参数$a$来调整（$J(G) =a J_{\text{content}}( C,G) + \beta J_{\text{style}}(S,G)$）</p>
<h3 id="风格代价函数（Style-cost-function）"><a href="#风格代价函数（Style-cost-function）" class="headerlink" title="风格代价函数（Style cost function）"></a>风格代价函数（Style cost function）</h3><p><img src="/2020/05/26/artificial_intelligence/%E6%9C%BA%E5%99%A8%E8%A7%86%E8%A7%89/%E7%A5%9E%E7%BB%8F%E9%A3%8E%E6%A0%BC%E8%BF%81%E7%A7%BB/%E9%A3%8E%E6%A0%BC%E4%BB%A3%E4%BB%B7%E5%87%BD%E6%95%B0.png" alt="风格代价函数"></p>
<p><img src="/2020/05/26/artificial_intelligence/%E6%9C%BA%E5%99%A8%E8%A7%86%E8%A7%89/%E7%A5%9E%E7%BB%8F%E9%A3%8E%E6%A0%BC%E8%BF%81%E7%A7%BB/%E9%A3%8E%E6%A0%BC%E4%BB%A3%E4%BB%B7%E5%87%BD%E6%95%B02.png" alt="风格代价函数2"></p>
<p><img src="/2020/05/26/artificial_intelligence/%E6%9C%BA%E5%99%A8%E8%A7%86%E8%A7%89/%E7%A5%9E%E7%BB%8F%E9%A3%8E%E6%A0%BC%E8%BF%81%E7%A7%BB/%E9%A3%8E%E6%A0%BC%E4%BB%A3%E4%BB%B7%E5%87%BD%E6%95%B03.png" alt="风格代价函数3"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wetts.github.io/2020/05/25/artificial_intelligence/%E6%9C%BA%E5%99%A8%E8%A7%86%E8%A7%89/%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Zhang Wetts">
      <meta itemprop="description" content="Stay Hungry, Stay Foolish. <br><br><p style="font-size:8px;">[build by hexo/next/gitalk/hexo-generator-search/LaTeX]</p>">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wetts's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/25/artificial_intelligence/%E6%9C%BA%E5%99%A8%E8%A7%86%E8%A7%89/%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB/" class="post-title-link" itemprop="url">人脸识别.md</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-25 19:42:35" itemprop="dateCreated datePublished" datetime="2020-05-25T19:42:35+08:00">2020-05-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-05-26 18:30:07" itemprop="dateModified" datetime="2020-05-26T18:30:07+08:00">2020-05-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%9C%BA%E5%99%A8%E8%A7%86%E8%A7%89/" itemprop="url" rel="index"><span itemprop="name">机器视觉</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Siamese-网络"><a href="#Siamese-网络" class="headerlink" title="Siamese 网络"></a>Siamese 网络</h2><p><img src="/2020/05/25/artificial_intelligence/%E6%9C%BA%E5%99%A8%E8%A7%86%E8%A7%89/%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB/Siamese%E7%BD%91%E7%BB%9C.png" alt="Siamese网络"></p>
<p>建立一个人脸识别系统的方法就是，如果你要比较两个图片的话，例如这里的第一张（编号1）和第二张图片（编号2），你要做的就是把第二张图片喂给有同样参数的同样的神经网络，然后得到一个不同的128维的向量（编号3），这个向量代表或者编码第二个图片，我要把第二张图片的编码叫做$f(x^{(2)})$。这里我用$x^{(1)}$和$x^{(2)}$仅仅代表两个输入图片，他们没必要非是第一个和第二个训练样本，可以是任意两个图片。</p>
<p>最后如果你相信这些编码很好地代表了这两个图片，你要做的就是定义$d$，将$x^{(1)}$和$x^{(2)}$的距离定义为这两幅图片的编码之差的范数，$d( x^{( 1)},x^{( 2)}) =|| f( x^{( 1)}) - f( x^{( 2)})||_{2}^{2}$。</p>
<h2 id="Triplet-损失"><a href="#Triplet-损失" class="headerlink" title="Triplet 损失"></a>Triplet 损失</h2><p><img src="/2020/05/25/artificial_intelligence/%E6%9C%BA%E5%99%A8%E8%A7%86%E8%A7%89/%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB/Triplet%E6%8D%9F%E5%A4%B1.png" alt="Triplet损失"></p>
<p><img src="/2020/05/25/artificial_intelligence/%E6%9C%BA%E5%99%A8%E8%A7%86%E8%A7%89/%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB/Triplet%E6%8D%9F%E5%A4%B12.png" alt="Triplet损失2"></p>
<h2 id="面部识别与二分类"><a href="#面部识别与二分类" class="headerlink" title="面部识别与二分类"></a>面部识别与二分类</h2><p><img src="/2020/05/25/artificial_intelligence/%E6%9C%BA%E5%99%A8%E8%A7%86%E8%A7%89/%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB/%E9%9D%A2%E9%83%A8%E8%AF%86%E5%88%AB%E4%B8%8E%E4%BA%8C%E5%88%86%E7%B1%BB.png" alt="面部识别与二分类"></p>
<p><img src="/2020/05/25/artificial_intelligence/%E6%9C%BA%E5%99%A8%E8%A7%86%E8%A7%89/%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB/%E9%9D%A2%E9%83%A8%E8%AF%86%E5%88%AB%E4%B8%8E%E4%BA%8C%E5%88%86%E7%B1%BB2.png" alt="面部识别与二分类2"></p>
<p><img src="/2020/05/25/artificial_intelligence/%E6%9C%BA%E5%99%A8%E8%A7%86%E8%A7%89/%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB/%E9%9D%A2%E9%83%A8%E8%AF%86%E5%88%AB%E4%B8%8E%E4%BA%8C%E5%88%86%E7%B1%BB3.png" alt="面部识别与二分类3"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wetts.github.io/2020/05/22/%E5%A4%A7%E6%95%B0%E6%8D%AE/Hadoop/Spark/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Zhang Wetts">
      <meta itemprop="description" content="Stay Hungry, Stay Foolish. <br><br><p style="font-size:8px;">[build by hexo/next/gitalk/hexo-generator-search/LaTeX]</p>">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wetts's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/22/%E5%A4%A7%E6%95%B0%E6%8D%AE/Hadoop/Spark/" class="post-title-link" itemprop="url">Spark.md</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-05-22 18:37:15 / 修改时间：23:04:27" itemprop="dateCreated datePublished" datetime="2020-05-22T18:37:15+08:00">2020-05-22</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Hadoop/" itemprop="url" rel="index"><span itemprop="name">Hadoop</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="Spark-简介"><a href="#Spark-简介" class="headerlink" title="Spark 简介"></a>Spark 简介</h3><p>Spark 具有如下 4 个主要特点：</p>
<ul>
<li>运行速度快。Spark 使用先进的 DAG（Directed Acyelic Graph，有向无环图）执行引擎，以支持循环数据流与内存计算，基于内存的执行速度可比 Hadoop MapReduce 快上百倍，基于磁盘的执行速度也能快十倍。</li>
<li>容易使用。Spark 支持使用 Scala、Java、Python 和 R 语言进行编程，简洁的 API 设计有助于用户轻松构建并行程序，并且可以通过 Spark Shell 进行交互式编程。</li>
<li>通用性。Spark 提供了完整而强大的技术栈，包括 SQL 查询、流式计算、机器学习和图算法组件，这些组件可以无缝整合在同一个应用中，足以应对复杂的计算。</li>
<li>运行模式多样。Spark 可运行于独立的集群模式中，或者运行于 Hadoop 中，也可运行于 Amazon EC2 等云环境中，并且可以访问 HDFS、Cassandra、HBase、Hive等多种数据源。</li>
</ul>
<h3 id="Spark-与-Hadoop-的对比"><a href="#Spark-与-Hadoop-的对比" class="headerlink" title="Spark 与 Hadoop 的对比"></a>Spark 与 Hadoop 的对比</h3><p>Hadoop 虽然已成为大数据技术的事实标准，但其本身还存在诸多缺陷，最主要的缺陷是其 MapReduce 计算模型延迟过高，无法胜任实时、快速计算的需求，因而只适用于离线批处理的应用场景。</p>
<p>Hadoop存在以下缺点：</p>
<ul>
<li>表达能力有限。计算都必须要转化成 Map 和 Reduce 两个操作，但这并不适合所有的情况，难以描述复杂的数据处理过程。</li>
<li>磁盘 IO 开销大。每次执行时都需要从磁盘读取数据，并且在计算完成后需要将中间结果写人到磁盘中，IO 开销较大。</li>
<li>延迟高。一次计算可能需要分解成一系列按顺序执行的 MapReduce 任务，任务之间的衔接由于涉及到 IO 开销，会产生较高延迟。而且，在前一个任务执行完成之前，其他任务无法开始，因此难以胜任复杂、多阶段的计算任务。</li>
</ul>
<p>Spark 在借鉴 Hadoop MapReduce 优点的同时，很好地解决了 MapReduce 所面临的问题。相比于 MapReduce，Spark主要具有如下优点：</p>
<ul>
<li>Spark 的计算模式也属于 MapReduce，但不局限于 Map 和 Reduce 操作，还提供了多种数据集操作类型，编程模型比 MapReduce 更灵活。</li>
<li>Spark 提供了内存计算，中间结果直接放到内存中，带来了更高的迭代运算效率。</li>
<li>Spark 基于 DAG 的任务调度执行机制，要优于 MapReduce 的迭代执行机制。</li>
</ul>
<p><img src="/2020/05/22/%E5%A4%A7%E6%95%B0%E6%8D%AE/Hadoop/Spark/Hadoop%E4%B8%8ESpark%E7%9A%84%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E5%AF%B9%E6%AF%94.png" alt="Hadoop与Spark的执行流程对比"></p>
<p>Spark 最大的特点就是将计算数据、中间结果都存储在内存中，大大减少了 IO 开销，因而 Spark 更适合于迭代运算比较多的数据挖掘与机器学习运算。</p>
<p>使用 Hadoop 进行迭代计算非常耗资源，因为每次迭代都需要从磁盘中写人、读取中间数据，IO 开销大。而 Spark 将数据载人内存后，之后的迭代计算都可以直接使用内存中的中间结果作运算，避免了从磁盘中频繁读取数据。</p>
<p><img src="/2020/05/22/%E5%A4%A7%E6%95%B0%E6%8D%AE/Hadoop/Spark/Hadoop%E4%B8%8ESpark%E6%89%A7%E8%A1%8C%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92%E7%9A%84%E6%97%B6%E9%97%B4%E5%AF%B9%E6%AF%94.png" alt="Hadoop与Spark执行逻辑回归的时间对比"></p>
<p>在实际进行开发时，使用 Hadoop 需要编写不少相对底层的代码，不够高效。相对而言，Spark 提供了多种高层次、简洁的 API。通常情况下，对于实现相同功能的应用程序，Hadoop 的代码量要比 Spark 多 2~5 倍。更重要的是，Spark 提供了实时交互式编程反馈，可以方便地验证、调整算法。</p>
<p>尽管 Spark 相对于 Hadoop 而言具有较大优势，但 Spark 并不能完全替代 Hadoop，主要用于替代 Hadoop 中的 MapReduce 计算模型。实际上，Spark 已经很好地融入了 Hadoop 生态圈，并成为其中的重要一员，它可以借助于 YARN 实现资源调度管理，借助于 HDFS 实现分布式存储。此外，Hadoop 可以使用廉价的、异构的机器来做分布式存储与计算，但是 Spark 对硬件的要求稍高一些，对内存与 CPU 有一定的要求。</p>
<h2 id="Spark-生态系统"><a href="#Spark-生态系统" class="headerlink" title="Spark 生态系统"></a>Spark 生态系统</h2><p>在实际应用中，大数据处理主要包括以下三个类型：</p>
<ul>
<li>复杂的批量数据处理：时间跨度通常在数十分钟到数小时之间。</li>
<li>基于历史数据的交互式查询：时间跨度通常在数十秒到数分钟之间。</li>
<li>基于实时数据流的数据处理：时间跨度通常在数百毫秒到数秒之间。</li>
</ul>
<p>目前，已有很多相对成熟的开源软件用于处理以上三种情景。</p>
<ul>
<li>可以利用 Hadoop MapReduce 来进行批量数据处理；</li>
<li>可以用 Impala 来进行交互式查询（Impala 与 Hive 相似，但底层引擎不同，提供了实时交互式 SQL 查询）；</li>
<li>对于流式数据处理可以采用开源流计算框架 Storm。</li>
</ul>
<p>一些企业可能只会涉及其中部分应用场景，只需部署相应软件即可满足业务需求，但是对于互联网公司而言，通常会同时存在以上三种场景，就需要同时部署三种不同的软件，这样做难免会带来一些问题。</p>
<ul>
<li>不同场景之间输人输出数据无法做到无缝共享，通常需要进行数据格式的转换。</li>
<li>不同的软件需要不同的开发和维护团队，带来了较高的使用成本。</li>
<li>比较难以对同一个集群中的各个系统进行统一的资源协调和分配。</li>
</ul>
<p>Spark 的设计遵循“一个软件栈满足不同应用场景”的理念，逐渐形成了一套完整的生态系统，既能够提供内存计算框架，也可以支持 SQL 即席查询、实时流式计算、机器学习和图计算等。Spark 可以部署在资源管理器 YARN 之上，提供一站式的大数据解决方案。因此，Spark 所提供的生态系统足以应对上述三种场景，即同时支持批处理、交互式查询和流数据处理。</p>
<p>Spark 生态系统主要包含了 Spark Core、Spark SQL、Spark Streaming、MLlib 和 GraphX 等组件，各个组件的具体功能如下：</p>
<ol>
<li>Spark Core<blockquote>
<p>Spark Core 包含 Spark 的基本功能，如内存计算、任务调度、部署模式、故障恢复、存储管理等，主要面向批数据处理。Spark 建立在统一的抽象 RDD 之上，使其可以以基本一致的方式应对不同的大数据处理场景。</p>
</blockquote>
</li>
<li>Spark SQL<blockquote>
<p>Spark SQL 允许开发人员直接处理 RDD，同时也可查询 Hive、HBase 等外部数据源。Spark SQL 的一个重要特点是其能够统一处理关系表和 RDD，使得开发人员不需要自己编写 Spark 应用程序，开发人员可以轻松地使用 SQL 命令进行查询，并进行更复杂的数据分析。</p>
</blockquote>
</li>
<li>Spark Streaming<blockquote>
<p>Spark Streaming 支持高吞吐量、可容错处理的实时流数据处理，其核心思路是将流数据分解成一系列短小的批处理作业，每个短小的批处理作业都可以使用 Spark Core 进行快速处理。Spark Streaming 支持多种数据输入源，如 Kafka、Flume 和 TCP 套接字等。</p>
</blockquote>
</li>
<li>MLlib（机器学习）<blockquote>
<p>MLlib 提供了常用机器学习算法的实现，包括聚类、分类、回归、协同过滤等，降低了机器学习的门槛，开发人员只要具备一定的理论知识就能进行机器学习的工作。</p>
</blockquote>
</li>
<li>GraphX（图计算）<blockquote>
<p>GraphX 是 Spark 中用于图计算的 API，可认为是 Pregel 在 Spark 上的重写及优化，GraphX 性能良好，拥有丰富的功能和运算符，能在海量数据上自如地运行复杂的图算法。</p>
</blockquote>
</li>
</ol>
<p>需要说明的是，无论是 Spark SQL、Spark Streaming、MLlib 还是 GraphX，都可以使用 Spark Core 的 API 处理问题，它们的方法几乎是通用的，处理的数据也可以共享，不同应用之间的数据可以无缝集成。</p>
<p><img src="/2020/05/22/%E5%A4%A7%E6%95%B0%E6%8D%AE/Hadoop/Spark/Spark%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF.png" alt="Spark的应用场景"></p>
<h2 id="Spark-运行架构"><a href="#Spark-运行架构" class="headerlink" title="Spark 运行架构"></a>Spark 运行架构</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ul>
<li>RDD：是弹性分布式数据集（Resilient Distributed Dataset）的英文缩写，是分布式内存的一个抽象概念，提供了一种高度受限的共享内存模型。</li>
<li>DAG：是 Directed Acyclic Graph（有向无环图）的英文缩写，反映 RDD 之间的依赖关系。</li>
<li>Executor：是运行在工作节点（Worker Node）上的一个进程，负责运行任务，并为应用程<br>序存储数据。</li>
<li>应用：用户编写的 Spark 应用程序。</li>
<li>任务：运行在 Executor 上的工作单元。</li>
<li>作业：一个作业包含多个 RDD 及作用于相应 RDD 上的各种操作。</li>
<li>阶段：是作业的基本调度单位，一个作业会分为多组任务，每组任务被称为“阶段”，或者<br>也被称为“任务集”。</li>
</ul>
<h3 id="架构设计"><a href="#架构设计" class="headerlink" title="架构设计"></a>架构设计</h3><p>Spark 运行架构包括集群资源管理器（Cluster Manager）、运行作业任务的工作节点（WorkerNode）、每个应用的任务控制节点（Driver）和每个工作节点上负责具体任务的执行进程（Executor）。其中，集群资源管理器可以是 Spark 自带的资源管理器，也可以是 YARN 或 Mesos 等资源管理框架。</p>
<p><img src="/2020/05/22/%E5%A4%A7%E6%95%B0%E6%8D%AE/Hadoop/Spark/Spark%E8%BF%90%E8%A1%8C%E6%9E%B6%E6%9E%84.png" alt="Spark运行架构"></p>
<p>与 Hadoop MapReduce 计算框架相比，Spark 所采用的 Executor 有两个优点：</p>
<ul>
<li>一是利用多线程来执行具体的任务（Hadoop MapReduce 采用的是进程模型），减少任务的启动开销；</li>
<li>二是 Executor 中有一个 BlockManager 存储模块，会将内存和磁盘共同作为存储设备，当需要多轮迭代计算时，可以将中间结果存储到这个存储模块里，下次需要时就可以直接读该存储模块里的数据，而不需要读写到 HDFS 等文件系统里，因而有效减少了 IO 开销；或者在交互式查询场景下，预先将表缓存到该存储系统上，从而可以提高读写 IO 性能。</li>
</ul>
<p>在 Spark 中，一个应用（Application）由一个任务控制节点（Driver）和若干个作业（Job）构成，一个作业由多个阶段（Stage）构成，一个阶段由多个任务（Task）组成。当执行一个应用时，任务控制节点会向集群管理器（Cluster Manager）申请资源，启动 Executor，并向 Executor 发送应用程序代码和文件，然后在 Executor 上执行任务，运行结束后执行结果会返回给任务控制节点，或者写到 HDFS 或者其他数据库中。</p>
<p><img src="/2020/05/22/%E5%A4%A7%E6%95%B0%E6%8D%AE/Hadoop/Spark/Spark%E4%B8%AD%E5%90%84%E7%A7%8D%E6%A6%82%E5%BF%B5%E4%B9%8B%E9%97%B4%E5%AE%9A%E7%9A%84%E7%9B%B8%E4%BA%92%E5%85%B3%E7%B3%BB.png" alt="Spark中各种概念之间定的相互关系"></p>
<h3 id="Spark-运行基本流程"><a href="#Spark-运行基本流程" class="headerlink" title="Spark 运行基本流程"></a>Spark 运行基本流程</h3><p>Spark 运行基本流程如下：</p>
<ol>
<li>当一个 Spark 应用被提交时，首先需要为这个应用构建起基本的运行环境，即由任务控制节点（Driver）创建一个 SparkContext，由 SparkContext 负责和资源管理器（Cluster Manager）的通信以及进行资源的申请、任务的分配和监控等。SparkContext 会向资源管理器注册并申请运行 Executor 的资源。</li>
<li>资源管理器为 Executor 分配资源，并启动 Executor 进程，Executor 运行情况将随着“心跳”发送到资源管理器上。</li>
<li>SparkContext 根据 RDD 的依赖关系构建 DAG 图，DAG 图提交给 DAG 调度器（DAGScheduler）进行解析，将 DAG 图分解成多个“阶段”（每个阶段都是一个任务集），并且计算出各个阶段之间的依赖关系，然后把一个个“任务集”提交给底层的任务调度器（TaskScheduler）进行处理；Executor 向 SparkContext 申请任务，任务调度器将任务分发给 Executor 运行，同时 SparkContext 将应用程序代码发放给 Executor。</li>
<li>任务在 Executor 上运行，把执行结果反馈给任务调度器，然后反馈给 DAG 调度器，运行完毕后写人数据并释放所有资源。</li>
</ol>
<p><img src="/2020/05/22/%E5%A4%A7%E6%95%B0%E6%8D%AE/Hadoop/Spark/Spark%E8%BF%90%E8%A1%8C%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="Spark运行基本流程图"></p>
<p>Spark 运行架构具有以下特点：</p>
<ol>
<li>每个应用都有自己专属的 Executor 进程，并且该进程在应用运行期间一直驻留。Executor 进程以多线程的方式运行任务，减少了多进程任务频繁的启动开销，使得任务执行变得非常高效和可靠。</li>
<li>Spark 运行过程与资源管理器无关，只要能够获取 Executor 进程并保持通信即可。</li>
<li>Executor 上有一个 BlockManager 存储模块，类似于键值存储系统（把内存和磁盘共同作为存储设备），在处理迭代计算任务时，不需要把中间结果写人到 HDFS 等文件系统，而是直接放在这个存储系统上，后续有需要时就可以直接读取；在交互式查询场景下，也可以把表提前缓存到这个存储系统上，提高读写 IO 性能。</li>
<li>任务采用了数据本地性和推测执行等优化机制。数据本地性是尽量将计算移到数据所在的节点上进行，即“计算向数据靠拢”，因为移动计算比移动数据所占的网络资源要少得多。而且，Spark 采用了延时调度机制，可以在更大的程度上实现执行过程优化。比如，拥有数据的节点当前正被其他的任务占用，那么在这种情况下是否需要将数据移动到其他的空闲节点上呢？答案是不一定。因为，如果经过预测发现当前节点结束当前任务的时间要比移动数据的时间还要少，那么调度就会等待，直到当前节点可用。</li>
</ol>
<h3 id="RDD-的设计与运行原理"><a href="#RDD-的设计与运行原理" class="headerlink" title="RDD 的设计与运行原理"></a>RDD 的设计与运行原理</h3><h4 id="RDD-设计背景"><a href="#RDD-设计背景" class="headerlink" title="RDD 设计背景"></a>RDD 设计背景</h4><p>在实际应用中，存在许多迭代式算法（比如机器学习、图算法等）和交互式数据挖掘工具，这些应用场景的共同之处是，不同计算阶段之间会重用中间结果，即一个阶段的输出结果会作为下一个阶段的输入。但是，目前的 MapReduce 框架都是把中间结果写人到 HDFS 中，带来了大量的数据复制、磁盘 IO 和序列化开销。虽然类似 Pregel 等图计算框架也是将结果保存在内存当中，但是这些框架只能支持一些特定的计算模式，并没有提供种通用的数据抽象。RDD 就是为了满足这种需求而出现的，它提供了一个抽象的数据架构，我们不必担心底层数据的分布式特性，只需将具体的应用逻辑表达为一系列转换处理，不同 RDD 之间的转换操作形成依赖关系，可以实现管道化，从而避免了中间结果的存储，大大降低了数据复制、磁盘 IO 和序列化开销。</p>
<h4 id="RDD-概念"><a href="#RDD-概念" class="headerlink" title="RDD 概念"></a>RDD 概念</h4><p>一个 RDD 就是一个分布式对象集合，本质上是一个只读的分区记录集合，每个 RDD 可以分成多个分区，每个分区就是一个数据集片段，并且一个 RDD 的不同分区可以被保存到集群中不同的节点上，从而可以在集群中的不同节点上进行并行计算。RDD 提供了一种高度受限的共享内存模型，即 RDD 是只读的记录分区的集合，不能直接修改，只能基于稳定的物理存储中的数据集来创建 RDD，或者通过在其他 RDD 上执行确定的转换操作（如 map、join 和 groupBy）而创建得到新的 RDD。</p>
<p>RDD 提供了一组丰富的操作以支持常见的数据运算，分为“行动”（Action）和“转换”（Transformation）两种类型：</p>
<ul>
<li>前者用于执行计算并指定输出的形式</li>
<li>后者指定 RDD 之间的相互依赖关系。</li>
</ul>
<p>两类操作的主要区别是，转换操作（如map、filter、 groupBy、 join等）接受 RDD 并返回 RDD，而行动操作（如 count、collect 等）接受 RDD 但是返回非 RDD（即输出一个值或结果）。</p>
<p>RDD提供的转换接口都非常简单，都是类似 map、filter、 groupBy、 join 等粗粒度的数据转换操作，而不是针对某个数据项的细粒度修改。因此，RDD 比较适合对于数据集中元素执行相同操作的批处理式应用，而不适合用于需要异步、细粒度状态的应用，比如 Web 应用系统、增量式的网页爬虫等。正因为这样，这种粗粒度转换接口设计，会使人直觉上认为 RDD 的功能很受限、不够强大。但是，实际上 RDD 已经被实践证明可以很好地应用于许多并行计算应用中，可以具备很多现有计算框架（如 MapReduce、SQL、 Pregel 等）的表达能力，并且可以应用于这些框架处理不了的交互式数据挖掘应用。</p>
<p><img src="/2020/05/22/%E5%A4%A7%E6%95%B0%E6%8D%AE/Hadoop/Spark/Spark%E7%9A%84%E8%BD%AC%E6%8D%A2%E5%92%8C%E8%A1%8C%E5%8A%A8%E6%93%8D%E4%BD%9C.png" alt="Spark的转换和行动操作"></p>
<h4 id="RDD-特性"><a href="#RDD-特性" class="headerlink" title="RDD 特性"></a>RDD 特性</h4><ol>
<li>高效的容错性。现有的分布式共享内存、键值存储、内存数据库等，为了实现容错，必须在集群节点之间进行数据复制或者记录日志，也就是在节点之间会发生大量的数据传输，这对于数据密集型应用而言会带来很大的开销。在 RDD 的设计中，数据只读，不可修改，如果需要修改数据，必须从父 RDD 转换到子 RDD，由此在不同 RDD 之间建立了血缘关系。所以，RDD 是一种天生具有容错机制的特殊集合，不需要通过数据冗余的方式（比如检查点）实现容错，而只需通过 RDD 父子依赖（血缘）关系重新计算得到丢失的分区来实现容错，无需回滚整个系统，这样就避免了数据复制的高开销，而且重算过程可以在不同节点之间并行进行，实现了高效的容错。此外，RDD 提供的转换操作都是一些粗粒度的操作（比如 map、filter 和 join），RDD 依赖关系只需要记录这种粗粒度的转换操作，而不需要记录具体的数据和各种细粒度操作的日志（比如对哪个数据项进行了修改），这就大大降低了数据密集型应用中的容错开销。</li>
<li>中间结果持久化到内存。数据在内存中的多个 RDD 操作之间进行传递，不需要“落地”到磁盘上，避免了不必要的读写磁盘开销。</li>
<li>存放的数据可以是 Java 对象，避免了不必要的对象序列化和反序列化开销。</li>
</ol>
<h4 id="RDD-之间的依赖关系"><a href="#RDD-之间的依赖关系" class="headerlink" title="RDD 之间的依赖关系"></a>RDD 之间的依赖关系</h4><p>RDD 中不同的操作会使得不同 RDD 中的分区产生不同的依赖。RDD 中的依赖关系分为窄依赖（Narrow Dependency）与宽依赖（Wide Dependency）。</p>
<p><img src="/2020/05/22/%E5%A4%A7%E6%95%B0%E6%8D%AE/Hadoop/Spark/RDD%E7%9A%84%E5%AE%BD%E4%BE%9D%E8%B5%96%E5%92%8C%E7%AA%84%E4%BE%9D%E8%B5%96.png" alt="RDD的宽依赖和窄依赖"></p>
<p>窄依赖表现为一个父 RDD 的分区对应于一个子 RDD 的分区，或多个父 RDD 的分区对应于一个子 RDD 的分区。比如图中，RDD1 是 RDD2 的父 RDD，RDD2 是子 RDD，RDD1 的分区 1 对应于 RDD2 的一个分区（即分区 4）；再比如，RDD6 和 RDD7 都是RDD8的父RDD, RDD6 中的分区（分区 15）和 RDD7 中的分区（分区18），两者都对应于 RDD8 中的一个分区（分区 21）。</p>
<p>宽依赖则表现为存在一个父 RDD 的一个分区对应一个子 RDD 的多个分区。比如中，RDD9 是 RDD12 的父 RDD，RDD9 中的分区 24 对应了 RDD12 中的两个分区（即分区 27 和分区 28）。</p>
<p>总体而言，如果父 RDD 的一个分区只被一个子 RDD 的一个分区所使用就是窄依赖，否则就<br>是宽依赖。窄依赖典型的操作包括 map、filter、 union 等，宽依赖典型的操作包括groupByKey、sortByKey 等。对于连接（Join）操作，可以分为两种情况。</p>
<ol>
<li>对输人进行协同划分，属于窄依赖，如图所示。所谓协同划分（Co-partitioned）是指多个父 RDD 的某一分区的所有“键（Key）”落在子 RDD的同一个分区内，不会产生同一个父 RDD 的某一分区落在子 RDD 的两个分区的情况。</li>
<li>对输人做非协同划分，属于宽依赖，如图所示。</li>
</ol>
<p>对于窄依赖的 RDD，可以以流水线的方式计算所有父分区，不会造成网络之间的数据混合。对于宽依赖的 RDD，则通常伴随着 Shuffle 操作，即首先需要计算好所有父分区数据，然后在节<br>点之间进行 Shuffle。</p>
<p>Spark 的这种依赖关系设计，使其具有了天生的容错性，大大加快了 Spark 的执行速度。因为，RDD 数据集通过“血缘关系”记住了它是如何从其他 RDD 中演变过来的，血缘关系记录的是粗颗粒度的转换操作行为，当这个 RDD 的部分分区数据丢失时，它可以通过血缘关系获取足够的信息来重新运算和恢复丢失的数据分区，由此带来了性能的提升。相对而言，在两种依赖关系中，窄依赖的失败恢复更为高效，它只需要根据父 RDD 分区重新计算丢失的分区即可（不需要重新计算所有分区），而且可以并行地在不同节点上进行重新计算。而对于宽依赖而言，单个节点失效通常意味着重新计算过程会涉及多个父 RDD 分区，开销较大。此外，Spark 还提供了数据检查点和记录日志，用于持久化中间 RDD，从而使得在进行失败恢复时不需要追溯到最开始的阶段。在进行故障恢复时，Spark 会对数据检查点开销和重新计算 RDD 分区的开销进行比较，从而自动选择最优的恢复策略。</p>
<h4 id="阶段的划分"><a href="#阶段的划分" class="headerlink" title="阶段的划分"></a>阶段的划分</h4><p>Spark 通过分析各个 RDD 的依赖关系生成了 DAG，再通过分析各个 RDD 中的分区之间的依赖关系来决定如何划分阶段，具体划分方法是：在DAG中进行反向解析，遇到宽依赖就断开，遇到窄依赖就把当前的 RDD 加入到当前的阶段中；将窄依赖尽量划分在同一个阶段中，可以实现流水线计算</p>
<p><img src="/2020/05/22/%E5%A4%A7%E6%95%B0%E6%8D%AE/Hadoop/Spark/RDD%E9%98%B6%E6%AE%B5%E5%88%92%E5%88%86.png" alt="RDD阶段划分"></p>
<p>例如，根据 RDD 分区的依赖关系划分阶段，假设从 HDFS 中读入数据生成 3 个不同的 RDD（即 A、C 和 E），通过一系列转换操作后再将计算结果保存回 HDFS。对 DAG 进行解析时，在依赖图中进行反向解析，由于从 RDD A到 RDD B 的转换以及从 RDD B 和 RDD F 到 RDD G 的转换都属于宽依赖，因此在宽依赖处断开后可以得到 3 个阶段，即阶段 1、阶段 2和阶段 3。由图可以看出，在阶段 2 中，从 map 到 union 都是窄依赖，这两步操作可以形成一个流水线操作。比如，分区 7 通过 map 操作生成的分区 9，可以不用等待分区 8 到分区 10 这个转换操作的计算结束，而是继续进行 union 操作，转换得到分区 13，这样流水线执行大大提高了计算的效率。</p>
<p>由上述论述可知，把一个 DAG 图划分成多个阶段以后，每个阶段都代表了一组关联的、相互之间没有 Shuffle 依赖关系的任务组成的任务集合。每个任务集合会被提交给任务调度器（TaskScheduler）进行处理，由任务调度器将任务分发给 Executor 运行。</p>
<h4 id="RDD-运行过程"><a href="#RDD-运行过程" class="headerlink" title="RDD 运行过程"></a>RDD 运行过程</h4><ol>
<li>创建 RDD 对象。</li>
<li>SparkContext 负责计算 RDD 之间的依赖关系，构建 DAG。</li>
<li>DAGScheduler 负责把 DAG 图分解成多个阶段，每个阶段中包含了多个任务，每个任务会被任务调度器分发给各个工作节点（Worker Node）上的 Executor 去执行。</li>
</ol>
<p><img src="/2020/05/22/%E5%A4%A7%E6%95%B0%E6%8D%AE/Hadoop/Spark/RDD%E8%BF%90%E8%A1%8C%E8%BF%87%E7%A8%8B.png" alt="RDD运行过程"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wetts.github.io/2020/05/19/%E5%B7%A5%E5%85%B7/VSCode/VSCode-%E5%BF%AB%E6%8D%B7%E9%94%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Zhang Wetts">
      <meta itemprop="description" content="Stay Hungry, Stay Foolish. <br><br><p style="font-size:8px;">[build by hexo/next/gitalk/hexo-generator-search/LaTeX]</p>">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wetts's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/19/%E5%B7%A5%E5%85%B7/VSCode/VSCode-%E5%BF%AB%E6%8D%B7%E9%94%AE/" class="post-title-link" itemprop="url">VSCode-快捷键.md</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-19 21:38:32" itemprop="dateCreated datePublished" datetime="2020-05-19T21:38:32+08:00">2020-05-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-29 22:09:19" itemprop="dateModified" datetime="2021-03-29T22:09:19+08:00">2021-03-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/VSCode/" itemprop="url" rel="index"><span itemprop="name">VSCode</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <ul>
<li><p>重命名并求改引用：<code>F2</code></p>
</li>
<li><p>格式化代码：<code>shift + alt + f</code> (Win、Mac)</p>
</li>
<li><p>workbench.files.action.showActiveFileInExplorer：<code>cmd + m</code> (Mac)</p>
</li>
<li><p>光标上一个位置：<code>ctrl + -</code> (Mac)</p>
</li>
<li><p>光标下一个位置：<code>ctrl + shift + -</code> (Mac)</p>
</li>
<li><p>code-runner 快速执行：<code>ctrl + alt + n</code></p>
</li>
<li><p>转换成大写：<code>shift + ctrl + u</code> (Mac)</p>
</li>
<li><p>转换成小写：<code>shift + ctrl + l</code> (Mac)</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wetts.github.io/2020/05/18/artificial_intelligence/%E6%9C%BA%E5%99%A8%E8%A7%86%E8%A7%89/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Zhang Wetts">
      <meta itemprop="description" content="Stay Hungry, Stay Foolish. <br><br><p style="font-size:8px;">[build by hexo/next/gitalk/hexo-generator-search/LaTeX]</p>">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wetts's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/18/artificial_intelligence/%E6%9C%BA%E5%99%A8%E8%A7%86%E8%A7%89/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/" class="post-title-link" itemprop="url">目标检测.md</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-18 22:36:32" itemprop="dateCreated datePublished" datetime="2020-05-18T22:36:32+08:00">2020-05-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-05-21 00:23:25" itemprop="dateModified" datetime="2020-05-21T00:23:25+08:00">2020-05-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%9C%BA%E5%99%A8%E8%A7%86%E8%A7%89/" itemprop="url" rel="index"><span itemprop="name">机器视觉</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <ul>
<li>滑动窗口目标检测<ul>
<li>缺点：计算成本</li>
</ul>
</li>
</ul>
<h3 id="评价对象检测算法"><a href="#评价对象检测算法" class="headerlink" title="评价对象检测算法"></a>评价对象检测算法</h3><p><img src="/2020/05/18/artificial_intelligence/%E6%9C%BA%E5%99%A8%E8%A7%86%E8%A7%89/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/%E4%BA%A4%E5%B9%B6%E6%AF%94.png" alt="交并比"></p>
<p>一般约定，在计算机检测任务中，如果 $IoU \geq 0.5$，就说检测正确，如果预测器和实际边界框完美重叠，$IoU$ 就是 1，因为交集就等于并集。但一般来说只要 $IoU \geq 0.5$，那么结果是可以接受的，看起来还可以。一般约定，0.5 是阈值，用来判断预测的边界框是否正确。</p>
<h3 id="非极大值抑制（Non-max-suppression）"><a href="#非极大值抑制（Non-max-suppression）" class="headerlink" title="非极大值抑制（Non-max suppression）"></a>非极大值抑制（Non-max suppression）</h3><p>算法可能对同一个对象做出多次检测，所以算法不是对某个对象检测出一次，而是检测出多次。非极大值抑制这个方法可以确保你的算法对每个对象只检测一次。</p>
<p><img src="/2020/05/18/artificial_intelligence/%E6%9C%BA%E5%99%A8%E8%A7%86%E8%A7%89/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/%E9%9D%9E%E6%9E%81%E5%A4%A7%E6%8A%91%E5%88%B6.png" alt="非极大抑制"></p>
<p>这个 $p_c$ 检测概率，首先看概率最大的那个，这个例子（右边车辆）中是 0.9，然后就说这是最可靠的检测，所以我们就用高亮标记，就说我这里找到了一辆车。这么做之后，非极大值抑制就会逐一审视剩下的矩形，所有和这个最大的边框有很高交并比，高度重叠的其他边界框，那么这些输出就会被抑制。所以这两个矩形 $p_c$ 分别是 0.6 和 0.7，这两个矩形和淡蓝色矩形重叠程度很高，所以会被抑制，变暗，表示它们被抑制了。</p>
<p><img src="/2020/05/18/artificial_intelligence/%E6%9C%BA%E5%99%A8%E8%A7%86%E8%A7%89/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/%E9%9D%9E%E6%9E%81%E5%A4%A7%E6%8A%91%E5%88%B62.png" alt="非极大抑制2"></p>
<p>接下来，逐一审视剩下的矩形，找出概率最高，$p_c$ 最高的一个，在这种情况下是 0.8，我们就认为这里检测出一辆车（左边车辆），然后非极大值抑制算法就会去掉其他 $IoU$ 值很高的矩形。所以现在每个矩形都会被高亮显示或者变暗，如果你直接抛弃变暗的矩形，那就剩下高亮显示的那些，这就是最后得到的两个预测结果。</p>
<p><img src="/2020/05/18/artificial_intelligence/%E6%9C%BA%E5%99%A8%E8%A7%86%E8%A7%89/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/%E9%9D%9E%E6%9E%81%E5%A4%A7%E6%8A%91%E5%88%B63.png" alt="非极大抑制3"></p>
<p><img src="/2020/05/18/artificial_intelligence/%E6%9C%BA%E5%99%A8%E8%A7%86%E8%A7%89/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/%E9%9D%9E%E6%9E%81%E5%A4%A7%E6%8A%91%E5%88%B6%E7%AE%97%E6%B3%95.png" alt="非极大抑制算法"></p>
<h3 id="Anchor-Boxes"><a href="#Anchor-Boxes" class="headerlink" title="Anchor Boxes"></a>Anchor Boxes</h3><p>对象检测中存在的一个问题是每个格子只能检测出一个对象，如果你想让一个格子检测出多个对象，你可以这么做，就是使用 anchor box 这个概念。</p>
<p><img src="/2020/05/18/artificial_intelligence/%E6%9C%BA%E5%99%A8%E8%A7%86%E8%A7%89/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/AnchorBoxes.png" alt="AnchorBoxes"></p>
<p>对于这个例子，我们继续使用3×3网格，注意行人的中点和汽车的中点几乎在同一个地方，两者都落入到同一个格子中。所以对于那个格子，如果 $y$ 输出这个向量$y= \ \begin{bmatrix} p_{c} \ b_{x} \ b_{y} \ b_{h} \ b_{w} \ c_{1} \ c_{2}\ c_{3} \\end{bmatrix}$，你可以检测这三个类别，行人、汽车和摩托车，它将无法输出检测结果，所以我必须从两个检测结果中选一个。</p>
<p>而<strong>anchor box</strong>的思路是，这样子，预先定义两个不同形状的<strong>anchor box</strong>，或者<strong>anchor box</strong>形状，你要做的是把预测结果和这两个<strong>anchor box</strong>关联起来。一般来说，你可能会用更多的<strong>anchor box</strong>，可能要5个甚至更多，但对于这个视频，我们就用两个<strong>anchor box</strong>，这样介绍起来简单一些。</p>
<p><img src="/2020/05/18/artificial_intelligence/%E6%9C%BA%E5%99%A8%E8%A7%86%E8%A7%89/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/AnchorBoxes2.png" alt="AnchorBoxes2"></p>
<p><img src="/2020/05/18/artificial_intelligence/%E6%9C%BA%E5%99%A8%E8%A7%86%E8%A7%89/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/AnchorBoxes3.png" alt="AnchorBoxes3"></p>
<p>你要做的是定义类别标签，用的向量不再是上面这个$\begin{bmatrix} p_{c} &amp; b_{x} &amp;b_{y} &amp; b_{h} &amp; b_{w} &amp; c_{1} &amp; c_{2} &amp; c_{3} \\end{bmatrix}^{T}$，而是重复两次，$y=  \begin{bmatrix} p_{c} &amp; b_{x} &amp; b_{y} &amp;b_{h} &amp; b_{w} &amp; c_{1} &amp; c_{2} &amp; c_{3} &amp; p_{c} &amp; b_{x} &amp; b_{y} &amp; b_{h} &amp; b_{w} &amp;c_{1} &amp; c_{2} &amp; c_{3} \\end{bmatrix}^{T}$，前面的$p_{c},b_{x},b_{y},b_{h},b_{w},c_{1},c_{2},c_{3}$（绿色方框标记的参数）是和<strong>anchor box 1</strong>关联的8个参数，后面的8个参数（橙色方框标记的元素）是和<strong>anchor box 2</strong>相关联。因为行人的形状更类似于<strong>anchor box 1</strong>的形状，而不是<strong>anchor box 2</strong>的形状，所以你可以用这8个数值（前8个参数），这么编码$p_{c} =1$，是的，代表有个行人，用$b_{x},b_{y},b_{h}$和$b_{w}$来编码包住行人的边界框，然后用$c_{1},c_{2},c_{3}$($c_{1}= 1,c_{2} = 0,c_{3} = 0$)来说明这个对象是个行人。</p>
<p>然后是车子，因为车子的边界框比起<strong>anchor box 1</strong>更像<strong>anchor box 2</strong>的形状，你就可以这么编码，这里第二个对象是汽车，然后有这样的边界框等等，这里所有参数都和检测汽车相关($p_{c}= 1,b_{x},b_{y},b_{h},b_{w},c_{1} = 0,c_{2} = 1,c_{3} = 0$)。</p>
<p><img src="/2020/05/18/artificial_intelligence/%E6%9C%BA%E5%99%A8%E8%A7%86%E8%A7%89/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/AnchorBoxes%E7%AE%97%E6%B3%95.png" alt="AnchorBoxes算法"></p>
<p>总结一下，用<strong>anchor box</strong>之前，你做的是这个，对于训练集图像中的每个对象，都根据那个对象中点位置分配到对应的格子中，所以输出$y$就是3×3×8，因为是3×3网格，对于每个网格位置，我们有输出向量，包含$p_{c}$，然后边界框参数$b_{x},b_{y},b_{h}$和$b_{w}$，然后$c_{1},c_{2},c_{3}$。</p>
<p>现在用到<strong>anchor box</strong>这个概念，是这么做的。现在每个对象都和之前一样分配到同一个格子中，分配到对象中点所在的格子中，以及分配到和对象形状交并比最高的<strong>anchor box</strong>中。所以这里有两个<strong>anchor box</strong>，你就取这个对象，如果你的对象形状是这样的（编号1，红色框），你就看看这两个<strong>anchor box</strong>，<strong>anchor box 1</strong>形状是这样（编号2，紫色框），<strong>anchor box 2</strong>形状是这样（编号3，紫色框），然后你观察哪一个<strong>anchor box</strong>和实际边界框（编号1，红色框）的交并比更高，不管选的是哪一个，这个对象不只分配到一个格子，而是分配到一对，即（<strong>grid cell，anchor box</strong>）对，这就是对象在目标标签中的编码方式。所以现在输出 $y$ 就是3×3×16，上一张幻灯片中你们看到 $y$ 现在是16维的，或者你也可以看成是3×3×2×8，因为现在这里有2个<strong>anchor box</strong>，而 $y$ 是8维的。$y$ 维度是8，因为我们有3个对象类别，如果你有更多对象，那么$y$ 的维度会更高。</p>
<h3 id="YOLO-算法（Putting-it-together-YOLO-algorithm）"><a href="#YOLO-算法（Putting-it-together-YOLO-algorithm）" class="headerlink" title="YOLO 算法（Putting it together: YOLO algorithm）"></a>YOLO 算法（Putting it together: YOLO algorithm）</h3><h3 id="候选区域（Region-proposals）"><a href="#候选区域（Region-proposals）" class="headerlink" title="候选区域（Region proposals）"></a>候选区域（Region proposals）</h3><p>滑动窗法，使用训练过的分类器，在这些窗口中全部运行一遍，然后运行一个检测器，看看里面是否有车辆，行人和摩托车。现在也可以运行一下卷积算法，这个算法的其中一个缺点是，它在显然没有任何对象的区域浪费时间。</p>
<p><img src="/2020/05/18/artificial_intelligence/%E6%9C%BA%E5%99%A8%E8%A7%86%E8%A7%89/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/%E5%80%99%E9%80%89%E5%8C%BA%E5%9F%9F.png" alt="候选区域"></p>
<p>所以这里这个矩形区域（编号1）基本是空的，显然没有什么需要分类的东西。也许算法会在这个矩形上（编号2）运行，而你知道上面没有什么有趣的东西。</p>
<p><strong>R-CNN</strong>的算法，意思是带区域的卷积网络，或者说带区域的<strong>CNN</strong>。这个算法尝试选出一些区域，在这些区域上运行卷积网络分类器是有意义的，所以这里不再针对每个滑动窗运行检测算法，而是只选择一些窗口，在少数窗口上运行卷积网络分类器。</p>
<p>选出候选区域的方法是运行图像分割算法，分割的结果是下边的图像，为了找出可能存在对象的区域。比如说，分割算法在这里得到一个色块，所以你可能会选择这样的边界框（编号1），然后在这个色块上运行分类器，就像这个绿色的东西（编号2），在这里找到一个色块，接下来我们还会在那个矩形上（编号2）运行一次分类器，看看有没有东西。在这种情况下，如果在蓝色色块上（编号3）运行分类器，希望你能检测出一个行人，如果你在青色色块(编号4)上运行算法，也许你可以发现一辆车，我也不确定。</p>
<p><img src="/2020/05/18/artificial_intelligence/%E6%9C%BA%E5%99%A8%E8%A7%86%E8%A7%89/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/%E5%80%99%E9%80%89%E5%8C%BA%E5%9F%9F2.png" alt="候选区域2"></p>
<p><img src="/2020/05/18/artificial_intelligence/%E6%9C%BA%E5%99%A8%E8%A7%86%E8%A7%89/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/RCNN.png" alt="RCNN"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wetts.github.io/2020/05/15/%E8%AF%AD%E8%A8%80/Python/%E7%8E%AF%E5%A2%83/Python-%E6%8D%A2pip%E6%BA%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Zhang Wetts">
      <meta itemprop="description" content="Stay Hungry, Stay Foolish. <br><br><p style="font-size:8px;">[build by hexo/next/gitalk/hexo-generator-search/LaTeX]</p>">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wetts's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/15/%E8%AF%AD%E8%A8%80/Python/%E7%8E%AF%E5%A2%83/Python-%E6%8D%A2pip%E6%BA%90/" class="post-title-link" itemprop="url">Python-换pip源.md</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-15 19:00:24" itemprop="dateCreated datePublished" datetime="2020-05-15T19:00:24+08:00">2020-05-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-05-16 22:16:34" itemprop="dateModified" datetime="2020-05-16T22:16:34+08:00">2020-05-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Python/" itemprop="url" rel="index"><span itemprop="name">Python</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="临时使用"><a href="#临时使用" class="headerlink" title="临时使用"></a>临时使用</h2><p>清华源：<code>-i https://pypi.tuna.tsinghua.edu.cn/simple</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">https://pypi.tuna.tsinghua.edu.cn/simple/	# 清华大学</span><br><span class="line">https://mirrors.aliyun.com/pypi/simple/		# 阿里云</span><br><span class="line">https://pypi.douban.com/simple/				# 豆瓣</span><br><span class="line">https://pypi.mirrors.ustc.edu.cn/simple/	# 中国科学技术大学</span><br></pre></td></tr></table></figure>

<h2 id="设为默认"><a href="#设为默认" class="headerlink" title="设为默认"></a>设为默认</h2><p>修改 <code>~/.config/pip/pip.conf</code>（Linux），<code>%APPDATA%\pip\pip.ini</code>（Windows 10）或 <code>$HOME/Library/Application Support/pip/pip.conf</code>（macOS）（没有就创建一个），修改 index-url 至 tuna，例如</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[global]</span><br><span class="line">index-url = https://pypi.tuna.tsinghua.edu.cn/simple</span><br></pre></td></tr></table></figure>

<p>pip 和 pip3 并存时，只需修改 <code>~/.pip/pip.conf</code>。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/69/">69</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Zhang Wetts"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">Zhang Wetts</p>
  <div class="site-description" itemprop="description">Stay Hungry, Stay Foolish. <br><br><p style="font-size:8px;">[build by hexo/next/gitalk/hexo-generator-search/LaTeX]</p></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">683</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">63</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">338</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/wetts" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;wetts" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:zhang.wetts@163.com" title="E-Mail → mailto:zhang.wetts@163.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Zhang Wetts</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

  


<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/hibiki.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"react":{"opacity":0.7}});</script></body>
</html>
