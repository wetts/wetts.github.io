<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"wetts.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="Stay Hungry, Stay Foolish. [build by hexo&#x2F;next&#x2F;gitalk&#x2F;hexo-generator-search&#x2F;LaTeX]">
<meta property="og:type" content="website">
<meta property="og:title" content="Wetts&#39;s blog">
<meta property="og:url" content="https://wetts.github.io/page/3/index.html">
<meta property="og:site_name" content="Wetts&#39;s blog">
<meta property="og:description" content="Stay Hungry, Stay Foolish. [build by hexo&#x2F;next&#x2F;gitalk&#x2F;hexo-generator-search&#x2F;LaTeX]">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Zhang Wetts">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://wetts.github.io/page/3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Wetts's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Wetts's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Stay Hungry, Stay Foolish.</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/wetts" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wetts.github.io/2021/04/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%81%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Zhang Wetts">
      <meta itemprop="description" content="Stay Hungry, Stay Foolish. <br><br><p style="font-size:8px;">[build by hexo/next/gitalk/hexo-generator-search/LaTeX]</p>">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wetts's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%81%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/" class="post-title-link" itemprop="url">数据结构-布隆过滤器.md</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-07 12:30:17" itemprop="dateCreated datePublished" datetime="2021-04-07T12:30:17+08:00">2021-04-07</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" itemprop="url" rel="index"><span itemprop="name">数据结构</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>转自：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/43263751">https://zhuanlan.zhihu.com/p/43263751</a></p>
<p>在进入正文之前，之前看到的有句话我觉得说得很好：</p>
<blockquote>
<p>Data structures are nothing different. They are like the bookshelves of your application where you can organize your data. Different data structures will give you different facility and benefits. To properly use the power and accessibility of the data structures you need to know the trade-offs of using one.</p>
<p>大意是不同的数据结构有不同的适用场景和优缺点，你需要仔细权衡自己的需求之后妥善适用它们，布隆过滤器就是践行这句话的代表。</p>
</blockquote>
<h2 id="什么是布隆过滤器"><a href="#什么是布隆过滤器" class="headerlink" title="什么是布隆过滤器"></a>什么是布隆过滤器</h2><p>本质上布隆过滤器是一种数据结构，比较巧妙的概率型数据结构（probabilistic data structure），特点是高效地插入和查询，可以用来告诉你 “<strong>某样东西一定不存在或者可能存在</strong>”。</p>
<p>相比于传统的 List、Set、Map 等数据结构，它更高效、占用空间更少，但是缺点是其返回的结果是概率性的，而不是确切的。</p>
<h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><h3 id="HashMap-的问题"><a href="#HashMap-的问题" class="headerlink" title="HashMap 的问题"></a>HashMap 的问题</h3><p>讲述布隆过滤器的原理之前，我们先思考一下，通常你判断某个元素是否存在用的是什么？应该蛮多人回答 HashMap 吧，确实可以将值映射到 HashMap 的 Key，然后可以在 $O(1)$ 的时间复杂度内返回结果，效率奇高。但是 HashMap 的实现也有缺点，例如存储容量占比高，考虑到负载因子的存在，通常空间是不能被用满的，而一旦你的值很多例如上亿的时候，那 HashMap 占据的内存大小就变得很可观了。</p>
<p>还比如说你的数据集存储在远程服务器上，本地服务接受输入，而数据集非常大不可能一次性读进内存构建 HashMap 的时候，也会存在问题。</p>
<h3 id="布隆过滤器数据结构"><a href="#布隆过滤器数据结构" class="headerlink" title="布隆过滤器数据结构"></a>布隆过滤器数据结构</h3><p>布隆过滤器是一个 bit 向量或者说 bit 数组，长这样：<br><img src="/2021/04/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%81%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/1.jpg" alt="1"></p>
<p>如果我们要映射一个值到布隆过滤器中，我们需要使用多个不同的哈希函数生成多个哈希值，并对每个生成的哈希值指向的 bit 位置 1，例如针对值 “baidu” 和三个不同的哈希函数分别生成了哈希值 1、4、7，则上图转变为：<br><img src="/2021/04/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%81%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/2.jpg" alt="2"></p>
<p>Ok，我们现在再存一个值 “tencent”，如果哈希函数返回 3、4、8 的话，图继续变为：<br><img src="/2021/04/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%81%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/3.jpg" alt="3"></p>
<p>值得注意的是，4 这个 bit 位由于两个值的哈希函数都返回了这个 bit 位，因此它被覆盖了。现在我们如果想查询 “dianping” 这个值是否存在，哈希函数返回了 1、5、8三个值，结果我们发现 5 这个 bit 位上的值为 0，说明没有任何一个值映射到这个 bit 位上，因此我们可以很确定地说 “dianping” 这个值不存在。而当我们需要查询 “baidu” 这个值是否存在的话，那么哈希函数必然会返回 1、4、7，然后我们检查发现这三个 bit 位上的值均为 1，那么我们可以说 “baidu” 存在了么？答案是不可以，只能是 “baidu” 这个值可能存在。</p>
<p>这是为什么呢？答案跟简单，因为随着增加的值越来越多，被置为 1 的 bit 位也会越来越多，这样某个值 “taobao” 即使没有被存储过，但是万一哈希函数返回的三个 bit 位都被其他值置位了 1 ，那么程序还是会判断 “taobao” 这个值存在。</p>
<h2 id="支持删除么"><a href="#支持删除么" class="headerlink" title="支持删除么"></a>支持删除么</h2><p>感谢评论区提醒，传统的布隆过滤器并不支持删除操作。但是名为 Counting Bloom filter 的变种可以用来测试元素计数个数是否绝对小于某个阈值，它支持元素删除。可以参考文章 <a href="%5Bhttps://link%5D(https://link.zhihu.com/?target=https://cloud.tencent.com/developer/article/1136056)">Counting Bloom Filter 的原理和实现</a></p>
<blockquote>
<p>注：【首先需要判断一定存在，才能进行删除】</p>
</blockquote>
<h2 id="如何选择哈希函数个数和布隆过滤器长度"><a href="#如何选择哈希函数个数和布隆过滤器长度" class="headerlink" title="如何选择哈希函数个数和布隆过滤器长度"></a>如何选择哈希函数个数和布隆过滤器长度</h2><p>很显然，过小的布隆过滤器很快所有的 bit 位均为 1，那么查询任何值都会返回“可能存在”，起不到过滤的目的了。布隆过滤器的长度会直接影响误报率，布隆过滤器越长其误报率越小。</p>
<p>另外，哈希函数的个数也需要权衡，个数越多则布隆过滤器 bit 位置位 1 的速度越快，且布隆过滤器的效率越低；但是如果太少的话，那我们的误报率会变高。<br><img src="/2021/04/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%81%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/4.jpg" alt="4"></p>
<p>k 为哈希函数个数，m 为布隆过滤器长度，n 为插入的元素个数，p 为误报率</p>
<p>如何选择适合业务的 k 和 m 值呢，这里直接贴一个公式：<br><img src="/2021/04/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%81%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/5.jpg" alt="5"></p>
<p>如何推导这个公式这里只是提一句，因为对于使用来说并没有太大的意义，你让一个高中生来推会推得很快。k 次哈希函数某一 bit 位未被置为 1 的概率为：</p>
<p>$\left(1-\frac{1}{m}\right)^{k}$</p>
<p>插入n个元素后依旧为 0 的概率和为 1 的概率分别是：</p>
<p>$\left(1-\frac{1}{m}\right)^{n k} 1-\left(1-\frac{1}{m}\right)^{n k}$</p>
<p>标明某个元素是否在集合中所需的 k 个位置都按照如上的方法设置为 1，但是该方法可能会使算法错误的认为某一原本不在集合中的元素却被检测为在该集合中（False Positives），该概率由以下公式确定</p>
<p>$\left[1-\left(1-\frac{1}{m}\right)^{n k}\right]^{k} \approx\left(1-e^{-k n / m}\right)^{k}$</p>
<h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><p>常见的适用常见有，利用布隆过滤器减少磁盘 IO 或者网络请求，因为一旦一个值必定不存在的话，我们可以不用进行后续昂贵的查询请求。</p>
<p>另外，既然你使用布隆过滤器来加速查找和判断是否存在，那么性能很低的哈希函数不是个好选择，推荐 MurmurHash、Fnv 这些。</p>
<h3 id="大Value拆分"><a href="#大Value拆分" class="headerlink" title="大Value拆分"></a>大Value拆分</h3><p>Redis 因其支持 setbit 和 getbit 操作，且纯内存性能高等特点，因此天然就可以作为布隆过滤器来使用。但是布隆过滤器的不当使用极易产生大 Value，增加 Redis 阻塞风险，因此生成环境中建议对体积庞大的布隆过滤器进行拆分。</p>
<p>拆分的形式方法多种多样，但是本质是不要将 <code>Hash(Key)</code> 之后的请求分散在多个节点的多个小 bitmap 上，而是应该拆分成多个小 bitmap 之后，对一个 Key 的所有哈希函数都落在这一个小 bitmap 上。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wetts.github.io/2021/04/07/%E5%B7%A5%E7%A8%8B/%E7%BC%93%E5%AD%98/%E7%BC%93%E5%AD%98-%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%EF%BC%8C%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%EF%BC%8C%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%E5%87%BA%E7%8E%B0%E7%9A%84%E5%8E%9F%E5%9B%A0%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Zhang Wetts">
      <meta itemprop="description" content="Stay Hungry, Stay Foolish. <br><br><p style="font-size:8px;">[build by hexo/next/gitalk/hexo-generator-search/LaTeX]</p>">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wetts's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/07/%E5%B7%A5%E7%A8%8B/%E7%BC%93%E5%AD%98/%E7%BC%93%E5%AD%98-%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%EF%BC%8C%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%EF%BC%8C%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%E5%87%BA%E7%8E%B0%E7%9A%84%E5%8E%9F%E5%9B%A0%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/" class="post-title-link" itemprop="url">缓存-缓存雪崩，缓存穿透，缓存击穿出现的原因及解决方案.md</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-07 12:10:23" itemprop="dateCreated datePublished" datetime="2021-04-07T12:10:23+08:00">2021-04-07</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BC%93%E5%AD%98/" itemprop="url" rel="index"><span itemprop="name">缓存</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>转自：<a target="_blank" rel="noopener" href="https://blog.csdn.net/zzti_erlie/article/details/104655455">https://blog.csdn.net/zzti_erlie/article/details/104655455</a></p>
<h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><h3 id="出现过程"><a href="#出现过程" class="headerlink" title="出现过程"></a>出现过程</h3><p>假设有如下一个系统，高峰期请求为5000次/秒，4000次走了缓存，只有1000次落到了数据库上，数据库每秒1000的并发是一个正常的指标，完全可以正常工作，但如果缓存宕机了，或者缓存设置了相同的过期时间，导致缓存在同一时刻同时失效，每秒5000次的请求会全部落到数据库上，数据库立马就死掉了，因为数据库一秒最多抗2000个请求，如果DBA重启数据库，立马又会被新的请求打死了，这就是缓存雪崩。<br><img src="/2021/04/07/%E5%B7%A5%E7%A8%8B/%E7%BC%93%E5%AD%98/%E7%BC%93%E5%AD%98-%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%EF%BC%8C%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%EF%BC%8C%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%E5%87%BA%E7%8E%B0%E7%9A%84%E5%8E%9F%E5%9B%A0%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9.png" alt="1"></p>
<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><ul>
<li>事前：redis高可用，主从+哨兵，redis cluster，避免全盘崩溃</li>
<li>事中：本地ehcache缓存 + hystrix限流&amp;降级，避免MySQL被打死</li>
<li>事后：redis持久化RDB+AOF，快速恢复缓存数据</li>
<li>缓存的失效时间设置为随机值，避免同时失效</li>
</ul>
<h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><h3 id="出现过程-1"><a href="#出现过程-1" class="headerlink" title="出现过程"></a>出现过程</h3><p>假如客户端每秒发送5000个请求，其中4000个为黑客的恶意攻击，即在数据库中也查不到。举个例子，用户id为正数，黑客构造的用户id为负数，如果黑客每秒一直发送这4000个请求，缓存就不起作用，数据库也很快被打死。<br><img src="/2021/04/07/%E5%B7%A5%E7%A8%8B/%E7%BC%93%E5%AD%98/%E7%BC%93%E5%AD%98-%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%EF%BC%8C%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%EF%BC%8C%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%E5%87%BA%E7%8E%B0%E7%9A%84%E5%8E%9F%E5%9B%A0%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F.png" alt="2"></p>
<h3 id="解决方法-1"><a href="#解决方法-1" class="headerlink" title="解决方法"></a>解决方法</h3><ul>
<li>对请求参数进行校验，不合理直接返回</li>
<li>查询不到的数据也放到缓存，value为空，如 set -999 “”</li>
<li>使用布隆过滤器，快速判断key是否在数据库中存在，不存在直接返回</li>
</ul>
<p>第一种是最基本的策略，第二种其实并不常用，第三种比较常用。</p>
<p>为什么第二种并不常用呢？</p>
<p>因为如果黑客构造的请求id是随机数，第二种并不能起作用，反而由于缓存的清空策略，（例如清除最近没有被访问的缓存）导致有用的缓存被清除了。</p>
<h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><h3 id="出现过程-2"><a href="#出现过程-2" class="headerlink" title="出现过程"></a>出现过程</h3><p>设置了过期时间的key，承载着高并发，是一种热点数据。从这个key过期到重新从MySQL加载数据放到缓存的一段时间，大量的请求有可能把数据库打死。缓存雪崩是指大量缓存失效，缓存击穿是指热点数据的缓存失效</p>
<h3 id="解决方法-2"><a href="#解决方法-2" class="headerlink" title="解决方法"></a>解决方法</h3><p>设置key永远不过期，或者快过期时，通过另一个异步线程重新设置key</p>
<p>当从缓存拿到的数据为null，重新从数据库加载数据的过程上锁，下面写个分布式锁实现的demo</p>
<h4 id="Redis实现分布式锁"><a href="#Redis实现分布式锁" class="headerlink" title="Redis实现分布式锁"></a>Redis实现分布式锁</h4><ol>
<li>加锁执行命令<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET resource_name random_value NX PX 30000</span><br></pre></td></tr></table></figure></li>
<li>解锁执行脚本<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if redis.call(&quot;get&quot;, KEYS[1]) == ARGV[1] then </span><br><span class="line">    return redis.call(&quot;del&quot;, KEYS[1]) </span><br><span class="line">else </span><br><span class="line">    return 0 </span><br><span class="line">end</span><br></pre></td></tr></table></figure></li>
</ol>
<p>写一个分布式锁工具类</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class LockUtil &#123;</span><br><span class="line"></span><br><span class="line">    private static final String OK = &quot;OK&quot;;</span><br><span class="line">    private static final Long LONG_ONE = 1L;</span><br><span class="line">    private static final String script = &quot;if redis.call(&#x27;get&#x27;, KEYS[1]) == ARGV[1] then return redis.call(&#x27;del&#x27;, KEYS[1]) else return 0 end&quot;;</span><br><span class="line"></span><br><span class="line">    public static boolean tryLock(String key, String value, long expire) &#123;</span><br><span class="line">        Jedis jedis = RedisPool.getJedis();</span><br><span class="line">        SetParams setParams = new SetParams();</span><br><span class="line">        setParams.nx().px(expire);</span><br><span class="line">        return OK.equals(jedis.set(key, value, setParams));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static boolean releaseLock(String key, String value) &#123;</span><br><span class="line">        Jedis jedis = RedisPool.getJedis();</span><br><span class="line">        return LONG_ONE.equals(jedis.eval(script, 1, key, value));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>工具类写起来还是挺简单的</p>
<p>示例代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public String getData(String key) &#123;</span><br><span class="line">	String lockKey = &quot;key&quot;;</span><br><span class="line">	String lockValue = String.valueOf(System.currentTimeMillis());</span><br><span class="line">	long expireTime = 1000L;</span><br><span class="line">	String value = getFromRedis(key);</span><br><span class="line">	if (value == null) &#123;</span><br><span class="line">		if (LockUtil.tryLock(lockKey, lockValue, expireTime)) &#123;</span><br><span class="line">			// 从数据库取值并放到redis中</span><br><span class="line">			LockUtil.releaseLock(lockKey, lockValue);</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			// sleep一段时间再从缓存中拿</span><br><span class="line">			Thread.sleep(100);</span><br><span class="line">			getFromRedis(key);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wetts.github.io/2021/03/24/%E5%B7%A5%E7%A8%8B/%E6%8E%A5%E5%8F%A3/%E9%AB%98%E5%B9%B6%E5%8F%91-%E9%AB%98%E5%B9%B6%E5%8F%91%E4%B8%8B%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%B9%82%E7%AD%89%E6%80%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Zhang Wetts">
      <meta itemprop="description" content="Stay Hungry, Stay Foolish. <br><br><p style="font-size:8px;">[build by hexo/next/gitalk/hexo-generator-search/LaTeX]</p>">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wetts's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/24/%E5%B7%A5%E7%A8%8B/%E6%8E%A5%E5%8F%A3/%E9%AB%98%E5%B9%B6%E5%8F%91-%E9%AB%98%E5%B9%B6%E5%8F%91%E4%B8%8B%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%B9%82%E7%AD%89%E6%80%A7/" class="post-title-link" itemprop="url">高并发-高并发下如何保证接口的幂等性.md</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-03-24 12:42:56" itemprop="dateCreated datePublished" datetime="2021-03-24T12:42:56+08:00">2021-03-24</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%AB%98%E5%B9%B6%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">高并发</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>转自：<a target="_blank" rel="noopener" href="https://blog.csdn.net/zzti_erlie/article/details/106910362">https://blog.csdn.net/zzti_erlie/article/details/106910362</a></p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>幂等性就是同一个操作执行多次，产生的效果一样。如 http 的 get 请求，数据库的 select 请求就是幂等的</p>
<p>在分布式系统中，保证接口的幂等性非常重要，如提交订单，扣款等接口都要保证幂等性，不然会造成重复创建订单，重复扣款，那么如何保证接口的幂等性呢？</p>
<h2 id="前端保证幂等性的方法"><a href="#前端保证幂等性的方法" class="headerlink" title="前端保证幂等性的方法"></a>前端保证幂等性的方法</h2><h3 id="按钮只能点击一次"><a href="#按钮只能点击一次" class="headerlink" title="按钮只能点击一次"></a>按钮只能点击一次</h3><p>用户点击按钮后将按钮置灰，或者显示 loading 状态</p>
<h3 id="RPG-模式"><a href="#RPG-模式" class="headerlink" title="RPG 模式"></a>RPG 模式</h3><p>即 Post-Redirect-Get，当客户提交表单后，去执行一个客户端的重定向，转到提交成功页面。避免用户按 F5 刷新导致的重复提交，也能消除按浏览器后退键导致的重复提交问题。目前绝大多数公司都是这样做的，比如淘宝，京东等</p>
<h2 id="后端保证幂等性的方法"><a href="#后端保证幂等性的方法" class="headerlink" title="后端保证幂等性的方法"></a>后端保证幂等性的方法</h2><h3 id="使用唯一索引"><a href="#使用唯一索引" class="headerlink" title="使用唯一索引"></a>使用唯一索引</h3><p>对业务唯一的字段加上唯一索引，这样当数据重复时，插入数据库会抛异常</p>
<h3 id="状态机幂等"><a href="#状态机幂等" class="headerlink" title="状态机幂等"></a>状态机幂等</h3><p>如果业务上需要修改订单状态，例如订单状态有待支付，支付中，支付成功，支付失败。设计时最好只支持状态的单向改变。这样在更新的时候就可以加上条件，多次调用也只会执行一次。例如想把订单状态更新为支持成功，则之前的状态必须为支付中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update table_name set status = 支付成功 where status = 支付中</span><br></pre></td></tr></table></figure>

<h3 id="乐观锁实现幂等"><a href="#乐观锁实现幂等" class="headerlink" title="乐观锁实现幂等"></a>乐观锁实现幂等</h3><ol>
<li>查询数据获得版本号</li>
<li>通过版本号去更新，版本号匹配则更新，版本号不匹配则不更新<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- 假如查询出的 version 为 1</span><br><span class="line">select version from table_name where userid = 10;</span><br><span class="line">-- 给用户的账户加10</span><br><span class="line">update table_name set money = money -10, version = version + 1 where userid = 10 and version = 1</span><br></pre></td></tr></table></figure></li>
</ol>
<p>也可以通过条件来实现乐观锁，如库存不能超卖，数量不能小于 0</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update table_name set num = num - 10 where num - 10 &gt;= 0</span><br></pre></td></tr></table></figure>

<h3 id="防重表"><a href="#防重表" class="headerlink" title="防重表"></a>防重表</h3><p>增加一个防重表，业务唯一的id作为唯一索引，如订单号，当想针对订单做一系列操作时，可以向防重表中插入一条记录，插入成功，执行后续操作，插入失败，则不执行后续操作。本质上可以看成是基于MySQL实现的分布式锁。根据业务场景决定执行成功后，是否删除防重表中对应的数据</p>
<h3 id="分布式锁实现幂等"><a href="#分布式锁实现幂等" class="headerlink" title="分布式锁实现幂等"></a>分布式锁实现幂等</h3><p>执行方法时，先根据业务唯一的 id 获取分布式锁，获取成功，则执行，失败则不执行。分布式锁可以基于 redis，zookeeper，mysql 来实现，分布式锁的细节就不介绍了</p>
<h3 id="select-insert"><a href="#select-insert" class="headerlink" title="select+insert"></a>select+insert</h3><p>先查询一下有没有符合要求的数据，如果没有再执行插入。没有并发的系统中可以保证幂等性，高并发下不要用这种方法，也会造成数据的重复插入。我一般做消息幂等的时候就是先 select，有数据直接返回，没有数据加分布式锁进行 insert 操作</p>
<h3 id="全局唯一号实现幂等"><a href="#全局唯一号实现幂等" class="headerlink" title="全局唯一号实现幂等"></a>全局唯一号实现幂等</h3><p>通过 source（来源）+ seq（序列号）来判断请求是否重复，重复则直接返回请求重复提交，否则执行。如当多个三方系统调用服务的时候，就可以采用这种方式</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wetts.github.io/2021/02/12/%E8%AF%AD%E8%A8%80/Java/basic_Java/API/%E5%B9%B6%E5%8F%91/%E5%85%B6%E4%BB%96/Java-%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E5%A4%9A%E4%B8%AA%E7%BA%BF%E7%A8%8B%E6%89%A7%E8%A1%8C%E5%AE%8C%E6%AF%95%E5%90%8E%EF%BC%8C%E6%89%8D%E6%89%A7%E8%A1%8C%E5%8F%A6%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Zhang Wetts">
      <meta itemprop="description" content="Stay Hungry, Stay Foolish. <br><br><p style="font-size:8px;">[build by hexo/next/gitalk/hexo-generator-search/LaTeX]</p>">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wetts's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/12/%E8%AF%AD%E8%A8%80/Java/basic_Java/API/%E5%B9%B6%E5%8F%91/%E5%85%B6%E4%BB%96/Java-%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E5%A4%9A%E4%B8%AA%E7%BA%BF%E7%A8%8B%E6%89%A7%E8%A1%8C%E5%AE%8C%E6%AF%95%E5%90%8E%EF%BC%8C%E6%89%8D%E6%89%A7%E8%A1%8C%E5%8F%A6%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B/" class="post-title-link" itemprop="url">Java-多线程-多个线程执行完毕后，才执行另一个线程.md</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-02-12 15:11:15" itemprop="dateCreated datePublished" datetime="2021-02-12T15:11:15+08:00">2021-02-12</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>转自：<a target="_blank" rel="noopener" href="https://blog.csdn.net/zzti_erlie/article/details/100047508">https://blog.csdn.net/zzti_erlie/article/details/100047508</a></p>
<h3 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h3><p>去掉try catch版本</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * Thread-1 在路上耗时4秒</span><br><span class="line">	 * Thread-2 在路上耗时0秒</span><br><span class="line">	 * Thread-0 在路上耗时4秒</span><br><span class="line">	 * Thread-2 到达车站了</span><br><span class="line">	 * Thread-1 到达车站了</span><br><span class="line">	 * Thread-0 到达车站了</span><br><span class="line">	 * 老司机，发车</span><br><span class="line">	 */</span><br><span class="line">	CountDownLatch countDownLatch = new CountDownLatch(3);</span><br><span class="line">	Random random = new Random();</span><br><span class="line">	for (int i = 0; i &lt; 3; i++) &#123;</span><br><span class="line">		new Thread(() -&gt; &#123;</span><br><span class="line">			//返回[0,5)的值</span><br><span class="line">			int time = random.nextInt(5);</span><br><span class="line">			System.out.println(Thread.currentThread().getName() + &quot; 在路上耗时&quot; + time + &quot;秒&quot;);</span><br><span class="line">			TimeUnit.SECONDS.sleep(time);</span><br><span class="line">			System.out.println(Thread.currentThread().getName() + &quot; 到达车站了&quot;);</span><br><span class="line">			countDownLatch.countDown();</span><br><span class="line">		&#125;).start();</span><br><span class="line">	&#125;</span><br><span class="line">	countDownLatch.await();</span><br><span class="line">	System.out.println(&quot;老司机，发车&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>先来演示一下用法，可以看到所有子线程都执行完毕才会执行主线程。实现这个功能主要靠的是 CountDownLatch 的 2 个方法 await() 和 countDown()。</p>
<p>new 一个 CountDownLatch 时会传一个计数器的值，上面的例子为 3。调用 await() 方法时判断计数是否为 0，如果不为 0 则呈等待状态。其他线程可以调用 countDown() 方法将计数减 1，当计数减到位 0 时，则呈等待的线程继续执行。</p>
<h3 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h3><p>去掉try catch版本</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * Thread-1 在路上耗时0秒</span><br><span class="line">	 * Thread-2 在路上耗时2秒</span><br><span class="line">	 * Thread-1 到达车站了</span><br><span class="line">	 * Thread-0 在路上耗时3秒</span><br><span class="line">	 * Thread-2 到达车站了</span><br><span class="line">	 * Thread-0 到达车站了</span><br><span class="line">	 * 老司机，发车</span><br><span class="line">	 */</span><br><span class="line">	CyclicBarrier cyclicBarrier = new CyclicBarrier(3, ()-&gt;&#123;</span><br><span class="line">		System.out.println(&quot;老司机，发车&quot;);</span><br><span class="line">	&#125;);</span><br><span class="line">	Random random = new Random();</span><br><span class="line">	for (int i = 0; i &lt; 3; i++) &#123;</span><br><span class="line">		new Thread(() -&gt; &#123;</span><br><span class="line">			//返回[0,5)的值</span><br><span class="line">			int time = random.nextInt(5);</span><br><span class="line">			System.out.println(Thread.currentThread().getName() + &quot; 在路上耗时&quot; + time + &quot;秒&quot;);</span><br><span class="line">			TimeUnit.SECONDS.sleep(time);</span><br><span class="line">			System.out.println(Thread.currentThread().getName() + &quot; 到达车站了&quot;);</span><br><span class="line">			cyclicBarrier.await();</span><br><span class="line">		&#125;).start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>CountDownLatch 的计数器只能使用一次，而 CyclicBarrier 的计数器可以使用 reset() 方法重置。挺简单的就不再演示。因为这 2 个工具类都用到了 AQS，而 AQS 的原理很长，因此在本文就不介绍 AQS 的实现了</p>
<h3 id="CompletableFuture"><a href="#CompletableFuture" class="headerlink" title="CompletableFuture"></a>CompletableFuture</h3><p>去掉try catch版本</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    /**</span><br><span class="line">     * ForkJoinPool.commonPool-worker-1 在路上耗时4秒</span><br><span class="line">     * ForkJoinPool.commonPool-worker-2 在路上耗时3秒</span><br><span class="line">     * ForkJoinPool.commonPool-worker-1 到达车站了</span><br><span class="line">     * ForkJoinPool.commonPool-worker-2 到达车站了</span><br><span class="line">     * 老司机，发车</span><br><span class="line">     */</span><br><span class="line">    Random random = new Random();</span><br><span class="line">    CompletableFuture future1 = CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">        int time = random.nextInt(5);</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot; 在路上耗时&quot; + time + &quot;秒&quot;);</span><br><span class="line">        TimeUnit.SECONDS.sleep(random.nextInt());</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot; 到达车站了&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">    CompletableFuture future2 = CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">        int time = random.nextInt(5);</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot; 在路上耗时&quot; + time + &quot;秒&quot;);</span><br><span class="line">        TimeUnit.SECONDS.sleep(random.nextInt());</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot; 到达车站了&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">    CompletableFuture.allOf(future1, future2).thenRun(() -&gt; &#123;</span><br><span class="line">        System.out.println(&quot;老司机，发车&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wetts.github.io/2021/02/11/%E8%AF%AD%E8%A8%80/Java/basic_Java/API/%E5%B9%B6%E5%8F%91/%E5%85%B6%E4%BB%96/Java-%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2%E5%9B%BE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Zhang Wetts">
      <meta itemprop="description" content="Stay Hungry, Stay Foolish. <br><br><p style="font-size:8px;">[build by hexo/next/gitalk/hexo-generator-search/LaTeX]</p>">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wetts's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/11/%E8%AF%AD%E8%A8%80/Java/basic_Java/API/%E5%B9%B6%E5%8F%91/%E5%85%B6%E4%BB%96/Java-%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2%E5%9B%BE/" class="post-title-link" itemprop="url">Java-多线程-线程状态转换图.md</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-02-11 15:23:36" itemprop="dateCreated datePublished" datetime="2021-02-11T15:23:36+08:00">2021-02-11</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>转自：<a target="_blank" rel="noopener" href="https://blog.csdn.net/zzti_erlie/article/details/95242525">https://blog.csdn.net/zzti_erlie/article/details/95242525</a></p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>简易的线程状态如下图<br><img src="/2021/02/11/%E8%AF%AD%E8%A8%80/Java/basic_Java/API/%E5%B9%B6%E5%8F%91/%E5%85%B6%E4%BB%96/Java-%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2%E5%9B%BE/1.png" alt="1"></p>
<p>Java Thread线程内部有一个枚举内部类State，定义了Java语言线程状态的枚举值</p>
<ul>
<li>NEW（初始化状态）</li>
<li>RUNNABLE （可运行/运行状态）</li>
<li>BLOCKED（阻塞状态）</li>
<li>WAITING （无时限等待）</li>
<li>TIMED_WAITING（有时限等待）</li>
<li>TERMINATED（终止状态）</li>
</ul>
<p>Java 将操作系统层面的阻塞状态细分为 BLOCK，WAITING，TIMED_WAITING 三种状态</p>
<p><strong>NEW：新建状态，线程被创建但未启动的状态</strong>。创建线程有三种方式</p>
<ul>
<li>继承Thread类</li>
<li>实现Runnable接口</li>
<li>实现Callable接口</li>
</ul>
<p>我们最常用的是通过实现接口这种方式，Runnable 和 Callable 接口的区别如下</p>
<ul>
<li>Runnable 无法获取返回值，而 Callable 可以获取返回值</li>
<li>Runnable 无法抛出异常，而 Callable可以抛出异常</li>
</ul>
<p><strong>RUNNABLE（就绪状态）：调用start之后运行之前的状态</strong><br><strong>RUNNING（运行状态）：线程正在运行</strong><br><strong>BLOCKED（阻塞状态）：进入以下状态，有以下几种情况</strong></p>
<ul>
<li>BLOCK（同步阻塞）：锁被其他线程占用，如等待进入 synchronized 方法或者代码块</li>
<li>WAITING（主动阻塞）：执行Object.wait()，Thread.join() 等</li>
<li>TIMED_WAITING（等待阻塞）：执行 Object.wait(long)，Thread.sleep(long) 等</li>
</ul>
<p><strong>DEAD（终止状态）：线程执行完毕</strong></p>
<p>最后将各种方法补充到线程状态图上<br><img src="/2021/02/11/%E8%AF%AD%E8%A8%80/Java/basic_Java/API/%E5%B9%B6%E5%8F%91/%E5%85%B6%E4%BB%96/Java-%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2%E5%9B%BE/2.png" alt="2"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wetts.github.io/2021/02/11/%E8%AF%AD%E8%A8%80/Java/basic_Java/API/%E5%B9%B6%E5%8F%91/%E5%85%B6%E4%BB%96/Java-%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E4%B8%80%E7%9B%B4%E5%BE%80%E7%BA%BF%E7%A8%8B%E6%B1%A0%E9%87%8C%E9%9D%A2%E6%94%BE%E4%BB%BB%E5%8A%A1%EF%BC%8C%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Zhang Wetts">
      <meta itemprop="description" content="Stay Hungry, Stay Foolish. <br><br><p style="font-size:8px;">[build by hexo/next/gitalk/hexo-generator-search/LaTeX]</p>">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wetts's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/11/%E8%AF%AD%E8%A8%80/Java/basic_Java/API/%E5%B9%B6%E5%8F%91/%E5%85%B6%E4%BB%96/Java-%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E4%B8%80%E7%9B%B4%E5%BE%80%E7%BA%BF%E7%A8%8B%E6%B1%A0%E9%87%8C%E9%9D%A2%E6%94%BE%E4%BB%BB%E5%8A%A1%EF%BC%8C%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88/" class="post-title-link" itemprop="url">Java-多线程-一直往线程池里面放任务，会发生什么.md</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-02-11 15:15:36" itemprop="dateCreated datePublished" datetime="2021-02-11T15:15:36+08:00">2021-02-11</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>转自：<a target="_blank" rel="noopener" href="https://blog.csdn.net/zzti_erlie/article/details/108552109">https://blog.csdn.net/zzti_erlie/article/details/108552109</a></p>
<h2 id="线程池的各种参数"><a href="#线程池的各种参数" class="headerlink" title="线程池的各种参数"></a>线程池的各种参数</h2><p>面试的时候最常问的就是线程池的各种参数的含义，和线程池的整个运行流程，这个一定要会</p>
<p>ThreadPoolExecutor 一 共有 4 个构造函数，但最后调用的都是如下构造函数</p>
<p>|参数｜含义｜<br>|—-|—-|<br>|corePoolSize|核心线程池大小|<br>|maximumPoolSize|线程池最大容量大小|<br>|keepAliveTime|线程池空闲时，线程存活的时间|<br>|TimeUnit|线程活动保持时间的单位|<br>|<code>BlockingQueue&lt;Runnable&gt;</code>|任务队列，用于保存等待执行的任务的阻塞队列|<br>|ThreadFactory|用于设置线程的工厂|<br>|RejectedExecutionHandler|饱和策略|</p>
<p>来类比学习一下这些参数，我们把线程池类比为项目组，线程是这个公司的成员</p>
<ul>
<li>corePoolSize：线程池中最少的线程数，一个项目组总得有 corePoolSize 人坚守阵地，都是签订劳动合同了，不能随便撤。</li>
<li>maximumPoolSize：当项目很忙时，就得加人，请其他项目组的人来帮忙。但是公司空间有限，最多只能加到 maximumPoolSize 个人。当项目闲了，就得撤人了，最多能撤到 corePoolSize 个人</li>
<li>keepAliveTime &amp; unit：上面提到项目根据忙闲来增减人员，那在编程世界里，如何定义忙和闲呢？如果一个线程在 keepAliveTime（时间数字）* unit（时间单位）时间内都没有执行任务，说明这个线程很闲。如果此时线程数大于 corePoolSize，这个线程就要被回收了</li>
<li>workQueue：就是任务队列</li>
<li>threadFactory：自定义如果创建线程，例如给线程指定一个有意义的名字</li>
<li>handler：workQueue满了（排期满了），再提交任务，该怎么处理呢？这个就是处理策略，线程池提供了4种策略，你也可以实现RejectedExecutionHandler接口来自定义策略</li>
</ul>
<table>
<thead>
<tr>
<th>类</th>
<th>策略</th>
</tr>
</thead>
<tbody><tr>
<td>AbortPolicy</td>
<td>丢弃任务，抛运行时异常（默认的处理策略）</td>
</tr>
<tr>
<td>CallerRunsPolicy</td>
<td>执行任务</td>
</tr>
<tr>
<td>DiscardPolicy</td>
<td>忽视，什么都不会发生</td>
</tr>
<tr>
<td>DiscardOldestPolicy</td>
<td>丢弃队列里最近的一个任务，并执行当前任务</td>
</tr>
</tbody></table>
<h2 id="线程池的工作流程"><a href="#线程池的工作流程" class="headerlink" title="线程池的工作流程"></a>线程池的工作流程</h2><p>可以参照一下源码理解一下下面的流程</p>
<ol>
<li>线程池刚创建时，里面没有一个线程。任务队列是作为参数传进来的。不过，就算队列里面有任务，线程池也不会马上执行他们。</li>
<li>当调用 execute() 方法添加一个任务时，线程池会做如下判断：<ol>
<li>如果正在运行的线程数量小于 corePoolSize，那么马上创建线程运行这个任务</li>
<li>如果正在运行的线程数量大于或等于 corePoolSize，那么将这个任务放入队列</li>
<li>如果这时候队列满了，而且正在运行的线程数量小于 maximunPoolSize，那么还是要创建非核心线程立刻运行这个任务</li>
<li>如果队列满了，而且正在运行的线程数量大于或等于 maximunPoolSize，那么线程池会抛出 RejectedExecutionException</li>
</ol>
</li>
<li>当一个线程完成任务时，它会从队列中取下一个任务来执行</li>
<li>当一个线程无事可做，超过一定的时间（keepAliveTime）时，线程池会判断，如果当前运行的线程数大于 corePoolSize，那么这个线程就被停掉。所以线程池的所有任务完成后，它最终会收缩到 corePoolSize 的大小</li>
</ol>
<p>可以用如下图来表示整体流程<br><img src="/2021/02/11/%E8%AF%AD%E8%A8%80/Java/basic_Java/API/%E5%B9%B6%E5%8F%91/%E5%85%B6%E4%BB%96/Java-%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E4%B8%80%E7%9B%B4%E5%BE%80%E7%BA%BF%E7%A8%8B%E6%B1%A0%E9%87%8C%E9%9D%A2%E6%94%BE%E4%BB%BB%E5%8A%A1%EF%BC%8C%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88/1.png" alt="1"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wetts.github.io/2020/10/19/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis-%E5%8E%9F%E7%90%86-%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Zhang Wetts">
      <meta itemprop="description" content="Stay Hungry, Stay Foolish. <br><br><p style="font-size:8px;">[build by hexo/next/gitalk/hexo-generator-search/LaTeX]</p>">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wetts's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/10/19/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis-%E5%8E%9F%E7%90%86-%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5/" class="post-title-link" itemprop="url">Redis-原理-内存淘汰策略.md</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-10-19 13:29:06" itemprop="dateCreated datePublished" datetime="2020-10-19T13:29:06+08:00">2020-10-19</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Redis/" itemprop="url" rel="index"><span itemprop="name">Redis</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>转自：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/105587132">https://zhuanlan.zhihu.com/p/105587132</a></p>
<h2 id="过期策略"><a href="#过期策略" class="headerlink" title="过期策略"></a>过期策略</h2><h3 id="定期删除"><a href="#定期删除" class="headerlink" title="定期删除"></a>定期删除</h3><p>redis 会将每个设置了过期时间的 key 放入到一个独立的字典中，以后会定期遍历这个字典来删除到期的 key。</p>
<p>Redis 默认会每秒进行十次过期扫描（100ms 一次），过期扫描不会遍历过期字典中所有的 key，而是采用了一种简单的贪心策略。</p>
<ol>
<li>从过期字典中随机 20 个 key；</li>
<li>删除这 20 个 key 中已经过期的 key；</li>
<li>如果过期的 key 比率超过 1/4，那就重复步骤 1；</li>
</ol>
<p>redis 默认是每隔 100ms 就随机抽取一些设置了过期时间的 key，检查其是否过期，如果过期就删除。注意这里是随机抽取的。为什么要随机呢？你想一想假如 redis 存了几十万个 key ，每隔 100ms 就遍历所有的设置过期时间的 key 的话，就会给 CPU 带来很大的负载。</p>
<h3 id="惰性删除"><a href="#惰性删除" class="headerlink" title="惰性删除"></a>惰性删除</h3><p>所谓惰性策略就是在客户端访问这个 key 的时候，redis 对 key 的过期时间进行检查，如果过期了就立即删除，不会给你返回任何东西。</p>
<p>定期删除可能会导致很多过期 key 到了时间并没有被删除掉。所以就有了惰性删除。假如你的过期 key，靠定期删除没有被删除掉，还停留在内存里，除非你的系统去查一下那个 key，才会被 redis 给删除掉。这就是所谓的惰性删除，即当你主动去查过期的 key 时，如果发现 key 过期了，就立即进行删除，不返回任何东西。</p>
<p>总结：定期删除是集中处理，惰性删除是零散处理。</p>
<h2 id="为什么需要淘汰策略"><a href="#为什么需要淘汰策略" class="headerlink" title="为什么需要淘汰策略"></a>为什么需要淘汰策略</h2><p>有了以上过期策略的说明后，就很容易理解为什么需要淘汰策略了，因为不管是定期采样删除还是惰性删除都不是一种完全精准的删除，就还是会存在 key 没有被删除掉的场景，所以就需要内存淘汰策略进行补充。</p>
<p>内存淘汰策略</p>
<ol>
<li>noeviction：当内存使用超过配置的时候会返回错误，不会驱逐任何键</li>
<li>allkeys-lru：加入键的时候，如果过限，首先通过 LRU 算法驱逐最久没有使用的键</li>
<li>volatile-lru：加入键的时候如果过限，首先从设置了过期时间的键集合中驱逐最久没有使用的键</li>
<li>allkeys-random：加入键的时候如果过限，从所有 key 随机删除</li>
<li>volatile-random：加入键的时候如果过限，从过期键的集合中随机驱逐</li>
<li>volatile-ttl：从配置了过期时间的键中驱逐马上就要过期的键</li>
<li>volatile-lfu：从所有配置了过期时间的键中驱逐使用频率最少的键</li>
<li>allkeys-lfu：从所有键中驱逐使用频率最少的键</li>
</ol>
<h2 id="LRU"><a href="#LRU" class="headerlink" title="LRU"></a>LRU</h2><h3 id="标准-LRU-实现方式"><a href="#标准-LRU-实现方式" class="headerlink" title="标准 LRU 实现方式"></a>标准 LRU 实现方式</h3><p><img src="/2020/10/19/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis-%E5%8E%9F%E7%90%86-%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5/1.jpg" alt="1"></p>
<ol>
<li>新增 key value 的时候首先在链表结尾添加 Node 节点，如果超过 LRU 设置的阈值就淘汰队头的节点并删除掉 HashMap 中对应的节点。</li>
<li>修改 key 对应的值的时候先修改对应的 Node 中的值，然后把 Node 节点移动队尾。</li>
<li>访问 key 对应的值的时候把访问的 Node 节点移动到队尾即可。</li>
</ol>
<h3 id="Redis-的-LRU-实现"><a href="#Redis-的-LRU-实现" class="headerlink" title="Redis 的 LRU 实现"></a>Redis 的 LRU 实现</h3><p>Redis 维护了一个 24 位时钟，可以简单理解为当前系统的时间戳，每隔一定时间会更新这个时钟。每个 key 对象内部同样维护了一个 24 位的时钟，当新增 key 对象的时候会把系统的时钟赋值到这个内部对象时钟。比如我现在要进行 LRU，那么首先拿到当前的全局时钟，然后再找到内部时钟与全局时钟距离时间最久的（差最大）进行淘汰，这里值得注意的是全局时钟只有 24 位，按秒为单位来表示才能存储 194 天，所以可能会出现 key 的时钟大于全局时钟的情况，如果这种情况出现那么就两个相加而不是相减来求最久的 key。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">struct redisServer &#123;</span><br><span class="line">       pid_t pid; </span><br><span class="line">       char *configfile; </span><br><span class="line">       //全局时钟</span><br><span class="line">       unsigned lruclock:LRU_BITS; </span><br><span class="line">       ...</span><br><span class="line">&#125;;</span><br><span class="line">typedef struct redisObject &#123;</span><br><span class="line">    unsigned type:4;</span><br><span class="line">    unsigned encoding:4;</span><br><span class="line">    /* key对象内部时钟 */</span><br><span class="line">    unsigned lru:LRU_BITS;</span><br><span class="line">    int refcount;</span><br><span class="line">    void *ptr;</span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure>

<p>Redis 中的 LRU 与常规的 LRU 实现并不相同，常规 LRU 会准确的淘汰掉队头的元素，但是 Redis 的 LRU 并不维护队列，只是根据配置的策略要么从所有的 key 中随机选择 N 个（N 可以配置）要么从所有的设置了过期时间的 key 中选出 N 个键，然后再从这 N 个键中选出最久没有使用的一个 key 进行淘汰。</p>
<p>下图是常规 LRU 淘汰策略与 Redis 随机样本取一键淘汰策略的对比，浅灰色表示已经删除的键，深灰色表示没有被删除的键，绿色表示新加入的键，越往上表示键加入的时间越久。从图中可以看出，在 redis 3 中，设置样本数为 10 的时候能够很准确的淘汰掉最久没有使用的键，与常规 LRU 基本持平。</p>
<p><img src="/2020/10/19/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis-%E5%8E%9F%E7%90%86-%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5/2.jpg" alt="2"></p>
<h3 id="为什么要使用近似-LRU？"><a href="#为什么要使用近似-LRU？" class="headerlink" title="为什么要使用近似 LRU？"></a>为什么要使用近似 LRU？</h3><ol>
<li>性能问题，由于近似 LRU 算法只是最多随机采样 N 个 key 并对其进行排序，如果精准需要对所有 key 进行排序，这样近似 LRU 性能更高</li>
<li>内存占用问题，redis 对内存要求很高，会尽量降低内存使用率，如果是抽样排序可以有效降低内存的占用</li>
<li>实际效果基本相等，如果请求符合长尾法则，那么真实 LRU 与 Redis LRU 之间表现基本无差异</li>
<li>在近似情况下提供可自配置的取样率来提升精准度，例如通过 <code>CONFIG SET maxmemory-samples &lt;count&gt;</code> 指令可以设置取样数，取样数越高越精准，如果你的 CPU 和内存有足够，可以提高取样数看命中率来探测最佳的采样比例。</li>
</ol>
<h2 id="LFU"><a href="#LFU" class="headerlink" title="LFU"></a>LFU</h2><p>LFU 是在 Redis4.0 后出现的，LRU 的最近最少使用实际上并不精确，考虑下面的情况，如果在|处删除，那么 A 距离的时间最久，但实际上 A 的使用频率要比 B 频繁，所以合理的淘汰策略应该是淘汰 B。LFU 就是为应对这种情况而生的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A~~A~~A~~A~~A~~A~~A~~A~~A~~A~~~|</span><br><span class="line"></span><br><span class="line">B~~~~~B~~~~~B~~~~~B~~~~~~~~~~~~B|</span><br></pre></td></tr></table></figure>
<p>LFU 把原来的 key 对象的内部时钟的 24 位分成两部分，前 16 位还代表时钟，后 8 位代表一个计数器。16 位的情况下如果还按照秒为单位就会导致不够用，所以一般这里以时钟为单位。而后 8 位表示当前 key 对象的访问频率，8 位只能代表 255，但是 redis 并没有采用线性上升的方式，而是通过一个复杂的公式，通过配置如下两个参数来调整数据的递增速度。</p>
<ul>
<li>lfu-log-factor 可以调整计数器 counter 的增长速度，lfu-log-factor 越大，counter 增长的越慢。</li>
<li>lfu-decay-time 是一个以分钟为单位的数值，可以调整 counter 的减少速度。</li>
</ul>
<p>所以这两个因素就对应到了 LFU 的 Counter 减少策略和增长策略，它们实现逻辑分别如下。</p>
<h3 id="降低-LFUDecrAndReturn"><a href="#降低-LFUDecrAndReturn" class="headerlink" title="降低 LFUDecrAndReturn"></a>降低 LFUDecrAndReturn</h3><ol>
<li>先从高 16 位获取最近的降低时间 ldt 以及低 8 位的计数器 counter 值</li>
<li>计算当前时间 now 与 ldt 的差值（now-ldt），当 ldt 大于 now 时，那说明是过了一个周期，按照 65535-ldt+now 计算（16 位一个周期最大 65535）</li>
<li>使用第 2 步计算的差值除以 lfu_decay_time，即 <code>LFUTimeElapsed(ldt) / server.lfu_decay_time</code>，已过去 n 个 lfu_decay_time，则将 counter 减少 n。</li>
</ol>
<h3 id="增长-LFULogIncr"><a href="#增长-LFULogIncr" class="headerlink" title="增长 LFULogIncr"></a>增长 LFULogIncr</h3><ol>
<li>获取 0-1 的随机数 r</li>
<li>计算 0-1 之间的控制因子 p，它的计算逻辑如下<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//LFU_INIT_VAL默认为5</span><br><span class="line">baseval = counter - LFU_INIT_VAL;</span><br><span class="line">//计算控制因子</span><br><span class="line">p = 1.0/(baseval*lfu_log_factor+1);</span><br></pre></td></tr></table></figure></li>
<li>如果 r 小于 p，counter 增长 1</li>
</ol>
<p>p 取决于当前 counter 值与 lfu_log_factor 因子，counter 值与 lfu_log_factor 因子越大，p 越小，r 小于 p 的概率也越小，counter 增长的概率也就越小。增长情况如下图：<br><img src="/2020/10/19/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis-%E5%8E%9F%E7%90%86-%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5/3.jpg" alt="3"></p>
<p>从左到右表示 key 的命中次数，从上到下表示影响因子，在影响因子为 100 的条件下，经过 10M 次命中才能把后 8 位值加满到 255.</p>
<h3 id="新生-KEY-策略"><a href="#新生-KEY-策略" class="headerlink" title="新生 KEY 策略"></a>新生 KEY 策略</h3><p>另外一个问题是，当创建新对象的时候，对象的 counter 如果为 0，很容易就会被淘汰掉，还需要为新生 key 设置一个初始 counter。counter 会被初始化为 LFU_INIT_VAL，默认 5。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wetts.github.io/2020/10/18/%E5%B7%A5%E7%A8%8B/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81-%E5%9F%BA%E4%BA%8Eredis%E7%9A%84setnx()%E3%80%81get()%E3%80%81getset()%E6%96%B9%E6%B3%95%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Zhang Wetts">
      <meta itemprop="description" content="Stay Hungry, Stay Foolish. <br><br><p style="font-size:8px;">[build by hexo/next/gitalk/hexo-generator-search/LaTeX]</p>">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wetts's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/10/18/%E5%B7%A5%E7%A8%8B/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81-%E5%9F%BA%E4%BA%8Eredis%E7%9A%84setnx()%E3%80%81get()%E3%80%81getset()%E6%96%B9%E6%B3%95%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/" class="post-title-link" itemprop="url">分布式锁-基于redis的setnx()、get()、getset()方法分布式锁.md</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-10-18 17:04:10" itemprop="dateCreated datePublished" datetime="2020-10-18T17:04:10+08:00">2020-10-18</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/" itemprop="url" rel="index"><span itemprop="name">分布式</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>转自：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/changemax/p/12311520.html">https://www.cnblogs.com/changemax/p/12311520.html</a></p>
<h2 id="redis-命令讲解："><a href="#redis-命令讲解：" class="headerlink" title="redis 命令讲解："></a>redis 命令讲解：</h2><h3 id="setex-命令："><a href="#setex-命令：" class="headerlink" title="setex()命令："></a>setex()命令：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SETEX key seconds value</span><br><span class="line"></span><br><span class="line">将值 value 关联到 key ，并将 key 的生存时间设为 seconds (以秒为单位)。</span><br><span class="line"></span><br><span class="line">如果 key 已经存在， SETEX 命令将覆写旧值。</span><br></pre></td></tr></table></figure>

<p>这个命令类似于以下两个命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SET key value</span><br><span class="line">EXPIRE key seconds  # 设置生存时间</span><br></pre></td></tr></table></figure>

<p>不同之处是， SETEX 是一个原子性(atomic)操作，关联值和设置生存时间两个动作会在同一时间内完成，该命令在 Redis 用作缓存时，非常实用。</p>
<ul>
<li>可用版本：<code>&gt;= 2.0.0</code></li>
<li>时间复杂度：$O(1)$</li>
<li>返回值：<ul>
<li>设置成功时返回 OK 。</li>
<li>当 seconds 参数不合法时，返回一个错误。</li>
</ul>
</li>
</ul>
<h3 id="setnx-命令："><a href="#setnx-命令：" class="headerlink" title="setnx()命令："></a>setnx()命令：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SETNX key value</span><br><span class="line"></span><br><span class="line">将 key 的值设为 value ，当且仅当 key 不存在。</span><br><span class="line"></span><br><span class="line">若给定的 key 已经存在，则 SETNX 不做任何动作。</span><br></pre></td></tr></table></figure>
<p>SETNX 是『SET if Not eXists』(如果不存在，则 SET)的简写。</p>
<ul>
<li>可用版本：<code>&gt;= 1.0.0</code></li>
<li>时间复杂度：$O(1)$</li>
<li>返回值：<ul>
<li>设置成功，返回 1 。</li>
<li>设置失败，返回 0 。</li>
</ul>
</li>
</ul>
<h3 id="get-命令："><a href="#get-命令：" class="headerlink" title="get()命令："></a>get()命令：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">GET key</span><br><span class="line"></span><br><span class="line">返回 key 所关联的字符串值。</span><br><span class="line"></span><br><span class="line">如果 key 不存在那么返回特殊值 nil 。</span><br><span class="line"></span><br><span class="line">假如 key 储存的值不是字符串类型，返回一个错误，因为 GET 只能用于处理字符串值。</span><br></pre></td></tr></table></figure>

<ul>
<li>可用版本：<code>&gt;= 1.0.0</code></li>
<li>时间复杂度：$O(1)$</li>
<li>返回值：<ul>
<li>当 key 不存在时，返回 nil ，否则，返回 key 的值。</li>
<li>如果 key 不是字符串类型，那么返回一个错误。</li>
</ul>
</li>
</ul>
<h3 id="getset-命令："><a href="#getset-命令：" class="headerlink" title="getset()命令："></a>getset()命令：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GETSET key value</span><br><span class="line"></span><br><span class="line">将给定 key 的值设为 value ，并返回 key 的旧值(old value)。</span><br><span class="line"></span><br><span class="line">当 key 存在但不是字符串类型时，返回一个错误。</span><br></pre></td></tr></table></figure>

<ul>
<li>可用版本：<code>&gt;= 1.0.0</code></li>
<li>时间复杂度：$O(1)$</li>
<li>返回值：<ul>
<li>返回给定 key 的旧值。</li>
<li>当 key 没有旧值时，也即是， key 不存在时，返回 nil 。</li>
</ul>
</li>
</ul>
<h2 id="具体的使用步骤如下："><a href="#具体的使用步骤如下：" class="headerlink" title="具体的使用步骤如下："></a>具体的使用步骤如下：</h2><ol>
<li>setnx(lockkey, 当前时间+过期超时时间) ，如果返回 1，则获取锁成功；如果返回 0 则没有获取到锁，转向 2。</li>
<li>get(lockkey) 获取值 oldExpireTime ，并将这个 value 值与当前的系统时间进行比较，如果小于当前系统时间，则认为这个锁已经超时，可以允许别的请求重新获取，转向 3。</li>
<li>计算 newExpireTime=当前时间+过期超时时间，然后 getset(lockkey, newExpireTime) 会返回当前 lockkey 的值 currentExpireTime。</li>
<li>判断 currentExpireTime 与 oldExpireTime 是否相等，如果相等，说明当前 getset 设置成功，获取到了锁。如果不相等，说明这个锁又被别的请求获取走了，那么当前请求可以直接返回失败，或者继续重试。</li>
<li>在获取到锁之后，当前线程可以开始自己的业务处理，当处理完毕后，比较自己的处理时间和对于锁设置的超时时间，如果小于锁设置的超时时间，则直接执行 delete 释放锁；如果大于锁设置的超时时间，则不需要再锁进行处理。 </li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wetts.github.io/2020/06/29/artificial_intelligence/%E6%9C%80%E4%BC%98%E8%A7%A3%E7%AE%97%E6%B3%95/BeanSearch/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Zhang Wetts">
      <meta itemprop="description" content="Stay Hungry, Stay Foolish. <br><br><p style="font-size:8px;">[build by hexo/next/gitalk/hexo-generator-search/LaTeX]</p>">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wetts's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/29/artificial_intelligence/%E6%9C%80%E4%BC%98%E8%A7%A3%E7%AE%97%E6%B3%95/BeanSearch/" class="post-title-link" itemprop="url">BeanSearch.md</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-06-29 16:34:09" itemprop="dateCreated datePublished" datetime="2020-06-29T16:34:09+08:00">2020-06-29</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>使用一个模型来进行机器翻译时，并不是从得到的分布中进行随机取样，而是你要找到一个句子，使得条件概率最大化。</p>
<p>贪心搜索是一种来自计算机科学的算法，生成第一个词的分布以后，它将会根据你的条件语言模型挑选出最有可能的第一个词进入你的机器翻译模型中，在挑选出第一个词之后它将会继续挑选出最有可能的第二个词，然后继续挑选第三个最有可能的词，这种算法就叫做贪心搜索。这种方法得到的有可能是局部最优解，而不是全局最优解。</p>
<p>然而全排列所有组合，由于排列数量过于巨大，也没有可行性。</p>
<p>集束搜索（beam search）算法可以应用到寻找全局最优解上。</p>
<h3 id="集束搜索（Beam-Search）"><a href="#集束搜索（Beam-Search）" class="headerlink" title="集束搜索（Beam Search）"></a>集束搜索（Beam Search）</h3><p>贪婪算法只会挑出最可能的那一个单词，然后继续。而集束搜索则会考虑多个选择，集束搜索算法会有一个参数 B，叫做集束宽（beam width）。例如：把这个集束宽设成 3，这样就意味着集束搜索不会只考虑一个可能结果，而是一次会考虑 3 个。</p>
<p><img src="/2020/06/29/artificial_intelligence/%E6%9C%80%E4%BC%98%E8%A7%A3%E7%AE%97%E6%B3%95/BeanSearch/BeamSearch1.png" alt="BeamSearch1"></p>
<p><img src="/2020/06/29/artificial_intelligence/%E6%9C%80%E4%BC%98%E8%A7%A3%E7%AE%97%E6%B3%95/BeanSearch/BeamSearch2.png" alt="BeamSearch2"></p>
<p><img src="/2020/06/29/artificial_intelligence/%E6%9C%80%E4%BC%98%E8%A7%A3%E7%AE%97%E6%B3%95/BeanSearch/BeamSearch3.png" alt="BeamSearch3"></p>
<p><img src="/2020/06/29/artificial_intelligence/%E6%9C%80%E4%BC%98%E8%A7%A3%E7%AE%97%E6%B3%95/BeanSearch/BeamSearch4.png" alt="BeamSearch4"></p>
<h3 id="Beam-Search-改进"><a href="#Beam-Search-改进" class="headerlink" title="Beam Search 改进"></a>Beam Search 改进</h3><p>概率公式可表示为：$P(y^{&lt;1&gt;}|X)$ $P(y^{&lt; 2 &gt;}|X,y^{&lt; 1 &gt;})$ $P(y^{&lt; 3 &gt;}|X,y^{&lt; 1 &gt;},y^{&lt; 2&gt;})$…$P(y^{&lt; T_{y} &gt;}|X,y^{&lt;1 &gt;},y^{&lt;2 &gt;}\ldots y^{&lt; T_{y} - 1 &gt;})$。</p>
<p>这些概率值都是小于 1 的，通常远小于 1。很多小于 1 的数乘起来，会得到很小很小的数字，会造成数值下溢（<strong>numerical underflow</strong>）。数值下溢就是数值太小了，导致电脑的浮点表示不能精确地储存，因此在实践中,我们不会最大化这个乘积，而是取 $log$ 值。如果在这加上一个 $log$，最大化这个 $log$ 求和的概率值，在选择最可能的句子 $y$ 时，你会得到同样的结果。</p>
<p>如果参照原来的目标函数（<strong>this original objective</strong>），如果有一个很长的句子，那么这个句子的概率会很低，因为乘了很多项小于 1 的数字来估计句子的概率。所以如果乘起来很多小于 1 的数字，那么就会得到一个更小的概率值，所以这个目标函数有一个缺点，它可能不自然地倾向于简短的翻译结果，它更偏向短的输出，因为短句子的概率是由更少数量的小于 1 的数字乘积得到的，所以这个乘积不会那么小。顺便说一下，这里也有同样的问题，概率的 $log$ 值通常小于等于 1，实际上在 $log$ 的这个范围内，所以加起来的项越多，得到的结果越负，所以对这个算法另一个改变也可以使它表现的更好，也就是我们不再最大化这个目标函数了，我们可以把它归一化，通过除以翻译结果的单词数量（<strong>normalize this by the number of words in your translation</strong>）。这样就是取每个单词的概率对数值的平均了，这样很明显地减少了对输出长的结果的惩罚（**this significantly reduces the penalty for outputting longer translations.**）。</p>
<p>在实践中，有个探索性的方法，相比于直接除 $T_{y}$，也就是输出句子的单词总数，我们有时会用一个更柔和的方法（<strong>a softer approach</strong>），在 $T_{y}$ 上加上指数 $a$，$a$ 可以等于 0.7。如果 $a$ 等于 1，就相当于完全用长度来归一化，如果 $a$ 等于 0，$T_{y}$ 的 0 次幂就是 1，就相当于完全没有归一化，这就是在完全归一化和没有归一化之间。$a$ 就是算法另一个超参数（<strong>hyper parameter</strong>），需要调整大小来得到最好的结果。</p>
<h3 id="Beam-Search-误差分析"><a href="#Beam-Search-误差分析" class="headerlink" title="Beam Search 误差分析"></a>Beam Search 误差分析</h3><p><img src="/2020/06/29/artificial_intelligence/%E6%9C%80%E4%BC%98%E8%A7%A3%E7%AE%97%E6%B3%95/BeanSearch/BeamSearch%E8%AF%AF%E5%B7%AE%E5%88%86%E6%9E%901.png" alt="BeamSearch误差分析1"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wetts.github.io/2020/06/23/%E8%AF%AD%E8%A8%80/Python/%E7%8E%AF%E5%A2%83/Python-%E6%96%87%E4%BB%B6%E6%9C%8D%E5%8A%A1%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Zhang Wetts">
      <meta itemprop="description" content="Stay Hungry, Stay Foolish. <br><br><p style="font-size:8px;">[build by hexo/next/gitalk/hexo-generator-search/LaTeX]</p>">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wetts's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/23/%E8%AF%AD%E8%A8%80/Python/%E7%8E%AF%E5%A2%83/Python-%E6%96%87%E4%BB%B6%E6%9C%8D%E5%8A%A1%E5%99%A8/" class="post-title-link" itemprop="url">Python-文件服务器.md</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-06-23 11:22:12" itemprop="dateCreated datePublished" datetime="2020-06-23T11:22:12+08:00">2020-06-23</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Python/" itemprop="url" rel="index"><span itemprop="name">Python</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h3><ul>
<li>Python2: <code>python -m SimpleHTTPServer 2019</code></li>
<li>Python3: <code>python3 -m http.server 2019</code></li>
</ul>
<h3 id="FTP"><a href="#FTP" class="headerlink" title="FTP"></a>FTP</h3><p>首先是安装这个模块</p>
<ul>
<li>python2: <code>pip install pyftpdlib</code></li>
<li>python3: <code>pip3 install pyftpdlib</code></li>
</ul>
<p>启动</p>
<ul>
<li>python2: <code>python -m pyftpdlib -p 2019</code></li>
<li>python3: <code>python -m pyftpdlib -p 2019</code></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/69/">69</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Zhang Wetts"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">Zhang Wetts</p>
  <div class="site-description" itemprop="description">Stay Hungry, Stay Foolish. <br><br><p style="font-size:8px;">[build by hexo/next/gitalk/hexo-generator-search/LaTeX]</p></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">686</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">67</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">352</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/wetts" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;wetts" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:zhang.wetts@163.com" title="E-Mail → mailto:zhang.wetts@163.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Zhang Wetts</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

  


<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/hibiki.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"react":{"opacity":0}});</script></body>
</html>
