<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"wetts.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="Stay Hungry, Stay Foolish. [build by hexo&#x2F;next&#x2F;gitalk&#x2F;hexo-generator-search&#x2F;LaTeX]">
<meta property="og:type" content="website">
<meta property="og:title" content="Wetts&#39;s blog">
<meta property="og:url" content="https://wetts.github.io/page/2/index.html">
<meta property="og:site_name" content="Wetts&#39;s blog">
<meta property="og:description" content="Stay Hungry, Stay Foolish. [build by hexo&#x2F;next&#x2F;gitalk&#x2F;hexo-generator-search&#x2F;LaTeX]">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Zhang Wetts">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://wetts.github.io/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Wetts's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Wetts's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Stay Hungry, Stay Foolish.</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/wetts" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wetts.github.io/2021/07/10/%E8%AF%AD%E8%A8%80/Java/JVM/Java%E8%87%AA%E5%B8%A6%E7%9A%84%E8%B0%83%E4%BC%98%E5%B7%A5%E5%85%B7%EF%BC%88jps%E3%80%81jstat%E3%80%81jstack%E3%80%81jmap%E3%80%81jhat%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Zhang Wetts">
      <meta itemprop="description" content="Stay Hungry, Stay Foolish. <br><br><p style="font-size:8px;">[build by hexo/next/gitalk/hexo-generator-search/LaTeX]</p>">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wetts's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/10/%E8%AF%AD%E8%A8%80/Java/JVM/Java%E8%87%AA%E5%B8%A6%E7%9A%84%E8%B0%83%E4%BC%98%E5%B7%A5%E5%85%B7%EF%BC%88jps%E3%80%81jstat%E3%80%81jstack%E3%80%81jmap%E3%80%81jhat%EF%BC%89/" class="post-title-link" itemprop="url">Java自带的调优工具（jps、jstat、jstack、jmap、jhat）.md</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-07-10 16:26:05" itemprop="dateCreated datePublished" datetime="2021-07-10T16:26:05+08:00">2021-07-10</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>转自：<a target="_blank" rel="noopener" href="https://blog.51cto.com/superleedo/2132016%E3%80%81https://my.oschina.net/feichexia/blog/196575">https://blog.51cto.com/superleedo/2132016、https://my.oschina.net/feichexia/blog/196575</a></p>
<h3 id="jps（Java-Virtual-Machine-Process-Status-Tool）"><a href="#jps（Java-Virtual-Machine-Process-Status-Tool）" class="headerlink" title="jps（Java Virtual Machine Process Status Tool）"></a>jps（Java Virtual Machine Process Status Tool）</h3><p>用来输出 JVM 中运行的进程状态信息。语法格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jps [options] [hostid]</span><br></pre></td></tr></table></figure>
<p>如果不指定 hostid 就默认为当前主机或服务器。</p>
<p>命令行参数选项说明如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-q 不输出类名、Jar名和传入main方法的参数</span><br><span class="line">-m 输出传入main方法的参数</span><br><span class="line">-l 输出main类或Jar的全限名</span><br><span class="line">-v 输出传入JVM的参数</span><br></pre></td></tr></table></figure>

<h3 id="jstack"><a href="#jstack" class="headerlink" title="jstack"></a>jstack</h3><p>主要用来查看某个 Java 进程内的线程堆栈信息。语法格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jstack [option] pid</span><br><span class="line">jstack [option] executable core</span><br><span class="line">jstack [option] [server-id@]remote-hostname-or-ip</span><br></pre></td></tr></table></figure>

<p>命令行参数选项说明如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-l long listings，会打印出额外的锁信息，在发生死锁时可以用jstack -l pid来观察锁持有情况</span><br><span class="line">-m mixed mode，不仅会输出Java堆栈信息，还会输出C/C++堆栈信息（比如Native方法）</span><br></pre></td></tr></table></figure>

<p>jstack 可以定位到线程堆栈，根据堆栈信息我们可以定位到具体代码，所以它在 JVM 性能调优中使用得非常多。下面我们来一个实例找出某个 Java 进程中最耗费 CPU 的 Java 线程并定位堆栈信息，用到的命令有 ps、top、printf、jstack、grep。</p>
<p>第一步先找出 Java 进程 ID，我部署在服务器上的 Java 应用名称为 mrf-center：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:/# ps -ef | grep mrf-center | grep -v grep</span><br><span class="line">root     21711     1  1 14:47 pts/3    00:02:10 java -jar mrf-center.jar</span><br></pre></td></tr></table></figure>

<p>得到进程 ID 为 21711，第二步找出该进程内最耗费 CPU 的线程，可以使用 <code>ps -Lfp pid</code> 或者 <code>ps -mp pid -o THREAD, tid, time</code> 或者 <code>top -Hp pid</code>，我这里用第三个，输出如下：</p>
<p><img src="/2021/07/10/%E8%AF%AD%E8%A8%80/Java/JVM/Java%E8%87%AA%E5%B8%A6%E7%9A%84%E8%B0%83%E4%BC%98%E5%B7%A5%E5%85%B7%EF%BC%88jps%E3%80%81jstat%E3%80%81jstack%E3%80%81jmap%E3%80%81jhat%EF%BC%89/1.png" alt="1"></p>
<p> TIME 列就是各个 Java 线程耗费的 CPU 时间，CPU 时间最长的是线程 ID 为 21742 的线程，用<br> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printf &quot;%x\n&quot; 21742</span><br></pre></td></tr></table></figure><br>得到 21742 的十六进制值为 <code>54ee</code>，下面会用到。</p>
<p>OK，下一步终于轮到 jstack 上场了，它用来输出进程 21711 的堆栈信息，然后根据线程 ID 的十六进制值 grep，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:/# jstack 21711 | grep 54ee</span><br><span class="line">&quot;PollIntervalRetrySchedulerThread&quot; prio=10 tid=0x00007f950043e000 nid=0x54ee in Object.wait() [0x00007f94c6eda000]</span><br></pre></td></tr></table></figure>

<p>可以看到 CPU 消耗在 PollIntervalRetrySchedulerThread 这个类的 <code>Object.wait()</code>，我找了下我的代码，定位到下面的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// Idle wait</span><br><span class="line">getLog().info(&quot;Thread [&quot; + getName() + &quot;] is idle waiting...&quot;);</span><br><span class="line">schedulerThreadState = PollTaskSchedulerThreadState.IdleWaiting;</span><br><span class="line">long now = System.currentTimeMillis();</span><br><span class="line">long waitTime = now + getIdleWaitTime();</span><br><span class="line">long timeUntilContinue = waitTime - now;</span><br><span class="line">synchronized(sigLock) &#123;</span><br><span class="line">	try &#123;</span><br><span class="line">    	if(!halted.get()) &#123;</span><br><span class="line">    		sigLock.wait(timeUntilContinue);</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125; </span><br><span class="line">	catch (InterruptedException ignore) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它是轮询任务的空闲等待代码，上面的 <code>sigLock.wait(timeUntilContinue)</code> 就对应了前面的 <code>Object.wait()</code>。</p>
<h3 id="jmap（Memory-Map）和jhat（Java-Heap-Analysis-Tool）"><a href="#jmap（Memory-Map）和jhat（Java-Heap-Analysis-Tool）" class="headerlink" title="jmap（Memory Map）和jhat（Java Heap Analysis Tool）"></a>jmap（Memory Map）和jhat（Java Heap Analysis Tool）</h3><p>jmap 用来查看堆内存使用状况，一般结合 jhat 使用。</p>
<p>jmap 语法格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jmap [option] pid</span><br><span class="line">jmap [option] executable core</span><br><span class="line">jmap [option] [server-id@]remote-hostname-or-ip</span><br></pre></td></tr></table></figure>

<p>如果运行在 64 位 JVM 上，可能需要指定 <code>-J-d64</code> 命令选项参数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmap -permstat pid</span><br></pre></td></tr></table></figure>
<p>打印进程的类加载器和类加载器加载的持久代对象信息，输出：类加载器名称、对象是否存活（不可靠）、对象地址、父类加载器、已加载的类大小等信息，如下图：<br><img src="/2021/07/10/%E8%AF%AD%E8%A8%80/Java/JVM/Java%E8%87%AA%E5%B8%A6%E7%9A%84%E8%B0%83%E4%BC%98%E5%B7%A5%E5%85%B7%EF%BC%88jps%E3%80%81jstat%E3%80%81jstack%E3%80%81jmap%E3%80%81jhat%EF%BC%89/2.png" alt="2"></p>
<p>使用 <code>jmap -heap pid</code> 查看进程堆内存使用情况，包括使用的 GC 算法、堆配置参数和各代中堆内存使用情况。比如下面的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:/# jmap -heap 21711</span><br><span class="line">Attaching to process ID 21711, please wait...</span><br><span class="line">Debugger attached successfully.</span><br><span class="line">Server compiler detected.</span><br><span class="line">JVM version is 20.10-b01</span><br><span class="line"></span><br><span class="line">using thread-local object allocation.</span><br><span class="line">Parallel GC with 4 thread(s)</span><br><span class="line"></span><br><span class="line">Heap Configuration:</span><br><span class="line">   MinHeapFreeRatio = 40</span><br><span class="line">   MaxHeapFreeRatio = 70</span><br><span class="line">   MaxHeapSize      = 2067791872 (1972.0MB)</span><br><span class="line">   NewSize          = 1310720 (1.25MB)</span><br><span class="line">   MaxNewSize       = 17592186044415 MB</span><br><span class="line">   OldSize          = 5439488 (5.1875MB)</span><br><span class="line">   NewRatio         = 2</span><br><span class="line">   SurvivorRatio    = 8</span><br><span class="line">   PermSize         = 21757952 (20.75MB)</span><br><span class="line">   MaxPermSize      = 85983232 (82.0MB)</span><br><span class="line"></span><br><span class="line">Heap Usage:</span><br><span class="line">PS Young Generation</span><br><span class="line">Eden Space:</span><br><span class="line">   capacity = 6422528 (6.125MB)</span><br><span class="line">   used     = 5445552 (5.1932830810546875MB)</span><br><span class="line">   free     = 976976 (0.9317169189453125MB)</span><br><span class="line">   84.78829520089286% used</span><br><span class="line">From Space:</span><br><span class="line">   capacity = 131072 (0.125MB)</span><br><span class="line">   used     = 98304 (0.09375MB)</span><br><span class="line">   free     = 32768 (0.03125MB)</span><br><span class="line">   75.0% used</span><br><span class="line">To Space:</span><br><span class="line">   capacity = 131072 (0.125MB)</span><br><span class="line">   used     = 0 (0.0MB)</span><br><span class="line">   free     = 131072 (0.125MB)</span><br><span class="line">   0.0% used</span><br><span class="line">PS Old Generation</span><br><span class="line">   capacity = 35258368 (33.625MB)</span><br><span class="line">   used     = 4119544 (3.9287033081054688MB)</span><br><span class="line">   free     = 31138824 (29.69629669189453MB)</span><br><span class="line">   11.683876009235595% used</span><br><span class="line">PS Perm Generation</span><br><span class="line">   capacity = 52428800 (50.0MB)</span><br><span class="line">   used     = 26075168 (24.867218017578125MB)</span><br><span class="line">   free     = 26353632 (25.132781982421875MB)</span><br><span class="line">   49.73443603515625% used</span><br><span class="line">   ....</span><br></pre></td></tr></table></figure>

<p>使用 <code>jmap -histo[:live] pid</code> 查看堆内存中的对象数目、大小统计直方图，如果带上 live 则只统计活对象，如下：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:/# jmap -histo:live 21711 | more</span><br><span class="line"></span><br><span class="line"> num     #instances         #bytes  class name</span><br><span class="line">----------------------------------------------</span><br><span class="line">   1:         38445        5597736  &lt;constMethodKlass&gt;</span><br><span class="line">   2:         38445        5237288  &lt;methodKlass&gt;</span><br><span class="line">   3:          3500        3749504  &lt;constantPoolKlass&gt;</span><br><span class="line">   4:         60858        3242600  &lt;symbolKlass&gt;</span><br><span class="line">   5:          3500        2715264  &lt;instanceKlassKlass&gt;</span><br><span class="line">   6:          2796        2131424  &lt;constantPoolCacheKlass&gt;</span><br><span class="line">   7:          5543        1317400  [I</span><br><span class="line">   8:         13714        1010768  [C</span><br><span class="line">   9:          4752        1003344  [B</span><br><span class="line">  10:          1225         639656  &lt;methodDataKlass&gt;</span><br><span class="line">  11:         14194         454208  java.lang.String</span><br><span class="line">  12:          3809         396136  java.lang.Class</span><br><span class="line">  13:          4979         311952  [S</span><br><span class="line">  14:          5598         287064  [[I</span><br><span class="line">  15:          3028         266464  java.lang.reflect.Method</span><br><span class="line">  16:           280         163520  &lt;objArrayKlassKlass&gt;</span><br><span class="line">  17:          4355         139360  java.util.HashMap$Entry</span><br><span class="line">  18:          1869         138568  [Ljava.util.HashMap$Entry;</span><br><span class="line">  19:          2443          97720  java.util.LinkedHashMap$Entry</span><br><span class="line">  20:          2072          82880  java.lang.ref.SoftReference</span><br><span class="line">  21:          1807          71528  [Ljava.lang.Object;</span><br><span class="line">  22:          2206          70592  java.lang.ref.WeakReference</span><br><span class="line">  23:           934          52304  java.util.LinkedHashMap</span><br><span class="line">  24:           871          48776  java.beans.MethodDescriptor</span><br><span class="line">  25:          1442          46144  java.util.concurrent.ConcurrentHashMap$HashEntry</span><br><span class="line">  26:           804          38592  java.util.HashMap</span><br><span class="line">  27:           948          37920  java.util.concurrent.ConcurrentHashMap$Segment</span><br><span class="line">  28:          1621          35696  [Ljava.lang.Class;</span><br><span class="line">  29:          1313          34880  [Ljava.lang.String;</span><br><span class="line">  30:          1396          33504  java.util.LinkedList$Entry</span><br><span class="line">  31:           462          33264  java.lang.reflect.Field</span><br><span class="line">  32:          1024          32768  java.util.Hashtable$Entry</span><br><span class="line">  33:           948          31440  [Ljava.util.concurrent.ConcurrentHashMap$HashEntry;</span><br></pre></td></tr></table></figure>

<p>class name 是对象类型，说明如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">B  byte</span><br><span class="line">C  char</span><br><span class="line">D  double</span><br><span class="line">F  float</span><br><span class="line">I  int</span><br><span class="line">J  long</span><br><span class="line">Z  boolean</span><br><span class="line">[  数组，如[I表示int[]</span><br><span class="line">[L+类名 其他对象</span><br></pre></td></tr></table></figure>

<p>还有一个很常用的情况是：用 jmap 把进程内存使用情况 dump 到文件中，再用 jhat 分析查看。 jmap 进行 dump 命令格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmap -dump:format=b,file=dumpFileName pid</span><br></pre></td></tr></table></figure>

<p>我一样地对上面进程 ID 为 21711 进行 Dump：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:/# jmap -dump:format=b,file=/tmp/dump.dat 21711     </span><br><span class="line">Dumping heap to /tmp/dump.dat ...</span><br><span class="line">Heap dump file created</span><br></pre></td></tr></table></figure>

<p>dump 出来的文件可以用 MAT、VisualVM 等工具查看，这里用 jhat 查看：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:/# jhat -port 9998 /tmp/dump.dat</span><br><span class="line">Reading from /tmp/dump.dat...</span><br><span class="line">Dump file created Tue Jan 28 17:46:14 CST 2014</span><br><span class="line">Snapshot read, resolving...</span><br><span class="line">Resolving 132207 objects...</span><br><span class="line">Chasing references, expect 26 dots..........................</span><br><span class="line">Eliminating duplicate references..........................</span><br><span class="line">Snapshot resolved.</span><br><span class="line">Started HTTP server on port 9998</span><br><span class="line">Server is ready.</span><br></pre></td></tr></table></figure>

<p>注意如果 Dump 文件太大，可能需要加上 <code>-J-Xmx512m</code> 这种参数指定最大堆内存，即 <code>jhat -J-Xmx512m -port 9998 /tmp/dump.dat</code>。然后就可以在浏览器中输入 <code>主机地址:9998</code> 查看了：<br><img src="/2021/07/10/%E8%AF%AD%E8%A8%80/Java/JVM/Java%E8%87%AA%E5%B8%A6%E7%9A%84%E8%B0%83%E4%BC%98%E5%B7%A5%E5%85%B7%EF%BC%88jps%E3%80%81jstat%E3%80%81jstack%E3%80%81jmap%E3%80%81jhat%EF%BC%89/3.png" alt="3"></p>
<p>上面红线框出来的部分大家可以自己去摸索下，最后一项支持 OQL（对象查询语言）。</p>
<h3 id="jstat"><a href="#jstat" class="headerlink" title="jstat"></a>jstat</h3><p>JVM 统计监测工具。语法格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jstat [ generalOption | outputOptions vmid [interval[s|ms] [count]] ]</span><br></pre></td></tr></table></figure>

<p>vmid 是 Java 虚拟机 ID，在 Linux/Unix 系统上一般就是进程 ID。interval 是采样时间间隔。count 是采样数目。比如下面输出的是 GC 信息，采样时间间隔为 250ms，采样数为 4：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:/# jstat -gc 21711 250 4</span><br><span class="line"> S0C    S1C    S0U    S1U      EC       EU        OC         OU       PC     PU    YGC     YGCT    FGC    FGCT     GCT   </span><br><span class="line">192.0  192.0   64.0   0.0    6144.0   1854.9   32000.0     4111.6   55296.0 25472.7    702    0.431   3      0.218    0.649</span><br><span class="line">192.0  192.0   64.0   0.0    6144.0   1972.2   32000.0     4111.6   55296.0 25472.7    702    0.431   3      0.218    0.649</span><br><span class="line">192.0  192.0   64.0   0.0    6144.0   1972.2   32000.0     4111.6   55296.0 25472.7    702    0.431   3      0.218    0.649</span><br><span class="line">192.0  192.0   64.0   0.0    6144.0   2109.7   32000.0     4111.6   55296.0 25472.7    702    0.431   3      0.218    0.649</span><br></pre></td></tr></table></figure>

<p>要明白上面各列的意义，先看 JVM 堆内存布局：<br><img src="/2021/07/10/%E8%AF%AD%E8%A8%80/Java/JVM/Java%E8%87%AA%E5%B8%A6%E7%9A%84%E8%B0%83%E4%BC%98%E5%B7%A5%E5%85%B7%EF%BC%88jps%E3%80%81jstat%E3%80%81jstack%E3%80%81jmap%E3%80%81jhat%EF%BC%89/4.jpg" alt="4"></p>
<p>可以看出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">堆内存 = 年轻代 + 年老代 + 永久代</span><br><span class="line">年轻代 = Eden区 + 两个Survivor区（From和To）</span><br></pre></td></tr></table></figure>

<p>现在来解释各列含义：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">S0C、S1C、S0U、S1U：Survivor 0/1区容量（Capacity）和使用量（Used）</span><br><span class="line">EC、EU：Eden区容量和使用量</span><br><span class="line">OC、OU：年老代容量和使用量</span><br><span class="line">PC、PU：永久代容量和使用量</span><br><span class="line">YGC、YGT：年轻代GC次数和GC耗时</span><br><span class="line">FGC、FGCT：Full GC次数和Full GC耗时</span><br><span class="line">GCT：GC总耗时</span><br></pre></td></tr></table></figure>

<h3 id="hprof（Heap-CPU-Profiling-Tool）"><a href="#hprof（Heap-CPU-Profiling-Tool）" class="headerlink" title="hprof（Heap/CPU Profiling Tool）"></a>hprof（Heap/CPU Profiling Tool）</h3><p>hprof 能够展现 CPU 使用率，统计堆内存使用情况。语法格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">java -agentlib:hprof[=options] ToBeProfiledClass</span><br><span class="line">java -Xrunprof[:options] ToBeProfiledClass</span><br><span class="line">javac -J-agentlib:hprof[=options] ToBeProfiledClass</span><br></pre></td></tr></table></figure>

<p>完整的命令选项如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Option Name and Value  Description                    Default</span><br><span class="line">---------------------  -----------                    -------</span><br><span class="line">heap=dump|sites|all    heap profiling                 all</span><br><span class="line">cpu=samples|times|old  CPU usage                      off</span><br><span class="line">monitor=y|n            monitor contention             n</span><br><span class="line">format=a|b             text(txt) or binary output     a</span><br><span class="line">file=&lt;file&gt;            write data to file             java.hprof[.txt]</span><br><span class="line">net=&lt;host&gt;:&lt;port&gt;      send data over a socket        off</span><br><span class="line">depth=&lt;size&gt;           stack trace depth              4</span><br><span class="line">interval=&lt;ms&gt;          sample interval in ms          10</span><br><span class="line">cutoff=&lt;value&gt;         output cutoff point            0.0001</span><br><span class="line">lineno=y|n             line number in traces?         y</span><br><span class="line">thread=y|n             thread in traces?              n</span><br><span class="line">doe=y|n                dump on exit?                  y</span><br><span class="line">msa=y|n                Solaris micro state accounting n</span><br><span class="line">force=y|n              force output to &lt;file&gt;         y</span><br><span class="line">verbose=y|n            print messages about dumps     y</span><br></pre></td></tr></table></figure>

<p>来几个官方指南上的实例。</p>
<p>CPU Usage Sampling Profiling(cpu=samples) 的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -agentlib:hprof=cpu=samples,interval=20,depth=3 Hello</span><br></pre></td></tr></table></figure>

<p>上面每隔 20 毫秒采样 CPU 消耗信息，堆栈深度为 3，生成的 profile 文件名称是 java.hprof.txt，在当前目录。</p>
<p>CPU Usage Times Profiling(cpu=times) 的例子，它相对于 CPU Usage Sampling Profile 能够获得更加细粒度的 CPU 消耗信息，能够细到每个方法调用的开始和结束，它的实现使用了字节码注入技术（BCI）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javac -J-agentlib:hprof=cpu=times Hello.java</span><br></pre></td></tr></table></figure>

<p>Heap Allocation Profiling(heap=sites) 的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javac -J-agentlib:hprof=heap=sites Hello.java</span><br></pre></td></tr></table></figure>

<p>Heap Dump(heap=dump) 的例子，它比上面的 Heap Allocation Profiling 能生成更详细的 Heap Dump 信息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javac -J-agentlib:hprof=heap=dump Hello.java</span><br></pre></td></tr></table></figure>

<p><strong>虽然在 JVM 启动参数中加入 -Xrunprof:heap=sites 参数可以生成 CPU/Heap Profile 文件，但对 JVM 性能影响非常大，不建议在线上服务器环境使用。</strong></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wetts.github.io/2021/06/04/%E8%AF%AD%E8%A8%80/Java/%E6%A1%86%E6%9E%B6%E3%80%81%E7%9B%B8%E5%85%B3%E6%8A%80%E6%9C%AF/Spring/%E7%94%A8%E6%B3%95/Spring-%E6%A1%86%E6%9E%B6%E8%AE%BE%E8%AE%A1-%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Zhang Wetts">
      <meta itemprop="description" content="Stay Hungry, Stay Foolish. <br><br><p style="font-size:8px;">[build by hexo/next/gitalk/hexo-generator-search/LaTeX]</p>">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wetts's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/06/04/%E8%AF%AD%E8%A8%80/Java/%E6%A1%86%E6%9E%B6%E3%80%81%E7%9B%B8%E5%85%B3%E6%8A%80%E6%9C%AF/Spring/%E7%94%A8%E6%B3%95/Spring-%E6%A1%86%E6%9E%B6%E8%AE%BE%E8%AE%A1-%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/" class="post-title-link" itemprop="url">Spring-框架设计-循环依赖.md</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-06-04 09:20:37" itemprop="dateCreated datePublished" datetime="2021-06-04T09:20:37+08:00">2021-06-04</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>转自：<a target="_blank" rel="noopener" href="https://blog.csdn.net/zzti_erlie/article/details/106876517">https://blog.csdn.net/zzti_erlie/article/details/106876517</a></p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>先说一下什么是循环依赖，Spring 在初始化 A 的时候需要注入 B，而初始化 B 的时候需要注入 A，在 Spring 启动后这 2 个 Bean 都要被初始化完成</p>
<p>Spring的循环依赖有两种场景</p>
<ol>
<li>构造器的循环依赖</li>
<li>属性的循环依赖</li>
</ol>
<p>构造器的循环依赖，可以在构造函数中使用 <code>@Lazy</code> 注解延迟加载。在注入依赖时，先注入代理对象，当首次使用时再创建对象完成注入</p>
<p>属性的循环依赖主要是通过3个map来解决的</p>
<h2 id="构造器的循环依赖"><a href="#构造器的循环依赖" class="headerlink" title="构造器的循环依赖"></a>构造器的循环依赖</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class ConstructorA &#123;</span><br><span class="line"></span><br><span class="line">	private ConstructorB constructorB;</span><br><span class="line"></span><br><span class="line">	@Autowired</span><br><span class="line">	public ConstructorA(ConstructorB constructorB) &#123;</span><br><span class="line">		this.constructorB = constructorB;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class ConstructorB &#123;</span><br><span class="line"></span><br><span class="line">	private ConstructorA constructorA;</span><br><span class="line"></span><br><span class="line">	@Autowired</span><br><span class="line">	public ConstructorB(ConstructorA constructorA) &#123;</span><br><span class="line">		this.constructorA = constructorA;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@ComponentScan(&quot;com.javashitang.dependency.constructor&quot;)</span><br><span class="line">public class ConstructorConfig &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class ConstructorMain &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		AnnotationConfigApplicationContext context =</span><br><span class="line">				new AnnotationConfigApplicationContext(ConstructorConfig.class);</span><br><span class="line">		System.out.println(context.getBean(ConstructorA.class));</span><br><span class="line">		System.out.println(context.getBean(ConstructorB.class));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行 ConstructorMain 的 main 方法的时候会在第一行就报异常，说明 Spring 没办法初始化所有的 Bean，即上面这种形式的循环依赖 Spring 无法解决。</p>
<p>我们可以在 ConstructorA 或者 ConstructorB 构造函数的参数上加上 @Lazy 注解就可以解决</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Autowired</span><br><span class="line">public ConstructorB(@Lazy ConstructorA constructorA) &#123;</span><br><span class="line">	this.constructorA = constructorA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为我们主要关注属性的循环依赖，构造器的循环依赖就不做过多分析了</p>
<h2 id="属性的循环依赖"><a href="#属性的循环依赖" class="headerlink" title="属性的循环依赖"></a>属性的循环依赖</h2><p>先演示一下什么是属性的循环依赖</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class FieldA &#123;</span><br><span class="line"></span><br><span class="line">	@Autowired</span><br><span class="line">	private FieldB fieldB;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class FieldB &#123;</span><br><span class="line"></span><br><span class="line">	@Autowired</span><br><span class="line">	private FieldA fieldA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@ComponentScan(&quot;com.javashitang.dependency.field&quot;)</span><br><span class="line">public class FieldConfig &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class FieldMain &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		AnnotationConfigApplicationContext context =</span><br><span class="line">				new AnnotationConfigApplicationContext(FieldConfig.class);</span><br><span class="line">		// com.javashitang.dependency.field.FieldA@3aa9e816</span><br><span class="line">		System.out.println(context.getBean(FieldA.class));</span><br><span class="line">		// com.javashitang.dependency.field.FieldB@17d99928</span><br><span class="line">		System.out.println(context.getBean(FieldB.class));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Spring 容器正常启动，能获取到 FieldA 和 FieldB 这2个 Bean</p>
<p>属性的循环依赖在面试中还是经常被问到的。总体来说也不复杂，但是涉及到 Spring Bean 的初始化过程，所以感觉比较复杂，我写个 demo 演示一下整个过程</p>
<p>Spring 的 Bean 的初始化过程其实比较复杂，为了方便理解 Demo，我就把 Spring Bean 的初始化过程分为 2 部分</p>
<ol>
<li>bean 的实例化过程，即调用构造函数将对象创建出来</li>
<li>bean 的初始化过程，即填充 bean 的各种属性</li>
</ol>
<p>bean 初始化过程完毕，则 bean 就能被正常创建出来了</p>
<p>下面开始写 Demo，ObjectFactory 接口用来生产 Bean，和 Spring 中定义的接口一样</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface ObjectFactory&lt;T&gt; &#123;</span><br><span class="line">	T getObject();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">public class DependencyDemo &#123;</span><br><span class="line"></span><br><span class="line">	// 初始化完毕的Bean</span><br><span class="line">	private final Map&lt;String, Object&gt; singletonObjects =</span><br><span class="line">			new ConcurrentHashMap&lt;&gt;(256);</span><br><span class="line"></span><br><span class="line">	// 正在初始化的Bean对应的工厂，此时对象已经被实例化</span><br><span class="line">	private final Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories =</span><br><span class="line">			new HashMap&lt;&gt;(16);</span><br><span class="line"></span><br><span class="line">	// 存放正在初始化的Bean，对象还没有被实例化之前就放进来了</span><br><span class="line">	private final Set&lt;String&gt; singletonsCurrentlyInCreation =</span><br><span class="line">			Collections.newSetFromMap(new ConcurrentHashMap&lt;&gt;(16));</span><br><span class="line"></span><br><span class="line">	public  &lt;T&gt; T getBean(Class&lt;T&gt; beanClass) throws Exception &#123;</span><br><span class="line">		// 类名为Bean的名字</span><br><span class="line">		String beanName = beanClass.getSimpleName();</span><br><span class="line">		// 已经初始化好了，或者正在初始化</span><br><span class="line">		Object initObj = getSingleton(beanName, true);</span><br><span class="line">		if (initObj != null) &#123;</span><br><span class="line">			return (T) initObj;</span><br><span class="line">		&#125;</span><br><span class="line">		// bean正在被初始化</span><br><span class="line">		singletonsCurrentlyInCreation.add(beanName);</span><br><span class="line">		// 实例化bean</span><br><span class="line">		Object object = beanClass.getDeclaredConstructor().newInstance();</span><br><span class="line">		singletonFactories.put(beanName, () -&gt; &#123;</span><br><span class="line">			return object;</span><br><span class="line">		&#125;);</span><br><span class="line">		// 开始初始化bean，即填充属性</span><br><span class="line">		Field[] fields = object.getClass().getDeclaredFields();</span><br><span class="line">		for (Field field : fields) &#123;</span><br><span class="line">			field.setAccessible(true);</span><br><span class="line">			// 获取需要注入字段的class</span><br><span class="line">			Class&lt;?&gt; fieldClass = field.getType();</span><br><span class="line">			field.set(object, getBean(fieldClass));</span><br><span class="line">		&#125;</span><br><span class="line">		// 初始化完毕</span><br><span class="line">		singletonObjects.put(beanName, object);</span><br><span class="line">		singletonsCurrentlyInCreation.remove(beanName);</span><br><span class="line">		return (T) object;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * allowEarlyReference参数的含义是Spring是否允许循环依赖，默认为true</span><br><span class="line">	 * 所以当allowEarlyReference设置为false的时候，当项目存在循环依赖，会启动失败</span><br><span class="line">	 */</span><br><span class="line">	public Object getSingleton(String beanName, boolean allowEarlyReference) &#123;</span><br><span class="line">		Object singletonObject = this.singletonObjects.get(beanName);</span><br><span class="line">		if (singletonObject == null </span><br><span class="line">				&amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">			synchronized (this.singletonObjects) &#123;</span><br><span class="line">				if (singletonObject == null &amp;&amp; allowEarlyReference) &#123;</span><br><span class="line">					ObjectFactory&lt;?&gt; singletonFactory =</span><br><span class="line">							this.singletonFactories.get(beanName);</span><br><span class="line">					if (singletonFactory != null) &#123;</span><br><span class="line">						singletonObject = singletonFactory.getObject();</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		return singletonObject;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * 判断bean是否正在被初始化</span><br><span class="line">	 */</span><br><span class="line">	public boolean isSingletonCurrentlyInCreation(String beanName) &#123;</span><br><span class="line">		return this.singletonsCurrentlyInCreation.contains(beanName);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>测试一波</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">	DependencyDemo dependencyDemo = new DependencyDemo();</span><br><span class="line">	// 假装扫描出来的对象</span><br><span class="line">	Class[] classes = &#123;A.class, B.class&#125;;</span><br><span class="line">	// 假装项目初始化所有bean</span><br><span class="line">	for (Class aClass : classes) &#123;</span><br><span class="line">		dependencyDemo.getBean(aClass);</span><br><span class="line">	&#125;</span><br><span class="line">	// true</span><br><span class="line">	System.out.println(</span><br><span class="line">			dependencyDemo.getBean(B.class).getA() == dependencyDemo.getBean(A.class));</span><br><span class="line">	// true</span><br><span class="line">	System.out.println(</span><br><span class="line">			dependencyDemo.getBean(A.class).getB() == dependencyDemo.getBean(B.class));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>是不是很简单？我们只用了 2 个 map 就搞定了 Spring 的循环依赖</p>
<p>2 个 Map 就能搞定循环依赖，那为什么 Spring 要用 3 个 Map 呢？</p>
<p>原因其实也很简单，当我们从 singletonFactories 中根据 BeanName 获取相应的 ObjectFactory，然后调用 getObject() 这个方法返回对应的 Bean。在我们的例子中 ObjectFactory 的实现很简单哈，就是将实例化好的对象直接返回，但是在 Spring 中就没有这么简单了，执行过程比较复杂，为了避免每次拿到 ObjectFactory 然后调用 getObject()，我们直接把 ObjectFactory 创建的对象缓存起来不就行了，这样就能提高效率了</p>
<p>比如 A 依赖 B 和 C，B 和 C 又依赖 A，如果不做缓存那么初始化 B 和 C 都会调用 A 对应的 ObjectFactory的getObject() 方法。如果做缓存只需要 B 或者 C 调用一次即可。</p>
<p>知道了思路，我们把上面的代码改一波，加个缓存。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">public class DependencyDemo &#123;</span><br><span class="line"></span><br><span class="line">	// 初始化完毕的Bean</span><br><span class="line">	private final Map&lt;String, Object&gt; singletonObjects =</span><br><span class="line">			new ConcurrentHashMap&lt;&gt;(256);</span><br><span class="line"></span><br><span class="line">	// 正在初始化的Bean对应的工厂，此时对象已经被实例化</span><br><span class="line">	private final Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories =</span><br><span class="line">			new HashMap&lt;&gt;(16);</span><br><span class="line"></span><br><span class="line">	// 缓存Bean对应的工厂生产好的Bean</span><br><span class="line">	private final Map&lt;String, Object&gt; earlySingletonObjects =</span><br><span class="line">			new HashMap&lt;&gt;(16);</span><br><span class="line"></span><br><span class="line">	// 存放正在初始化的Bean，对象还没有被实例化之前就放进来了</span><br><span class="line">	private final Set&lt;String&gt; singletonsCurrentlyInCreation =</span><br><span class="line">			Collections.newSetFromMap(new ConcurrentHashMap&lt;&gt;(16));</span><br><span class="line"></span><br><span class="line">	public  &lt;T&gt; T getBean(Class&lt;T&gt; beanClass) throws Exception &#123;</span><br><span class="line">		// 类名为Bean的名字</span><br><span class="line">		String beanName = beanClass.getSimpleName();</span><br><span class="line">		// 已经初始化好了，或者正在初始化</span><br><span class="line">		Object initObj = getSingleton(beanName, true);</span><br><span class="line">		if (initObj != null) &#123;</span><br><span class="line">			return (T) initObj;</span><br><span class="line">		&#125;</span><br><span class="line">		// bean正在被初始化</span><br><span class="line">		singletonsCurrentlyInCreation.add(beanName);</span><br><span class="line">		// 实例化bean</span><br><span class="line">		Object object = beanClass.getDeclaredConstructor().newInstance();</span><br><span class="line">		singletonFactories.put(beanName, () -&gt; &#123;</span><br><span class="line">			return object;</span><br><span class="line">		&#125;);</span><br><span class="line">		// 开始初始化bean，即填充属性</span><br><span class="line">		Field[] fields = object.getClass().getDeclaredFields();</span><br><span class="line">		for (Field field : fields) &#123;</span><br><span class="line">			field.setAccessible(true);</span><br><span class="line">			// 获取需要注入字段的class</span><br><span class="line">			Class&lt;?&gt; fieldClass = field.getType();</span><br><span class="line">			field.set(object, getBean(fieldClass));</span><br><span class="line">		&#125;</span><br><span class="line">		singletonObjects.put(beanName, object);</span><br><span class="line">		singletonsCurrentlyInCreation.remove(beanName);</span><br><span class="line">		earlySingletonObjects.remove(beanName);</span><br><span class="line">		return (T) object;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * allowEarlyReference参数的含义是Spring是否允许循环依赖，默认为true</span><br><span class="line">	 */</span><br><span class="line">	public Object getSingleton(String beanName, boolean allowEarlyReference) &#123;</span><br><span class="line">		Object singletonObject = this.singletonObjects.get(beanName);</span><br><span class="line">		if (singletonObject == null</span><br><span class="line">				&amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">			synchronized (this.singletonObjects) &#123;</span><br><span class="line">				singletonObject = this.earlySingletonObjects.get(beanName);</span><br><span class="line">				if (singletonObject == null &amp;&amp; allowEarlyReference) &#123;</span><br><span class="line">					ObjectFactory&lt;?&gt; singletonFactory =</span><br><span class="line">							this.singletonFactories.get(beanName);</span><br><span class="line">					if (singletonFactory != null) &#123;</span><br><span class="line">						singletonObject = singletonFactory.getObject();</span><br><span class="line">						this.earlySingletonObjects.put(beanName, singletonObject);</span><br><span class="line">						this.singletonFactories.remove(beanName);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		return singletonObject;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们写的 getSingleton 的实现和 org.springframework.beans.factory.support.DefaultSingletonBeanRegistry#getSingleton(java.lang.String, boolean) 的实现一模一样，这个方法几乎所有分析 Spring 循环依赖的文章都会提到，这次你明白工作原理是什么了把</p>
<h2 id="总结一波"><a href="#总结一波" class="headerlink" title="总结一波"></a>总结一波</h2><ol>
<li>拿 bean 的时候先从 singletonObjects（一级缓存）中获取</li>
<li>如果获取不到，并且对象正在创建中，就从 earlySingletonObjects（二级缓存）中获取</li>
<li>如果还是获取不到就从 singletonFactories（三级缓存）中获取，然后将获取到的对象放到 earlySingletonObjects（二级缓存）中，并且将 bean 对应的 singletonFactories（三级缓存）清除</li>
<li>bean 初始化完毕，放到 singletonObjects（一级缓存）中，将 bean 对应的 earlySingletonObjects（二级缓存）清除</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wetts.github.io/2021/06/03/%E8%AF%AD%E8%A8%80/Java/basic_Java/API/%E5%B9%B6%E5%8F%91/%E5%85%B6%E4%BB%96/Java-%E5%A4%9A%E7%BA%BF%E7%A8%8B-Callable%E6%8E%A5%E5%8F%A3%E5%8F%8AFutrue%E6%8E%A5%E5%8F%A3%E8%AF%A6%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Zhang Wetts">
      <meta itemprop="description" content="Stay Hungry, Stay Foolish. <br><br><p style="font-size:8px;">[build by hexo/next/gitalk/hexo-generator-search/LaTeX]</p>">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wetts's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/06/03/%E8%AF%AD%E8%A8%80/Java/basic_Java/API/%E5%B9%B6%E5%8F%91/%E5%85%B6%E4%BB%96/Java-%E5%A4%9A%E7%BA%BF%E7%A8%8B-Callable%E6%8E%A5%E5%8F%A3%E5%8F%8AFutrue%E6%8E%A5%E5%8F%A3%E8%AF%A6%E8%A7%A3/" class="post-title-link" itemprop="url">Java-多线程-Callable接口及Futrue接口详解.md</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-06-03 15:34:03" itemprop="dateCreated datePublished" datetime="2021-06-03T15:34:03+08:00">2021-06-03</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>转自：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/guanbin-529/p/11784914.html">https://www.cnblogs.com/guanbin-529/p/11784914.html</a></p>
<h2 id="Callable接口"><a href="#Callable接口" class="headerlink" title="Callable接口"></a>Callable接口</h2><p>有两种创建线程的方法：一种是通过创建 Thread 类，另一种是通过使用 Runnable 创建线程。但是，Runnable 缺少的一项功能是，当线程终止时（即run() 完成时），我们无法使线程返回结果。为了支持此功能，Java 中提供了 Callable 接口。</p>
<ul>
<li>为了实现 Runnable，需要实现不返回任何内容的 run() 方法，而对于 Callable，需要实现在完成时返回结果的 call() 方法。请注意，不能使用 Callable 创建线程，只能使用 Runnable 创建线程。</li>
<li>另一个区别是 call() 方法可以引发异常，而 run() 则不能。</li>
<li>为实现 Callable 而必须重写 call 方法。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// Java program to illustrate Callable </span><br><span class="line">// to return a random number </span><br><span class="line">import java.util.Random; </span><br><span class="line">import java.util.concurrent.Callable; </span><br><span class="line">import java.util.concurrent.FutureTask; </span><br><span class="line">  </span><br><span class="line">class CallableExample implements Callable </span><br><span class="line">&#123; </span><br><span class="line">  </span><br><span class="line">    public Object call() throws Exception </span><br><span class="line">    &#123; </span><br><span class="line">        // Create random number generator </span><br><span class="line">        Random generator = new Random(); </span><br><span class="line">  </span><br><span class="line">        Integer randomNumber = generator.nextInt(5); </span><br><span class="line">  </span><br><span class="line">        // To simulate a heavy computation, </span><br><span class="line">        // we delay the thread for some random time </span><br><span class="line">        Thread.sleep(randomNumber * 1000); </span><br><span class="line">  </span><br><span class="line">        return randomNumber; </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h2 id="Futrue接口"><a href="#Futrue接口" class="headerlink" title="Futrue接口"></a>Futrue接口</h2><p>当 call() 方法完成时，结果必须存储在主线程已知的对象中，以便主线程可以知道该线程返回的结果。为此，可以使用 Future 对象。将 Future 视为保存结果的对象–它可能暂时不保存结果，但将来会保存（一旦 Callable 返回）。因此，Future 基本上是主线程可以跟踪进度以及其他线程的结果的一种方式。要实现此接口，必须重写 5 种方法，但是由于下面的示例使用了库中的具体实现，因此这里仅列出了重要的方法。</p>
<ul>
<li>public boolean cancel(boolean mayInterrupt)：用于停止任务。如果尚未启动，它将停止任务。如果已启动，则仅在 mayInterrupt 为 true 时才会中断任务。</li>
<li>public Object get() 抛出 InterruptedException，ExecutionException：用于获取任务的结果。如果任务完成，它将立即返回结果，否则将等待任务完成，然后返回结果。</li>
<li>public boolean isDone()：如果任务完成，则返回 true，否则返回 false</li>
</ul>
<p>可以看到 Callable 和 Future 做两件事：Callable 与 Runnable类似，因为它封装了要在另一个线程上运行的任务，而 Future 用于存储从另一个线程获得的结果。实际上，future 也可以与 Runnable 一起使用。</p>
<p>要创建线程，需要 Runnable。为了获得结果，需要 future。</p>
<p>Java 库具有具体的 FutureTask 类型，该类型实现 Runnable 和 Future，并方便地将两种功能组合在一起。<br>可以通过为其构造函数提供 Callable 来创建 FutureTask。然后，将 FutureTask 对象提供给 Thread 的构造函数以创建 Thread 对象。因此，间接地使用 Callable 创建线程。</p>
<h3 id="使用Callable和Future的完整示例"><a href="#使用Callable和Future的完整示例" class="headerlink" title="使用Callable和Future的完整示例"></a>使用Callable和Future的完整示例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line">package com.example.thread.callable;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.Date;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author: GuanBin</span><br><span class="line"> * @date: Created in 下午11:19 2019/10/31</span><br><span class="line"> */</span><br><span class="line">public class TestCallable implements Callable&lt;Object&gt; &#123;</span><br><span class="line"></span><br><span class="line">    private int taskNum;</span><br><span class="line"></span><br><span class="line">    public TestCallable(int taskNum) &#123;</span><br><span class="line">        this.taskNum = taskNum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //1，2主要区别是创建线程的方式</span><br><span class="line">    public static void main(String[] args) throws ExecutionException, InterruptedException &#123;</span><br><span class="line">        test1();</span><br><span class="line">        test2();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 使用Executors.newFixedThreadPool创建线程池</span><br><span class="line">     * @throws InterruptedException</span><br><span class="line">     * @throws ExecutionException</span><br><span class="line">     */</span><br><span class="line">    private static void test1() throws InterruptedException, ExecutionException &#123;</span><br><span class="line">        System.out.println(&quot;----程序开始运行----&quot;);</span><br><span class="line">        Date date1 = new Date();</span><br><span class="line">        int taskSize=5;</span><br><span class="line">        ExecutorService pool = Executors.newFixedThreadPool(taskSize);</span><br><span class="line">        List&lt;Future&gt; list = new ArrayList&lt;Future&gt;();</span><br><span class="line">        for (int i = 0; i &lt; taskSize; i++) &#123;</span><br><span class="line">            Callable c = new TestCallable(i);</span><br><span class="line">            // 执行任务并获取Future对象</span><br><span class="line">            Future f = pool.submit(c);</span><br><span class="line">            list.add(f);</span><br><span class="line">        &#125;</span><br><span class="line">        // 关闭线程池</span><br><span class="line">        pool.shutdown();</span><br><span class="line">        // 获取所有并发任务的运行结果</span><br><span class="line">        for (Future f : list) &#123;</span><br><span class="line">            // 从Future对象上获取任务的返回值，并输出到控制台</span><br><span class="line">            System.out.println(&quot;&gt;&gt;&gt;&quot; + f.get().toString()); //OPTION + return 抛异常</span><br><span class="line">        &#125;</span><br><span class="line">        Date date2 = new Date();</span><br><span class="line">        System.out.println(&quot;----程序结束运行----，程序运行时间【&quot; + (date2.getTime() - date1.getTime()) + &quot;毫秒】&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 线程直接使用new Thread来创建</span><br><span class="line">     * @throws ExecutionException</span><br><span class="line">     * @throws InterruptedException</span><br><span class="line">     */</span><br><span class="line">    private static void test2() throws ExecutionException, InterruptedException &#123;</span><br><span class="line">        System.out.println(&quot;----程序开始运行----&quot;);</span><br><span class="line">        Date date1 = new Date();</span><br><span class="line">        int taskSize=5;</span><br><span class="line">        FutureTask[] randomNumberTasks = new FutureTask[5];</span><br><span class="line">        List&lt;Future&gt; list = new ArrayList&lt;Future&gt;();</span><br><span class="line">        for (int i = 0; i &lt; randomNumberTasks.length; i++) &#123;</span><br><span class="line">            Callable c = new TestCallable(i);</span><br><span class="line">            // 执行任务并获取Future对象</span><br><span class="line">            randomNumberTasks[i]=   new FutureTask(c);</span><br><span class="line"></span><br><span class="line">            Thread t = new Thread(randomNumberTasks[i]);</span><br><span class="line">            t.start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 获取所有并发任务的运行结果</span><br><span class="line">        for (Future f : randomNumberTasks) &#123;</span><br><span class="line">            // 从Future对象上获取任务的返回值，并输</span><br><span class="line">            System.out.println(&quot;&gt;&gt;&gt;&quot; + f.get().toString()); //OPTION + return 抛异常</span><br><span class="line">        &#125;</span><br><span class="line">        Date date2 = new Date();</span><br><span class="line">        System.out.println(&quot;----程序结束运行----，程序运行时间【&quot; + (date2.getTime() - date1.getTime()) + &quot;毫秒】&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * call方法的实现，主要用于执行线程的具体实现，并返回结果</span><br><span class="line">     * @return</span><br><span class="line">     * @throws Exception</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public Object call() throws Exception &#123;</span><br><span class="line">        System.out.println(&quot;&gt;&gt;&gt;&quot; + taskNum + &quot;任务启动&quot;);</span><br><span class="line">        Date dateTmp1 = new Date();</span><br><span class="line">        Thread.sleep(1000);</span><br><span class="line">        Date dateTmp2 = new Date();</span><br><span class="line">        long time = dateTmp2.getTime() - dateTmp1.getTime();</span><br><span class="line">        System.out.println(&quot;&gt;&gt;&gt;&quot; + taskNum + &quot;任务终止&quot;);</span><br><span class="line">        return taskNum + &quot;任务返回运行结果,当前任务时间【&quot; + time + &quot;毫秒】&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">----程序开始运行----</span><br><span class="line">&gt;&gt;&gt;0任务启动</span><br><span class="line">&gt;&gt;&gt;1任务启动</span><br><span class="line">&gt;&gt;&gt;2任务启动</span><br><span class="line">&gt;&gt;&gt;3任务启动</span><br><span class="line">&gt;&gt;&gt;4任务启动</span><br><span class="line">&gt;&gt;&gt;0任务终止</span><br><span class="line">&gt;&gt;&gt;0任务返回运行结果,当前任务时间【1002毫秒】</span><br><span class="line">&gt;&gt;&gt;1任务终止</span><br><span class="line">&gt;&gt;&gt;2任务终止</span><br><span class="line">&gt;&gt;&gt;4任务终止</span><br><span class="line">&gt;&gt;&gt;1任务返回运行结果,当前任务时间【1005毫秒】</span><br><span class="line">&gt;&gt;&gt;2任务返回运行结果,当前任务时间【1005毫秒】</span><br><span class="line">&gt;&gt;&gt;3任务终止</span><br><span class="line">&gt;&gt;&gt;3任务返回运行结果,当前任务时间【1005毫秒】</span><br><span class="line">&gt;&gt;&gt;4任务返回运行结果,当前任务时间【1005毫秒】</span><br><span class="line">----程序结束运行----，程序运行时间【1007毫秒】</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure>

<h3 id="使用-Callable-和-FutureTask-的完整示例"><a href="#使用-Callable-和-FutureTask-的完整示例" class="headerlink" title="使用 Callable 和 FutureTask 的完整示例"></a>使用 Callable 和 FutureTask 的完整示例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">// Java program to illustrate Callable and FutureTask </span><br><span class="line">// for random number generation </span><br><span class="line">import java.util.Random; </span><br><span class="line">import java.util.concurrent.Callable; </span><br><span class="line">import java.util.concurrent.FutureTask; </span><br><span class="line">  </span><br><span class="line">class CallableExample implements Callable </span><br><span class="line">&#123; </span><br><span class="line">  </span><br><span class="line">  public Object call() throws Exception </span><br><span class="line">  &#123; </span><br><span class="line">    Random generator = new Random(); </span><br><span class="line">    Integer randomNumber = generator.nextInt(5); </span><br><span class="line">  </span><br><span class="line">    Thread.sleep(randomNumber * 1000); </span><br><span class="line">  </span><br><span class="line">    return randomNumber; </span><br><span class="line">  &#125; </span><br><span class="line">  </span><br><span class="line">&#125; </span><br><span class="line">  </span><br><span class="line">public class CallableFutureTest </span><br><span class="line">&#123; </span><br><span class="line">  public static void main(String[] args) throws Exception </span><br><span class="line">  &#123; </span><br><span class="line">  </span><br><span class="line">    // FutureTask is a concrete class that </span><br><span class="line">    // implements both Runnable and Future </span><br><span class="line">    FutureTask[] randomNumberTasks = new FutureTask[5]; </span><br><span class="line">  </span><br><span class="line">    for (int i = 0; i &lt; 5; i++) </span><br><span class="line">    &#123; </span><br><span class="line">      Callable callable = new CallableExample(); </span><br><span class="line">  </span><br><span class="line">      // Create the FutureTask with Callable </span><br><span class="line">      randomNumberTasks[i] = new FutureTask(callable); </span><br><span class="line">  </span><br><span class="line">      // As it implements Runnable, create Thread </span><br><span class="line">      // with FutureTask </span><br><span class="line">      Thread t = new Thread(randomNumberTasks[i]); </span><br><span class="line">      t.start(); </span><br><span class="line">    &#125; </span><br><span class="line">  </span><br><span class="line">    for (int i = 0; i &lt; 5; i++) </span><br><span class="line">    &#123; </span><br><span class="line">      // As it implements Future, we can call get() </span><br><span class="line">      System.out.println(randomNumberTasks[i].get()); </span><br><span class="line">  </span><br><span class="line">      // This method blocks till the result is obtained </span><br><span class="line">      // The get method can throw checked exceptions </span><br><span class="line">      // like when it is interrupted. This is the reason </span><br><span class="line">      // for adding the throws clause to main </span><br><span class="line">    &#125; </span><br><span class="line">  &#125; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>启动线程后，与线程的所有交互都使用 FutureTask，因为它实现了 Future 接口。因此，不需要存储 Thread 对象。使用 FutureTask 对象，还可以取消任务，检查任务是否完成或尝试获取结果。</p>
<h3 id="使用Runnable来获取返回结果的实现"><a href="#使用Runnable来获取返回结果的实现" class="headerlink" title="使用Runnable来获取返回结果的实现"></a>使用Runnable来获取返回结果的实现</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">// Java program to illustrate Runnable </span><br><span class="line">// for random number generation </span><br><span class="line">import java.util.Random; </span><br><span class="line">import java.util.concurrent.Callable; </span><br><span class="line">import java.util.concurrent.FutureTask; </span><br><span class="line">  </span><br><span class="line">class RunnableExample implements Runnable </span><br><span class="line">&#123; </span><br><span class="line">    // Shared object to store result </span><br><span class="line">    private Object result = null; </span><br><span class="line">  </span><br><span class="line">    public void run() </span><br><span class="line">    &#123; </span><br><span class="line">        Random generator = new Random(); </span><br><span class="line">        Integer randomNumber = generator.nextInt(5); </span><br><span class="line">  </span><br><span class="line">        // As run cannot throw any Exception </span><br><span class="line">        try</span><br><span class="line">        &#123; </span><br><span class="line">            Thread.sleep(randomNumber * 1000); </span><br><span class="line">        &#125; </span><br><span class="line">        catch (InterruptedException e) </span><br><span class="line">        &#123; </span><br><span class="line">            e.printStackTrace(); </span><br><span class="line">        &#125; </span><br><span class="line">  </span><br><span class="line">        // Store the return value in result when done </span><br><span class="line">        result = randomNumber; </span><br><span class="line">  </span><br><span class="line">        // Wake up threads blocked on the get() method </span><br><span class="line">        synchronized(this) </span><br><span class="line">        &#123; </span><br><span class="line">            notifyAll(); </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">  </span><br><span class="line">    public synchronized Object get() </span><br><span class="line">          throws InterruptedException </span><br><span class="line">    &#123; </span><br><span class="line">        while (result == null) </span><br><span class="line">            wait(); </span><br><span class="line">  </span><br><span class="line">        return result; </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line">  </span><br><span class="line">// Code is almost same as the previous example with a </span><br><span class="line">// few changes made to use Runnable instead of Callable </span><br><span class="line">public class RunnableTest </span><br><span class="line">&#123; </span><br><span class="line">    public static void main(String[] args) throws Exception </span><br><span class="line">    &#123; </span><br><span class="line">        RunnableExample[] randomNumberTasks = new RunnableExample[5]; </span><br><span class="line">  </span><br><span class="line">        for (int i = 0; i &lt; 5; i++) </span><br><span class="line">        &#123; </span><br><span class="line">            randomNumberTasks[i] = new RunnableExample(); </span><br><span class="line">            Thread t = new Thread(randomNumberTasks[i]); </span><br><span class="line">            t.start(); </span><br><span class="line">        &#125; </span><br><span class="line">  </span><br><span class="line">        for (int i = 0; i &lt; 5; i++) </span><br><span class="line">            System.out.println(randomNumberTasks[i].get()); </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wetts.github.io/2021/06/01/%E8%AF%AD%E8%A8%80/Java/basic_Java/API/%E5%B9%B6%E5%8F%91/%E5%85%B6%E4%BB%96/Java-%E5%B9%B6%E5%8F%91-%E6%8E%A7%E5%88%B6%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Zhang Wetts">
      <meta itemprop="description" content="Stay Hungry, Stay Foolish. <br><br><p style="font-size:8px;">[build by hexo/next/gitalk/hexo-generator-search/LaTeX]</p>">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wetts's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/06/01/%E8%AF%AD%E8%A8%80/Java/basic_Java/API/%E5%B9%B6%E5%8F%91/%E5%85%B6%E4%BB%96/Java-%E5%B9%B6%E5%8F%91-%E6%8E%A7%E5%88%B6%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/" class="post-title-link" itemprop="url">Java-并发-控制多线程执行顺序.md</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-06-01 16:33:14" itemprop="dateCreated datePublished" datetime="2021-06-01T16:33:14+08:00">2021-06-01</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>转自：<a target="_blank" rel="noopener" href="https://blog.csdn.net/zzti_erlie/article/details/84926355">https://blog.csdn.net/zzti_erlie/article/details/84926355</a></p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>先看如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line"></span><br><span class="line">    static Thread thread1 = new Thread(()-&gt; &#123;</span><br><span class="line">        System.out.println(&quot;thread1&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    static Thread thread2 = new Thread(()-&gt; &#123;</span><br><span class="line">        System.out.println(&quot;thread2&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    static Thread thread3 = new Thread(()-&gt; &#123;</span><br><span class="line">        System.out.println(&quot;thread3&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        thread3.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重复执行多次，发现输出并不是按照线程的启动顺序来执行。因为这个里面涉及到CPU对线程的调度问题。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">thread1</span><br><span class="line">thread3</span><br><span class="line">thread2</span><br></pre></td></tr></table></figure>

<p>如何让 thread1，thread2，thread3 顺序执行呢？</p>
<h2 id="方法1"><a href="#方法1" class="headerlink" title="方法1"></a>方法1</h2><p>通过join方法去保证多线程顺序执行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line"></span><br><span class="line">    static Thread thread1 = new Thread(()-&gt; &#123;</span><br><span class="line">        System.out.println(&quot;thread1&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    static Thread thread2 = new Thread(()-&gt; &#123;</span><br><span class="line">        System.out.println(&quot;thread2&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    static Thread thread3 = new Thread(()-&gt; &#123;</span><br><span class="line">        System.out.println(&quot;thread3&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread1.join();</span><br><span class="line">        thread2.start();</span><br><span class="line">        thread2.join();</span><br><span class="line">        thread3.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到输出一直是如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">thread1</span><br><span class="line">thread2</span><br><span class="line">thread3</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure>

<p>join 是怎么实现这个功能的呢？</p>
<p>join 方法让主线程等待子线程结束以后才能继续运行，因此保证了线程的顺序执行</p>
<h2 id="方法2"><a href="#方法2" class="headerlink" title="方法2"></a>方法2</h2><p>使用单例线程池，用唯一的工作线程执行任务，保证所有任务按照指定顺序执行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService executorService = Executors.newSingleThreadExecutor();</span><br></pre></td></tr></table></figure>

<p>这个会把线程放在一个 FIFO 队列，依次执行线程</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line"></span><br><span class="line">    static Thread thread1 = new Thread(()-&gt; &#123;</span><br><span class="line">        System.out.println(&quot;thread1&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    static Thread thread2 = new Thread(()-&gt; &#123;</span><br><span class="line">        System.out.println(&quot;thread2&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    static Thread thread3 = new Thread(()-&gt; &#123;</span><br><span class="line">        System.out.println(&quot;thread3&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    static ExecutorService executorService = Executors.newSingleThreadExecutor();</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        executorService.submit(thread1);</span><br><span class="line">        executorService.submit(thread2);</span><br><span class="line">        executorService.submit(thread3);</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出一直为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">thread1</span><br><span class="line">thread2</span><br><span class="line">thread3</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wetts.github.io/2021/05/13/%E8%AF%AD%E8%A8%80/Java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%BE%8B/Java-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E9%97%AE%E9%A2%98%E4%B8%BA%E4%BD%95%E5%8F%AF%E4%BB%A5%E9%80%9A%E8%BF%87%E6%9E%9A%E4%B8%BE%E8%A7%A3%E5%86%B3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Zhang Wetts">
      <meta itemprop="description" content="Stay Hungry, Stay Foolish. <br><br><p style="font-size:8px;">[build by hexo/next/gitalk/hexo-generator-search/LaTeX]</p>">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wetts's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/13/%E8%AF%AD%E8%A8%80/Java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%BE%8B/Java-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E9%97%AE%E9%A2%98%E4%B8%BA%E4%BD%95%E5%8F%AF%E4%BB%A5%E9%80%9A%E8%BF%87%E6%9E%9A%E4%B8%BE%E8%A7%A3%E5%86%B3/" class="post-title-link" itemprop="url">Java-设计模式-单例模式问题为何可以通过枚举解决.md</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-05-13 21:30:07" itemprop="dateCreated datePublished" datetime="2021-05-13T21:30:07+08:00">2021-05-13</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>转自：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/call-me-pengye/p/11214435.html">https://www.cnblogs.com/call-me-pengye/p/11214435.html</a></p>
<p>首先我们都知道 enum 默认继承了 java.lang.Enum 类并实现了 java.lang.Seriablizable 和 java.lang.Comparable 两个接口。接下来我们将依次说明枚举是如何防止这三种方式对单例的破环</p>
<h2 id="克隆"><a href="#克隆" class="headerlink" title="克隆"></a>克隆</h2><p>一个普通的类要是clone必须实现 java.lang.Cloneable 接口，重写 clone() 方法，同理我们来看看枚举能否也是一样<br><img src="/2021/05/13/%E8%AF%AD%E8%A8%80/Java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%BE%8B/Java-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E9%97%AE%E9%A2%98%E4%B8%BA%E4%BD%95%E5%8F%AF%E4%BB%A5%E9%80%9A%E8%BF%87%E6%9E%9A%E4%B8%BE%E8%A7%A3%E5%86%B3/1.png" alt="1"></p>
<p>我们可以看到 enum 是不被允许重写 clone()，因为 Enum 类已经将 clone() 方法定义为 final 了，并且 Enum 在使用 clone() 时直接抛出异常，如下图，这就是枚举为什么能防止克隆破环的原因，它根本就不允许克隆<br><img src="/2021/05/13/%E8%AF%AD%E8%A8%80/Java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%BE%8B/Java-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E9%97%AE%E9%A2%98%E4%B8%BA%E4%BD%95%E5%8F%AF%E4%BB%A5%E9%80%9A%E8%BF%87%E6%9E%9A%E4%B8%BE%E8%A7%A3%E5%86%B3/2.png" alt="2"></p>
<h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class DestroySingleton &#123;</span><br><span class="line">    </span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        //通过反射获取</span><br><span class="line">        Constructor&lt;Singleton&gt; constructor = Singleton.class.getDeclaredConstructor();</span><br><span class="line">        constructor.setAccessible(true);</span><br><span class="line">        Singleton reflex = constructor.newInstance();</span><br><span class="line">        System.out.println(&quot;reflex的hashCode:&quot;+reflex.hashCode());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们先来看一下反射实现的主要步骤：首先通过 class 的 getDeclaredConstructor() 获取到反射对象的构造器，然后通过 newInstance() 调用其构造方法获取对象，getDeclaredConstructor() 主要是通过 getConstructor0() 来获取构造器，具体代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@CallerSensitive</span><br><span class="line">public Constructor&lt;T&gt; getDeclaredConstructor(Class&lt;?&gt;... parameterTypes)</span><br><span class="line">    throws NoSuchMethodException, SecurityException &#123;</span><br><span class="line">    checkMemberAccess(Member.DECLARED, Reflection.getCallerClass(), true);</span><br><span class="line">    return getConstructor0(parameterTypes, Member.DECLARED);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 getConstructor0 中，他会先调用 privateGetDeclaredConstructors 方法去获取；具体代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">private Constructor&lt;T&gt; getConstructor0(Class&lt;?&gt;[] parameterTypes,int which) throws NoSuchMethodException</span><br><span class="line">    &#123;</span><br><span class="line">        Constructor&lt;T&gt;[] constructors = privateGetDeclaredConstructors((which == Member.PUBLIC));</span><br><span class="line">        for (Constructor&lt;T&gt; constructor : constructors) &#123;</span><br><span class="line">            if (arrayContentsEq(parameterTypes,constructor.getParameterTypes())) &#123;</span><br><span class="line">                return getReflectionFactory().copyConstructor(constructor);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        throw new NoSuchMethodException(getName() + &quot;.&lt;init&gt;&quot; + argumentTypesToString(parameterTypes));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>在 privateGetDeclaredConstructors() 中 publicOnly 的值是 false，ReflectionData 的 publicConstructors 和 declaredConstructors 都是 null；而 privateGetDeclaredConstructors() 中真正决定 <code>Constructor&lt;T&gt;[]</code> 的代码是 getDeclaredConstructors0(publicOnly)。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">private Constructor&lt;T&gt;[] privateGetDeclaredConstructors(boolean publicOnly) &#123;</span><br><span class="line">        checkInitted();</span><br><span class="line">        Constructor&lt;T&gt;[] res;</span><br><span class="line">        ReflectionData&lt;T&gt; rd = reflectionData();</span><br><span class="line">        if (rd != null) &#123;</span><br><span class="line">            res = publicOnly ? rd.publicConstructors : rd.declaredConstructors;</span><br><span class="line">            if (res != null) return res;</span><br><span class="line">        &#125;</span><br><span class="line">        // No cached value available; request value from VM</span><br><span class="line">        if (isInterface()) &#123;</span><br><span class="line">            @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">            Constructor&lt;T&gt;[] temporaryRes = (Constructor&lt;T&gt;[]) new Constructor&lt;?&gt;[0];</span><br><span class="line">            res = temporaryRes;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            res = getDeclaredConstructors0(publicOnly);</span><br><span class="line">        &#125;</span><br><span class="line">        if (rd != null) &#123;</span><br><span class="line">            if (publicOnly) &#123;</span><br><span class="line">                rd.publicConstructors = res;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                rd.declaredConstructors = res;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>在得到 <code>Constructor&lt;T&gt;[]</code> 后回到 getConstructor0() 将依次对其进行轮询判断，找到合适的 Constructor 并交由 ReflectionFactory 工厂 copy 出一个 Constructor。其中轮询的判断条件由 parameterTypes 和 constructor.getParameterTypes() 决定，parameterTypes 是个空数组；普通类的 constructor.getParameterTypes() 得出的结果也是空数组，而枚举产生的数组为:<code>[class java.lang.String, int]</code>；接着就交由 arrayContentsEq() 执行，并返回一个 boolean值。</p>
<p>arrayContentsEq 具体代码如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">private static boolean arrayContentsEq(Object[] a1, Object[] a2) &#123;</span><br><span class="line">        if (a1 == null) &#123;</span><br><span class="line">            return a2 == null || a2.length == 0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (a2 == null) &#123;</span><br><span class="line">            return a1.length == 0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (a1.length != a2.length) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; a1.length; i++) &#123;</span><br><span class="line">            if (a1[i] != a2[i]) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>普通类在 arrayContentsEq() 中所有的 if 和 for 都通不过，最后直接返回 true；而枚举类则会因为 <code>a1.length != a2.length</code>（注：a2.length的之为2）条件成立而返回 false。于是普通类接着执行 <code>return getReflectionFactory().copyConstructor(constructor);</code> 而枚举类则直接抛出异常 <code>throw new NoSuchMethodException(getName() + &quot;.&lt;init&gt;&quot; + argumentTypesToString(parameterTypes));</code> 具体错误信息如下：</p>
<blockquote>
<p>Exception in thread “main” java.lang.NoSuchMethodException: designPatterns.singleton.useenum.Singleton.<init>()<br>　　　　 at java.lang.Class.getConstructor0(Class.java:3082)<br>　　　　 at java.lang.Class.getDeclaredConstructor(Class.java:2178)<br>　　　　 at designPatterns.singleton.useenum.DestroySingleton.main(DestroySingleton.java:18)</init></p>
</blockquote>
<p>从控制台输出的信息来看 parameterTypes 的确是一个空对象，但是为什么给出 init() 的 NoSuchMethodException 异常。这就是为什么枚举不能通过反射实例化的原因之一，另一个原因就是：在获取到类构造器后通过 newInstance() 来实例化前，枚举是无法通过</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if( (clazz.getModifiers() &amp; Modifier.ENUM) != 0 )</span><br></pre></td></tr></table></figure>
<p>条件判断的，具体代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@CallerSensitive</span><br><span class="line">    public T newInstance(Object ... initargs)</span><br><span class="line">        throws InstantiationException, IllegalAccessException,</span><br><span class="line">               IllegalArgumentException, InvocationTargetException</span><br><span class="line">    &#123;</span><br><span class="line">        if (!override) &#123;</span><br><span class="line">            if (!Reflection.quickCheckMemberAccess(clazz, modifiers)) &#123;</span><br><span class="line">                Class&lt;?&gt; caller = Reflection.getCallerClass();</span><br><span class="line">                checkAccess(caller, clazz, null, modifiers);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if ((clazz.getModifiers() &amp; Modifier.ENUM) != 0)</span><br><span class="line">            throw new IllegalArgumentException(&quot;Cannot reflectively create enum objects&quot;);</span><br><span class="line">        ConstructorAccessor ca = constructorAccessor;   // read volatile</span><br><span class="line">        if (ca == null) &#123;</span><br><span class="line">            ca = acquireConstructorAccessor();</span><br><span class="line">        &#125;</span><br><span class="line">        @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">        T inst = (T) ca.newInstance(initargs);</span><br><span class="line">        return inst;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class CreateClassBySerialized &#123;</span><br><span class="line">    </span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">    public static &lt;T extends Serializable&gt; T createClassBySerialized(T  t) throws IOException, ClassNotFoundException&#123;</span><br><span class="line">        ByteArrayOutputStream bos = new ByteArrayOutputStream();</span><br><span class="line">        ObjectOutputStream oos = new ObjectOutputStream(bos);</span><br><span class="line">        oos.writeObject(t);</span><br><span class="line">        ByteArrayInputStream bis = new ByteArrayInputStream(bos.toByteArray());</span><br><span class="line">        ObjectInputStream ois = new ObjectInputStream(bis);</span><br><span class="line">        T object = (T) ois.readObject();</span><br><span class="line">        if (ois != null)    ois.close();</span><br><span class="line">        if (bis != null) bis.close();</span><br><span class="line">        if (oos != null) oos.close();</span><br><span class="line">        if (bos != null) bos.close();</span><br><span class="line">        return object;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class DestroySingleton &#123;</span><br><span class="line">    </span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        //通过序列化，反序列化获取</span><br><span class="line">        Singleton serialize = CreateClassBySerialized.createClassBySerialized(Singleton.getInstance());</span><br><span class="line">        System.out.println(&quot;serialize的hashCode:&quot;+serialize.hashCode());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先我们先来看看为什么添加 readResolve() 方法就能防止序列化对单例的破环。关键的代码就是在 readObject() 里的 readObject0() 实现的，readObject() 具体代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public final Object readObject() throws IOException, ClassNotFoundException&#123;</span><br><span class="line">     if (enableOverride) &#123;</span><br><span class="line">         return readObjectOverride();</span><br><span class="line">     &#125;</span><br><span class="line">     // if nested read, passHandle contains handle of enclosing object</span><br><span class="line">     int outerHandle = passHandle;</span><br><span class="line">     try &#123;</span><br><span class="line">         Object obj = readObject0(false);</span><br><span class="line">         handles.markDependency(outerHandle, passHandle);</span><br><span class="line">         ClassNotFoundException ex = handles.lookupException(passHandle);</span><br><span class="line">         if (ex != null) &#123;</span><br><span class="line">             throw ex;</span><br><span class="line">         &#125;</span><br><span class="line">         if (depth == 0) &#123;</span><br><span class="line">             vlist.doCallbacks();</span><br><span class="line">         &#125;</span><br><span class="line">         return obj;</span><br><span class="line">     &#125; finally &#123;</span><br><span class="line">         passHandle = outerHandle;</span><br><span class="line">         if (closed &amp;&amp; depth == 0) &#123;</span><br><span class="line">             clear();</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>而 readObject0() 对类的实现体现在 switch 选择器上：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">switch (tc) &#123;</span><br><span class="line">    case TC_NULL:</span><br><span class="line">        return readNull();</span><br><span class="line">    case TC_REFERENCE:</span><br><span class="line">        return readHandle(unshared);</span><br><span class="line">    case TC_CLASS:</span><br><span class="line">        return readClass(unshared);</span><br><span class="line">    case TC_CLASSDESC:</span><br><span class="line">    case TC_PROXYCLASSDESC:</span><br><span class="line">        return readClassDesc(unshared);</span><br><span class="line">    case TC_STRING:</span><br><span class="line">    case TC_LONGSTRING:</span><br><span class="line">        return checkResolve(readString(unshared));</span><br><span class="line">    case TC_ARRAY:</span><br><span class="line">        return checkResolve(readArray(unshared));</span><br><span class="line">    case TC_ENUM:</span><br><span class="line">        return checkResolve(readEnum(unshared));</span><br><span class="line">    case TC_OBJECT:</span><br><span class="line">        return checkResolve(readOrdinaryObject(unshared));</span><br><span class="line">    case TC_EXCEPTION:</span><br><span class="line">        IOException ex = readFatalException();</span><br><span class="line">        throw new WriteAbortedException(&quot;writing aborted&quot;, ex);</span><br><span class="line">    case TC_BLOCKDATA:</span><br><span class="line">    case TC_BLOCKDATALONG:</span><br><span class="line">        if (oldMode) &#123;</span><br><span class="line">            bin.setBlockDataMode(true);</span><br><span class="line">            bin.peek();             // force header read</span><br><span class="line">            throw new OptionalDataException(bin.currentBlockRemaining());</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            throw new StreamCorruptedException(&quot;unexpected block data&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    case TC_ENDBLOCKDATA:</span><br><span class="line">        if (oldMode) &#123;</span><br><span class="line">            throw new OptionalDataException(true);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            throw new StreamCorruptedException(&quot;unexpected end of block data&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    default:</span><br><span class="line">        throw new StreamCorruptedException(String.format(&quot;invalid type code: %02X&quot;, tc));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>tc 值不同，类的实现方式也不同；普通类(TC_OBJECT)由 readOrdinaryObject(unshared) 来实现，枚举类(TC_ENUM)由 readOrdinaryObject(unshared) 来实现。</p>
<p>readOrdinaryObject(unshared) 决定了类是通过构造器实现还是通过 readResolve() 来实现</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">if (obj != null &amp;&amp; handles.lookupException(passHandle) == null &amp;&amp; desc.hasReadResolveMethod())</span><br><span class="line">&#123;</span><br><span class="line">    Object rep = desc.invokeReadResolve(obj);</span><br><span class="line">    if (unshared &amp;&amp; rep.getClass().isArray()) &#123;</span><br><span class="line">        rep = cloneArray(rep);</span><br><span class="line">    &#125;</span><br><span class="line">    if (rep != obj) &#123;</span><br><span class="line">        // Filter the replacement object</span><br><span class="line">        if (rep != null) &#123;</span><br><span class="line">            if (rep.getClass().isArray()) &#123;</span><br><span class="line">                filterCheck(rep.getClass(), Array.getLength(rep));</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                filterCheck(rep.getClass(), -1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        handles.setObject(passHandle, obj = rep);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中 desc.hasReadResolveMethod() 就是来用判断是否有 readResolve()</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">boolean hasReadResolveMethod() &#123;</span><br><span class="line">    requireInitialized();</span><br><span class="line">    return (readResolveMethod != null);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果不存在 readResolve() 则 readResolveMethod 为 null，反之则为 readResolve() 对应的 Method 对象（我这儿的是 private java.lang.Object designPatterns.singleton.doublecheck.Singleton.readResolve() ）。于是乎就执行 desc.invokeReadResolve(obj) 代码，通过 Method.invoke 执行 readResolve() 方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">Object invokeReadResolve(Object obj) throws IOException, UnsupportedOperationException</span><br><span class="line">&#123;</span><br><span class="line">    requireInitialized();</span><br><span class="line">    if (readResolveMethod != null) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            return readResolveMethod.invoke(obj, (Object[]) null);</span><br><span class="line">        &#125; catch (InvocationTargetException ex) &#123;</span><br><span class="line">            Throwable th = ex.getTargetException();</span><br><span class="line">            if (th instanceof ObjectStreamException) &#123;</span><br><span class="line">                throw (ObjectStreamException) th;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                throwMiscException(th);</span><br><span class="line">                throw new InternalError(th);  // never reached</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (IllegalAccessException ex) &#123;</span><br><span class="line">            // should not occur, as access checks have been suppressed</span><br><span class="line">            throw new InternalError(ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        throw new UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@CallerSensitive</span><br><span class="line">public Object invoke(Object obj, Object... args) throws IllegalAccessException, IllegalArgumentException,InvocationTargetException</span><br><span class="line">&#123;</span><br><span class="line">    if (!override) &#123;</span><br><span class="line">        if (!Reflection.quickCheckMemberAccess(clazz, modifiers)) &#123;</span><br><span class="line">            Class&lt;?&gt; caller = Reflection.getCallerClass();</span><br><span class="line">            checkAccess(caller, clazz, obj, modifiers);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    MethodAccessor ma = methodAccessor;             // read volatile</span><br><span class="line">    if (ma == null) &#123;</span><br><span class="line">        ma = acquireMethodAccessor();</span><br><span class="line">    &#125;</span><br><span class="line">    return ma.invoke(obj, args);                   // readResolve最终执行处&#125;</span><br></pre></td></tr></table></figure>

<p>这样就得到了我们的静态 singleton，实现单例模式。而在实现枚举的 readEnum() 方法中，枚举的实现是通过调用 java.lang.Enum的 静态方法 valueOf 来实现的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;T extends Enum&lt;T&gt;&gt; T valueOf(Class&lt;T&gt; enumType,String name) &#123;</span><br><span class="line">        T result = enumType.enumConstantDirectory().get(name);</span><br><span class="line">        if (result != null)</span><br><span class="line">            return result;</span><br><span class="line">        if (name == null)</span><br><span class="line">            throw new NullPointerException(&quot;Name is null&quot;);</span><br><span class="line">        throw new IllegalArgumentException(</span><br><span class="line">            &quot;No enum constant &quot; + enumType.getCanonicalName() + &quot;.&quot; + name);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>enumType.enumConstantDirectory() 返回的对象是继承了枚举常量的 hashMap，其中 key 键是枚举常量名字，value 键是常量枚举对象本身；当它拿到枚举类中全部的枚举后，再其轮询将每一个枚举常量存入 hashMap 中：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, T&gt; enumConstantDirectory() &#123;</span><br><span class="line">        if (enumConstantDirectory == null) &#123;</span><br><span class="line">            T[] universe = getEnumConstantsShared();</span><br><span class="line">            if (universe == null)</span><br><span class="line">                throw new IllegalArgumentException(</span><br><span class="line">                    getName() + &quot; is not an enum type&quot;);</span><br><span class="line">            Map&lt;String, T&gt; m = new HashMap&lt;&gt;(2 * universe.length);</span><br><span class="line">            for (T constant : universe)</span><br><span class="line">                m.put(((Enum&lt;?&gt;)constant).name(), constant);</span><br><span class="line">            enumConstantDirectory = m;</span><br><span class="line">        &#125;</span><br><span class="line">        return enumConstantDirectory;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//getEnumConstantsShared()就是获取到的一个个枚举对象</span><br><span class="line">T[] getEnumConstantsShared() &#123;</span><br><span class="line">        if (enumConstants == null) &#123;</span><br><span class="line">            if (!isEnum()) return null;</span><br><span class="line">            try &#123;</span><br><span class="line">                final Method values = getMethod(&quot;values&quot;);</span><br><span class="line">                java.security.AccessController.doPrivileged(</span><br><span class="line">                    new java.security.PrivilegedAction&lt;Void&gt;() &#123;</span><br><span class="line">                        public Void run() &#123;</span><br><span class="line">                                values.setAccessible(true);</span><br><span class="line">                                return null;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;);</span><br><span class="line">                @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">                T[] temporaryConstants = (T[])values.invoke(null);</span><br><span class="line">                enumConstants = temporaryConstants;</span><br><span class="line">            &#125;</span><br><span class="line">            // These can happen when users concoct enum-like classes</span><br><span class="line">            // that don&#x27;t comply with the enum spec.</span><br><span class="line">            catch (InvocationTargetException | NoSuchMethodException |</span><br><span class="line">                   IllegalAccessException ex) &#123; return null; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return enumConstants;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>当我们拿到枚举的 hashMap 后，通过 get(name) 方法获取对应的枚举然后层层返回。代码中实现枚举的入口代码是 Enum.valueOf((Class)cl, name)，这样实现的现过其实就是 EnumClass.name(我代码的体现是Singleton.INSTANCE)，这样来看的话无论是 EnumClass.name 获取对象，还是 Enum.valueOf((Class)cl, name) 获取对象，它们得到的都是同一个对象，这其实就是枚举保持单例的原理。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wetts.github.io/2021/05/13/%E8%AF%AD%E8%A8%80/Java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%BE%8B/Java-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E9%97%AE%E9%A2%98%EF%BC%88%E5%8F%8D%E5%B0%84%E3%80%81%E5%BA%8F%E5%88%97%E5%8C%96%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Zhang Wetts">
      <meta itemprop="description" content="Stay Hungry, Stay Foolish. <br><br><p style="font-size:8px;">[build by hexo/next/gitalk/hexo-generator-search/LaTeX]</p>">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wetts's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/13/%E8%AF%AD%E8%A8%80/Java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%BE%8B/Java-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E9%97%AE%E9%A2%98%EF%BC%88%E5%8F%8D%E5%B0%84%E3%80%81%E5%BA%8F%E5%88%97%E5%8C%96%EF%BC%89/" class="post-title-link" itemprop="url">Java-设计模式-单例模式问题（反射、序列化）.md</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-05-13 21:12:07" itemprop="dateCreated datePublished" datetime="2021-05-13T21:12:07+08:00">2021-05-13</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>参考：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/call-me-pengye/p/11169051.html%E3%80%81https://zhuanlan.zhihu.com/p/144092983">https://www.cnblogs.com/call-me-pengye/p/11169051.html、https://zhuanlan.zhihu.com/p/144092983</a></p>
<p>使用枚举(《Effective Java》作者的Josh Bloch提倡的方式)</p>
<h3 id="破环单例模式的方式"><a href="#破环单例模式的方式" class="headerlink" title="破环单例模式的方式"></a>破环单例模式的方式</h3><p>破环单例模式的三种方式：反射，序列化，克隆</p>
<p>以双重检测方式为例测试反射，序列化，克隆是否能破环单例模式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton  implements Serializable,Cloneable&#123;</span><br><span class="line">    private static final long serialVersionUID = 6125990676610180062L;</span><br><span class="line">    private static Singleton singleton;</span><br><span class="line">    </span><br><span class="line">    private Singleton()&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    public void doAction()&#123;</span><br><span class="line">        //TODO 实现你需要做的事</span><br><span class="line">    &#125;</span><br><span class="line">    public  static Singleton getInstance()&#123;</span><br><span class="line">        if (singleton == null) &#123;</span><br><span class="line">            synchronized (Singleton.class) &#123;</span><br><span class="line">                if (singleton == null) &#123;</span><br><span class="line">                    singleton = new Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return singleton;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    protected Object clone() throws CloneNotSupportedException &#123;</span><br><span class="line">        return super.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试用例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public class DestroySingleton &#123;</span><br><span class="line">    </span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        //通过getInstance()获取</span><br><span class="line">        Singleton singleton = Singleton.getInstance();</span><br><span class="line">        System.out.println(&quot;singleton的hashCode:&quot;+singleton.hashCode());</span><br><span class="line">        //通过反射获取</span><br><span class="line">        Constructor&lt;Singleton&gt; constructor = Singleton.class.getDeclaredConstructor();</span><br><span class="line">        constructor.setAccessible(true);</span><br><span class="line">        Singleton reflex = constructor.newInstance();</span><br><span class="line">        System.out.println(&quot;reflex的hashCode:&quot;+reflex.hashCode());</span><br><span class="line">        //通过克隆获取</span><br><span class="line">        Singleton clob = (Singleton) Singleton.getInstance().clone();</span><br><span class="line">        System.out.println(&quot;clob的hashCode:&quot;+clob.hashCode());</span><br><span class="line">        //通过序列化，反序列化获取</span><br><span class="line">        ByteArrayOutputStream bos = new ByteArrayOutputStream();</span><br><span class="line">        ObjectOutputStream oos = new ObjectOutputStream(bos);</span><br><span class="line">        oos.writeObject(Singleton.getInstance());</span><br><span class="line">        ByteArrayInputStream bis = new ByteArrayInputStream(bos.toByteArray());</span><br><span class="line">        ObjectInputStream ois = new ObjectInputStream(bis);</span><br><span class="line">        Singleton serialize = (Singleton) ois.readObject();</span><br><span class="line">        if (ois != null)    ois.close();</span><br><span class="line">        if (bis != null) bis.close();</span><br><span class="line">        if (oos != null) oos.close();</span><br><span class="line">        if (bos != null) bos.close();</span><br><span class="line">        System.out.println(&quot;serialize的hashCode:&quot;+serialize.hashCode());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">singleton的hashCode:366712642</span><br><span class="line">reflex的hashCode:1829164700</span><br><span class="line">clob的hashCode:2018699554</span><br><span class="line">serialize的hashCode:990368553</span><br></pre></td></tr></table></figure>

<p>运行结果表明通过 getInstance()、反射、克隆、序列化这四种方式得到的 Singleton 对象的 hashCode 是不一样的，此时单例模式已然被破环</p>
<h3 id="如何防止反射、克隆、序列化对单例模式的破环"><a href="#如何防止反射、克隆、序列化对单例模式的破环" class="headerlink" title="如何防止反射、克隆、序列化对单例模式的破环"></a>如何防止反射、克隆、序列化对单例模式的破环</h3><ul>
<li>防止反射破环（虽然构造方法已私有化，但通过反射机制使用 newInstance() 方法构造方法也是可以被调用）:<ul>
<li>首先定义一个全局变量开关 isFristCreate 默认为开启状态</li>
<li>当第一次加载时将其状态更改为关闭状态</li>
</ul>
</li>
<li>防止克隆破环<ul>
<li>重写 clone()，直接返回单例对象</li>
</ul>
</li>
<li>防止序列化破环<ul>
<li>添加 readResolve()，返回 Object 对象</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton  implements Serializable,Cloneable&#123;</span><br><span class="line">    private static final long serialVersionUID = 6125990676610180062L;</span><br><span class="line">    private static Singleton singleton;</span><br><span class="line">    private static boolean isFristCreate = true;//默认是第一次创建</span><br><span class="line">    </span><br><span class="line">    private Singleton() &#123;</span><br><span class="line">            if (isFristCreate) &#123;</span><br><span class="line">                synchronized (Singleton.class) &#123;</span><br><span class="line">                    if (isFristCreate) &#123;</span><br><span class="line">                        sFristCreate = false;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                throw new RuntimeException(&quot;已然被实例化一次，不能在实例化&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public void doAction()&#123;</span><br><span class="line">        //TODO 实现你需要做的事</span><br><span class="line">    &#125;</span><br><span class="line">    public static Singleton getInstance()&#123;</span><br><span class="line">        if (singleton == null) &#123;</span><br><span class="line">            synchronized (Singleton.class) &#123;</span><br><span class="line">                if (singleton == null) &#123;</span><br><span class="line">                    singleton = new Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return singleton;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    protected Singleton clone() throws CloneNotSupportedException &#123;</span><br><span class="line">        return singleton;</span><br><span class="line">    &#125;</span><br><span class="line">    private Object readResolve() &#123;</span><br><span class="line">        return singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试用例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public class DestroySingleton &#123;</span><br><span class="line">    </span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        //通过getInstance()获取</span><br><span class="line">        Singleton singleton = Singleton.getInstance();</span><br><span class="line">        System.out.println(&quot;singleton的hashCode:&quot;+singleton.hashCode());</span><br><span class="line">        //通过克隆获取</span><br><span class="line">        Singleton clob = (Singleton) Singleton.getInstance().clone();</span><br><span class="line">        System.out.println(&quot;clob的hashCode:&quot;+clob.hashCode());</span><br><span class="line">        //通过序列化，反序列化获取</span><br><span class="line">        ByteArrayOutputStream bos = new ByteArrayOutputStream();</span><br><span class="line">        ObjectOutputStream oos = new ObjectOutputStream(bos);</span><br><span class="line">        oos.writeObject(Singleton.getInstance());</span><br><span class="line">        ByteArrayInputStream bis = new ByteArrayInputStream(bos.toByteArray());</span><br><span class="line">        ObjectInputStream ois = new ObjectInputStream(bis);</span><br><span class="line">        Singleton serialize = (Singleton) ois.readObject();</span><br><span class="line">        if (ois != null)    ois.close();</span><br><span class="line">        if (bis != null) bis.close();</span><br><span class="line">        if (oos != null) oos.close();</span><br><span class="line">        if (bos != null) bos.close();</span><br><span class="line">        System.out.println(&quot;serialize的hashCode:&quot;+serialize.hashCode());</span><br><span class="line">        //通过反射获取</span><br><span class="line">        Constructor&lt;Singleton&gt; constructor = Singleton.class.getDeclaredConstructor();</span><br><span class="line">        constructor.setAccessible(true);</span><br><span class="line">        Singleton reflex = constructor.newInstance();</span><br><span class="line">        System.out.println(&quot;reflex的hashCode:&quot;+reflex.hashCode());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">singleton的hashCode:366712642</span><br><span class="line">clob的hashCode:366712642</span><br><span class="line">serialize的hashCode:366712642</span><br><span class="line">Exception in thread &quot;main&quot; java.lang.reflect.InvocationTargetException</span><br><span class="line">    at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)</span><br><span class="line">    at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:62)</span><br><span class="line">    at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)</span><br><span class="line">    at java.lang.reflect.Constructor.newInstance(Constructor.java:423)</span><br><span class="line">    at designPatterns.singleton.doublecheck.DestroySingleton.main(DestroySingleton.java:33)</span><br><span class="line">Caused by: java.lang.RuntimeException: 已然被实例化一次，不能在实例化</span><br><span class="line">    at designPatterns.singleton.doublecheck.Singleton.&lt;init&gt;(Singleton.java:16)</span><br><span class="line">    ... 5 more</span><br></pre></td></tr></table></figure>

<p>从运行结果上看重写 clone()，添加 readResolve() 后通过克隆和序列化得到的对象的 hashCode 与从 getInstance() 得到的对象得而 hashCode 值相同，而通过反射运行得到的结果符合预想的报错；因为以上三种手段对防止单例被破坏起作用了</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wetts.github.io/2021/05/13/%E8%AF%AD%E8%A8%80/Java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%BE%8B/Java-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Zhang Wetts">
      <meta itemprop="description" content="Stay Hungry, Stay Foolish. <br><br><p style="font-size:8px;">[build by hexo/next/gitalk/hexo-generator-search/LaTeX]</p>">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wetts's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/13/%E8%AF%AD%E8%A8%80/Java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%BE%8B/Java-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/" class="post-title-link" itemprop="url">Java-设计模式-单例模式.md</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-05-13 20:32:26" itemprop="dateCreated datePublished" datetime="2021-05-13T20:32:26+08:00">2021-05-13</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>转自：<a target="_blank" rel="noopener" href="https://blog.csdn.net/zzti_erlie/article/details/80714424">https://blog.csdn.net/zzti_erlie/article/details/80714424</a></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>有一些对象其实我们只需要一个，比方说：线程池，缓存，对话框，处理偏好设置和注册表的对象，日志对象，充当打印机，显卡等设备的驱动程序的对象。事实上，这类对象只能有一个实例，如果制造出多个实例，就会导致许多问题产生，例如：程序的行为异常，资源使用过量，或者是不一致的结果</p>
<p>单例模式确保一个类只有一个实例，并提供一个全局访问点，实现单例模式的方法是私有化构造函数，通过 <code>getInstance()</code> 方法实例化对象，并返回这个实例</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="第一种（懒汉）"><a href="#第一种（懒汉）" class="headerlink" title="第一种（懒汉）"></a>第一种（懒汉）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// code1</span><br><span class="line">public class Singleton &#123;</span><br><span class="line"></span><br><span class="line">    private static Singleton uniqueInstance;</span><br><span class="line"></span><br><span class="line">    private Singleton() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    public static Singleton getInstance() &#123;</span><br><span class="line">        if (uniqueInstance == null) &#123;</span><br><span class="line">            uniqueInstance = new Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        return uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当2个线程同时进入 <code>getInstance()</code> 的 if 语句里面，会返回 2 个不同实例，因此这种方式是线程不安全的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// code2</span><br><span class="line">public class Singleton &#123;</span><br><span class="line"></span><br><span class="line">    private static Singleton uniqueInstance;</span><br><span class="line"></span><br><span class="line">    private Singleton() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    public static synchronized Singleton getInstance() &#123;</span><br><span class="line">        if (uniqueInstance == null) &#123;</span><br><span class="line">            uniqueInstance = new Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        return uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用 synchronized 修饰可以保证线程安全，但是只有第一次执行此方法时才需要同步，设置好 uniqueInstance，就不需要同步这个方法了，之后每次调用这个方法，同步都是一种累赘</p>
<h3 id="第二种（双重检查锁定）"><a href="#第二种（双重检查锁定）" class="headerlink" title="第二种（双重检查锁定）"></a>第二种（双重检查锁定）</h3><p>synchronized 锁的粒度太大，人们就想到通过双重检查锁定来降低同步的开销，下面是实例代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// code3</span><br><span class="line">public class Singleton &#123;</span><br><span class="line"></span><br><span class="line">    private static Singleton uniqueInstance;</span><br><span class="line"></span><br><span class="line">    private Singleton() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    public static Singleton getInstance() &#123;</span><br><span class="line">        if (uniqueInstance == null) &#123;</span><br><span class="line">            synchronized (Singleton.class) &#123;</span><br><span class="line">                if (uniqueInstance == null) &#123;</span><br><span class="line">                    uniqueInstance = new Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上面代码所示，如果第一次检查 uniqueInstance 不为 null，那么就不需要执行下面的加锁和初始化操作，可以大幅降低 synchronized 带来的性能开销，只有在多个线程试图在同一时间创建对象时，会通过加锁来保证只有一个线程能创建对象</p>
<p>经常有人对 code3 中，为什么要执行 2 次 if 语句不太清楚，简单描述一下，有可能有 AB 2 个线程同时进入了第一个 if 语句，然后 A 拿到锁，创建对象完成。如果不再做一次判空处理的话，B 拿到锁后会重新创建对象，加了第 2 个 if 语句，就直接退出了</p>
<p>双重检查锁定看起来似乎很完美，但这是一个错误的优化！在线程执行到 <code>getInstance()</code> 方法的第 4 行，代码读取到 uniqueInstance 不为 null 时，uniqueInstance 引用的对象有可能还没有完成初始化</p>
<p>简单概述一下《Java并发编程的艺术》的解释，<code>uniqueInstance = new Singleton()</code> 可以分解为如下三行伪代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">memory = allocate();    // 1:分配对象的内存空间</span><br><span class="line">ctorInstance(memory);   // 2:初始化对象</span><br><span class="line">uniqueInstance = memory;// 3:设置uniqueInstance指向刚分配的内存地址</span><br></pre></td></tr></table></figure>

<p>3 行伪代码中的 2 和 3 之间，可能会被重排序，重排序后执行时序如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">memory = allocate();    // 1:分配对象的内存空间</span><br><span class="line">uniqueInstance = memory;// 3:设置uniqueInstance指向刚分配的内存地址</span><br><span class="line">                        // 注意，此时对象还没有被初始化</span><br><span class="line">ctorInstance(memory);   // 2:初始化对象</span><br></pre></td></tr></table></figure>

<p>多个线程访问时可能出现如下情况<br>|时间|线程A|线程B|<br>|—-|—-|—-|<br>|t1|A1：分配对象的内存空间||<br>|t2|A3：设置uniqueinstance指向内存空间||<br>|t3||B1：判断uniqueinstance是否为空|<br>|t4||B2：由于uniqueinstace不为null,线程B间访问uniqueinstance引用的对象|<br>|t5|A2：初始化对象||<br>|t6|A4：访问instace引用的对象||</p>
<p>这样会导致线程 B 访问到一个还未初始化的对象，此时可以用 volatile 来修饰 Singleton，这样 3 行伪代码中的 2 和 3 之间的重排序，在多线程环境中将会被禁止</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// code4</span><br><span class="line">public class Singleton &#123;</span><br><span class="line"></span><br><span class="line">    private volatile static Singleton uniqueInstance;</span><br><span class="line"></span><br><span class="line">    private Singleton() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    public static Singleton getInstance() &#123;</span><br><span class="line">        if (uniqueInstance == null) &#123;</span><br><span class="line">            synchronized (Singleton.class) &#123;</span><br><span class="line">                if (uniqueInstance == null) &#123;</span><br><span class="line">                    uniqueInstance = new Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第三种（饿汉）"><a href="#第三种（饿汉）" class="headerlink" title="第三种（饿汉）"></a>第三种（饿汉）</h3><p>如果应用程序总是创建并使用单例式例，或者在创建和运行时方面的负担不太繁重，我们可以以饿汉式的方式来创建单例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// code5</span><br><span class="line">public class Singleton &#123;</span><br><span class="line"></span><br><span class="line">    private static Singleton uniqueInstance = new Singleton();</span><br><span class="line"></span><br><span class="line">    private Singleton() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    public static Singleton getInstance() &#123;</span><br><span class="line">        return uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// code6</span><br><span class="line">public class Singleton &#123;</span><br><span class="line"></span><br><span class="line">    private static Singleton uniqueInstance;</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        uniqueInstance = new Singleton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private Singleton() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    public static Singleton getInstance() &#123;</span><br><span class="line">        return uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在类加载的时候直接创建这个对象，这样既能提高效率，又能保证线程安全，code5和code6几乎没有区别，因为静态成员变量和静态代码块都是类初始化的时候被加载</p>
<h3 id="第四种（静态内部类）"><a href="#第四种（静态内部类）" class="headerlink" title="第四种（静态内部类）"></a>第四种（静态内部类）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// code7</span><br><span class="line">public class Singleton &#123;</span><br><span class="line"></span><br><span class="line">    private static class SingletonHolder &#123;</span><br><span class="line">        private static Singleton uniqueInstance = new Singleton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private Singleton() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    public static Singleton getInstance() &#123;</span><br><span class="line">        return SingletonHolder.uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>饿汉式的方式只要 Singleton 类被装载了，那么 uniqueInstance 就会被实例化（没有达到 lazy loading 效果），而这种方式是 Singleton 类被装载了，uniqueInstance 不一定被初始化。因为 SingletonHolder 类没有被主动使用，只有显示通过调用 getInstance 方法时，才会显示装载 SingletonHolder 类，从而实例化 uniqueInstance</p>
<h3 id="第五种（枚举）"><a href="#第五种（枚举）" class="headerlink" title="第五种（枚举）"></a>第五种（枚举）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// code8</span><br><span class="line">public enum Singleton &#123;</span><br><span class="line"></span><br><span class="line">    INSTANCE;</span><br><span class="line"></span><br><span class="line">    public void doSomething() &#123;</span><br><span class="line">        System.out.println(&quot;单例对象的一个方法&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Singleton.INSTANCE.doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过 Singleton.INSTANCE 来获取枚举对象。</p>
<p>用枚举实现单例模式可以避免如下 2 个问题，其他四种方式都不能避免</p>
<ol>
<li>序列化造成单例模式不安全</li>
<li>反射造成单例模式不安全</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wetts.github.io/2021/05/11/%E8%AF%AD%E8%A8%80/Java/basic_Java/API/%E5%AE%B9%E5%99%A8/Java-API-%E5%AE%B9%E5%99%A8-HashMap/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Zhang Wetts">
      <meta itemprop="description" content="Stay Hungry, Stay Foolish. <br><br><p style="font-size:8px;">[build by hexo/next/gitalk/hexo-generator-search/LaTeX]</p>">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wetts's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/11/%E8%AF%AD%E8%A8%80/Java/basic_Java/API/%E5%AE%B9%E5%99%A8/Java-API-%E5%AE%B9%E5%99%A8-HashMap/" class="post-title-link" itemprop="url">Java-API-容器-HashMap.md</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-05-11 19:19:02" itemprop="dateCreated datePublished" datetime="2021-05-11T19:19:02+08:00">2021-05-11</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>转自：<a target="_blank" rel="noopener" href="https://blog.csdn.net/zzti_erlie/article/details/79823187">https://blog.csdn.net/zzti_erlie/article/details/79823187</a></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>HashMap 是怎么实现的？</p>
<ol>
<li>jdk1.7 的 HashMap 是用数组+链表实现的</li>
<li>jdk1.8 的 HashMap 是用数组+链表+红黑树实现的</li>
</ol>
<p><img src="/2021/05/11/%E8%AF%AD%E8%A8%80/Java/basic_Java/API/%E5%AE%B9%E5%99%A8/Java-API-%E5%AE%B9%E5%99%A8-HashMap/1.png" alt="1"></p>
<p>HashMap 的主干是一个数组，假设我们有 3 个键值对 dnf:1，cf:2，lol:3，每次放的时候会根据 <code>key.hash % table.length</code>（对象的 hashcode 进行一些操作后对数组的长度取余）确定这个键值对应该放在数组的哪个位位置</p>
<p><code>1 = indexFor(dnf)</code>，我们将键值对放在数组下标为 1 的位置<br><img src="/2021/05/11/%E8%AF%AD%E8%A8%80/Java/basic_Java/API/%E5%AE%B9%E5%99%A8/Java-API-%E5%AE%B9%E5%99%A8-HashMap/2.png" alt="2"></p>
<p><code>3 = indexFor(cf)</code><br><img src="/2021/05/11/%E8%AF%AD%E8%A8%80/Java/basic_Java/API/%E5%AE%B9%E5%99%A8/Java-API-%E5%AE%B9%E5%99%A8-HashMap/3.png" alt="3"></p>
<p><code>1 = indexFor(lol)</code>，这时发现数组下标为 1 的位置已经有值了，我们把 lol:3 放到链表的第一位，将原先的 dnf:1 用链表的形式放到 lol 键值对的下面</p>
<ul>
<li>jdk1.7 是头插法</li>
<li>jdk1.8 是尾插法<br><img src="/2021/05/11/%E8%AF%AD%E8%A8%80/Java/basic_Java/API/%E5%AE%B9%E5%99%A8/Java-API-%E5%AE%B9%E5%99%A8-HashMap/4.png" alt="4"></li>
</ul>
<p>在获取 key 为 dnf 的键值对时，<code>1=hash(dnf)</code>，得到这个键值对在数组下标为1的位置，dnf 和 lol 不相等，和下一个元素比较，相等返回。set 和 get 的过程就是这么简单。先定位到槽的位置（即数组中的位置），再遍历链表找到相同的元素。</p>
<p>由上图可以看出，HashMap 在发生 hash 冲突的时候用的是链地址法，解决 hash 冲突并不只有这一种方法，常见的有如下四种方法：</p>
<ol>
<li>开放定址法</li>
<li>链地址法</li>
<li>再哈希法</li>
<li>公共溢出区域法。</li>
</ol>
<h2 id="JDK1-7源码"><a href="#JDK1-7源码" class="headerlink" title="JDK1.7源码"></a>JDK1.7源码</h2><p>几个重要的属性</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">//初始容量是16，且容量必须是2的倍数</span><br><span class="line">static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4;</span><br><span class="line"></span><br><span class="line">//最大容量是2的30次方</span><br><span class="line">static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;</span><br><span class="line"></span><br><span class="line">//负载因子</span><br><span class="line">static final float DEFAULT_LOAD_FACTOR = 0.75f;</span><br><span class="line"></span><br><span class="line">static final Entry&lt;?,?&gt;[] EMPTY_TABLE = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">//HashMap的主干是一个Entry数组,在需要的时候进行扩容，长度必须是2的被数</span><br><span class="line">transient Entry&lt;K,V&gt;[] table = (Entry&lt;K,V&gt;[]) EMPTY_TABLE;</span><br><span class="line"></span><br><span class="line">//放置的key-value对的个数</span><br><span class="line">transient int size;</span><br><span class="line"></span><br><span class="line">//进行扩容的阈值，值为 capacity * load factor，即容量 * 负载因子</span><br><span class="line">int threshold;</span><br><span class="line"></span><br><span class="line">//负载因子</span><br><span class="line">final float loadFactor;</span><br></pre></td></tr></table></figure>

<p>这里说一下 threshold 和 loadFactor，<code>threshold = capacity * load factor</code>，即 <code>扩容的阈值=数组长度 * 负载因子</code>，如果 hashmap 数组的长度为 16，负载因子为 0.75，则扩容阈值为 16*0.75=12。</p>
<ul>
<li>负载因子越小，容易扩容，浪费空间，但查找效率高</li>
<li>负载因子越大，不易扩容，对空间的利用更加充分，查找效率低（链表拉长）</li>
</ul>
<p>存储数据的静态内部类，数组+链表，这里的数组指的就是 Entry 数组</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">static class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;</span><br><span class="line">	final K key;</span><br><span class="line">	V value;</span><br><span class="line">	Entry&lt;K,V&gt; next;//存储指向下一个Entry的引用，单链表结构</span><br><span class="line">	int hash;//对key的hashcode值进行hash运算后得到的值，存储在Entry，避免重复计算</span><br><span class="line"></span><br><span class="line">	Entry(int h, K k, V v, Entry&lt;K,V&gt; n) &#123;</span><br><span class="line">		value = v;</span><br><span class="line">		next = n;</span><br><span class="line">		key = k;</span><br><span class="line">		hash = h;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>其他都是在此基础上的扩展，主要就是设置初始容量和负载因子，这 2 个参数前面介绍过了哈。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public HashMap(int initialCapacity, float loadFactor) &#123;</span><br><span class="line">	if (initialCapacity &lt; 0)</span><br><span class="line">		throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; +</span><br><span class="line">				initialCapacity);</span><br><span class="line">	if (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">		initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">	if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))</span><br><span class="line">		throw new IllegalArgumentException(&quot;Illegal load factor: &quot; +</span><br><span class="line">				loadFactor);</span><br><span class="line"></span><br><span class="line">	this.loadFactor = loadFactor;</span><br><span class="line">	threshold = initialCapacity;</span><br><span class="line">	init();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="put-方法的执行过程"><a href="#put-方法的执行过程" class="headerlink" title="put 方法的执行过程"></a>put 方法的执行过程</h3><ol>
<li>key 为 null 直接放在 <code>table[0]</code> 处，对 key 的 <code>hashCode()</code> 做 hash 运算，计算 index;</li>
<li>如果节点已经存在就替换 old value（保证 key 的唯一性），并返回 old Value</li>
<li>如果达到扩容的阈值（超过 capacity * load factor），并且发生碰撞，就要 resize</li>
<li>将元素放到 bucket 的首位，即头插法</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public V put(K key, V value) &#123;</span><br><span class="line">	//hashmap的数组为空</span><br><span class="line">	if (table == EMPTY_TABLE) &#123;</span><br><span class="line">		inflateTable(threshold);</span><br><span class="line">	&#125;</span><br><span class="line">	if (key == null)</span><br><span class="line">		return putForNullKey(value);</span><br><span class="line">	//获取hash值</span><br><span class="line">	int hash = hash(key);</span><br><span class="line">	//找到应该放到table的哪个位置</span><br><span class="line">	int i = indexFor(hash, table.length);</span><br><span class="line">	//遍历table[i]位置的链表，查找相同的key,若找到则使用新的value替换oldValue,并返回oldValue</span><br><span class="line">	for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) &#123;</span><br><span class="line">		Object k;</span><br><span class="line">		//如果key已经存在，将value设置为新的，并返回旧的value值</span><br><span class="line">		if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">			V oldValue = e.value;</span><br><span class="line">			e.value = value;</span><br><span class="line">			e.recordAccess(this);</span><br><span class="line">			return oldValue;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	modCount++;</span><br><span class="line">	//将元素放到table[i]，新的元素总在table[i]位置的第一个元素，原来的元素后移</span><br><span class="line">	addEntry(hash, key, value, i);</span><br><span class="line">	return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为空时，HashMap 还没有创建这个数组，有可能用的是默认的 16 的初始值，还有可能自定义了长度，这时需要把数组长度变为 2 的最小倍数，并且这个 2 的倍数大于等于初始容量</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">private void inflateTable(int toSize) &#123;</span><br><span class="line">	//返回大于或等于最接近2的幂数</span><br><span class="line">	int capacity = roundUpToPowerOf2(toSize);</span><br><span class="line"></span><br><span class="line">	threshold = (int) Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + 1);</span><br><span class="line">	table = new Entry[capacity];</span><br><span class="line">	initHashSeedAsNeeded(capacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>若 key 为 null，则将值放在 table[0] 这个链上</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">private V putForNullKey(V value) &#123;</span><br><span class="line">	for (Entry&lt;K,V&gt; e = table[0]; e != null; e = e.next) &#123;</span><br><span class="line">		if (e.key == null) &#123;</span><br><span class="line">			V oldValue = e.value;</span><br><span class="line">			e.value = value;</span><br><span class="line">			e.recordAccess(this);</span><br><span class="line">			return oldValue;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	modCount++;</span><br><span class="line">	addEntry(0, null, value, 0);</span><br><span class="line">	return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>找到应该放在数组的位置，<code>h &amp; (length-1)</code> 这个式子你可以认为 hash 值对数组长度取余，后面会说到这个式子</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static int indexFor(int h, int length) &#123;</span><br><span class="line">	// assert Integer.bitCount(length) == 1 : &quot;length must be a non-zero power of 2&quot;;</span><br><span class="line">	return h &amp; (length-1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>添加元素</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void addEntry(int hash, K key, V value, int bucketIndex) &#123;</span><br><span class="line">	// 容量超过阈值，并且发生碰撞时进行扩容</span><br><span class="line">	if ((size &gt;= threshold) &amp;&amp; (null != table[bucketIndex])) &#123;</span><br><span class="line">		// 数组扩容为原来的2倍，并将元素复制到新数组上</span><br><span class="line">		resize(2 * table.length);</span><br><span class="line">		// 重新计算hash值，如果不做特殊设置的话，和之前算出来的hash值一样</span><br><span class="line">		hash = (null != key) ? hash(key) : 0;</span><br><span class="line">		bucketIndex = indexFor(hash, table.length);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	createEntry(hash, key, value, bucketIndex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将新增加的元素放到table的第一位，并且将其他元素跟在第一个元素后面</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void createEntry(int hash, K key, V value, int bucketIndex) &#123;</span><br><span class="line">	Entry&lt;K,V&gt; e = table[bucketIndex];</span><br><span class="line">	table[bucketIndex] = new Entry&lt;&gt;(hash, key, value, e);</span><br><span class="line">	size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>容量超过阈值并且发生碰撞，开始扩容</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void resize(int newCapacity) &#123;</span><br><span class="line">    Entry[] oldTable = table;</span><br><span class="line">    int oldCapacity = oldTable.length;</span><br><span class="line">    //容量已经达到最大</span><br><span class="line">    if (oldCapacity == MAXIMUM_CAPACITY) &#123;</span><br><span class="line">        threshold = Integer.MAX_VALUE;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Entry[] newTable = new Entry[newCapacity];</span><br><span class="line">    transfer(newTable, initHashSeedAsNeeded(newCapacity));</span><br><span class="line">    table = newTable;</span><br><span class="line">    threshold = (int)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + 1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重新计算元素在新的数组中的位置，并进行复制处理，initHashSeedAsNeeded 函数默认情况下会一直返回false，即 rehash 在默认情况下为 false</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">void transfer(Entry[] newTable, boolean rehash) &#123;</span><br><span class="line">    int newCapacity = newTable.length;</span><br><span class="line">    // 遍历数组</span><br><span class="line">    for (Entry&lt;K,V&gt; e : table) &#123;</span><br><span class="line">        // 遍历链表</span><br><span class="line">        while(null != e) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">            if (rehash) &#123;</span><br><span class="line">                e.hash = null == e.key ? 0 : hash(e.key);</span><br><span class="line">            &#125;</span><br><span class="line">            int i = indexFor(e.hash, newCapacity);</span><br><span class="line">            e.next = newTable[i];</span><br><span class="line">            newTable[i] = e;</span><br><span class="line">            e = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个 transfer 函数挺有意思的，如果你仔细理解它的复制过程，会发现有如下 2 个特别有意思的地方</p>
<ol>
<li>原来在 <code>oldTable[i]</code> 位置的元素，会被放到 <code>newTable[i]</code> 或者 <code>newTable[i+oldTable.length]</code> 的位置</li>
<li>链表在复制的时候会反转</li>
</ol>
<p>这 2 个点需要注意一下，我会在 JDK1.8 中再次提到这 2 个点</p>
<h3 id="get-方法的执行过程"><a href="#get-方法的执行过程" class="headerlink" title="get 方法的执行过程"></a>get 方法的执行过程</h3><ol>
<li>key 为 null 直接从 <code>table[0]</code> 处取，对 key 用 <code>hashCode()</code> 做 hash 运算，计算 index;</li>
<li>通过 <code>key.equals(k)</code> 去查找对应的 Entry，接着返回 value<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public V get(Object key) &#123;</span><br><span class="line">	if (key == null)</span><br><span class="line">		return getForNullKey();</span><br><span class="line">	Entry&lt;K,V&gt; entry = getEntry(key);</span><br><span class="line"></span><br><span class="line">	return null == entry ? null : entry.getValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>从 <code>table[0]</code> 初获取 key 为 null 的值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">private V getForNullKey() &#123;</span><br><span class="line">	if (size == 0) &#123;</span><br><span class="line">		return null;</span><br><span class="line">	&#125;</span><br><span class="line">	for (Entry&lt;K,V&gt; e = table[0]; e != null; e = e.next) &#123;</span><br><span class="line">		if (e.key == null)</span><br><span class="line">			return e.value;</span><br><span class="line">	&#125;</span><br><span class="line">	return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>key 不为 null 时</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">final Entry&lt;K,V&gt; getEntry(Object key) &#123;</span><br><span class="line">	if (size == 0) &#123;</span><br><span class="line">		return null;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	int hash = (key == null) ? 0 : hash(key);</span><br><span class="line">	for (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)]; e != null; e = e.next) &#123;</span><br><span class="line">		Object k;</span><br><span class="line">		if (e.hash == hash &amp;&amp;</span><br><span class="line">			((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">			return e;</span><br><span class="line">	&#125;</span><br><span class="line">	return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="JDK1-8-源码"><a href="#JDK1-8-源码" class="headerlink" title="JDK1.8 源码"></a>JDK1.8 源码</h2><p>jdk1.8 存取 key 为 null 的数据并没有进行特判，而是通过将 hash 值返回为 0 将其放在 table[0] 处</p>
<h3 id="put-执行过程"><a href="#put-执行过程" class="headerlink" title="put 执行过程"></a>put 执行过程</h3><ol>
<li>对 key 的 hashcode() 高 16 位和低 16 位进行异或运算求出具体的 hash 值</li>
<li>如果 table 数组没有初始化，则初始化 table 数组长度为 16</li>
<li>根据 hash 值计算 index，如果没碰撞则直接放到 bucket 里（bucket 可为链表或者红黑树）</li>
<li>如果碰撞导致链表过长，就把链表转为红黑树</li>
<li>如果 key 已经存在，用 new value 替换 old value，并返回 old value</li>
<li>如果超过扩容的阈值则进行扩容，<code>threshold = capacity * load factor</code></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public V put(K key, V value) &#123;</span><br><span class="line">	return putVal(hash(key), key, value, false, true);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">static final int hash(Object key) &#123;</span><br><span class="line">	int h;</span><br><span class="line">	// 对象的hashCode高16位和低16位进行异或操作</span><br><span class="line">	return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">final V putVal(int hash, K key, V value, boolean onlyIfAbsent,</span><br><span class="line">			   boolean evict) &#123;</span><br><span class="line">	Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;</span><br><span class="line">	// 如果HashMap的初始容量没有指定，则为16</span><br><span class="line">	if ((tab = table) == null || (n = tab.length) == 0)</span><br><span class="line">		n = (tab = resize()).length;</span><br><span class="line">	// 用hash值求出bucket的位置</span><br><span class="line">	if ((p = tab[i = (n - 1) &amp; hash]) == null)</span><br><span class="line">		// bucket位置上没有放元素,放置第一个元素</span><br><span class="line">		tab[i] = newNode(hash, key, value, null);</span><br><span class="line">	else &#123;</span><br><span class="line">		// bucket位置上已经有了元素</span><br><span class="line">		Node&lt;K,V&gt; e; K k;</span><br><span class="line">		// 有同名key存在</span><br><span class="line">		if (p.hash == hash &amp;&amp;</span><br><span class="line">			((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">			e = p;</span><br><span class="line">		else if (p instanceof TreeNode)</span><br><span class="line">			// 判断该链为红黑树</span><br><span class="line">			e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);</span><br><span class="line">		else &#123;</span><br><span class="line">			// 判断该链为链表</span><br><span class="line">			for (int binCount = 0; ; ++binCount) &#123;</span><br><span class="line">				if ((e = p.next) == null) &#123;</span><br><span class="line">					p.next = newNode(hash, key, value, null);</span><br><span class="line">					if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st</span><br><span class="line">						treeifyBin(tab, hash);</span><br><span class="line">					break;</span><br><span class="line">				&#125;</span><br><span class="line">				if (e.hash == hash &amp;&amp;</span><br><span class="line">					((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">					break;</span><br><span class="line">				p = e;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		if (e != null) &#123; // existing mapping for key</span><br><span class="line">			V oldValue = e.value;</span><br><span class="line">			if (!onlyIfAbsent || oldValue == null)</span><br><span class="line">				// key相等用新值替换旧值</span><br><span class="line">				e.value = value;</span><br><span class="line">			afterNodeAccess(e);</span><br><span class="line">			return oldValue;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	++modCount;</span><br><span class="line">	// 超过扩容阈值则扩容</span><br><span class="line">	if (++size &gt; threshold)</span><br><span class="line">		resize();</span><br><span class="line">	afterNodeInsertion(evict);</span><br><span class="line">	return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>移动的过程和 jdk1.7 相比变化比较大</p>
<p>jdk1.8 和 jdk1.7 重新获取元素值在新数组中所处的位置的算法发生了变化（实际效果没发生改变）</p>
<ol>
<li>jdk1.7，<code>hash &amp; (length-1)</code></li>
<li>jdk1.8，判断原来 hash 值要新增的 bit 位是 0 还是 1。假如是 0，放到 <code>newTable[i]</code>，否则放到 <code>newTable[i+oldTable.length]</code></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">final Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">	Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">	int oldCap = (oldTab == null) ? 0 : oldTab.length;</span><br><span class="line">	int oldThr = threshold;</span><br><span class="line">	int newCap, newThr = 0;</span><br><span class="line">	if (oldCap &gt; 0) &#123;</span><br><span class="line">		// 查过最大值就不再扩充</span><br><span class="line">		if (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">			threshold = Integer.MAX_VALUE;</span><br><span class="line">			return oldTab;</span><br><span class="line">		&#125;</span><br><span class="line">		// 没超过最大值，就扩充为原来的2倍</span><br><span class="line">		else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">				 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">			newThr = oldThr &lt;&lt; 1; // double threshold</span><br><span class="line">	&#125;</span><br><span class="line">	else if (oldThr &gt; 0) // initial capacity was placed in threshold</span><br><span class="line">		newCap = oldThr;</span><br><span class="line">	else &#123;               // zero initial threshold signifies using defaults</span><br><span class="line">		newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">		newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">	&#125;</span><br><span class="line">	// 重新计算扩容阈值</span><br><span class="line">	if (newThr == 0) &#123;</span><br><span class="line">		float ft = (float)newCap * loadFactor;</span><br><span class="line">		newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?</span><br><span class="line">				  (int)ft : Integer.MAX_VALUE);</span><br><span class="line">	&#125;</span><br><span class="line">	threshold = newThr;</span><br><span class="line">	@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span><br><span class="line">		Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];</span><br><span class="line">	table = newTab;</span><br><span class="line">	if (oldTab != null) &#123;</span><br><span class="line">		// 把每个bucket都移动到新的bucket中</span><br><span class="line">		for (int j = 0; j &lt; oldCap; ++j) &#123;</span><br><span class="line">			Node&lt;K,V&gt; e;</span><br><span class="line">			if ((e = oldTab[j]) != null) &#123;</span><br><span class="line">				oldTab[j] = null;</span><br><span class="line">				if (e.next == null)</span><br><span class="line">					newTab[e.hash &amp; (newCap - 1)] = e;</span><br><span class="line">				else if (e instanceof TreeNode)</span><br><span class="line">					((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);</span><br><span class="line">				else &#123; // preserve order</span><br><span class="line">					// 链表优化重hash的代码块</span><br><span class="line">					Node&lt;K,V&gt; loHead = null, loTail = null;</span><br><span class="line">					Node&lt;K,V&gt; hiHead = null, hiTail = null;</span><br><span class="line">					Node&lt;K,V&gt; next;</span><br><span class="line">					do &#123;</span><br><span class="line">						next = e.next;</span><br><span class="line">						if ((e.hash &amp; oldCap) == 0) &#123;</span><br><span class="line">							if (loTail == null)</span><br><span class="line">								loHead = e;</span><br><span class="line">							else</span><br><span class="line">								loTail.next = e;</span><br><span class="line">							loTail = e;</span><br><span class="line">						&#125;</span><br><span class="line">						else &#123;</span><br><span class="line">							if (hiTail == null)</span><br><span class="line">								hiHead = e;</span><br><span class="line">							else</span><br><span class="line">								hiTail.next = e;</span><br><span class="line">							hiTail = e;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125; while ((e = next) != null);</span><br><span class="line">					if (loTail != null) &#123;</span><br><span class="line">						loTail.next = null;</span><br><span class="line">						newTab[j] = loHead;</span><br><span class="line">					&#125;</span><br><span class="line">					if (hiTail != null) &#123;</span><br><span class="line">						hiTail.next = null;</span><br><span class="line">						newTab[j + oldCap] = hiHead;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="get-执行过程"><a href="#get-执行过程" class="headerlink" title="get 执行过程"></a>get 执行过程</h3><ol>
<li>对 key 的 hashcode() 高 16 位和低 16 位进行异或运算求出具体的 hash 值</li>
<li>如果在 bucket 里的第一个节点直接命中，则直接返回</li>
<li>如果有冲突，通过 key.equals(k) 去查找对应的 Node，并返回 value。在树中查找的效率为 O(logn)，在链表中查找的效率为 O(n)</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public V get(Object key) &#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    return (e = getNode(hash(key), key)) == null ? null : e.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">final Node&lt;K,V&gt; getNode(int hash, Object key) &#123;</span><br><span class="line">	Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k;</span><br><span class="line">	if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;</span><br><span class="line">		(first = tab[(n - 1) &amp; hash]) != null) &#123;</span><br><span class="line">		if (first.hash == hash &amp;&amp; // always check first node</span><br><span class="line">			((k = first.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">			return first;</span><br><span class="line">		if ((e = first.next) != null) &#123;</span><br><span class="line">			if (first instanceof TreeNode)</span><br><span class="line">				return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">			do &#123;</span><br><span class="line">				if (e.hash == hash &amp;&amp;</span><br><span class="line">					((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">					return e;</span><br><span class="line">			&#125; while ((e = e.next) != null);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="常见面试题"><a href="#常见面试题" class="headerlink" title="常见面试题"></a>常见面试题</h2><h3 id="HashMap，HashTable，ConcurrentHashMap-之间的区别"><a href="#HashMap，HashTable，ConcurrentHashMap-之间的区别" class="headerlink" title="HashMap，HashTable，ConcurrentHashMap 之间的区别"></a>HashMap，HashTable，ConcurrentHashMap 之间的区别</h3><table>
<thead>
<tr>
<th>对象</th>
<th>key和value是否允许为空</th>
<th>是否线程安全</th>
</tr>
</thead>
<tbody><tr>
<td>HashMap</td>
<td>key和value都允许为null</td>
<td>否</td>
</tr>
<tr>
<td>HashTable</td>
<td>key和value都不允许为null</td>
<td>是</td>
</tr>
<tr>
<td>ConcurrentHashMap</td>
<td>key和value都不允许为null</td>
<td>是</td>
</tr>
</tbody></table>
<h3 id="HashMap-在什么条件下扩容"><a href="#HashMap-在什么条件下扩容" class="headerlink" title="HashMap 在什么条件下扩容"></a>HashMap 在什么条件下扩容</h3><ul>
<li>jdk1.7<ol>
<li>超过扩容的阈值</li>
<li>发生碰撞</li>
</ol>
</li>
<li>jdk1.8<ol>
<li>超过扩容的阈值</li>
</ol>
</li>
</ul>
<h3 id="HashMap-的大小为什么是-2-n"><a href="#HashMap-的大小为什么是-2-n" class="headerlink" title="HashMap 的大小为什么是 2^n"></a>HashMap 的大小为什么是 2^n</h3><p>为了通过 hash 值确定元素在数组中存的位置，我们需要进行如下操作 <code>hash % length</code>，当时 % 操作比较耗时间，所以优化为 <code>hash &amp; (length - 1)</code></p>
<p>当 length 为 2 的 n 次方时，<code>hash &amp; (length - 1) = hash % length</code></p>
<p>我们假设数组的长度为 15 和 16，hash 码为 8 和 9<br>|h &amp; (length - 1)|h|length|index|<br>|—-|—-|—-|—-|<br>|8 &amp; (15 - 1)|0100|1110|0100|<br>|9 &amp; (15 - 1)|0101|1110|0100|<br>|8 &amp; (16 - 1)|0100|1111|0100|<br>|9 &amp; (16 - 1)|0101|1111|0101|</p>
<p>可以看出数组长度为 15 的时候，hash 码为 8 和 9 的元素被放到数组中的同一个位置形成链表，键低了查询效率，当 hash 码和 15-1(1110) 进行 &amp; 时，最后一位永远是 0，这样 0001，0011，0101，1001，1011，0111，1101 这些位置永远不会被放置元素，这样会导致</p>
<ol>
<li>空间浪费大</li>
<li>增加了碰撞的几率，减慢查询的效率</li>
</ol>
<p>当数组长度为 $2^n$ 时，$2^n − 1$ 的所有位都是 1，如 8-1=7 即 111，那么进行低位 &amp; 运算时，值总与原来的 hash 值相同，降低了碰撞的概率</p>
<h3 id="JDK1-8-发生了哪些变化？"><a href="#JDK1-8-发生了哪些变化？" class="headerlink" title="JDK1.8 发生了哪些变化？"></a>JDK1.8 发生了哪些变化？</h3><ol>
<li>由数组+链表改为数组+链表+红黑树，当链表的长度超过8时，链表变为红黑树。<ol>
<li>为什么要这么改？<ol>
<li>我们知道链表的查找效率为 $O(n)$，而红黑树的查找效率为 $O(logn)$，查找效率变高了。</li>
</ol>
</li>
<li>为什么不直接用红黑树？<ol>
<li>因为红黑树的查找效率虽然变高了，但是插入效率变低了，如果从一开始就用红黑树并不合适。从概率学的角度选了一个合适的临界值为 8</li>
</ol>
</li>
</ol>
</li>
<li>优化了 hash 算法</li>
<li>计算元素在新数组中位置的算法发生了变化，新算法通过新增位判断 <code>oldTable[i]</code> 应该放在 <code>newTable[i]</code> 还是 <code>newTable[i+oldTable.length]</code></li>
<li>头插法改为尾插法，扩容时链表没有发生倒置（避免形成死循环）</li>
</ol>
<h3 id="HashMap-在高并发下会发生什么问题？"><a href="#HashMap-在高并发下会发生什么问题？" class="headerlink" title="HashMap 在高并发下会发生什么问题？"></a>HashMap 在高并发下会发生什么问题？</h3><ol>
<li>多线程扩容，会让链表形成环，从而造成死循环</li>
<li>多线程 put 可能导致元素丢失</li>
</ol>
<p>jdk1.8 中死循环问题已经解决，元素丢失问题还存在</p>
<h3 id="如何避免-HashMap-在高并发下的问题？"><a href="#如何避免-HashMap-在高并发下的问题？" class="headerlink" title="如何避免 HashMap 在高并发下的问题？"></a>如何避免 HashMap 在高并发下的问题？</h3><ol>
<li>使用 ConcurrentHashMap</li>
<li>用 Collections.synchronizedMap(hashMap) 包装成同步集合</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wetts.github.io/2021/05/10/%E8%AF%AD%E8%A8%80/Java/basic_Java/API/%E5%AE%B9%E5%99%A8/Java-API-%E5%AE%B9%E5%99%A8-map/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Zhang Wetts">
      <meta itemprop="description" content="Stay Hungry, Stay Foolish. <br><br><p style="font-size:8px;">[build by hexo/next/gitalk/hexo-generator-search/LaTeX]</p>">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wetts's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/10/%E8%AF%AD%E8%A8%80/Java/basic_Java/API/%E5%AE%B9%E5%99%A8/Java-API-%E5%AE%B9%E5%99%A8-map/" class="post-title-link" itemprop="url">Java-API-容器-map.md</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-05-10 16:06:37" itemprop="dateCreated datePublished" datetime="2021-05-10T16:06:37+08:00">2021-05-10</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <ul>
<li><p>HashMap是一个最常用的 Map，它根据键的 hashCode 值存储数据，根据键可以直接获取它的值，具有很快的访问速度。HashMap 最多只允许一条记录的键为 NULL，允许多条记录的值为 NULL。</p>
</li>
<li><p>HashMap 不支持线程同步，即任一时刻可以有多个线程同时写 HashMap，可能会导致数据的不一致性。如果需要同步，可以用 Collections 的 synchronizedMap 方法使 HashMap 具有同步的能力。</p>
</li>
<li><p>Hashtable 与 HashMap 类似，不同的是：它不允许记录的键或者值为空；它支持线程的同步，即任一时刻只有一个线程能写 Hashtable，因此也导致了 Hashtable 在写入时会比较慢。</p>
</li>
<li><p>LinkedHashMap 保存了记录的插入顺序，在用 Iterator 遍历 LinkedHashMap 时，先得到的记录肯定是先插入的。在遍历的时候会比 HashMap 慢，不过有种情况例外，当 HashMap 容量很大，实际数据较少时，遍历起来可能会比 LinkedHashMap 慢，因为 LinkedHashMap 的遍历速度只和实际数据有关，和容量无关，而 HashMap 的遍历速度和他的容量有关。</p>
</li>
<li><p>TreeMap 能够把它保存的记录根据键排序，默认是按升序排序，也可以指定排序的比较器。当用 Iterator 遍历 TreeMap 时，得到的记录是排过序的。</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wetts.github.io/2021/05/10/%E8%AF%AD%E8%A8%80/Java/basic_Java/API/%E5%AE%B9%E5%99%A8/Java-API-%E5%AE%B9%E5%99%A8-list/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Zhang Wetts">
      <meta itemprop="description" content="Stay Hungry, Stay Foolish. <br><br><p style="font-size:8px;">[build by hexo/next/gitalk/hexo-generator-search/LaTeX]</p>">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wetts's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/10/%E8%AF%AD%E8%A8%80/Java/basic_Java/API/%E5%AE%B9%E5%99%A8/Java-API-%E5%AE%B9%E5%99%A8-list/" class="post-title-link" itemprop="url">Java-API-容器-list.md</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-05-10 12:10:26" itemprop="dateCreated datePublished" datetime="2021-05-10T12:10:26+08:00">2021-05-10</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>ArrayList 和 Vector 都是使用数组方式存储数据，此数组元素数大于实际存储的数据以便增加和插入元素，它们都允许直接按序号索引元素，但是插入元素要涉及数组元素移动等内存操作，所以索引数据快而插入数据慢。</p>
<p><strong>Vector 中的方法由于添加了 synchronized 修饰，因此 Vector 是线程安全的容器，但性能上较 ArrayList 差，因此已经是 Java 中的遗留容器。</strong></p>
<p>LinkedList 使用双向链表实现存储（将内存中零散的内存单元通过附加的引用关联起来，形成一个可以按序号索引的线性结构，这种链式存储方式与数组的连续存储方式相比，内存的利用率更高），按序号索引数据需要进行前向或后向遍历，但是插入数据时只需要记录本项的前后项即可，所以插入速度较快。</p>
<p>Vector 属于遗留容器（Java 早期的版本中提供的容器，除此之外，Hashtable、Dictionary、BitSet、Stack、Propertie 都是遗留容器），已经不推荐使用。</p>
<p>由于 ArrayList 和 LinkedListed 都是非线程安全的，如果遇到多个线程操作同一个容器的场景，则可以通过工具类 Collections 中的 synchronizedList 方法将其转换成线程安全的容器后再使用（这是对装潢模式的应用，将已有对象传入另一个类的构造器中创建新的对象来增强实现）。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/69/">69</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Zhang Wetts"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">Zhang Wetts</p>
  <div class="site-description" itemprop="description">Stay Hungry, Stay Foolish. <br><br><p style="font-size:8px;">[build by hexo/next/gitalk/hexo-generator-search/LaTeX]</p></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">686</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">67</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">352</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/wetts" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;wetts" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:zhang.wetts@163.com" title="E-Mail → mailto:zhang.wetts@163.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Zhang Wetts</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

  


<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/hibiki.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"react":{"opacity":0}});</script></body>
</html>
