<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"wetts.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="Stay Hungry, Stay Foolish. [build by hexo&#x2F;next&#x2F;gitalk&#x2F;hexo-generator-search&#x2F;LaTeX]">
<meta property="og:type" content="website">
<meta property="og:title" content="Wetts&#39;s blog">
<meta property="og:url" content="https://wetts.github.io/page/8/index.html">
<meta property="og:site_name" content="Wetts&#39;s blog">
<meta property="og:description" content="Stay Hungry, Stay Foolish. [build by hexo&#x2F;next&#x2F;gitalk&#x2F;hexo-generator-search&#x2F;LaTeX]">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Zhang Wetts">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://wetts.github.io/page/8/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Wetts's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Wetts's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Stay Hungry, Stay Foolish.</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/wetts" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wetts.github.io/2020/03/14/%E7%B3%BB%E7%BB%9F%E3%80%81%E6%9C%8D%E5%8A%A1%E5%99%A8/%E7%B3%BB%E7%BB%9F/Linux/Linux-%E5%91%BD%E4%BB%A4-su/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Zhang Wetts">
      <meta itemprop="description" content="Stay Hungry, Stay Foolish. <br><br><p style="font-size:8px;">[build by hexo/next/gitalk/hexo-generator-search/LaTeX]</p>">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wetts's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/14/%E7%B3%BB%E7%BB%9F%E3%80%81%E6%9C%8D%E5%8A%A1%E5%99%A8/%E7%B3%BB%E7%BB%9F/Linux/Linux-%E5%91%BD%E4%BB%A4-su/" class="post-title-link" itemprop="url">Linux-命令-su</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-03-14 12:24:24" itemprop="dateCreated datePublished" datetime="2020-03-14T12:24:24+08:00">2020-03-14</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">系统</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>su 是用户切换的命令。```</p>
<ul>
<li><code>su [user]</code>：切换到其他用户，但是不切换环境变量</li>
<li><code>su - [user]</code>：则是完整的切换到新的用户环境</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wetts.github.io/2020/03/14/%E7%B3%BB%E7%BB%9F%E3%80%81%E6%9C%8D%E5%8A%A1%E5%99%A8/%E7%B3%BB%E7%BB%9F/Linux/Linux-%E5%91%BD%E4%BB%A4-apt%E4%B8%8Eapt-get%E7%9A%84%E5%8C%BA%E5%88%AB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Zhang Wetts">
      <meta itemprop="description" content="Stay Hungry, Stay Foolish. <br><br><p style="font-size:8px;">[build by hexo/next/gitalk/hexo-generator-search/LaTeX]</p>">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wetts's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/14/%E7%B3%BB%E7%BB%9F%E3%80%81%E6%9C%8D%E5%8A%A1%E5%99%A8/%E7%B3%BB%E7%BB%9F/Linux/Linux-%E5%91%BD%E4%BB%A4-apt%E4%B8%8Eapt-get%E7%9A%84%E5%8C%BA%E5%88%AB/" class="post-title-link" itemprop="url">Linux-命令-apt与apt-get的区别</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-03-14 00:50:21" itemprop="dateCreated datePublished" datetime="2020-03-14T00:50:21+08:00">2020-03-14</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">系统</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>参考：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.sysgeek.cn/apt-vs-apt-get/">https://www.sysgeek.cn/apt-vs-apt-get/</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/c58de6f018fa">https://www.jianshu.com/p/c58de6f018fa</a></li>
</ul>
<hr>
<p>Ubuntu 16.04 发布时，一个引人注目的新特性便是 <code>apt</code> 命令的引入。其实早在 2014 年，apt 命令就已经发布了第一个稳定版，只是直到 2016 年的 Ubuntu 16.04 系统发布时才开始引人关注。</p>
<p>随着 <code>apt install package</code> 命令的使用频率和普遍性逐步超过 <code>apt-get install package</code>，越来越多的其它 Linux 发行版也开始遵循 Ubuntu 的脚步，开始鼓励用户使用 <code>apt</code> 而不是 <code>apt-get</code>。</p>
<p>那么，<code>apt-get</code> 与 <code>apt</code> 命令之间到底有什么区别呢？如果它们有类似的命令结构，为什么还需要新的 <code>apt</code> 命令呢？是否 <code>apt</code> 真的比 <code>apt-get</code> 更好？普通用户应该使用新的 <code>apt</code> 命令还是坚持旧有习惯继续使用 <code>apt-get</code> 呢？</p>
<h3 id="apt-与-apt-get"><a href="#apt-与-apt-get" class="headerlink" title="apt 与 apt-get"></a>apt 与 apt-get</h3><p>在开始对比 <code>apt</code> 与 <code>apt-get</code> 命令的区别之前，我们先来看看这两个命令的背景，以及它们要试图达到的目的。</p>
<p>Debian 作为 Ubuntu、Linux Mint 和 elementary OS 等 Linux 操作系统的母板，其具有强健的「包管理」系统，它的每个组件和应用程序都内置在系统中安装的软件包中。Debian 使用一套名为 Advanced Packaging Tool（APT）的工具来管理这种包系统，不过请不要把它与 <code>apt</code> 命令混淆，它们之间是其实不是同一个东西。</p>
<p>在基于 Debian 的 Linux 发行版中，有各种工具可以与 APT 进行交互，以方便用户安装、删除和管理的软件包。<code>apt-get</code> 便是其中一款广受欢迎的命令行工具，另外一款较为流行的是 Aptitude 这一命令行与 GUI 兼顾的小工具。</p>
<p>如果你已阅读过我们的 <code>apt-get</code> 命令指南，可能已经遇到过许多类似的命令，如 <code>apt-cache</code>、<code>apt-config</code> 等。如你所见，这些命令都比较低级又包含众多功能，普通的 Linux 用户也许永远都不会使用到。换种说法来说，就是最常用的 Linux 包管理命令都被分散在了 <code>apt-get</code>、<code>apt-cache</code> 和 <code>apt-config</code> 这三条命令当中。</p>
<p><code>apt</code> 命令的引入就是为了解决命令过于分散的问题，它包括了 <code>apt-get</code> 命令出现以来使用最广泛的功能选项，以及 <code>apt-cache</code> 和 <code>apt-config</code> 命令中很少用到的功能。</p>
<p>在使用 <code>apt</code> 命令时，用户不必再由 <code>apt-get</code> 转到 <code>apt-cache</code> 或 <code>apt-config</code>，而且 <code>apt</code> 更加结构化，并为用户提供了管理软件包所需的必要选项。</p>
<blockquote>
<p>简单来说就是：<code>apt</code> = <code>apt-get</code>、<code>apt-cache</code> 和 <code>apt-config</code> 中最常用命令选项的集合。</p>
</blockquote>
<h3 id="apt-与-apt-get-之间的区别"><a href="#apt-与-apt-get-之间的区别" class="headerlink" title="apt 与 apt-get 之间的区别"></a>apt 与 apt-get 之间的区别</h3><p>通过 <code>apt</code> 命令，用户可以在同一地方集中得到所有必要的工具，<code>apt</code> 的主要目的是提供一种以「让终端用户满意」的方式来处理 Linux 软件包的有效方式。</p>
<p><code>apt</code> 具有更精减但足够的命令选项，而且参数选项的组织方式更为有效。除此之外，它默认启用的几个特性对最终用户也非常有帮助。例如，可以在使用 <code>apt</code> 命令安装或删除程序时看到进度条。</p>
<p><code>apt</code> 还会在更新存储库数据库时提示用户可升级的软件包个数。</p>
<p>如果你使用 <code>apt</code> 的其它命令选项，也可以实现与使用 <code>apt-get</code> 时相同的操作。</p>
<h4 id="apt-和-apt-get-命令之间的区别"><a href="#apt-和-apt-get-命令之间的区别" class="headerlink" title="apt 和 apt-get 命令之间的区别"></a>apt 和 apt-get 命令之间的区别</h4><p>虽然 <code>apt</code> 与 <code>apt-get</code> 有一些类似的命令选项，但它并不能完全向下兼容 <code>apt-get</code> 命令。也就是说，可以用 <code>apt</code> 替换部分 <code>apt-get</code> 系列命令，但不是全部。</p>
<table>
<thead>
<tr>
<th align="center">apt 命令</th>
<th align="center">取代的命令</th>
<th align="center">命令的功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center">apt install</td>
<td align="center">apt-get install</td>
<td align="center">安装软件包</td>
</tr>
<tr>
<td align="center">apt remove</td>
<td align="center">apt-get remove</td>
<td align="center">移除软件包</td>
</tr>
<tr>
<td align="center">apt purge</td>
<td align="center">apt-get purge</td>
<td align="center">移除软件包及配置文件</td>
</tr>
<tr>
<td align="center">apt update</td>
<td align="center">apt-get update</td>
<td align="center">刷新存储库索引</td>
</tr>
<tr>
<td align="center">apt upgrade</td>
<td align="center">apt-get upgrade</td>
<td align="center">升级所有可升级的软件包</td>
</tr>
<tr>
<td align="center">apt autoremove</td>
<td align="center">apt-get autoremove</td>
<td align="center">自动删除不需要的包</td>
</tr>
<tr>
<td align="center">apt full-upgrade</td>
<td align="center">apt-get dist-upgrade</td>
<td align="center">在升级软件包时自动处理依赖关系</td>
</tr>
<tr>
<td align="center">apt search</td>
<td align="center">apt-cache search</td>
<td align="center">搜索应用程序</td>
</tr>
<tr>
<td align="center">apt show</td>
<td align="center">apt-cache show</td>
<td align="center">显示装细节</td>
</tr>
</tbody></table>
<p>当然，<code>apt</code> 还有一些自己的命令：</p>
<table>
<thead>
<tr>
<th align="center">新的apt命令</th>
<th align="center">命令的功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center">apt list</td>
<td align="center">列出包含条件的包（已安装，可升级等）</td>
</tr>
<tr>
<td align="center">apt edit-sources</td>
<td align="center">编辑源列表</td>
</tr>
</tbody></table>
<p>需要大家注意的是：<code>apt</code> 命令也还在不断发展，因此，你可能会在将来的版本中看到新的选项。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wetts.github.io/2020/03/12/%E5%A4%A7%E6%95%B0%E6%8D%AE/HBase/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Zhang Wetts">
      <meta itemprop="description" content="Stay Hungry, Stay Foolish. <br><br><p style="font-size:8px;">[build by hexo/next/gitalk/hexo-generator-search/LaTeX]</p>">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wetts's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/12/%E5%A4%A7%E6%95%B0%E6%8D%AE/HBase/" class="post-title-link" itemprop="url">HBase.md</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-03-12 18:59:31" itemprop="dateCreated datePublished" datetime="2020-03-12T18:59:31+08:00">2020-03-12</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Hadoop/" itemprop="url" rel="index"><span itemprop="name">Hadoop</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>HBase 利用 Hadoop MapReduce 来处理 HBase 中的海量数据，实现高性能计算；利用 Zookeeper 作为协同服务，实现稳定服务和失败恢复；使用 HDFS 作为高可靠的底层存储，利用廉价集群提供海量数据存储能力。当然，HBase 也可以直接使用本地文件系统而不用 HDFS 作为底层数据存储方式，不过，为了提高数据可靠性和系统的健壮性，发挥 HBase 处理大数据量等功能，一般都使用 HDFS 作为 HBase 的底层数据存储方式。此外，为了方便在 HBase 上进行数据处理，Sqoop 为 HBase 提供了高效、便捷的 RDBMS 数据导人功能，Pig 和 Hive 为 HBase 提供了高层语言支持。HBase 是 BigTable 的开源实现。</p>
<p><img src="/2020/03/12/%E5%A4%A7%E6%95%B0%E6%8D%AE/HBase/HBase%E4%B8%8E%E5%85%B6%E4%BB%96%E9%83%A8%E5%88%86%E7%9A%84%E5%85%B3%E7%B3%BB.png" alt="HBase与其他部分的关系"></p>
<p><img src="/2020/03/12/%E5%A4%A7%E6%95%B0%E6%8D%AE/HBase/HBase%E4%B8%8EBigTable.png" alt="HBase与BigTable"></p>
<h2 id="HBase-数据模型"><a href="#HBase-数据模型" class="headerlink" title="HBase 数据模型"></a>HBase 数据模型</h2><h3 id="数据模型概述"><a href="#数据模型概述" class="headerlink" title="数据模型概述"></a>数据模型概述</h3><p>HBase 是一个稀疏、多维度、排序的映射表，这张表的索引是行键、列族、列限定符和时间戳。每个值是一个未经解释的字符串，没有数据类型。用户在表中存储数据，每一行都有一个可排序的行键和任意多的列。表在水平方向由一个或者多个列族组成，同一个列族中可以包含任意多个列，同一个列族里面的数据存储在一起。列族支持动态扩展，可以很轻松地添加-个列族或列，无需预先定义列的数量以及类型，所有列均以字符串形式存储，用户需要自行进行数据类型转换。由于同-张表里面的每一行数据都可以有截然不同的列，因此对于整个映射表的每行数据而言，有些列的值就是空的，所以说 HBase 是稀疏的。</p>
<p>在 HBase 中执行更新操作时，并不会删除数据旧的版本，而是生成一个新的版本，旧有的版本仍然保留，HBase 可以对允许保留的版本的数量进行设置。客户端可以选择获取距离某个时间最近的版本，或者一次获取所有版本。如果在查询的时候不提供时间戳，那么会返回距离现在最近的那一个版本的数据，因为在存储的时候，数据会按照时间戳排序。</p>
<p>HBase 提供了两种数据版本回收方式：</p>
<ul>
<li>一是保存数据的最后 n 个版本；</li>
<li>二是保存最近一段时间内的版本(如最近7天)。</li>
</ul>
<h3 id="数据模型的相关概念"><a href="#数据模型的相关概念" class="headerlink" title="数据模型的相关概念"></a>数据模型的相关概念</h3><p><img src="/2020/03/12/%E5%A4%A7%E6%95%B0%E6%8D%AE/HBase/HBase%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B%E5%AE%9E%E4%BE%8B.png" alt="HBase数据模型实例"></p>
<h4 id="表"><a href="#表" class="headerlink" title="表"></a>表</h4><p>HBase 采用表来组织数据，表由行和列组成，列划分为若千个列族。</p>
<h4 id="行"><a href="#行" class="headerlink" title="行"></a>行</h4><p>每个 HBase 表都由若干行组成，每个行由行键（Row Key）来标识。访问表中的行只有 3 种方式：</p>
<ol>
<li>通过单个行键访问；</li>
<li>通过一个行键的区间来访问；</li>
<li>全表扫描。</li>
</ol>
<p>行键可以是任意字符串（最大长度是 64 KB，实际应用中长度一般为 10~100 字节），在 HBase 内部，行键保存为字节数组。存储时，数据按照行键的字典序排序存储。在设计行键时，要充分考虑这个特性，将经常一起读取的行存储在一起。</p>
<h4 id="列族"><a href="#列族" class="headerlink" title="列族"></a>列族</h4><p>一个 HBase 表被分组成许多“列族”的集合，它是基本的访问控制单元。列族需要在表创建时就定义好，数量不能太多（HBase 的一些缺陷使得列族数量只限于几十个），而且不要频繁修改。</p>
<p>存储在一个列族当中的所有数据，通常都属于同一种数据类型，这通常意味着具有更高的压缩率。表中的每个列都归属于某个列族，数据可以被存放到列族的某个列下面，但是在把数据存放到这个列族的某个列下面之前，必须首先创建这个列族。在创建完成一个列族以后，就可以使用同一个列族当中的列。列名都以列族作为前缀。例如，courses:history 和 courses:math 这两个列都属于 courses 这个列族。</p>
<p>在 HBase 中，访问控制、磁盘和内存的使用统计都是在列族层面进行的。实际应用中，我们可以借助列族上的控制权限帮助实现特定的目的。比如，我们可以允许一些应用能够向表中添加新的数据，而另一些应用则只允许浏览数据。HBase 列族还可以被配置成支持不同类型的访问模式。比如，一个列族也可以被设置成放入内存当中，以消耗内存为代价，从而换取更好的响应性能。</p>
<h4 id="列限定符"><a href="#列限定符" class="headerlink" title="列限定符"></a>列限定符</h4><p>列族里的数据通过列限定符（或列）来定位。列限定符不用事先定义，也不需要在不同行之间保持一致。列限定符没有数据类型，总被视为字节数组 byte[]。</p>
<h4 id="单元格"><a href="#单元格" class="headerlink" title="单元格"></a>单元格</h4><p>在 HBase 表中，通过行、列族和列限定符确定一个“单元格”(Cell)。单元格中存储的数据没有数据类型，总被视为字节数组 bytel]。每个单元格中可以保存一个数据的多个版本，每个版本对应一个不同的时间戳。</p>
<h4 id="时间戳"><a href="#时间戳" class="headerlink" title="时间戳"></a>时间戳</h4><p>每个单元格都保存着同一份数据的多个版本，这些版本采用时间戳进行索引。每次对一个单元格执行操作（新建、修改、删除）时，HBase 都会隐式地自动生成并存储一个时间戳。时间戳一般是 64 位整型，可以由用户自己赋值（自己生成唯一时间戳可以避免应用程序中出现数据版本冲突），也可以由 HBase 在数据写入时自动赋值。一个单元格的不同版本是根据时间戳降序的顺序进行存储的，这样，最新的版本可以被最先读取。</p>
<h3 id="数据坐标"><a href="#数据坐标" class="headerlink" title="数据坐标"></a>数据坐标</h3><p>HBase 使用坐标来定位表中的数据，也就是说，每个值都是通过坐标来访问的。对于我们熟悉的关系数据库而言，数据定位可以理解为采用“二维坐标”，即根据行和列就可以确定表中一个具体的值。但是，HBase中需要根据行键、列族、列限定符和时间戳来确定一个单元格，因此可以视为一个“四维坐标”，即 [行键，列族，列限定符，时间戳]。</p>
<h3 id="概念视图"><a href="#概念视图" class="headerlink" title="概念视图"></a>概念视图</h3><p>在 HBase 的概念视图中，一个表可以视为一个稀疏、多维的映射关系。</p>
<p><img src="/2020/03/12/%E5%A4%A7%E6%95%B0%E6%8D%AE/HBase/HBase%E6%95%B0%E6%8D%AE%E7%9A%84%E6%A6%82%E5%BF%B5%E8%A7%86%E5%9B%BE.png" alt="HBase数据的概念视图"></p>
<p>上图行键是一个反向 URL（即 com.cnn.www），之所以这样存放，是因为 HBase 是按照行键的字典序来排序存储数据的，采用反向 URL 的方式，可以让来自同一个网站的数据内容都保存在相邻的位置，在按照行键的值进行水平分区时，就可以尽量把来自同一个网站的数据划分到同一个分区（Region）中。</p>
<h3 id="物理视图"><a href="#物理视图" class="headerlink" title="物理视图"></a>物理视图</h3><p>从概念视图层面，HBase 中的每个表是由许多行组成的，但是在物理存储层面，它是采用了基于列的存储方式，而不是像传统关系数据库那样采用基于行的存储方式，这也是 HBase 和传统关系数据库的重要区别。</p>
<p><img src="/2020/03/12/%E5%A4%A7%E6%95%B0%E6%8D%AE/HBase/HBase%E6%95%B0%E6%8D%AE%E7%9A%84%E7%89%A9%E7%90%86%E8%A7%86%E5%9B%BE.png" alt="HBase数据的物理视图"></p>
<h3 id="面向列的存储"><a href="#面向列的存储" class="headerlink" title="面向列的存储"></a>面向列的存储</h3><p>行式数据库使用 NSM（N-ary Storage Model）存储模型，一个元组（或行）会被连续地存储在磁盘页中，也就是说，数据是一行一行被存储的，第一行写人磁盘页后，再继续写人第二行，依此类推。在从磁盘中读取数据时，需要从磁盘中顺序扫描每个元组的完整内容，然后从每个元组中筛选出查询所需要的属性。如果每个元组只有少量属性的值对于查询是有用的，那么 NSM 就会浪费许多磁盘空间和内存带宽。</p>
<p>列式数据库采用 DSM（Decomposition Storage Model）存储模型，它是在 1985 年提出来的，目的是最小化无用的 I/O。DSM 采用了不同于 NSM 的思路，对于采用 DSM 存储模型的关系数据库而言，DSM 会对关系进行垂直分解，并为每个属性分配一个子关系。因此，一个具有 n 个属性的关系会被分解成 n 个子关系，每个子关系单独存储，每个子关系只有当其相应的属性被请求时才会被访问。也就是说，DSM 是以关系数据库中的属性或列为单位进行存储，关系中多个元组的同一属性值（或同一列值）会被存储在一起，而一个元组中不同属性值则通常会被分别存放于不同的磁盘页中。</p>
<p><img src="/2020/03/12/%E5%A4%A7%E6%95%B0%E6%8D%AE/HBase/%E8%A1%8C%E5%BC%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E5%92%8C%E5%88%97%E5%BC%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84.png" alt="行式存储结构和列式存储结构"></p>
<ul>
<li>行式数据库主要适合于小批量的数据处理，如联机事务型数据处理，我们平时熟悉的 Oracle 和 MySQL 等关系数据库都属于行式数据库。</li>
<li>列式数据库主要适合于批量数据处理和即席查询（Ad-Hoc Query）。</li>
</ul>
<p>列式存储的优点是：</p>
<ul>
<li>可以降低 IO 开销，支持大量并发用户查询，其数据处理速度比传统方法快 100 倍，因为仅需要处理可以回答这些查询的列，而不是分类整理与特定查询无关的数据行；</li>
<li>具有较高的数据压缩比，较传统的行式数据库更加有效，甚至能达到 5 倍的效果。</li>
</ul>
<p>列式数据库主要用于数据挖掘、决策支持和地理信息系统等查询密集型系统中，因为一次查询就可以得出结果，而不必每次都要遍历所有的数据库。所以，列式数据库大多都是应用在人口统计调查、医疗分析等行业中，这种行业需要处理大量的数据统计分析，假如采用行式数据库，势必导致消耗的时间会无限放大。</p>
<p>DSM 存储模型的缺陷是：</p>
<ul>
<li>执行连接操作时需要昂贵的元组重构代价，因为一个元组的不同属性被分散到不同磁盘页中存储，当需要一个完整的元组时，就要从多个磁盘页中读取相应字段的值来重新组合得到原来的一个元组。</li>
<li>对于联机事务型数据处理而言，需要频繁对一些元组进行修改（如百货商场售出一件衣服后要立即修改库存数据），如果采用DSM存储模型，就会带来高昂的开销。</li>
</ul>
<h2 id="HBase-的实现原理"><a href="#HBase-的实现原理" class="headerlink" title="HBase 的实现原理"></a>HBase 的实现原理</h2><h3 id="HBase-的功能组件"><a href="#HBase-的功能组件" class="headerlink" title="HBase 的功能组件"></a>HBase 的功能组件</h3><p>HBase 的实现包括3个主要的功能组件：</p>
<ul>
<li>库函数，链接到每个客户端；</li>
<li>一个 Master 主服务器；</li>
<li>许多个 Region 服务器。</li>
</ul>
<hr>
<ul>
<li>Region 服务器负责存储和维护分配给自己的 Region，处理来自客户端的读写请求。</li>
<li>主服务器 Master 负责管理和维护 HBase 表的分区信息，比如，一个表被分成了哪些 Region，每个 Region 被存放在哪台 Region 服务器上，同时也负责维护 Region 服务器列表。</li>
</ul>
<p>因此，如果 Master 主服务器死机，那么整个系统都会无效。Master 会实时监测集群中的 Region 服务器，把特定的 Region 分配到可用的 Region 服务器上，并确保整个集群内部不同 Region 服务器之间的负载均衡，当某个 Region 服务器因出现故障而失效时，Master 会把该故障服务器上存储的 Region 重新分配给其他可用的 Region 服务器。除此以外，Master 还处理模式变化，如表和列族的创建。同客户端并不是直接从 Master 主服务器上读取数据，而是在获得 Region 的存储位置信息后，直接从 Region 服务器上读取数据。尤其需要指出的是，HBase 客户端并不依赖于 Master 而是借助于 Zookeeper 来获得 Region 的位置信息的，所以大多数客户端从来不和主服务器 Master 通信，这种设计方式使 Master 的负载很小。</p>
<h3 id="表和-Region"><a href="#表和-Region" class="headerlink" title="表和 Region"></a>表和 Region</h3><p>在一个 HBase 中，存储了许多表。对于每个 HBase 表而言，表中的行是根据行键的值的字典序进行维护的，表中包含的行的数量可能非常庞大，无法存储在一台机器上，需要分布存储到多台机器上。因此，需要根据行键的值对表中的行进行分区，每个行区间构成一个分区，被称为”Region”，包含了位于某个值域区间内的所有数据，它是负载均衡和数据分发的基本单位，这些 Region 会被分发到不同的 Region 服务器上。</p>
<p><img src="/2020/03/12/%E5%A4%A7%E6%95%B0%E6%8D%AE/HBase/%E4%B8%80%E4%B8%AAHBase%E8%A1%A8%E8%A2%AB%E5%88%92%E5%88%86%E6%88%90%E5%A4%9A%E4%B8%AARegion.png" alt="一个HBase表被划分成多个Region"></p>
<p>初始时，每个表只包含一个Region，随着数据的不断插入，Region 会持续增大，当一个 Region 中包含的行数量达到一个阈值时，就会被自动等分成两个新的 Region。随着表中行的数量继续增加，就会分裂出越来越多的 Region。</p>
<p><img src="/2020/03/12/%E5%A4%A7%E6%95%B0%E6%8D%AE/HBase/%E4%B8%80%E4%B8%AARegion%E5%88%86%E8%A3%82%E6%88%90%E5%A4%9A%E4%B8%AA%E6%96%B0%E7%9A%84Region.png" alt="一个Region分裂成多个新的Region"></p>
<p>每个 Region 的默认大小是 100MB 到 200MB，是 HBase 中负载均衡和数据分发的基本单位。Master 主服务器会把不同的 Region 分配到不同的 Region 服务器上，但是同一个 Region 是不会被拆分到多个 Region 服务器上的。每个 Region 服务器负责管理-个 Region 集合，通常在每个 Region 服务器上会放置 10~1000 个 Region。</p>
<p><img src="/2020/03/12/%E5%A4%A7%E6%95%B0%E6%8D%AE/HBase/%E4%B8%8D%E5%90%8CRegion%E5%88%86%E5%B8%83%E5%9C%A8%E4%B8%8D%E5%90%8CRegion%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A.png" alt="不同Region分布在不同Region服务器上"></p>
<h3 id="Region-的定位"><a href="#Region-的定位" class="headerlink" title="Region 的定位"></a>Region 的定位</h3><p>每个 Region 都有一个 RegionID 来标识它的唯一性，这样，一个 Region 标识符就可以表示成“表名 + 开始主键 + RegionID”。</p>
<p>有了 Region 标识符，就可以唯一标识每个 Region。为了定位每个 Region 所在的位置，就可以构建一张映射表，映射表的每个条目（或每行）包含两项内容，一个是 Region 标识符，另一个是 Region 服务器标识，这个条目就表示 Region 和 Region 服务器之间的对应关系，从而就可以知道某个 Region 被保存在哪个 Region 服务器中。这个映射表包含了关于 Region 的元数据（即 Region 和 Region 服务器之间的对应关系），因此也被称为“元数据表”，又名“.META.表”。</p>
<p>当一个 HBase 表中的 Region 数量非常庞大的时候，.META.表的条目就会非常多，一个服务器保存不下，也需要分区存储到不同的服务器上，因此.META.表也会被分裂成多个 Region，这时，为了定位这些 Region，就需要再构建一个新的映射表，记录所有元数据的具体位置，这个新的映射表就是“根数据表”，又名“-ROOT-表”。-ROOT-表是不能被分割的，永远只存在一个 Region 用于存放-ROOT-表，因此这个用来存放-ROOT-表的唯一一个 Region, 它的名字是在程序中被写死的，Master 主服务器永远知道它的位置。</p>
<p>综上所述，HBase 使用类似 B+树的三层结构来保存 Region 位置信息。</p>
<p><img src="/2020/03/12/%E5%A4%A7%E6%95%B0%E6%8D%AE/HBase/HBase%E7%9A%84%E4%B8%89%E5%B1%82%E7%BB%93%E6%9E%84.png" alt="HBase的三层结构"></p>
<p><img src="/2020/03/12/%E5%A4%A7%E6%95%B0%E6%8D%AE/HBase/HBase%E4%B8%89%E5%B1%82%E7%BB%93%E6%9E%84%E7%9A%84%E5%90%8D%E7%A7%B0%E5%92%8C%E4%BD%9C%E7%94%A8.png" alt="HBase三层结构的名称和作用"></p>
<p>为了加快访问速度，.META.表的全部 Region 都会被保存在内存中。假设.META.表的每行（一个映射条目）在内存中大约占用 1KB，并且每个 Region 限制为 128MB，那么，上面的三层结构可以保存的用户数据表的 Region 数目的计算方法是：(-ROOT-表能够寻址的.META.表的 Region 个数) x (每个.META.表的 Region 可以寻址的用户数据表的 Region 个数)。一个-ROOT-表最多只能有一个 Region，也就是最多只能有 128MB，按照每行（一个映射条目）占用 1KB 内存计算，128MB 空间可以容纳 128MB/1KB=2^17 行，也就是说，一个-ROOT表可以寻址 2^17 个.META.表的 Region。同理，每个.META.表的 Region 可以寻址的用户数据表的 Region 个数是 128MB/1KB=2^17。最终，三层结构可以保存的 Region 数目是 (128MB/1KB) * (128MB/1KB) = 234 个 Region。可以看出，这种数量已经足够可以满足实际应用中的用户数据存储需求。</p>
<p>客户端访问用户数据之前，需要首先访问 Zookeeper，获取-ROOT-表的位置信息，然后访问-ROOT-表，获得.META.表的信息，接着访问.META.表，找到所需的 Region 具体位于哪个 Region 服务器，最后才会到该 Region 服务器读取数据。该过程需要多次网络操作，为了加速寻址过程，一般会在客户端做缓存，把查询过的位置信息缓存起来，这样以后访问相同的数据时，就可以直接从客户端缓存中获取 Region 的位置信息，而不需要每次都经历一个“三级寻址”过程。需要注意的是，随着 HBase 中表的不断更新，Region 的位置信息可能会发生变化，但是客户端缓存并不会自己检测 Region 位置信息是否失效，而是在需要访问数据时，从缓存中获取 Region 位置信息却发现不存在的时候，才会判断出缓存失效，这时，就需要再次经历上述的“三级寻址”过程，重新获取最新的 Region 位置信息去访问数据，并用最新的 Region 位置信息替换缓存中失效的信息。</p>
<p>当一个客户端从 Zookeeper 服务器上拿到-ROOT-表的地址以后，就可以通过“三级寻址”找到用户数据表所在的 Region 服务器，并直接访问该 Region 服务器获得数据，没有必要再连接主服务器 Master。因此，主服务器的负载相对就小了很多。</p>
<h2 id="HBase-运行机制"><a href="#HBase-运行机制" class="headerlink" title="HBase 运行机制"></a>HBase 运行机制</h2><h3 id="HBase-系统架构"><a href="#HBase-系统架构" class="headerlink" title="HBase 系统架构"></a>HBase 系统架构</h3><p>HBase 的系统架构包括客户端、Zookeeper 服务器、Master 主服务器、Region 服务器。需要说明的是，HBase 一般采用 HDFS 作为底层数据存储。</p>
<p><img src="/2020/03/12/%E5%A4%A7%E6%95%B0%E6%8D%AE/HBase/HBase%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84.png" alt="HBase的系统架构"></p>
<h4 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h4><p>客户端包含访问 HBase 的接口，同时在缓存中维护着已经访问过的 Region 位置信息，用来加快后续数据访问过程。HBase 客户端使用 HBase 的 RPC 机制与 Master 和 Region 服务器进行通信。其中，对于管理类操作，客户端与 Master 进行 RPC；而对于数据读写类操作，客户端则会与 Region 服务器进行 RPC。</p>
<h4 id="Zookeeper-服务器"><a href="#Zookeeper-服务器" class="headerlink" title="Zookeeper 服务器"></a>Zookeeper 服务器</h4><p>Zookeeper 服务器并非一台单一的机器，可能是由多台机器构成的集群来提供稳定可靠的协同服务。Zookeeper 能够很容易地实现集群管理的功能，如果有多台服务器组成一个服务器集群，那么必须有一个“总管”知道当前集群中每台机器的服务状态，一旦某台机器不能提供服务，集群中其他机器必须知道，从而做出调整重新分配服务策略。同样，当增加集群的服务能力时，就会增加一台或多台服务器，同样也必须让“总管”知道。</p>
<p>在 HBase 服务器集群中，包含了一个 Master 和多个 Region 服务器，Master 就是这个 HBase 集群的“总管”，它必须知道 Region 服务器的状态。Zookeeper 就可以轻松做到这一点，每个 Region 服务器都需要到 Zookeeper 中进行注册，Zookeeper 会实时监控每个 Region 服务器的状态并通知给 Master，这样，Master 就可以通过 Zookeeper 随时感知到各个 Region 服务器的工作状态。</p>
<p>Zookeeper 不仅能够帮助维护当前的集群中机器的服务状态，而且能够帮助选出一个“总管”，让这个总管来管理集群。HBase 中可以启动多个 Master，但是 Zookeeper 可以帮助选举出一个 Master 作为集群的总管，并保证在任何时刻总有唯一一个 Master 在运行，这就避免了 Master 的“单点失效”问题。</p>
<p>Zookeeper 中保存了-ROOT-表的地址和 Master 的地址，客户端可以通过访问 Zookeeper 获得-ROOT-表的地址，并最终通过“三级寻址”找到所需的数据。Zookeeper 中还存储了 HBase 的模式，包括有哪些表，每个表有哪些列族。</p>
<h4 id="Master"><a href="#Master" class="headerlink" title="Master"></a>Master</h4><p>主服务器 Master 主要负责表和 Region 的管理工作。</p>
<ul>
<li>管理用户对表的增加、删除、修改、查询等操作。</li>
<li>实现不同 Region 服务器之间的负载均衡。</li>
<li>在 Region 分裂或合并后，负责重新调整 Region 的分布。</li>
<li>对发生故障失效的 Region 服务器上的 Region 进行迁移。</li>
</ul>
<p>客户端访问 HBase 上数据的过程并不需要 Master 的参与，客户端可以访问 Zookeeper 获取-ROOT-表的地址，并最终到达相应的 Region 服务器进行数据读写，Master 仅仅维护着表和 Region 的元数据信息，因此负载很低。</p>
<p>任何时刻，一个 Region 只能分配给一个 Region 服务器。Master 维护了当前可用的 Region 服务器列表，以及当前哪些 Region 分配给了哪些 Region 服务器，哪些 Region 还未被分配。当存在未被分配的 Region，并且有一个 Region 服务器上有可用空间时，Master 就给这个 Region 服务器发送一个请求，把该 Region 分配给它。Region 服务器接受请求并完成数据加载后，就开始负责管理该 Region 对象，并对外提供服务。</p>
<h4 id="Region-服务器"><a href="#Region-服务器" class="headerlink" title="Region 服务器"></a>Region 服务器</h4><p>Region 服务器是 HBase 中最核心的模块，负责维护分配给自己的 Region，并响应用户的读写请求。HBase 一般采用 HDFS 作为底层存储文件系统，因此 Region 服务器需要向 HDFS 文件系统中读写数据。采用 HDFS 作为底层存储，可以为 HBase 提供可靠稳定的数据存储，HBase 自身并不具备数据复制和维护数据副本的功能，而HDFS可以为 HBase 提供这些支持。当然，HBase 也可以不采用 HDFS，而是使用其他任何支持 Hadoop 接口的文件系统作为底层存储，比如本地文件系统或云计算环境中的 AmazonS3(Simple Storage Service)。</p>
<h3 id="Region-服务器的工作原理"><a href="#Region-服务器的工作原理" class="headerlink" title="Region 服务器的工作原理"></a>Region 服务器的工作原理</h3><p>Region 服务器是 HBase 中最核心的模块，Region 服务器内部管理了一系列 Region 对象和一个 HLog 文件，其中 HLog 是磁盘上面的记录文件，它记录着所有的更新操作。每个 Region 对象又是由多个 Store 组成的，每个 Store 对应了表中的一个列族的存储。每个 Store 又包含了一个 MemStore 和若千个 StoreFile。</p>
<ul>
<li>MemStore 是在内存中的缓存，保存最近更新的数据; </li>
<li>StoreFile 是磁盘中的文件，这些文件都是 B 树结构的，方便快速读取。StoreFile 在底层的实现方式是 HDFS 文件系统的 HFile, HFile 的数据块通常采用压缩方式存储，压缩之后可以大大减少网络 I/0 和磁盘 I/O。</li>
</ul>
<p><img src="/2020/03/12/%E5%A4%A7%E6%95%B0%E6%8D%AE/HBase/Region%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%90%91HDFS%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E4%B8%AD%E8%AF%BB%E5%86%99%E6%95%B0%E6%8D%AE.png" alt="Region服务器向HDFS文件系统中读写数据"></p>
<h4 id="用户读写数据的过程"><a href="#用户读写数据的过程" class="headerlink" title="用户读写数据的过程"></a>用户读写数据的过程</h4><p>当用户写入数据时，会被分配到相应的 Region 服务器去执行操作。用户数据首先被写人到 MemStore 和 HLog 中，当操作写入 HLog 之后，commit() 调用才会将其返回给客户端。</p>
<p>当用户读取数据时，Region 服务器会首先访问 MemStore 缓存，如果数据不在缓存中，才会到磁盘上面的 StoreFile 中去寻找。</p>
<h4 id="缓存的刷新"><a href="#缓存的刷新" class="headerlink" title="缓存的刷新"></a>缓存的刷新</h4><p>MemStore 缓存的容量有限，系统会周期性地调用 Region.flushcache() 把 MemStore 缓存里面的内容写到磁盘的 StoreFile 文件中，清空缓存，并在 HLog 文件中写入一个标记，用来表示缓存中<br>的内容已经被写人 StoreFile 文件中。每次缓存刷新操作都会在磁盘上生成一个新的 StoreFile 文件，因此每个 Store 会包含多个 StoreFile 文件。</p>
<p>每个 Region 服务器都有一个自己的 HLog 文件，在启动的时候，每个 Region 服务器都会检查自己的 HLog 文件，确认最近一次执行缓存刷新操作之后是否发生新的写人操作。如果没有更新，说明所有数据已经被永久保存到磁盘的 StoreFile 文件中；如果发现更新，就先把这些更新写人 MemStore，然后再刷新缓存，写人到磁盘的 StoreFile 文件中。最后，删除旧的 HLog 文件，并开始为用户提供数据访问服务。</p>
<h4 id="StoreFile-的合并"><a href="#StoreFile-的合并" class="headerlink" title="StoreFile 的合并"></a>StoreFile 的合并</h4><p>每次 MemStore 缓存的刷新操作都会在磁盘上生成一个新的 StoreFile 文件，这样，系统中的每个 Store 就会存在多个 StoreFile 文件。当需要访问某个 Store 中的某个值时，就必须查找所有这些 StoreFile 文件，非常耗费时间。因此，为了减少查找时间，系统一般会调用 Store.compact() 把多个 StoreFile 文件合并成一个大文件。由于合并操作比较耗费资源，因此只会在 StoreFile 文件的数量达到一个阈值的时候才会触发合并操作。</p>
<h3 id="Store-的工作原理"><a href="#Store-的工作原理" class="headerlink" title="Store 的工作原理"></a>Store 的工作原理</h3><p>Region 服务器是 HBase 的核心模块，而 Store 则是 Region 服务器的核心。每个 Store 对应了表中的一个列族的存储。每个 Store 包含一个 MemStore 缓存和若于个 StoreFile 文件。MemStore 是排序的内存缓冲区，当用户写入数据时，系统首先把数据放人 MemStore 缓存，当 MemStore 缓存满时，就会刷新到磁盘中的一个 StoreFile 文件中。随着 StoreFile 文件数量的不断增加，当达到事先设定的数量时，就会触发文件合并操作，多个 StoreFile 文件会被合并成一个大的 StoreFile 文件。当多个 StoreFile 文件合并后，会逐步形成越来越大的 StoreFile 文件，当单个 StoreFile 文件大小超过一定阈值时，就会触发文件分裂操作。同时，当前的 1 个父 Region 会被分裂成 2 个子 Region, 父 Region 会下线，新分裂出的 2 个子 Region 会被 Master 分配到相应的 Region 服务器上。</p>
<p><img src="/2020/03/12/%E5%A4%A7%E6%95%B0%E6%8D%AE/HBase/StoreFile%E7%9A%84%E5%90%88%E5%B9%B6%E5%92%8C%E5%88%86%E8%A3%82%E8%BF%87%E7%A8%8B.png" alt="StoreFile的合并和分裂过程"></p>
<h3 id="HLog-的工作原理"><a href="#HLog-的工作原理" class="headerlink" title="HLog 的工作原理"></a>HLog 的工作原理</h3><p>在分布式环境下，必须要考虑到系统出错的情形，比如当 Region 服务器发生故障时，MemStore 缓存中的数据（还没有被写人文件）会全部丢失。因此，HBase 采用 HLog 来保证系统发生故障时能够恢复到正确的状态。</p>
<p>HBase 系统为每个 Region 服务器配置了一个 HLog 文件，它是一种预写式日志（Write Ahead Log），也就是说，用户更新数据必须首先被记人日志后才能写人 MemStore 缓存，并且直到 MemStore 缓存内容对应的日志已经被写入磁盘之后，该缓存内容才会被刷新写入磁盘。</p>
<p>Zookeeper 会实时监测每个 Region 服务器的状态，当某个 Region 服务器发生故障时，Zookeeper 会通知 Master。Master 首先会处理该故障 Region 服务器上面遗留的 HLog 文件，由于一个 Region 服务器上面可能会维护着多个 Region 对象，这些 Region 对象共用一个HLog文件，因此这个遗留的 HLog 文件中包含了来自多个 Region 对象的日志记录。系统会根据每条日志记录所属的 Region 对象对 HLog 数据进行拆分，分别放到相应 Region 对象的目录下，然后再将失效的 Region 重新分配到可用的 Region 服务器中，并把与该 Region 对象相关的 HLog 日志记录也发送给相应的 Region 服务器。Region 服务器领取到分配给自己的 Region 对象以及与之相关的 HLog 日志记录以后，会重新做一遍日志记录中的各种操作，把日志记录中的数据写人 MemStore 缓存，然后刷新到磁盘的 StoreFile 文件中，完成数据恢复。</p>
<p>需要特别指出的是，HBase 系统中，每个 Region 服务器只需要维护一个 HLog 文件，所有 Region 对象共用一个 HLog，而不是每个 Region 使用一个 HLog。在这种 Region 对象共用一个 HLog 的方式中，多个 Region 对象的更新操作所发生的日志修改，只需要不断把日志记录追加到单个日志文件中，而不需要同时打开、写入到多个日志文件中，因此可以减少磁盘寻址次数，提高对表的写操作性能。这种方式的缺点是，如果个 Region 服务器发生故障，为了恢复其上的 Region 对象，需要将 Region 服务器上的 HLog 按照其所属的 Region 对象进行拆分，然后分发到其他 Region 服务器上执行恢复操作。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wetts.github.io/2020/03/12/%E5%A4%A7%E6%95%B0%E6%8D%AE/HDFS/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Zhang Wetts">
      <meta itemprop="description" content="Stay Hungry, Stay Foolish. <br><br><p style="font-size:8px;">[build by hexo/next/gitalk/hexo-generator-search/LaTeX]</p>">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wetts's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/12/%E5%A4%A7%E6%95%B0%E6%8D%AE/HDFS/" class="post-title-link" itemprop="url">HDFS</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-03-12 14:21:34" itemprop="dateCreated datePublished" datetime="2020-03-12T14:21:34+08:00">2020-03-12</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Hadoop/" itemprop="url" rel="index"><span itemprop="name">Hadoop</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>HDFS（Hadoop Distributed File System，Hadoop 分布式文件系统）</p>
<h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><h3 id="块"><a href="#块" class="headerlink" title="块"></a>块</h3><p>在传统的文件系统中，为了提高磁盘读写效率，一般以数据块为单位，而不是以字节为单位。比如，机械式硬盘（磁盘的一种）包含了磁头和转动部件，在读取数据时有一个寻道的过程，通过转动盘片和移动磁头的位置，来找到数据在机械式硬盘中的存储位置，然后才能进行读写。在 I/O 开销中，机械式硬盘的寻址时间是最耗时的部分，一旦找到第条记录，剩下的顺序读取效率是非常高的。因此，以块为单位读写数据，可以把磁盘寻道时间分摊到大量数据中。</p>
<p>HDFS 也同样采用了块的概念，默认的一个块大小是 64 MB。</p>
<p>当客户端需要访问一个文件时，首先从名称节点获得组成这个文件的数据块的位置列表，然后根据位置列表获取实际存储各个数据块的数据节点的位置，最后数据节点根据数据块信息在本地 Linux 文件系统中找到对应的文件，并把数据返回给客户端。</p>
<h3 id="名称节点"><a href="#名称节点" class="headerlink" title="名称节点"></a>名称节点</h3><p>名称节点（NameNode）负责管理分布式文件系统的命名空间（Namespace），保存了两个核心的数据结构，即 FsImage 和 EditLog。</p>
<ul>
<li>FsImage：维护文件系统树以及文件树中所有的文件和文件夹的元数据。</li>
<li>EditLog：记录了所有针对文件的创建、删除、重命名等操作。</li>
</ul>
<p><img src="/2020/03/12/%E5%A4%A7%E6%95%B0%E6%8D%AE/HDFS/%E5%90%8D%E7%A7%B0%E8%8A%82%E7%82%B9%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png" alt="名称节点的数据结构"></p>
<p>名称节点记录了每个文件中各个块所在的数据节点的位置信息，但是并不持久化存储这些信息，而是在系统每次启动时扫描所有数据节点重构得到这些信息。</p>
<h3 id="数据节点"><a href="#数据节点" class="headerlink" title="数据节点"></a>数据节点</h3><p>数据节点（DataNode）是分布式文件系统HDFS的工作节点，负责数据的存储和读取，会根据客户端或者名称节点的调度来进行数据的存储和检索，并且向名称节点定期发送自己所存储的块的列表。每个数据节点中的数据会被保存在各自节点的本地Linux文件系统中。</p>
<h3 id="第二名称节点"><a href="#第二名称节点" class="headerlink" title="第二名称节点"></a>第二名称节点</h3><p>在名称节点运行期间，HDFS会不断发生更新操作，这些更新操作都是直接被写人到 EditLog 文件，因此 EditLog 文件也会逐渐变大。在名称节点运行期间，不断变大的 EditLog 文件通常对于系统性能不会产生显著影响，但是当名称节点重启时，需要将 FsImage 加载到内存中，然后逐条执行 EditLog 中的记录，使得 FsImage 保持最新。可想而知，如果 EditLog 很大，就会导致整个过程变得非常缓慢，使得名称节点在启动过程中长期处于“安全模式”，无法正常对外提供写操作，影响了用户的使用。</p>
<p>为了有效解决 EditLog 逐渐变大带来的问题，HDFS 在设计中采用了第二名称节点（Secondary NameNode）。第二名称节点是 HDFS 架构的一个重要组成部分，具有两个方面的功能：</p>
<ul>
<li>首先，可以完成 EditLog 与 Fslmage 的合并操作，减小 EditLog 文件大小，缩短名称节点重启时间；</li>
<li>其次，可以作为名称节点的“检查点”，保存名称节点中的元数据信息。</li>
</ul>
<p>具体如下：</p>
<ol>
<li>EditLog 与 Fslmage 的合并操作。每隔一段时间，第二名称节点会和名称节点通信，请求其停止使用 EditLog 文件（这里假设这个时刻为 t），暂时将新到达的写操作添加到一个新的文件 EditLog.new 中。然后，第二名称节点把名称节点中的 FsImage 文件和 EditLog 文件拉回到本地，再加载到内存中；对二者执行合并操作，即在内存中逐条执行 EditLog 中的操作，使得 FsImage 保持最新。合并结束后，第二名称节点会把合并后得到的最新的 FsImage 文件发送到名称节点。名称节点收到后，会用最新的 FsImage 文件去替换旧的 FsImage 文件，同时用 EditLog.new 文件去替换 EditLog 文件（这里假设这个时刻为 t2），从而减小了，EditLog 文件的大小。</li>
<li>作为名称节点的“检查点”。从上面的合并过程可以看出，第二名称节点会定期和名称节点通信，从名称节点获取 FsImage 文件和 EditLog 文件，执行合并操作得到新的 FsImage 文件。从这个角度来讲，第二名称节点相当于为名称节点设置了一个“检查点”，周期性地备份名称节点中的元数据信息，当名称节点发生故障时，就可以用第二名称节点中记录的元数据信息进行系统恢复。但是，在第二名称节点上合并操作得到的新的 FsImage 文件是合并操作发生时（即 t1 时刻）HDFS 记录的元数据信息，并没有包含 t1 时刻和 t2 时刻期间发生的更新操作，如果名称节点在 t1 时刻和 t2 时刻期间发生故障，系统就会丢失部分元数据信息，在 HDFS 的设计中，也并不支持把系统直接切换到第二名称节点，因此从这个角度来讲，第二名称节点只是起到了名称节点的“检查点”作用，并不能起到“热备份”作用。即使有了第二名称节点的存在，当名称节点发生故障时，系统还是有可能会丢失部分元数据信息的。</li>
</ol>
<p><img src="/2020/03/12/%E5%A4%A7%E6%95%B0%E6%8D%AE/HDFS/%E7%AC%AC%E4%BA%8C%E5%90%8D%E7%A7%B0%E8%8A%82%E7%82%B9%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="第二名称节点工作过程示意图"></p>
<h2 id="HDFS-体系结构"><a href="#HDFS-体系结构" class="headerlink" title="HDFS 体系结构"></a>HDFS 体系结构</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p><img src="/2020/03/12/%E5%A4%A7%E6%95%B0%E6%8D%AE/HDFS/HDFS%E7%9A%84%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.png" alt="HDFS的体系结构"></p>
<h3 id="HDFS-命名控件管理"><a href="#HDFS-命名控件管理" class="headerlink" title="HDFS 命名控件管理"></a>HDFS 命名控件管理</h3><p>HDFS 的命名空间包含目录、文件和块。命名空间管理是指命名空间支持对 HDFS 中的目录、文件和块做类似文件系统的创建、修改、删除等基本操作。在当前的 HDFS 体系结构中，在整个 HDFS 集群中只有一个命名空间，并且只有唯一一个名称节点，该节点负责对这个命名空间进行管理。</p>
<p>HDFS 使用的是传统的分级文件体系，因此用户可以像使用普通文件系统样，创建、删除目录和文件，在目录间转移文件、重命名文件等。但是，HDFS 还没有实现磁盘配额和文件访问权限等功能，也不支持文件的硬连接和软连接（快捷方式）。</p>
<h3 id="通信协议"><a href="#通信协议" class="headerlink" title="通信协议"></a>通信协议</h3><p>HDFS 是一个部署在集群上的分布式文件系统，因此很多数据需要通过网络进行传输。所有的 HDFS 通信协议都是构建在 TCP/IP 协议基础之上的。客户端通过一个可配置的端口向名称节点主动发起 TCP 连，并使用客户端协议与名称节点进行交互。名称节点和数据节点之间则使用数据节点协议进行交互。客户端与数据节点的交互是通过 RPC（Remote Procedure Call）来实现的。在设计上，名称节点不会主动发起 RPC，而是响应来自客户端和数据节点的 RPC 请求。</p>
<h3 id="HDFS-体系结构的局限性"><a href="#HDFS-体系结构的局限性" class="headerlink" title="HDFS 体系结构的局限性"></a>HDFS 体系结构的局限性</h3><p>HDFS只设置唯一一个名称节点，这样做虽然大大简化了系统设计，但也带来了一些明显的局限性，具体如下。</p>
<ol>
<li>命名空间的限制。名称节点是保存在内存中的，因此名称节点能够容纳对象（文件、块）的个数会受到内存空间大小的限制。</li>
<li>性能的瓶颈。整个分布式文件系统的吞吐量受限于单个名称节点的吞吐量。</li>
<li>隔离问题。由于集群中只有一个名称节点，只有一个命名空间，因此无法对不同应用程序进行隔离。</li>
<li>集群的可用性。一旦这个唯一的名称节点发生故障，会导致整个集群变得不可用。</li>
</ol>
<h2 id="HDFS-的存储原理"><a href="#HDFS-的存储原理" class="headerlink" title="HDFS 的存储原理"></a>HDFS 的存储原理</h2><h3 id="数据的冗余存储"><a href="#数据的冗余存储" class="headerlink" title="数据的冗余存储"></a>数据的冗余存储</h3><p>HDFS 采用了多副本方式对数据进行冗余存储，通常一个数据块的多个副本会被分布到不同的数据节点上。</p>
<p><img src="/2020/03/12/%E5%A4%A7%E6%95%B0%E6%8D%AE/HDFS/HDFS%E6%95%B0%E6%8D%AE%E5%9D%97%E5%A4%9A%E5%89%AF%E6%9C%AC%E5%AD%98%E5%82%A8.png" alt="HDFS数据块多副本存储"></p>
<p>多副本方式具有以下 3 个优点：</p>
<ol>
<li>加快数据传输速度。当多个客户端需要同时访问同个文件时，可以让各个客户端分别从不同的数据块副本中读取数据，这就大大加快了数据传输速度。</li>
<li>容易检查数据错误。HDFS 的数据节点之间通过网络传输数据，采用多个副本可以很容易判断数据传输是否出错。</li>
<li>保证数据的可靠性。即使某个数据节点出现故障失效，也不会造成数据丢失。</li>
</ol>
<h3 id="数据存取策略"><a href="#数据存取策略" class="headerlink" title="数据存取策略"></a>数据存取策略</h3><h4 id="数据存放"><a href="#数据存放" class="headerlink" title="数据存放"></a>数据存放</h4><p>HDFS 默认的冗余复制因子是 3，每一个文件块会被同时保存到 3 个地方，其中，有两份副本放在同一个机架的不同机器上面，第三个副本放在不同机架的机器上面，这样既可以保证机架发生异常时的数据恢复，也可以提高数据读写性能（同机架内带宽高）。一般而言，HDFS 副本的放置策略如下：</p>
<ol>
<li>如果是在集群内发起写操作请求，则把第一个副本放置在发起写操作请求的数据节点上，实现就近写入数据。如果是来自集群外部的写操作请求，则从集群内部挑选一台磁盘不太满、CPU 不太忙的数据节点，作为第一个副本的存放地。</li>
<li>第二个副本会被放置在与第一个副本不同的机架的数据节点上。</li>
<li>第三个副本会被放置在与第一个副本相同的机架的其他节点上。</li>
<li>如果还有更多的副本，则继续从集群中随机选择数据节点进行存放。</li>
</ol>
<h4 id="数据读取"><a href="#数据读取" class="headerlink" title="数据读取"></a>数据读取</h4><p>HDFS 提供了一个 API 可以确定一个数据节点所属的机架 ID，客户端也可以调用 API 获取自已所属的机架 ID。当客户端读取数据时，从名称节点获得数据块不同副本的存放位置列表，列表中包含了副本所在的数据节点，可以调用 API 来确定客户端和这些数据节点所属的机架 ID。当发现某个数据块副本对应的机架 ID 和客户端对应的机架 ID 相同时，就优先选择该副本读取数据，如果没有发现，就随机选择-个副本读取数据。</p>
<h4 id="数据复制"><a href="#数据复制" class="headerlink" title="数据复制"></a>数据复制</h4><p>HDFS 的数据复制采用了流水线复制的策略，大大提高了数据复制过程的效率。当客户端要往 HDFS 中写入一个文件时，这个文件会首先被写入本地，并被切分成若千个块，每个块的大小是由 HDFS 的设定值来决定的。每个块都向 HDFS 集群中的名称节点发起写请求，名称节点会根据系统中各个数据节点的使用情况，选择一个数据节点列表返回给客户端，然后客户端就把数据首先写入列表中的第一个数据节点，同时把列表传给第一个数据节点，当第一个数据节点接收到 4 KB 数据的时候，写入本地，并且向列表中的第二个数据节点发起连接请求，把自己已经接收到的 4 KB 数据和列表传给第二个数据节点，当第二个数据节点接收到 4 KB 数据的时候，写人本地，并且向列表中的第三个数据节点发起连接请求，依次类推，列表中的多个数据节点形成一条数据复制的流水线。最后，当文件写完的时候，数据复制也同时完成。</p>
<h3 id="数据错误与恢复"><a href="#数据错误与恢复" class="headerlink" title="数据错误与恢复"></a>数据错误与恢复</h3><h4 id="名称节点出错"><a href="#名称节点出错" class="headerlink" title="名称节点出错"></a>名称节点出错</h4><p>Hadoop 采用两种机制来确保名称节点的安全：</p>
<ul>
<li>第一，把名称节点上的元数据信息同步存储到其他文件系统（比如远程挂载的网络文件系统 NFS）中；</li>
<li>第二，运行一个第二名称节点，当名称节点宕机以后，可以把第二名称节点作为一种弥补措施，利用第二名称节点中的元数据信息进行系统恢复。</li>
</ul>
<h4 id="数据节点出错"><a href="#数据节点出错" class="headerlink" title="数据节点出错"></a>数据节点出错</h4><p>每个数据节点会定期向名称节点发送“心跳”信息，向名称节点报告自己的状态。当数据节点发生故障，或者网络发生断网时，名称节点就无法收到来自一些数据节点的“心跳”信息，这时这些数据节点就会被标记为“宕机”，节点上面的所有数据都会被标记为“不可读”，名称节点不会再给它们发送任何 IO 请求。</p>
<p>这时，有可能出现一种情形，即由于些数据节点的不可用，会导致一些数据块的副本数量小于冗余因子。名称节点会定期检查这种情况，一旦发现某个数据块的副本数量小于冗余因子，就会启动数据冗余复制，为它生成新的副本。HDFS 与其他分布式文件系统的最大区别就是可以调整冗余数据的位置。</p>
<h4 id="数据出错"><a href="#数据出错" class="headerlink" title="数据出错"></a>数据出错</h4><p>网络传输和磁盘错误等因素都会造成数据错误。客户端在读取到数据后，会采用 md5 和 sha1 对数据块进行校验，以确定读取到正确的数据。在文件被创建时，客户端就会对每一个文件块进行信息摘录，并把这些信息写人同一个路径的隐藏文件里面。当客户端读取文件的时候，会先读取该信息文件，然后利用该信息文件对每个读取的数据块进行校验，如果校验出错，客户端就会请求到另外一个数据节点读取该文件块，并且向名称节点报告这个文件块有错误，名称节点会定期检查并且重新复制这个块。</p>
<h2 id="HDFS-的数据读写过程"><a href="#HDFS-的数据读写过程" class="headerlink" title="HDFS 的数据读写过程"></a>HDFS 的数据读写过程</h2><h3 id="读数据的过程"><a href="#读数据的过程" class="headerlink" title="读数据的过程"></a>读数据的过程</h3><p><img src="/2020/03/12/%E5%A4%A7%E6%95%B0%E6%8D%AE/HDFS/HDFS%E8%AF%BB%E6%95%B0%E6%8D%AE%E7%9A%84%E8%BF%87%E7%A8%8B.png" alt="HDFS读数据的过程"></p>
<h3 id="写数据的过程"><a href="#写数据的过程" class="headerlink" title="写数据的过程"></a>写数据的过程</h3><p><img src="/2020/03/12/%E5%A4%A7%E6%95%B0%E6%8D%AE/HDFS/HDFS%E5%86%99%E6%95%B0%E6%8D%AE%E7%9A%84%E8%BF%87%E7%A8%8B.png" alt="HDFS写数据的过程"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wetts.github.io/2020/01/07/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%85%B6%E4%BB%96/%E6%95%B0%E6%8D%AE%E5%BA%93-%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Zhang Wetts">
      <meta itemprop="description" content="Stay Hungry, Stay Foolish. <br><br><p style="font-size:8px;">[build by hexo/next/gitalk/hexo-generator-search/LaTeX]</p>">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wetts's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/07/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%85%B6%E4%BB%96/%E6%95%B0%E6%8D%AE%E5%BA%93-%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5/" class="post-title-link" itemprop="url">数据库-索引优化策略.md</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-01-07 19:50:22" itemprop="dateCreated datePublished" datetime="2020-01-07T19:50:22+08:00">2020-01-07</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>转自：<a target="_blank" rel="noopener" href="https://blog.csdn.net/zzti_erlie/article/details/103665903">https://blog.csdn.net/zzti_erlie/article/details/103665903</a></p>
<h2 id="索引的种类"><a href="#索引的种类" class="headerlink" title="索引的种类"></a>索引的种类</h2><p>众所周知，索引类似于字典的目录，可以提高查询的效率。</p>
<p>索引从物理上可以分为：聚集索引，非聚集索引</p>
<p>从逻辑上可以分为：普通索引，唯一索引，主键索引，联合索引，全文索引</p>
<h2 id="索引优化策略"><a href="#索引优化策略" class="headerlink" title="索引优化策略"></a>索引优化策略</h2><h3 id="不要在索引列上进行运算或使用函数"><a href="#不要在索引列上进行运算或使用函数" class="headerlink" title="不要在索引列上进行运算或使用函数"></a>不要在索引列上进行运算或使用函数</h3><p>在列上进行运算或使用函数会使索引失效，从而进行全表扫描。如下面例子在 publish_time，id 列上分别加上索引，publish_time 为 datetime 类型，id 为 int 类型</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 全表扫描</span><br><span class="line">select * from article where year(publish_time) &lt; 2019</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 走索引</span><br><span class="line">select * from article where publish_time &lt; &#x27;2019-01-01&#x27;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 全表扫描</span><br><span class="line">select * from article where id + 1 = 5</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 走索引</span><br><span class="line">select * from article where id = 4</span><br></pre></td></tr></table></figure>

<h3 id="小心隐式类型转换"><a href="#小心隐式类型转换" class="headerlink" title="小心隐式类型转换"></a>小心隐式类型转换</h3><p>假设 id 为 varchar 类型</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 全表扫描</span><br><span class="line">select * from article where id = 100</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 走索引</span><br><span class="line">select * from article where id = &#x27;100&#x27;</span><br></pre></td></tr></table></figure>

<p>为什么呢？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select * from article where id = 100</span><br><span class="line">-- 等价于</span><br><span class="line">select * from article where CAST(id AS signed int) = 100</span><br></pre></td></tr></table></figure>

<p>上一条规则说过，不要在索引列上使用函数，隐式类型转换在索引字段上做了函数操作，因此会全表扫描</p>
<p>那么如果 id 是 int，执行下面这个语句是否会导致全表扫描呢？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from article where id = &#x27;100&#x27;</span><br></pre></td></tr></table></figure>

<p>答案是会用到索引，我们来分析一下为什么会用到索引</p>
<p>我们先来做一个实验，看一下数据库中字符串和数字做比较的时候，是怎么转换的？</p>
<p>这里有个简单的方法执行select “10” &gt; 9即可</p>
<ul>
<li>如果结果是1，则是把字符串转成数字，然后进行比较</li>
<li>如果结果是0，则是把数字转成字符串（因为字符串比较是从高位到低位按照asciss码来逐位比较，“1”比“9”小，所以为0），然后进行比较<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select &quot;10&quot; &gt; 9;</span><br><span class="line">+----------+</span><br><span class="line">| &quot;10&quot; &gt; 9 |</span><br><span class="line">+----------+</span><br><span class="line">|        1 |</span><br><span class="line">+----------+</span><br></pre></td></tr></table></figure></li>
</ul>
<p>结果为 1 表明当字符串和数字进行比较的时候，是把字符串转成数字</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select &quot;a&quot; = 0;</span><br><span class="line">+---------+</span><br><span class="line">| &quot;a&quot; = 0 |</span><br><span class="line">+---------+</span><br><span class="line">|       1 |</span><br><span class="line">+---------+</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select &quot;123abc&quot; = 123;</span><br><span class="line">+----------------+</span><br><span class="line">| &quot;123abc&quot; = 123 |</span><br><span class="line">+----------------+</span><br><span class="line">|              1 |</span><br><span class="line">+----------------+</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select &quot;  123abc456&quot; = 123;</span><br><span class="line">+---------------------+</span><br><span class="line">| &quot;  123abc456&quot; = 123 |</span><br><span class="line">+---------------------+</span><br><span class="line">|                   1 |</span><br><span class="line">+---------------------+</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure>

<p><strong>从实验结果中可以看到，当字符串不含有数字时，会转成 0，否则转成字符串中第一段连续的数字</strong></p>
<p>我们接着来分析上面的例子，为什么一会会用到索引，一会不会用到</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-- id列上有索引，id为varchar，不会走索引</span><br><span class="line">-- id是字符串时，数据库中的id都要转成数字，转成的值不确定（例如id=&#x27;12ab&#x27;会被转成12，不可能从索引上找到12这个值的）</span><br><span class="line">-- 所以得全表扫描</span><br><span class="line">select * from article where id = 100</span><br><span class="line"></span><br><span class="line">-- id列上有索引，id为int，会走索引</span><br><span class="line">-- id是int时，&#x27;100&#x27;会被转成数字100，所以能走索引</span><br><span class="line">select * from article where id = &#x27;100&#x27;</span><br></pre></td></tr></table></figure>

<h3 id="前导模糊查询不会使用索引"><a href="#前导模糊查询不会使用索引" class="headerlink" title="前导模糊查询不会使用索引"></a>前导模糊查询不会使用索引</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 全表扫描</span><br><span class="line">select * from article where author like &#x27;%李&#x27;</span><br></pre></td></tr></table></figure>

<p>%李,%李%都会导致全表扫描，非前导模糊查询可以使用索引</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 走索引</span><br><span class="line">select * from article where author like &#x27;李%&#x27;</span><br></pre></td></tr></table></figure>

<h3 id="联合索引最左前缀原则"><a href="#联合索引最左前缀原则" class="headerlink" title="联合索引最左前缀原则"></a>联合索引最左前缀原则</h3><p>mysql 会一直向右匹配直到遇到范围查询（&gt;、&lt;、between、like）就停止匹配，比如 <code>a = 1 and b = 2 and c &gt; 3 and d = 4</code> 如果建立（a,b,c,d）顺序的索引，d 是用不到索引的，如果建立（a,b,d,c）的索引则都可以用到，a,b,d 的顺序可以任意调整</p>
<ol>
<li>将区分度最高的字段放在最左边</li>
</ol>
<p>当不需要考虑排序和分组时，将区分度最高的列放在前面通常是很好的。这时候索引的作用只是用于优化 WHERE 条件的查找</p>
<p>如果在 a b 列上建立联合索引，该如何建立，才能使查询效率最高</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select count(distinct a) / count(*), count(distinct b) / count(*), count(*) from table</span><br></pre></td></tr></table></figure>

<p>执行如下语句，假设 3 个输出依次为 0.0001,0.373,16049，可以看到 b 列的选择性最高，因此将其作为联合索引的第一列，即建立（b, a）的联合索引</p>
<ol start="2">
<li><p>查询时=可以乱序<br>如果建立了联合索引（a, b）。例如下面的2个写法是等价的，因为MySQL会将查询的顺序优化成和联合索引的顺序一致</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from table where a = &#x27;1&#x27; and b = &#x27;1&#x27;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from table where b = &#x27;1&#x27; and a = &#x27;1&#x27;</span><br></pre></td></tr></table></figure></li>
<li><p>优化查询，避免出现 filesort</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from table where a = ? and b = ? order by c</span><br></pre></td></tr></table></figure>
<p>最左前缀原则不仅用在查询中，还能用在排序中。MySQL 中，有两种方式生成有序结果集：</p>
</li>
<li><p>通过有序索引顺序扫描直接返回有序数据</p>
</li>
<li><p>Filesort排序，对返回的数据进行排序</p>
</li>
</ol>
<p>因为索引的结构是 B+树，索引中的数据是按照一定顺序进行排列的，所以在排序查询中如果能利用索引，就能避免额外的排序操作。EXPLAIN 分析查询时，Extra 显示为 Using index。</p>
<p>所有不是通过索引直接返回排序结果的操作都是 Filesort 排序，也就是说进行了额外的排序操作。EXPLAIN 分析查询时，Extra 显示为 Using filesort，当出现 Using filesort 时对性能损耗较大，所以要尽量避免 Using filesort</p>
<p>对于如下sql</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from table where a = ? and b = ? order by c</span><br></pre></td></tr></table></figure>
<p>可以建立联合索引（a, b, c）</p>
<p>如果索引中有范围查找，那么索引有序性无法利用，如</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from table where a &gt; 10 order by b</span><br></pre></td></tr></table></figure>
<p>索引（a，b）无法排序。</p>
<p>放几个例子</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">-- 使用了a列</span><br><span class="line">where a = 3</span><br><span class="line"></span><br><span class="line">-- 使用了a b列</span><br><span class="line">where a = 3 and b = 5</span><br><span class="line"></span><br><span class="line">-- 使用了a b c列</span><br><span class="line">where a = 3 and c = 4 and b = 5</span><br><span class="line"> </span><br><span class="line">-- 没有使用索引</span><br><span class="line">where b = 3</span><br><span class="line"></span><br><span class="line">-- 使用了a列 </span><br><span class="line">where a = 3 and c = 4</span><br><span class="line"></span><br><span class="line">-- 使用了a b列 </span><br><span class="line">where a = 3 and b &gt; 10 and c = 7</span><br><span class="line"> </span><br><span class="line">-- 使用了a b 列</span><br><span class="line">where a = 3 and b like &#x27;xx%&#x27; and c = 7</span><br></pre></td></tr></table></figure>

<h3 id="union，or，in-都能命中索引，建议使用in"><a href="#union，or，in-都能命中索引，建议使用in" class="headerlink" title="union，or，in 都能命中索引，建议使用in"></a>union，or，in 都能命中索引，建议使用in</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select * from article where id = 1</span><br><span class="line">union all</span><br><span class="line">select * from article where id = 2</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from article where id in (1 , 2)</span><br></pre></td></tr></table></figure>
<p>新版MySQL的or可以命中索引</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from article where id = 1 or id = 2</span><br></pre></td></tr></table></figure>
<p>效率从高到低为union，in，or。in 和 union 的效率差别可以忽略不计，建议使用 in</p>
<h3 id="负向条件索引不会使用索引，建议用-in"><a href="#负向条件索引不会使用索引，建议用-in" class="headerlink" title="负向条件索引不会使用索引，建议用 in"></a>负向条件索引不会使用索引，建议用 in</h3><p>负向条件有：!=、&lt;&gt;、not in、not exists、not like 等</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 全表扫描</span><br><span class="line">select * from article where id != 1 and id != 2</span><br></pre></td></tr></table></figure>
<p>知道 id 的所有取值范围，可以改为类似如下形式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 走索引</span><br><span class="line">select * from article where id in (0, 3, 4)</span><br></pre></td></tr></table></figure>

<h3 id="建立覆盖索引"><a href="#建立覆盖索引" class="headerlink" title="建立覆盖索引"></a>建立覆盖索引</h3><p>众所周知，表数据是放在一个聚集索引上的，而建立的索引为非聚集索引，非聚集索引的叶子节点存放索引键值，以及该索引键指向的主键。一般查找的过程是从非聚集索引上找到数据的主键，然后根据该主键到聚集索引上查找记录，这个过程称为回表，不清楚的看推荐阅读。</p>
<p>如有下面这个sql</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select uid, login_time from user where username = ? and passwd = ?</span><br></pre></td></tr></table></figure>
<p>可以建立（username, passwd, login_time）的联合索引，由于 login_time 的值可以直接从索引中拿到，不用再回表查询，提高了查询效率</p>
<h3 id="经常更改，区分度不高的列上不宜加索引"><a href="#经常更改，区分度不高的列上不宜加索引" class="headerlink" title="经常更改，区分度不高的列上不宜加索引"></a>经常更改，区分度不高的列上不宜加索引</h3><p>更新会变更 B+ 树，更新频繁的字段建立索引会大大降低数据库性能。</p>
<p>“性别”这种区分度不大的属性，建立索引是没有什么意义的，不能有效过滤数据，性能与全表扫描类似。</p>
<p>一般区分度在80%以上的时候就可以建立索引，区分度可以使用 <code>count(distinct(列名))/count(*)</code> 来计算</p>
<h3 id="明确知道只会返回一条记录，可以加limit-1"><a href="#明确知道只会返回一条记录，可以加limit-1" class="headerlink" title="明确知道只会返回一条记录，可以加limit 1"></a>明确知道只会返回一条记录，可以加limit 1</h3><p>当查询确定只有一条记录时，可以加 liimit 1，让 MySQL 停止游标移动，提高查询效率</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select uid from user where username = ? and passwd = ?</span><br></pre></td></tr></table></figure>
<p>可改为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select uid from user where username = ? and passwd = ? limit 1</span><br></pre></td></tr></table></figure>

<h3 id="对文本建立前缀索引"><a href="#对文本建立前缀索引" class="headerlink" title="对文本建立前缀索引"></a>对文本建立前缀索引</h3><p>用邮箱登录是一个常见的问题，如果对email整个字段建立索引，会让索引变得大且慢</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select username from user where email=&#x27;xxx&#x27;;</span><br></pre></td></tr></table></figure>

<p>这时我们可以索引开始的部分字符，这样可以大大节约索引空间，从而提高索引效率，但这样也会降低索引的区分度。索引的区分度是指，不重复的索引值和数据表的记录总数的比值。索引的区分度越高则查询效率越高，因为区分度高的索引可以让MySQL在查找时过滤掉更多的行。</p>
<p>因此我们选择足够长的前缀保证较高的区分度，同时又不能太长（以便节约空间）</p>
<p>可以进行如下实验</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select count(distinct left(email, 5)) / count(*) as col5,</span><br><span class="line">count(distinct left(email, 6)) / count(*) as col6,</span><br><span class="line">count(distinct left(email, 7)) / count(*) as col7</span><br><span class="line">from user</span><br></pre></td></tr></table></figure>

<p>假设输出依次为0.0305，0.0309，0.0310<br>查询显示当前缀长度达到7的时候，再增加前缀长度，区分度提升的幅度已经很小了，因此创建email(7)的前缀索引即可</p>
<p><strong>需要注意的一点是，前缀索引不能使用覆盖索引</strong></p>
<h3 id="建立索引的列不为NULL"><a href="#建立索引的列不为NULL" class="headerlink" title="建立索引的列不为NULL"></a>建立索引的列不为NULL</h3><p>只要列中包含有 NULL 值都将不会被包含在索引中，复合索引中只要有一列含有 NULL值，那么这一列对于此复合索引就是无效的。</p>
<p>因此，在数据库设计时，除非有一个很特别的原因使用 NULL 值，不然尽量不要让字段的默认值为 NULL。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wetts.github.io/2019/12/23/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%81%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95-%E7%BC%93%E5%AD%98%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Zhang Wetts">
      <meta itemprop="description" content="Stay Hungry, Stay Foolish. <br><br><p style="font-size:8px;">[build by hexo/next/gitalk/hexo-generator-search/LaTeX]</p>">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wetts's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/12/23/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%81%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95-%E7%BC%93%E5%AD%98%E7%AE%97%E6%B3%95/" class="post-title-link" itemprop="url">算法-缓存算法.md</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-12-23 15:23:18" itemprop="dateCreated datePublished" datetime="2019-12-23T15:23:18+08:00">2019-12-23</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="FIFO算法"><a href="#FIFO算法" class="headerlink" title="FIFO算法"></a>FIFO算法</h2><p>FIFO（First in First out），先进先出。其实在操作系统的设计理念中很多地方都利用到了先进先出的思想，比如作业调度（先来先服务），为什么这个原则在很多地方都会用到呢？因为这个原则简单、且符合人们的惯性思维，具备公平性，并且实现起来简单，直接使用数据结构中的队列即可实现。</p>
<p>在 FIFO Cache 设计中，核心原则就是：如果一个数据最先进入缓存中，则应该最早淘汰掉。也就是说，当缓存满的时候，应当把最先进入缓存的数据给淘汰掉。在 FIFO Cache 中应该支持以下操作;</p>
<ul>
<li><code>get(key)</code>：如果 Cache 中存在该 key，则返回对应的 value 值，否则，返回 -1；</li>
<li><code>set(key,value)</code>：如果 Cache 中存在该 key，则重置 value 值；如果不存在该 key，则将该 key 插入到到 Cache 中，若 Cache 已满，则淘汰最早进入 Cache 的数据。</li>
</ul>
<p>举个例子：假如 Cache 大小为 3，访问数据序列为 <code>set(1,1),set(2,2),set(3,3),set(4,4),get(2),set(5,5)</code></p>
<p>则 Cache 中的数据变化为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(1,1)                           set(1,1)</span><br><span class="line"></span><br><span class="line">(1,1) (2,2)                     set(2,2)</span><br><span class="line"></span><br><span class="line">(1,1) (2,2) (3,3)               set(3,3)</span><br><span class="line"></span><br><span class="line">(2,2) (3,3) (4,4)               set(4,4)</span><br><span class="line"></span><br><span class="line">(2,2) (3,3) (4,4)               get(2)</span><br><span class="line"></span><br><span class="line">(3,3) (4,4) (5,5)               set(5,5)</span><br></pre></td></tr></table></figure>

<p>那么利用什么数据结构来实现呢？</p>
<p>下面提供一种实现思路：</p>
<p>利用一个双向链表保存数据，当来了新的数据之后便添加到链表末尾，如果 Cache 存满数据，则把链表头部数据删除，然后把新的数据添加到链表末尾。在访问数据的时候，如果在 Cache 中存在该数据的话，则返回对应的 value 值；否则返回 -1。如果想提高访问效率，可以利用 hashmap 来保存每个 key 在链表中对应的位置。</p>
<h2 id="LFU-算法"><a href="#LFU-算法" class="headerlink" title="LFU 算法"></a>LFU 算法</h2><p>LFU（Least Frequently Used）最近最少使用算法。它是基于“如果一个数据在最近一段时间内使用次数很少，那么在将来一段时间内被使用的可能性也很小”的思路。</p>
<p>注意 LFU 和 LRU 算法的不同之处，LRU 的淘汰规则是基于访问时间，而 LFU 是基于访问次数的。举个简单的例子：</p>
<p>假设缓存大小为 3，数据访问序列为 <code>set(2,2),set(1,1),get(2),get(1),get(2),set(3,3),set(4,4)</code>，</p>
<p>则在 <code>set(4,4)</code> 时对于 LFU 算法应该淘汰 <code>(3,3)</code>，而 LRU 应该淘汰 <code>(1,1)</code>。</p>
<p>那么 LFU Cache 应该支持的操作为：</p>
<ul>
<li><code>get(key)</code>：如果 Cache 中存在该 key，则返回对应的 value 值，否则，返回 -1；</li>
<li><code>set(key,value)</code>：如果 Cache 中存在该 key，则重置 value 值；如果不存在该 key，则将该 key 插入到到 Cache 中，若 Cache 已满，则淘汰最少访问的数据。</li>
</ul>
<p>为了能够淘汰最少使用的数据，因此 LFU 算法最简单的一种设计思路就是 利用一个数组存储数据项，用 hashmap 存储每个数据项在数组中对应的位置，然后为每个数据项设计一个访问频次，当数据项被命中时，访问频次自增，在淘汰的时候淘汰访问频次最少的数据。这样一来的话，在插入数据和访问数据的时候都能达到 $O(1)$ 的时间复杂度，在淘汰数据的时候，通过选择算法得到应该淘汰的数据项在数组中的索引，并将该索引位置的内容替换为新来的数据内容即可，这样的话，淘汰数据的操作时间复杂度为 $O(n)$。</p>
<p>另外还有一种实现思路就是利用小顶堆+hashmap，小顶堆插入、删除操作都能达到 $O(logn)$ 时间复杂度，因此效率相比第一种实现方法更加高效。</p>
<h2 id="LRU"><a href="#LRU" class="headerlink" title="LRU"></a>LRU</h2><p>LRU（Least recently used，最近最少使用）算法根据数据的历史访问记录来进行淘汰数据，其核心思想是“如果数据最近被访问过，那么将来被访问的几率也更高”。</p>
<p><img src="/2019/12/23/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%81%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95-%E7%BC%93%E5%AD%98%E7%AE%97%E6%B3%95/1.png" alt="1"></p>
<ol>
<li>新数据插入到链表头部；</li>
<li>每当缓存命中（即缓存数据被访问），则将数据移到链表头部；</li>
<li>当链表满的时候，将链表尾部的数据丢弃。</li>
</ol>
<p>过程如下：</p>
<p><img src="/2019/12/23/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%81%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95-%E7%BC%93%E5%AD%98%E7%AE%97%E6%B3%95/2.png" alt="2"></p>
<ol>
<li>最开始时，内存空间是空的，因此依次进入 A、B、C 是没有问题的</li>
<li>当加入 D 时，就出现了问题，内存空间不够了，因此根据 LRU 算法，内存空间中 A 待的时间最为久远，选择 A，将其淘汰</li>
<li>当再次引用 B 时，内存空间中的 B 又处于活跃状态，而 C 则变成了内存空间中，近段时间最久未使用的</li>
<li>当再次向内存空间加入 E 时，这时内存空间又不足了，选择在内存空间中待的最久的C将其淘汰出内存，这时的内存空间存放的对象就是 E-&gt;B-&gt;D</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wetts.github.io/2019/12/21/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/MySQL-MVCC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Zhang Wetts">
      <meta itemprop="description" content="Stay Hungry, Stay Foolish. <br><br><p style="font-size:8px;">[build by hexo/next/gitalk/hexo-generator-search/LaTeX]</p>">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wetts's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/12/21/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/MySQL-MVCC/" class="post-title-link" itemprop="url">MySQL-MVCC.md</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-12-21 12:11:49" itemprop="dateCreated datePublished" datetime="2019-12-21T12:11:49+08:00">2019-12-21</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MySQL/" itemprop="url" rel="index"><span itemprop="name">MySQL</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>转自：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/8845ddca3b23">https://www.jianshu.com/p/8845ddca3b23</a></p>
<h2 id="前提概要"><a href="#前提概要" class="headerlink" title="前提概要"></a>前提概要</h2><h3 id="什么是MVCC"><a href="#什么是MVCC" class="headerlink" title="什么是MVCC?"></a>什么是MVCC?</h3><blockquote>
<p>MVCC，全称Multi-Version Concurrency Control，即多版本并发控制。MVCC是一种并发控制的方法，一般在数据库管理系统中，实现对数据库的并发访问，在编程语言中实现事务内存。</p>
</blockquote>
<p>MVCC 在 MySQL InnoDB中的实现主要是为了提高数据库并发性能，用更好的方式去处理读-写冲突，做到即使有读写冲突时，也能做到不加锁，非阻塞并发读</p>
<h3 id="什么是当前读和快照读？"><a href="#什么是当前读和快照读？" class="headerlink" title="什么是当前读和快照读？"></a>什么是当前读和快照读？</h3><p>在学习MVCC多版本并发控制之前，我们必须先了解一下，什么是MySQL InnoDB下的当前读和快照读?</p>
<h4 id="当前读"><a href="#当前读" class="headerlink" title="当前读"></a>当前读</h4><p>像select lock in share mode(共享锁), select for update ; update, insert ,delete(排他锁)这些操作都是一种当前读，为什么叫当前读？就是它读取的是记录的最新版本，读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁。</p>
<h4 id="快照读"><a href="#快照读" class="headerlink" title="快照读"></a>快照读</h4><p>像不加锁的select操作就是快照读，即不加锁的非阻塞读；快照读的前提是隔离级别不是串行级别，串行级别下的快照读会退化成当前读；之所以出现快照读的情况，是基于提高并发性能的考虑，快照读的实现是基于多版本并发控制，即MVCC,可以认为MVCC是行锁的一个变种，但它在很多情况下，避免了加锁操作，降低了开销；既然是基于多版本，即快照读可能读到的并不一定是数据的最新版本，而有可能是之前的历史版本</p>
<p>说白了MVCC就是为了实现读-写冲突不加锁，而这个读指的就是快照读, 而非当前读，当前读实际上是一种加锁的操作，是悲观锁的实现</p>
<h4 id="当前读，快照读和MVCC的关系"><a href="#当前读，快照读和MVCC的关系" class="headerlink" title="当前读，快照读和MVCC的关系"></a>当前读，快照读和MVCC的关系</h4><ul>
<li>准确的说，MVCC多版本并发控制指的是 “维持一个数据的多个版本，使得读写操作没有冲突” 这么一个概念。仅仅是一个理想概念</li>
<li>而在MySQL中，实现这么一个MVCC理想概念，我们就需要MySQL提供具体的功能去实现它，而快照读就是MySQL为我们实现MVCC理想模型的其中一个具体非阻塞读功能。而相对而言，当前读就是悲观锁的具体功能实现</li>
<li>要说的再细致一些，快照读本身也是一个抽象概念，再深入研究。MVCC模型在MySQL中的具体实现则是由 3个隐式字段，undo日志 ，Read View 等去完成的，具体可以看下面的MVCC实现原理</li>
</ul>
<h4 id="MVCC能解决什么问题，好处是？"><a href="#MVCC能解决什么问题，好处是？" class="headerlink" title="MVCC能解决什么问题，好处是？"></a>MVCC能解决什么问题，好处是？</h4><h5 id="数据库并发场景有三种，分别为："><a href="#数据库并发场景有三种，分别为：" class="headerlink" title="数据库并发场景有三种，分别为："></a>数据库并发场景有三种，分别为：</h5><ul>
<li>读-读：不存在任何问题，也不需要并发控制</li>
<li>读-写：有线程安全问题，可能会造成事务隔离性问题，可能遇到脏读，幻读，不可重复读</li>
<li>写-写：有线程安全问题，可能会存在更新丢失问题，比如第一类更新丢失，第二类更新丢失</li>
</ul>
<h5 id="MVCC带来的好处是？"><a href="#MVCC带来的好处是？" class="headerlink" title="MVCC带来的好处是？"></a>MVCC带来的好处是？</h5><p>多版本并发控制（MVCC）是一种用来解决读-写冲突的无锁并发控制，也就是为事务分配单向增长的时间戳，为每个修改保存一个版本，版本与事务时间戳关联，读操作只读该事务开始前的数据库的快照。 所以MVCC可以为数据库解决以下问题</p>
<ul>
<li>在并发读写数据库时，可以做到在读操作时不用阻塞写操作，写操作也不用阻塞读操作，提高了数据库并发读写的性能</li>
<li>同时还可以解决脏读，幻读，不可重复读等事务隔离问题，但不能解决更新丢失问题</li>
</ul>
<h5 id="小结一下咯"><a href="#小结一下咯" class="headerlink" title="小结一下咯"></a>小结一下咯</h5><p>总之，MVCC就是因为大牛们，不满意只让数据库采用悲观锁这样性能不佳的形式去解决读-写冲突问题，而提出的解决方案，所以在数据库中，因为有了MVCC，所以我们可以形成两个组合：</p>
<ul>
<li>MVCC + 悲观锁<ul>
<li>MVCC解决读写冲突，悲观锁解决写写冲突</li>
</ul>
</li>
<li>MVCC + 乐观锁<ul>
<li>MVCC解决读写冲突，乐观锁解决写写冲突</li>
</ul>
</li>
</ul>
<p>这种组合的方式就可以最大程度的提高数据库并发性能，并解决读写冲突，和写写冲突导致的问题</p>
<h2 id="MVCC的实现原理"><a href="#MVCC的实现原理" class="headerlink" title="MVCC的实现原理"></a>MVCC的实现原理</h2><p>MVCC的目的就是多版本并发控制，在数据库中的实现，就是为了解决读写冲突，它的实现原理主要是依赖记录中的 3个隐式字段，undo日志 ，Read View 来实现的。所以我们先来看看这个三个point的概念</p>
<h3 id="隐式字段"><a href="#隐式字段" class="headerlink" title="隐式字段"></a>隐式字段</h3><p>每行记录除了我们自定义的字段外，还有数据库隐式定义的DB_TRX_ID,DB_ROLL_PTR,DB_ROW_ID等字段</p>
<ul>
<li>DB_TRX_ID<ul>
<li>6byte，最近修改(修改/插入)事务ID：记录创建这条记录/最后一次修改该记录的事务ID</li>
</ul>
</li>
<li>DB_ROLL_PTR<ul>
<li>7byte，回滚指针，指向这条记录的上一个版本（存储于rollback segment里）</li>
</ul>
</li>
<li>DB_ROW_ID<ul>
<li>6byte，隐含的自增ID（隐藏主键），如果数据表没有主键，InnoDB会自动以DB_ROW_ID产生一个聚簇索引</li>
</ul>
</li>
<li>实际还有一个删除flag隐藏字段, 既记录被更新或删除并不代表真的删除，而是删除flag变了</li>
</ul>
<p><img src="/2019/12/21/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/MySQL-MVCC/1.png" alt="1"></p>
<p>如上图，DB_ROW_ID是数据库默认为该行记录生成的唯一隐式主键，DB_TRX_ID是当前操作该记录的事务ID,而DB_ROLL_PTR是一个回滚指针，用于配合undo日志，指向上一个旧版本</p>
<h3 id="undo日志"><a href="#undo日志" class="headerlink" title="undo日志"></a>undo日志</h3><p>undo log主要分为两种：</p>
<ul>
<li>insert undo log<ul>
<li>代表事务在insert新记录时产生的undo log, 只在事务回滚时需要，并且在事务提交后可以被立即丢弃</li>
</ul>
</li>
<li>update undo log<ul>
<li>事务在进行update或delete时产生的undo log; 不仅在事务回滚时需要，在快照读时也需要；所以不能随便删除，只有在快速读或事务回滚不涉及该日志时，对应的日志才会被purge线程统一清除</li>
</ul>
</li>
</ul>
<blockquote>
<p>purge</p>
<ul>
<li>从前面的分析可以看出，为了实现InnoDB的MVCC机制，更新或者删除操作都只是设置一下老记录的deleted_bit，并不真正将过时的记录删除。</li>
<li>为了节省磁盘空间，InnoDB有专门的purge线程来清理deleted_bit为true的记录。为了不影响MVCC的正常工作，purge线程自己也维护了一个read view（这个read view相当于系统中最老活跃事务的read view）;如果某个记录的deleted_bit为true，并且DB_TRX_ID相对于purge线程的read view可见，那么这条记录一定是可以被安全清除的。</li>
</ul>
</blockquote>
<p>对MVCC有帮助的实质是update undo log ，undo log实际上就是存在rollback segment中旧记录链，它的执行流程如下：</p>
<p>一、 比如一个有个事务插入persion表插入了一条新记录，记录如下，name为Jerry, age为24岁，隐式主键是1，事务ID和回滚指针，我们假设为NULL<br><img src="/2019/12/21/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/MySQL-MVCC/2.png" alt="2"></p>
<p>二、 现在来了一个事务1对该记录的name做出了修改，改为Tom</p>
<ul>
<li>在事务1修改该行(记录)数据时，数据库会先对该行加排他锁</li>
<li>然后把该行数据拷贝到undo log中，作为旧记录，既在undo log中有当前行的拷贝副本</li>
<li>拷贝完毕后，修改该行name为Tom，并且修改隐藏字段的事务ID为当前事务1的ID, 我们默认从1开始，之后递增，回滚指针指向拷贝到undo log的副本记录，既表示我的上一个版本就是它</li>
<li>事务提交后，释放锁</li>
</ul>
<p><img src="/2019/12/21/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/MySQL-MVCC/3.png" alt="3"></p>
<p>三、 又来了个事务2修改person表的同一个记录，将age修改为30岁</p>
<ul>
<li>在事务2修改该行数据时，数据库也先为该行加锁</li>
<li>然后把该行数据拷贝到undo log中，作为旧记录，发现该行记录已经有undo log了，那么最新的旧数据作为链表的表头，插在该行记录的undo log最前面</li>
<li>修改该行age为30岁，并且修改隐藏字段的事务ID为当前事务2的ID, 那就是2，回滚指针指向刚刚拷贝到undo log的副本记录</li>
<li>事务提交，释放锁</li>
</ul>
<p><img src="/2019/12/21/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/MySQL-MVCC/4.png" alt="4"></p>
<p>从上面，我们就可以看出，不同事务或者相同事务的对同一记录的修改，会导致该记录的undo log成为一条记录版本线性表，既链表，undo log的链首就是最新的旧记录，链尾就是最早的旧记录（当然就像之前说的该undo log的节点可能是会purge线程清除掉，向图中的第一条insert undo log，其实在事务提交之后可能就被删除丢失了，不过这里为了演示，所以还放在这里）</p>
<h3 id="Read-View-读视图"><a href="#Read-View-读视图" class="headerlink" title="Read View(读视图)"></a>Read View(读视图)</h3><h4 id="什么是Read-View"><a href="#什么是Read-View" class="headerlink" title="什么是Read View?"></a>什么是Read View?</h4><p>什么是Read View，说白了Read View就是事务进行快照读操作的时候生产的读视图(Read View)，在该事务执行的快照读的那一刻，会生成数据库系统当前的一个快照，记录并维护系统当前活跃事务的ID(当每个事务开启时，都会被分配一个ID, 这个ID是递增的，所以最新的事务，ID值越大)</p>
<p>所以我们知道 Read View主要是用来做可见性判断的, 即当我们某个事务执行快照读的时候，对该记录创建一个Read View读视图，把它比作条件用来判断当前事务能够看到哪个版本的数据，既可能是当前最新的数据，也有可能是该行记录的undo log里面的某个版本的数据。</p>
<p>Read View遵循一个可见性算法，主要是将要被修改的数据的最新记录中的DB_TRX_ID（即当前事务ID）取出来，与系统当前其他活跃事务的ID去对比（由Read View维护），如果DB_TRX_ID跟Read View的属性做了某些比较，不符合可见性，那就通过DB_ROLL_PTR回滚指针去取出Undo Log中的DB_TRX_ID再比较，即遍历链表的DB_TRX_ID（从链首到链尾，即从最近的一次修改查起），直到找到满足特定条件的DB_TRX_ID, 那么这个DB_TRX_ID所在的旧记录就是当前事务能看见的最新老版本</p>
<p>那么这个判断条件是什么呢？</p>
<p><img src="/2019/12/21/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/MySQL-MVCC/5.png" alt="5"></p>
<p>如上，它是一段MySQL判断可见性的一段源码，即changes_visible方法（不完全哈，但能看出大致逻辑），该方法展示了我们拿DB_TRX_ID去跟Read View某些属性进行怎么样的比较</p>
<p>在展示之前，我先简化一下Read View，我们可以把Read View简单的理解成有三个全局属性</p>
<ul>
<li>trx_list（名字我随便取的）<ul>
<li>一个数值列表，用来维护Read View生成时刻系统正活跃的事务ID</li>
</ul>
</li>
<li>up_limit_id<ul>
<li>记录trx_list列表中事务ID最小的ID</li>
</ul>
</li>
<li>low_limit_id<ul>
<li>ReadView生成时刻系统尚未分配的下一个事务ID，也就是目前已出现过的事务ID的最大值+1</li>
</ul>
</li>
</ul>
<ol>
<li>首先比较DB_TRX_ID &lt; up_limit_id, 如果小于，则当前事务能看到DB_TRX_ID 所在的记录，如果大于等于进入下一个判断</li>
<li>接下来判断 DB_TRX_ID 大于等于 low_limit_id , 如果大于等于则代表DB_TRX_ID 所在的记录在Read View生成后才出现的，那对当前事务肯定不可见，如果小于则进入下一个判断</li>
<li>判断DB_TRX_ID 是否在活跃事务之中，trx_list.contains(DB_TRX_ID)，如果在，则代表我Read View生成时刻，你这个事务还在活跃，还没有Commit，你修改的数据，我当前事务也是看不见的；如果不在，则说明，你这个事务在Read View生成之前就已经Commit了，你修改的结果，我当前事务是能看见的</li>
</ol>
<h3 id="整体流程"><a href="#整体流程" class="headerlink" title="整体流程"></a>整体流程</h3><p>我们在了解了隐式字段，undo log， 以及Read View的概念之后，就可以来看看MVCC实现的整体流程是怎么样了</p>
<p>整体的流程是怎么样的呢？我们可以模拟一下</p>
<ul>
<li>当事务2对某行数据执行了快照读，数据库为该行数据生成一个Read View读视图，假设当前事务ID为2，此时还有事务1和事务3在活跃中，事务4在事务2快照读前一刻提交更新了，所以Read View记录了系统当前活跃事务1，3的ID，维护在一个列表上，假设我们称为trx_list</li>
</ul>
<p><img src="/2019/12/21/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/MySQL-MVCC/6.png" alt="6"></p>
<ul>
<li>Read View不仅仅会通过一个列表trx_list来维护事务2执行快照读那刻系统正活跃的事务ID，还会有两个属性up_limit_id（记录trx_list列表中事务ID最小的ID），low_limit_id(记录trx_list列表中事务ID最大的ID，也有人说快照读那刻系统尚未分配的下一个事务ID也就是目前已出现过的事务ID的最大值+1，我更倾向于后者；所以在这里例子中up_limit_id就是1，low_limit_id就是4 + 1 = 5，trx_list集合的值是1,3，Read View如下图</li>
</ul>
<p><img src="/2019/12/21/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/MySQL-MVCC/7.png" alt="7"></p>
<ul>
<li>我们的例子中，只有事务4修改过该行记录，并在事务2执行快照读前，就提交了事务，所以当前该行当前数据的undo log如下图所示；我们的事务2在快照读该行记录的时候，就会拿该行记录的DB_TRX_ID去跟up_limit_id,low_limit_id和活跃事务ID列表(trx_list)进行比较，判断当前事务2能看到该记录的版本是哪个。</li>
</ul>
<p><img src="/2019/12/21/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/MySQL-MVCC/8.png" alt="8"></p>
<ul>
<li>所以先拿该记录DB_TRX_ID字段记录的事务ID 4去跟Read View的的up_limit_id比较，看4是否小于up_limit_id(1)，所以不符合条件，继续判断 4 是否大于等于 low_limit_id(5)，也不符合条件，最后判断4是否处于trx_list中的活跃事务, 最后发现事务ID为4的事务不在当前活跃事务列表中, 符合可见性条件，所以事务4修改后提交的最新结果对事务2快照读时是可见的，所以事务2能读到的最新数据记录是事务4所提交的版本，而事务4提交的版本也是全局角度上最新的版本</li>
</ul>
<p><img src="/2019/12/21/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/MySQL-MVCC/9.png" alt="9"></p>
<p>也正是Read View生成时机的不同，从而造成RC,RR级别下快照读的结果的不同</p>
<h2 id="MVCC相关问题"><a href="#MVCC相关问题" class="headerlink" title="MVCC相关问题"></a>MVCC相关问题</h2><h3 id="RR是如何在RC级的基础上解决不可重复读的？"><a href="#RR是如何在RC级的基础上解决不可重复读的？" class="headerlink" title="RR是如何在RC级的基础上解决不可重复读的？"></a>RR是如何在RC级的基础上解决不可重复读的？</h3><p>当前读和快照读在RR级别下的区别：</p>
<p>表1:<br><img src="/2019/12/21/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/MySQL-MVCC/10.png" alt="10"></p>
<p>表2:<br><img src="/2019/12/21/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/MySQL-MVCC/11.png" alt="11"></p>
<p>而在表2这里的顺序中，事务B在事务A提交后的快照读和当前读都是实时的新数据400，这是为什么呢？</p>
<ul>
<li>这里与上表的唯一区别仅仅是表1的事务B在事务A修改金额前快照读过一次金额数据，而表2的事务B在事务A修改金额前没有进行过快照读。</li>
</ul>
<p>所以我们知道事务中快照读的结果是非常依赖该事务首次出现快照读的地方，即某个事务中首次出现快照读的地方非常关键，它有决定该事务后续快照读结果的能力</p>
<p>我们这里测试的是更新，同时删除和更新也是一样的，如果事务B的快照读是在事务A操作之后进行的，事务B的快照读也是能读取到最新的数据的</p>
<h3 id="RC-RR级别下的InnoDB快照读有什么不同？"><a href="#RC-RR级别下的InnoDB快照读有什么不同？" class="headerlink" title="RC,RR级别下的InnoDB快照读有什么不同？"></a>RC,RR级别下的InnoDB快照读有什么不同？</h3><p>正是Read View生成时机的不同，从而造成RC,RR级别下快照读的结果的不同</p>
<ul>
<li>在RR级别下的某个事务的对某条记录的第一次快照读会创建一个快照及Read View, 将当前系统活跃的其他事务记录起来，此后在调用快照读的时候，还是使用的是同一个Read View，所以只要当前事务在其他事务提交更新之前使用过快照读，那么之后的快照读使用的都是同一个Read View，所以对之后的修改不可见；</li>
<li>即RR级别下，快照读生成Read View时，Read View会记录此时所有其他活动事务的快照，这些事务的修改对于当前事务都是不可见的。而早于Read View创建的事务所做的修改均是可见</li>
<li>而在RC级别下的，事务中，每次快照读都会新生成一个快照和Read View, 这就是我们在RC级别下的事务中可以看到别的事务提交的更新的原因</li>
</ul>
<p>总之在RC隔离级别下，是每个快照读都会生成并获取最新的Read View；而在RR隔离级别下，则是同一个事务中的第一个快照读才会创建Read View, 之后的快照读获取的都是同一个Read View。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wetts.github.io/2019/12/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%81%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91-%E4%BA%8C%E5%8F%89%E6%A0%91%E3%80%81B%E6%A0%91%E3%80%81B+%E6%A0%91%E3%80%81B*%E6%A0%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Zhang Wetts">
      <meta itemprop="description" content="Stay Hungry, Stay Foolish. <br><br><p style="font-size:8px;">[build by hexo/next/gitalk/hexo-generator-search/LaTeX]</p>">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wetts's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/12/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%81%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91-%E4%BA%8C%E5%8F%89%E6%A0%91%E3%80%81B%E6%A0%91%E3%80%81B+%E6%A0%91%E3%80%81B*%E6%A0%91/" class="post-title-link" itemprop="url">数据结构-树-二叉树、B树、B+树、B*树</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-12-13 02:05:01" itemprop="dateCreated datePublished" datetime="2019-12-13T02:05:01+08:00">2019-12-13</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" itemprop="url" rel="index"><span itemprop="name">数据结构</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>转自：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/27700617">https://zhuanlan.zhihu.com/p/27700617</a></p>
<h2 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>平衡二叉树是基于二分法的策略提高数据的查找速度的二叉树的数据结构；</p>
<h3 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h3><p>平衡二叉树是采用二分法思维把数据按规则组装成一个树形结构的数据，用这个树形结构的数据减少无关数据的检索，大大的提升了数据检索的速度；平衡二叉树的数据结构组装过程有以下规则：</p>
<ol>
<li>非叶子节点只能允许最多两个子节点存在。</li>
<li>每一个非叶子节点数据分布规则为左边的子节点小当前节点的值，右边的子节点大于当前节点的值(这里值是基于自己的算法规则而定的，比如hash值)；</li>
</ol>
<p><img src="/2019/12/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%81%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91-%E4%BA%8C%E5%8F%89%E6%A0%91%E3%80%81B%E6%A0%91%E3%80%81B+%E6%A0%91%E3%80%81B*%E6%A0%91/1.jpg" alt="1"></p>
<p>平衡树的层级结构：因为平衡二叉树查询性能和树的层级（h高度）成反比，h值越小查询越快、为了保证树的结构左右两端数据大致平衡降低二叉树的查询难度一般会采用一种算法机制实现节点数据结构的平衡，实现了这种算法的有比如Treap、红黑树，使用平衡二叉树能保证数据的左右两边的节点层级相差不会大于1.，通过这样避免树形结构由于删除增加变成线性链表影响查询效率，保证数据平衡的情况下查找数据的速度近于二分法查找；</p>
<p><img src="/2019/12/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%81%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91-%E4%BA%8C%E5%8F%89%E6%A0%91%E3%80%81B%E6%A0%91%E3%80%81B+%E6%A0%91%E3%80%81B*%E6%A0%91/2.jpg" alt="2"></p>
<p>总结平衡二叉树特点：</p>
<ol>
<li>非叶子节点最多拥有两个子节点；</li>
<li>非叶子节值大于左边子节点、小于右边子节点；</li>
<li>树的左右两边的层级数相差不会大于1;</li>
<li>没有值相等重复的节点;</li>
</ol>
<h2 id="B树-B-tree"><a href="#B树-B-tree" class="headerlink" title="B树(B-tree)"></a>B树(B-tree)</h2><p>注意:之前有看到有很多文章把B树和B-tree理解成了两种不同类别的树，其实这两个是同一种树;</p>
<h3 id="概念："><a href="#概念：" class="headerlink" title="概念："></a>概念：</h3><p>B树和平衡二叉树稍有不同的是B树属于多叉树又名平衡多路查找树（查找路径不只两个），数据库索引技术里大量使用者B树和B+树的数据结构，让我们来看看他有什么特点;</p>
<h3 id="规则："><a href="#规则：" class="headerlink" title="规则："></a>规则：</h3><ol>
<li>排序方式：所有节点关键字是按递增次序排列，并遵循左小右大原则；</li>
<li>子节点数：非叶节点的子节点数&gt;1，且&lt;=M ，且M&gt;=2，空树除外（注：M阶代表一个树节点最多有多少个查找路径，M=M路,当M=2则是2叉树,M=3则是3叉）；</li>
<li>关键字数：枝节点的关键字数量大于等于ceil(m/2)-1个且小于等于M-1个（注：ceil()是个朝正无穷方向取整的函数 如ceil(1.1)结果为2);</li>
<li>所有叶子节点均在同一层、叶子节点除了包含了关键字和关键字记录的指针外也有指向其子节点的指针只不过其指针地址都为null对应下图最后一层节点的空格子;</li>
</ol>
<p>最后我们用一个图和一个实际的例子来理解B树（这里为了理解方便我就直接用实际字母的大小来排列C&gt;B&gt;A）<br><img src="/2019/12/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%81%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91-%E4%BA%8C%E5%8F%89%E6%A0%91%E3%80%81B%E6%A0%91%E3%80%81B+%E6%A0%91%E3%80%81B*%E6%A0%91/3.jpg" alt="3"></p>
<h3 id="B树的查询流程："><a href="#B树的查询流程：" class="headerlink" title="B树的查询流程："></a>B树的查询流程：</h3><p>如上图我要从上图中找到E字母，查找流程如下</p>
<ol>
<li>获取根节点的关键字进行比较，当前根节点关键字为M，E&lt;M（26个字母顺序），所以往找到指向左边的子节点（二分法规则，左小右大，左边放小于当前节点值的子节点、右边放大于当前节点值的子节点）；</li>
<li>拿到关键字D和G，D&lt;E&lt;G 所以直接找到D和G中间的节点；</li>
<li>拿到E和F，因为E=E 所以直接返回关键字和指针信息（如果树结构里面没有包含所要查找的节点则返回null）；</li>
</ol>
<h3 id="B树的插入节点流程"><a href="#B树的插入节点流程" class="headerlink" title="B树的插入节点流程"></a>B树的插入节点流程</h3><p>定义一个5阶树（平衡5路查找树;），现在我们要把3、8、31、11、23、29、50、28 这些数字构建出一个5阶树出来;</p>
<p>遵循规则：</p>
<ol>
<li>节点拆分规则：当前是要组成一个5路查找树，那么此时m=5,关键字数必须&lt;=5-1（这里关键字数&gt;4就要进行节点拆分）；</li>
<li>排序规则：满足节点本身比左边节点大，比右边节点小的排序规则;</li>
</ol>
<p>先插入 3、8、31、11<br><img src="/2019/12/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%81%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91-%E4%BA%8C%E5%8F%89%E6%A0%91%E3%80%81B%E6%A0%91%E3%80%81B+%E6%A0%91%E3%80%81B*%E6%A0%91/4.jpg" alt="4"></p>
<p>再插入23、29<br><img src="/2019/12/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%81%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91-%E4%BA%8C%E5%8F%89%E6%A0%91%E3%80%81B%E6%A0%91%E3%80%81B+%E6%A0%91%E3%80%81B*%E6%A0%91/5.png" alt="5"></p>
<p>再插入50、28<br><img src="/2019/12/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%81%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91-%E4%BA%8C%E5%8F%89%E6%A0%91%E3%80%81B%E6%A0%91%E3%80%81B+%E6%A0%91%E3%80%81B*%E6%A0%91/6.png" alt="6"></p>
<h3 id="B树节点的删除"><a href="#B树节点的删除" class="headerlink" title="B树节点的删除"></a>B树节点的删除</h3><p>规则：</p>
<ol>
<li>节点合并规则：当前是要组成一个5路查找树，那么此时m=5,关键字数必须大于等于ceil（5/2）（这里关键字数&lt;2就要进行节点合并）；</li>
<li>满足节点本身比左边节点大，比右边节点小的排序规则;</li>
<li>关键字数小于二时先从子节点取，子节点没有符合条件时就向向父节点取，取中间值往父节点放；<br><img src="/2019/12/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%81%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91-%E4%BA%8C%E5%8F%89%E6%A0%91%E3%80%81B%E6%A0%91%E3%80%81B+%E6%A0%91%E3%80%81B*%E6%A0%91/7.png" alt="7"></li>
</ol>
<h3 id="特点：-1"><a href="#特点：-1" class="headerlink" title="特点："></a>特点：</h3><p>B树相对于平衡二叉树的不同是，每个节点包含的关键字增多了，特别是在B树应用到数据库中的时候，数据库充分利用了磁盘块的原理（磁盘数据存储是采用块的形式存储的，每个块的大小为4K，每次IO进行数据读取时，同一个磁盘块的数据可以一次性读取出来）把节点大小限制和充分使用在磁盘快大小范围；把树的节点关键字增多后树的层级比原来的二叉树少了，减少数据查找的次数和复杂度;</p>
<h2 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p>B+树是B树的一个升级版，相对于B树来说B+树更充分的利用了节点的空间，让查询速度更加稳定，其速度完全接近于二分法查找。为什么说B+树查找的效率要比B树更高、更稳定；我们先看看两者的区别</p>
<h3 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h3><ol>
<li>B+跟B树不同B+树的非叶子节点不保存关键字记录的指针，只进行数据索引，这样使得B+树每个非叶子节点所能保存的关键字大大增加；</li>
<li>B+树叶子节点保存了父节点的所有关键字记录的指针，所有数据地址必须要到叶子节点才能获取到。所以每次数据查询的次数都一样；</li>
<li>B+树叶子节点的关键字从小到大有序排列，左边结尾数据都会保存右边节点开始数据的指针。</li>
<li>非叶子节点的子节点数=关键字数（来源百度百科）（根据各种资料 这里有两种算法的实现方式，另一种为非叶节点的关键字数=子节点数-1（来源维基百科)，虽然他们数据排列结构不一样，但其原理还是一样的Mysql 的B+树是用第一种方式实现）;</li>
</ol>
<p><img src="/2019/12/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%81%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91-%E4%BA%8C%E5%8F%89%E6%A0%91%E3%80%81B%E6%A0%91%E3%80%81B+%E6%A0%91%E3%80%81B*%E6%A0%91/8.jpg" alt="8"><br>（百度百科算法结构示意图）</p>
<p><img src="/2019/12/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%81%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91-%E4%BA%8C%E5%8F%89%E6%A0%91%E3%80%81B%E6%A0%91%E3%80%81B+%E6%A0%91%E3%80%81B*%E6%A0%91/9.jpg" alt="9"><br>（维基百科算法结构示意图）</p>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ol>
<li>B+树的层级更少：相较于B树B+每个非叶子节点存储的关键字数更多，树的层级更少所以查询数据更快；</li>
<li>B+树查询速度更稳定：B+所有关键字数据地址都存在叶子节点上，所以每次查找的次数都相同所以查询速度要比B树更稳定;</li>
<li>B+树天然具备排序功能：B+树所有的叶子节点数据构成了一个有序链表，在查询大小区间的数据时候更方便，数据紧密性很高，缓存的命中率也会比B树高。</li>
<li>B+树全节点遍历更快：B+树遍历整棵树只需要遍历所有的叶子节点即可，，而不需要像B树一样需要对每一层进行遍历，这有利于数据库做全表扫描。</li>
</ol>
<p>B树相对于B+树的优点是，如果经常访问的数据离根节点很近，而B树的非叶子节点本身存有关键字其数据的地址，所以这种数据检索的时候会要比B+树快。</p>
<h2 id="B-树-1"><a href="#B-树-1" class="headerlink" title="B*树"></a>B*树</h2><h3 id="规则-1"><a href="#规则-1" class="headerlink" title="规则"></a>规则</h3><p>B*树是B+树的变种，相对于B+树他们的不同之处如下：</p>
<ol>
<li>首先是关键字个数限制问题，B+树初始化的关键字初始化个数是cei(m/2)，b<em>树的初始化个数为（cei(2/3</em>m)）</li>
<li>B+树节点满时就会分裂，而B*树节点满时会检查兄弟节点是否满（因为每个节点都有指向兄弟的指针），如果兄弟节点未满则向兄弟节点转移关键字，如果兄弟节点已满，则从当前节点和兄弟节点各拿出1/3的数据创建一个新的节点出来；</li>
</ol>
<h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><p>在B+树的基础上因其初始化的容量变大，使得节点空间使用率更高，而又存有兄弟节点的指针，可以向兄弟节点转移关键字的特性使得B*树额分解次数变得更少；</p>
<p><img src="/2019/12/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%81%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91-%E4%BA%8C%E5%8F%89%E6%A0%91%E3%80%81B%E6%A0%91%E3%80%81B+%E6%A0%91%E3%80%81B*%E6%A0%91/10.jpg" alt="10"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li><p>相同思想和策略</p>
<p> 从平衡数据结构-树-二叉树、B树、B+树、B*树总体来看它们的贯彻的思想是相同的，都是采用二分法和数据平衡策略来提升查找数据的速度；</p>
</li>
<li><p>不同的方式的磁盘空间利用</p>
<p> 不同点是他们一个一个在演变的过程中通过IO从磁盘读取数据的原理进行一步步的演变，每一次演变都是为了让节点的空间更合理的运用起来，从而使树的层级减少达到快速查找数据的目的；</p>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wetts.github.io/2019/11/27/%E5%B7%A5%E7%A8%8B/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8FID-%E9%9B%AA%E8%8A%B1%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Zhang Wetts">
      <meta itemprop="description" content="Stay Hungry, Stay Foolish. <br><br><p style="font-size:8px;">[build by hexo/next/gitalk/hexo-generator-search/LaTeX]</p>">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wetts's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/11/27/%E5%B7%A5%E7%A8%8B/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8FID-%E9%9B%AA%E8%8A%B1%E7%AE%97%E6%B3%95/" class="post-title-link" itemprop="url">分布式ID-雪花算法.md</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-11-27 14:58:57" itemprop="dateCreated datePublished" datetime="2019-11-27T14:58:57+08:00">2019-11-27</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/" itemprop="url" rel="index"><span itemprop="name">分布式</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>转自：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/85837641">https://zhuanlan.zhihu.com/p/85837641</a></p>
<h1 id="一"><a href="#一" class="headerlink" title="一"></a>一</h1><h2 id="分布式ID的特点"><a href="#分布式ID的特点" class="headerlink" title="分布式ID的特点"></a>分布式ID的特点</h2><h3 id="全局唯一性"><a href="#全局唯一性" class="headerlink" title="全局唯一性"></a>全局唯一性</h3><p>不能出现有重复的ID标识，这是基本要求。</p>
<h3 id="递增性"><a href="#递增性" class="headerlink" title="递增性"></a>递增性</h3><p>确保生成ID对于用户或业务是递增的。</p>
<h3 id="高可用性"><a href="#高可用性" class="headerlink" title="高可用性"></a>高可用性</h3><p>确保任何时候都能生成正确的ID。</p>
<h3 id="高性能性"><a href="#高性能性" class="headerlink" title="高性能性"></a>高性能性</h3><p>在高并发的环境下依然表现良好。</p>
<h2 id="分布式ID的常见解决方案"><a href="#分布式ID的常见解决方案" class="headerlink" title="分布式ID的常见解决方案"></a>分布式ID的常见解决方案</h2><h3 id="UUID"><a href="#UUID" class="headerlink" title="UUID"></a>UUID</h3><p>Java自带的生成一串唯一随机36位字符串（32个字符串+4个“-”）的算法。它可以保证唯一性，且据说够用N亿年，但是其业务可读性差，无法有序递增。</p>
<h3 id="SnowFlake"><a href="#SnowFlake" class="headerlink" title="SnowFlake"></a>SnowFlake</h3><p>今天的主角雪花算法，它是Twitter开源的由64位整数组成分布式ID，性能较高，并且在单机上递增。 具体参考：<code>https://github.com/twitter-archive/snowflake</code></p>
<h3 id="UidGenerator"><a href="#UidGenerator" class="headerlink" title="UidGenerator"></a>UidGenerator</h3><p>UidGenerator是百度开源的分布式ID生成器，其基于雪花算法实现。 具体参考：<code>https://github.com/baidu/uid-generator/blob/master/README.zh_cn.md</code></p>
<h3 id="Leaf"><a href="#Leaf" class="headerlink" title="Leaf"></a>Leaf</h3><p>Leaf是美团开源的分布式ID生成器，能保证全局唯一，趋势递增，但需要依赖关系数据库、Zookeeper等中间件。 具体参考：<code>https://tech.meituan.com/MT_Leaf.html</code></p>
<h2 id="雪花算法的概要"><a href="#雪花算法的概要" class="headerlink" title="雪花算法的概要"></a>雪花算法的概要</h2><p>SnowFlake是Twitter公司采用的一种算法，目的是在分布式系统中产生全局唯一且趋势递增的ID。</p>
<p><img src="/2019/11/27/%E5%B7%A5%E7%A8%8B/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8FID-%E9%9B%AA%E8%8A%B1%E7%AE%97%E6%B3%95/1.jpg" alt="1"></p>
<h3 id="组成部分（64bit）"><a href="#组成部分（64bit）" class="headerlink" title="组成部分（64bit）"></a>组成部分（64bit）</h3><ol>
<li>第一位 占用1bit，其值始终是0，没有实际作用。</li>
<li>时间戳 占用41bit，精确到毫秒，总共可以容纳约69年的时间。</li>
<li>工作机器id 占用10bit，其中高位5bit是数据中心ID，低位5bit是工作节点ID，做多可以容纳1024个节点。</li>
<li>序列号 占用12bit，每个节点每毫秒0开始不断累加，最多可以累加到4095，一共可以产生4096个ID。</li>
</ol>
<p>SnowFlake算法在同一毫秒内最多可以生成多少个全局唯一ID呢：： 同一毫秒的ID数量 = 1024 X 4096 = 4194304</p>
<h2 id="雪花算法的实现"><a href="#雪花算法的实现" class="headerlink" title="雪花算法的实现"></a>雪花算法的实现</h2><p>雪花算法的实现主要依赖于数据中心ID和数据节点ID这两个参数，具体实现如下。</p>
<h3 id="JAVA实现"><a href="#JAVA实现" class="headerlink" title="JAVA实现"></a>JAVA实现</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line">public class SnowflakeIdWorker &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 开始时间截 (2015-01-01)</span><br><span class="line">     */</span><br><span class="line">    private final long twepoch = 1420041600000L;</span><br><span class="line">    /**</span><br><span class="line">     * 机器id所占的位数</span><br><span class="line">     */</span><br><span class="line">    private final long workerIdBits = 5L;</span><br><span class="line">    /**</span><br><span class="line">     * 数据标识id所占的位数</span><br><span class="line">     */</span><br><span class="line">    private final long datacenterIdBits = 5L;</span><br><span class="line">    /**</span><br><span class="line">     * 支持的最大机器id，结果是31 (这个移位算法可以很快的计算出几位二进制数所能表示的最大十进制数)</span><br><span class="line">     */</span><br><span class="line">    private final long maxWorkerId = -1L ^ (-1L &lt;&lt; workerIdBits);</span><br><span class="line">    /**</span><br><span class="line">     * 支持的最大数据标识id，结果是31</span><br><span class="line">     */</span><br><span class="line">    private final long maxDatacenterId = -1L ^ (-1L &lt;&lt; datacenterIdBits);</span><br><span class="line">    /**</span><br><span class="line">     * 序列在id中占的位数</span><br><span class="line">     */</span><br><span class="line">    private final long sequenceBits = 12L;</span><br><span class="line">    /**</span><br><span class="line">     * 机器ID向左移12位</span><br><span class="line">     */</span><br><span class="line">    private final long workerIdShift = sequenceBits;</span><br><span class="line">    /**</span><br><span class="line">     * 数据标识id向左移17位(12+5)</span><br><span class="line">     */</span><br><span class="line">    private final long datacenterIdShift = sequenceBits + workerIdBits;</span><br><span class="line">    /**</span><br><span class="line">     * 时间截向左移22位(5+5+12)</span><br><span class="line">     */</span><br><span class="line">    private final long timestampLeftShift = sequenceBits + workerIdBits + datacenterIdBits;</span><br><span class="line">    /**</span><br><span class="line">     * 生成序列的掩码，这里为4095 (0b111111111111=0xfff=4095)</span><br><span class="line">     */</span><br><span class="line">    private final long sequenceMask = -1L ^ (-1L &lt;&lt; sequenceBits);</span><br><span class="line">    /**</span><br><span class="line">     * 工作机器ID(0~31)</span><br><span class="line">     */</span><br><span class="line">    private long workerId;</span><br><span class="line">    /**</span><br><span class="line">     * 数据中心ID(0~31)</span><br><span class="line">     */</span><br><span class="line">    private long datacenterId;</span><br><span class="line">    /**</span><br><span class="line">     * 毫秒内序列(0~4095)</span><br><span class="line">     */</span><br><span class="line">    private long sequence = 0L;</span><br><span class="line">    /**</span><br><span class="line">     * 上次生成ID的时间截</span><br><span class="line">     */</span><br><span class="line">    private long lastTimestamp = -1L;</span><br><span class="line">    /**</span><br><span class="line">     * 构造函数</span><br><span class="line">     * @param workerId     工作ID (0~31)</span><br><span class="line">     * @param datacenterId 数据中心ID (0~31)</span><br><span class="line">     */</span><br><span class="line">    public SnowflakeIdWorker(long workerId, long datacenterId) &#123;</span><br><span class="line">        if (workerId &gt; maxWorkerId || workerId &lt; 0) &#123;</span><br><span class="line">            throw new IllegalArgumentException(String.format(&quot;worker Id can&#x27;t be greater than %d or less than 0&quot;, maxWorkerId));</span><br><span class="line">        &#125;</span><br><span class="line">        if (datacenterId &gt; maxDatacenterId || datacenterId &lt; 0) &#123;</span><br><span class="line">            throw new IllegalArgumentException(String.format(&quot;datacenter Id can&#x27;t be greater than %d or less than 0&quot;, maxDatacenterId));</span><br><span class="line">        &#125;</span><br><span class="line">        this.workerId = workerId;</span><br><span class="line">        this.datacenterId = datacenterId;</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * 获得下一个ID (该方法是线程安全的)</span><br><span class="line">     * @return SnowflakeId</span><br><span class="line">     */</span><br><span class="line">    public synchronized long nextId() &#123;</span><br><span class="line">        long timestamp = timeGen();</span><br><span class="line">        // 如果当前时间小于上一次ID生成的时间戳，说明系统时钟回退过这个时候应当抛出异常</span><br><span class="line">        if (timestamp &lt; lastTimestamp) &#123;</span><br><span class="line">            throw new RuntimeException(</span><br><span class="line">                    String.format(&quot;Clock moved backwards.  Refusing to generate id for %d milliseconds&quot;, lastTimestamp - timestamp));</span><br><span class="line">        &#125;</span><br><span class="line">        // 如果是同一时间生成的，则进行毫秒内序列</span><br><span class="line">        if (lastTimestamp == timestamp) &#123;</span><br><span class="line">            sequence = (sequence + 1) &amp; sequenceMask;</span><br><span class="line">            // 毫秒内序列溢出</span><br><span class="line">            if (sequence == 0) &#123;</span><br><span class="line">                //阻塞到下一个毫秒,获得新的时间戳</span><br><span class="line">                timestamp = tilNextMillis(lastTimestamp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 时间戳改变，毫秒内序列重置</span><br><span class="line">        else &#123;</span><br><span class="line">            sequence = 0L;</span><br><span class="line">        &#125;</span><br><span class="line">        // 上次生成ID的时间截</span><br><span class="line">        lastTimestamp = timestamp;</span><br><span class="line">        // 移位并通过或运算拼到一起组成64位的ID</span><br><span class="line">        return ((timestamp - twepoch) &lt;&lt; timestampLeftShift) //</span><br><span class="line">                | (datacenterId &lt;&lt; datacenterIdShift) //</span><br><span class="line">                | (workerId &lt;&lt; workerIdShift) //</span><br><span class="line">                | sequence;</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * 阻塞到下一个毫秒，直到获得新的时间戳</span><br><span class="line">     * @param lastTimestamp 上次生成ID的时间截</span><br><span class="line">     * @return 当前时间戳</span><br><span class="line">     */</span><br><span class="line">    protected long tilNextMillis(long lastTimestamp) &#123;</span><br><span class="line">        long timestamp = timeGen();</span><br><span class="line">        while (timestamp &lt;= lastTimestamp) &#123;</span><br><span class="line">            timestamp = timeGen();</span><br><span class="line">        &#125;</span><br><span class="line">        return timestamp;</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * 返回以毫秒为单位的当前时间</span><br><span class="line">     * @return 当前时间(毫秒)</span><br><span class="line">     */</span><br><span class="line">    protected long timeGen() &#123;</span><br><span class="line">        return System.currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        SnowflakeIdWorker idWorker = new SnowflakeIdWorker(0, 0);</span><br><span class="line">        for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">            long id = idWorker.nextId();</span><br><span class="line">            Thread.sleep(1);</span><br><span class="line">            System.out.println(id);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Python实现"><a href="#Python实现" class="headerlink" title="Python实现"></a>Python实现</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"># coding: utf-8</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class InvalidSystemClock(Exception):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    时钟回拨异常</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line"># 64位ID的划分</span><br><span class="line">WORKER_ID_BITS = 5</span><br><span class="line">DATACENTER_ID_BITS = 5</span><br><span class="line">SEQUENCE_BITS = 12</span><br><span class="line"></span><br><span class="line"># 最大取值计算</span><br><span class="line">MAX_WORKER_ID = -1 ^ (-1 &lt;&lt; WORKER_ID_BITS)  # 2**5-1 0b11111</span><br><span class="line">MAX_DATACENTER_ID = -1 ^ (-1 &lt;&lt; DATACENTER_ID_BITS)</span><br><span class="line"></span><br><span class="line"># 移位偏移计算</span><br><span class="line">WOKER_ID_SHIFT = SEQUENCE_BITS</span><br><span class="line">DATACENTER_ID_SHIFT = SEQUENCE_BITS + WORKER_ID_BITS</span><br><span class="line">TIMESTAMP_LEFT_SHIFT = SEQUENCE_BITS + WORKER_ID_BITS + DATACENTER_ID_BITS</span><br><span class="line"></span><br><span class="line"># 序号循环掩码</span><br><span class="line">SEQUENCE_MASK = -1 ^ (-1 &lt;&lt; SEQUENCE_BITS)</span><br><span class="line"></span><br><span class="line"># 开始时间截 (2015-01-01)</span><br><span class="line">TWEPOCH = 1420041600000</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class IdWorker(object):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    用于生成IDs</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    def __init__(self, datacenter_id, worker_id, sequence=0):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        初始化</span><br><span class="line">        :param datacenter_id: 数据中心（机器区域）ID</span><br><span class="line">        :param worker_id: 机器ID</span><br><span class="line">        :param sequence: 其实序号</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        # sanity check</span><br><span class="line">        if worker_id &gt; MAX_WORKER_ID or worker_id &lt; 0:</span><br><span class="line">            raise ValueError(&#x27;worker_id值越界&#x27;)</span><br><span class="line"></span><br><span class="line">        if datacenter_id &gt; MAX_DATACENTER_ID or datacenter_id &lt; 0:</span><br><span class="line">            raise ValueError(&#x27;datacenter_id值越界&#x27;)</span><br><span class="line"></span><br><span class="line">        self.worker_id = worker_id</span><br><span class="line">        self.datacenter_id = datacenter_id</span><br><span class="line">        self.sequence = sequence</span><br><span class="line"></span><br><span class="line">        self.last_timestamp = -1  # 上次计算的时间戳</span><br><span class="line"></span><br><span class="line">    def _gen_timestamp(self):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        生成整数时间戳</span><br><span class="line">        :return:int timestamp</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        return int(time.time() * 1000)</span><br><span class="line"></span><br><span class="line">    def get_id(self):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        获取新ID</span><br><span class="line">        :return:</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        timestamp = self._gen_timestamp()</span><br><span class="line"></span><br><span class="line">        # 时钟回拨</span><br><span class="line">        if timestamp &lt; self.last_timestamp:</span><br><span class="line">            raise InvalidSystemClock</span><br><span class="line"></span><br><span class="line">        if timestamp == self.last_timestamp:</span><br><span class="line">            self.sequence = (self.sequence + 1) &amp; SEQUENCE_MASK</span><br><span class="line">            if self.sequence == 0:</span><br><span class="line">                timestamp = self._til_next_millis(self.last_timestamp)</span><br><span class="line">        else:</span><br><span class="line">            self.sequence = 0</span><br><span class="line"></span><br><span class="line">        self.last_timestamp = timestamp</span><br><span class="line"></span><br><span class="line">        new_id = ((timestamp - TWEPOCH) &lt;&lt; TIMESTAMP_LEFT_SHIFT) | (self.datacenter_id &lt;&lt; DATACENTER_ID_SHIFT) | \</span><br><span class="line">                 (self.worker_id &lt;&lt; WOKER_ID_SHIFT) | self.sequence</span><br><span class="line">        return new_id</span><br><span class="line"></span><br><span class="line">    def _til_next_millis(self, last_timestamp):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        等到下一毫秒</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        timestamp = self._gen_timestamp()</span><br><span class="line">        while timestamp &lt;= last_timestamp:</span><br><span class="line">            timestamp = self._gen_timestamp()</span><br><span class="line">        return timestamp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    worker = IdWorker(0, 0)</span><br><span class="line">    print(worker.get_id())</span><br></pre></td></tr></table></figure>

<hr>
<p>转自：<a target="_blank" rel="noopener" href="https://blog.csdn.net/ycb1689/article/details/89331634">https://blog.csdn.net/ycb1689/article/details/89331634</a></p>
<h1 id="二"><a href="#二" class="headerlink" title="二"></a>二</h1><h2 id="snowflake简介"><a href="#snowflake简介" class="headerlink" title="snowflake简介"></a>snowflake简介</h2><p>互联网快速发展的今天，分布式应用系统已经见怪不怪，在分布式系统中，我们需要各种各样的ID，既然是ID那么必然是要保证全局唯一，除此之外，不同当业务还需要不同的特性，比如像并发巨大的业务要求ID生成效率高，吞吐大；比如某些银行类业务，需要按每日日期制定交易流水号；又比如我们希望用户的ID是随机的，无序的，纯数字的，且位数长度是小于10位的。等等，不同的业务场景需要的ID特性各不一样，于是，衍生了各种ID生成器，但大多数利用数据库控制ID的生成，性能受数据库并发能力限制，那么有没有一款不需要依赖任何中间件（如数据库，分布式缓存服务等）的ID生成器呢？本着取之于开源，用之于开源的原则，今天，特此介绍Twitter开源的一款分布式自增ID算法snowflake，并附上算法原理推导和演算过程！</p>
<p>snowflake算法是一款本地生成的（ID生成过程不依赖任何中间件，无网络通信），保证ID全局唯一，并且ID总体有序递增，性能每秒生成300w＋。</p>
<p><img src="/2019/11/27/%E5%B7%A5%E7%A8%8B/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8FID-%E9%9B%AA%E8%8A%B1%E7%AE%97%E6%B3%95/2.png" alt="2"></p>
<ul>
<li>1bit:一般是符号位，不做处理</li>
<li>41bit:用来记录时间戳，这里可以记录69年，如果设置好起始时间比如今年是2018年，那么可以用到2089年，到时候怎么办？要是这个系统能用69年，我相信这个系统早都重构了好多次了。</li>
<li>10bit:10bit用来记录机器ID，总共可以记录1024台机器，一般用前5位代表数据中心ID，后面5位是某个数据中心的机器ID</li>
<li>12bit:循环位，用来对同一个毫秒之内产生不同的ID，12位可以最多记录4095个，也就是在同一个机器同一毫秒最多记录4095个，多余的需要进行等待下毫秒。</li>
</ul>
<blockquote>
<p>总体来说，在工作节点达到1024顶配的场景下，SnowFlake算法在同一毫秒内最多可以生成多少个全局唯一ID呢？这是一个简单的乘法：</p>
<p>同一毫秒的ID数量 = 1024 X 4096 = 4194304</p>
<p>400多万个ID，这个数字在绝大多数并发场景下都是够用的。</p>
<p>snowflake 算法中，第三个部分是工作机器ID，可以结合上一节的命名方法，并通过Zookeeper管理workId，免去手动频繁修改集群节点，免去配置机器ID的麻烦。</p>
</blockquote>
<p>上面只是一个将64bit划分的标准，当然也不一定这么做，可以根据不同业务的具体场景来划分，比如下面给出一个业务场景：</p>
<ul>
<li>服务目前QPS10万，预计几年之内会发展到百万。</li>
<li>当前机器三地部署，上海，北京，深圳都有。</li>
<li>当前机器10台左右，预计未来会增加至百台。</li>
</ul>
<p>这个时候我们根据上面的场景可以再次合理的划分62bit,QPS几年之内会发展到百万，那么每毫秒就是千级的请求，目前10台机器那么每台机器承担百级的请求，为了保证扩展，后面的循环位可以限制到1024，也就是2^10，那么循环位10位就足够了。</p>
<p>机器三地部署我们可以用3bit总共8来表示机房位置，当前的机器10台，为了保证扩展到百台那么可以用7bit 128来表示，时间位依然是41bit,那么还剩下64-10-3-7-41-1 = 2bit,还剩下2bit可以用来进行扩展。</p>
<p><img src="/2019/11/27/%E5%B7%A5%E7%A8%8B/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8FID-%E9%9B%AA%E8%8A%B1%E7%AE%97%E6%B3%95/3.png" alt="3"></p>
<p>适用场景：当我们需要无序不能被猜测的ID，并且需要一定高性能，且需要long型，那么就可以使用我们雪花算法。比如常见的订单ID，用雪花算法别人就发猜测你每天的订单量是多少。</p>
<p>上面定义了雪花算法的实现，在nextId中是我们生成雪花算法的关键。</p>
<h2 id="防止时钟回拨"><a href="#防止时钟回拨" class="headerlink" title="防止时钟回拨"></a>防止时钟回拨</h2><p>因为机器的原因会发生时间回拨，我们的雪花算法是强依赖我们的时间的，如果时间发生回拨，有可能会生成重复的ID，在我们上面的nextId中我们用当前时间和上一次的时间进行判断，如果当前时间小于上一次的时间那么肯定是发生了回拨，普通的算法会直接抛出异常,这里我们可以对其进行优化,一般分为两个情况:</p>
<ul>
<li>如果时间回拨时间较短，比如配置5ms以内，那么可以直接等待一定的时间，让机器的时间追上来。</li>
<li>如果时间的回拨时间较长，我们不能接受这么长的阻塞等待，那么又有两个策略:<ol>
<li>直接拒绝，抛出异常，打日志，通知RD时钟回滚。</li>
<li>利用扩展位，上面我们讨论过不同业务场景位数可能用不到那么多，那么我们可以把扩展位数利用起来了，比如当这个时间回拨比较长的时候，我们可以不需要等待，直接在扩展位加1。2位的扩展位允许我们有3次大的时钟回拨，一般来说就够了，如果其超过三次我们还是选择抛出异常，打日志。</li>
</ol>
</li>
</ul>
<p>通过上面的几种策略可以比较的防护我们的时钟回拨，防止出现回拨之后大量的异常出现。下面是修改之后的代码，这里修改了时钟回拨的逻辑:</p>
<p>最终代码如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br></pre></td><td class="code"><pre><span class="line">import org.apache.commons.lang3.RandomUtils;</span><br><span class="line">import org.apache.commons.lang3.StringUtils;</span><br><span class="line">import org.slf4j.Logger;</span><br><span class="line">import org.slf4j.LoggerFactory;</span><br><span class="line"> </span><br><span class="line">import java.lang.management.ManagementFactory;</span><br><span class="line">import java.net.InetAddress;</span><br><span class="line">import java.net.NetworkInterface;</span><br><span class="line">import java.net.UnknownHostException;</span><br><span class="line">import java.text.SimpleDateFormat;</span><br><span class="line">import java.util.*;</span><br><span class="line">import java.util.concurrent.ConcurrentHashMap;</span><br><span class="line">import java.util.concurrent.CountDownLatch;</span><br><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line">import java.util.concurrent.locks.LockSupport;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">/**</span><br><span class="line"> * 分布式全局ID雪花算法解决方案</span><br><span class="line"> *</span><br><span class="line"> * 防止时钟回拨</span><br><span class="line"> * 因为机器的原因会发生时间回拨，我们的雪花算法是强依赖我们的时间的，如果时间发生回拨，</span><br><span class="line"> * 有可能会生成重复的ID，在我们上面的nextId中我们用当前时间和上一次的时间进行判断，</span><br><span class="line"> * 如果当前时间小于上一次的时间那么肯定是发生了回拨，</span><br><span class="line"> * 普通的算法会直接抛出异常,这里我们可以对其进行优化,一般分为两个情况:</span><br><span class="line"> * 如果时间回拨时间较短，比如配置5ms以内，那么可以直接等待一定的时间，让机器的时间追上来。</span><br><span class="line"> * 如果时间的回拨时间较长，我们不能接受这么长的阻塞等待，那么又有两个策略:</span><br><span class="line"> * 直接拒绝，抛出异常，打日志，通知RD时钟回滚。</span><br><span class="line"> * 利用扩展位，上面我们讨论过不同业务场景位数可能用不到那么多，那么我们可以把扩展位数利用起来了，</span><br><span class="line"> * 比如当这个时间回拨比较长的时候，我们可以不需要等待，直接在扩展位加1。</span><br><span class="line"> * 2位的扩展位允许我们有3次大的时钟回拨，一般来说就够了，如果其超过三次我们还是选择抛出异常，打日志。</span><br><span class="line"> * 通过上面的几种策略可以比较的防护我们的时钟回拨，防止出现回拨之后大量的异常出现。下面是修改之后的代码，这里修改了时钟回拨的逻辑:</span><br><span class="line"> */</span><br><span class="line">public class SnowflakeIdFactory &#123;</span><br><span class="line"> </span><br><span class="line">    private static final Logger log = LoggerFactory.getLogger(SnowflakeIdFactory.class);</span><br><span class="line"> </span><br><span class="line">    /**</span><br><span class="line">     * EPOCH是服务器第一次上线时间点, 设置后不允许修改</span><br><span class="line">     * 2018/9/29日，从此时开始计算，可以用到2089年</span><br><span class="line">     */</span><br><span class="line">    private static long EPOCH = 1538211907857L;</span><br><span class="line"> </span><br><span class="line">    /**</span><br><span class="line">     * 每台workerId服务器有3个备份workerId, 备份workerId数量越多, 可靠性越高, 但是可部署的sequence ID服务越少</span><br><span class="line">     */</span><br><span class="line">    private static final long BACKUP_COUNT = 3;</span><br><span class="line"> </span><br><span class="line">    /**</span><br><span class="line">     * worker id 的bit数，最多支持8192个节点</span><br><span class="line">     */</span><br><span class="line">    private static final long workerIdBits = 5L;</span><br><span class="line">    /**</span><br><span class="line">     * 数据中心标识位数</span><br><span class="line">     */</span><br><span class="line">    private static final long dataCenterIdBits = 5L;</span><br><span class="line">    /**</span><br><span class="line">     * 序列号，支持单节点最高每毫秒的最大ID数4096</span><br><span class="line">     * 毫秒内自增位</span><br><span class="line">     */</span><br><span class="line">    private static final long sequenceBits = 12L;</span><br><span class="line"> </span><br><span class="line">    /**</span><br><span class="line">     * 机器ID偏左移12位</span><br><span class="line">     */</span><br><span class="line">    private static final long workerIdShift = sequenceBits;</span><br><span class="line"> </span><br><span class="line">    /**</span><br><span class="line">     * 数据中心ID左移17位(12+5)</span><br><span class="line">     */</span><br><span class="line">    private static final long dataCenterIdShift = sequenceBits + workerIdBits;</span><br><span class="line"> </span><br><span class="line">    /**</span><br><span class="line">     * 时间毫秒左移22位(5+5+12)</span><br><span class="line">     */</span><br><span class="line">    private static final long timestampLeftShift = sequenceBits + workerIdBits + dataCenterIdBits;</span><br><span class="line">    /**</span><br><span class="line">     * sequence掩码，确保sequnce不会超出上限</span><br><span class="line">     * 最大的序列号，4096</span><br><span class="line">     * -1 的补码（二进制全1）右移12位, 然后取反</span><br><span class="line">     * 生成序列的掩码，这里为4095 (0b111111111111=0xfff=4095)</span><br><span class="line">     */</span><br><span class="line">    private static final long sequenceMask = -1L ^ (-1L &lt;&lt; sequenceBits);</span><br><span class="line"> </span><br><span class="line">    //private final static long sequenceMask = ~(-1L &lt;&lt; sequenceBits);</span><br><span class="line">    /**</span><br><span class="line">     * 实际的最大workerId的值 结果是31，8091</span><br><span class="line">     * workerId原则上上限为1024, 但是需要为每台sequence服务预留BACKUP_AMOUNT个workerId,</span><br><span class="line">     * (这个移位算法可以很快的计算出几位二进制数所能表示的最大十进制数)</span><br><span class="line">     */</span><br><span class="line">    //private static final long maxWorkerId = (1L &lt;&lt; workerIdBits) / (BACKUP_COUNT + 1);</span><br><span class="line"> </span><br><span class="line">    //原来代码 -1 的补码（二进制全1）右移13位, 然后取反</span><br><span class="line">    private static final long maxWorkerId = -1L ^ (-1L &lt;&lt; workerIdBits);</span><br><span class="line">    //private final static long maxWorkerId = ~(-1L &lt;&lt; workerIdBits);</span><br><span class="line"> </span><br><span class="line">    /**</span><br><span class="line">     * 支持的最大数据标识id，结果是31</span><br><span class="line">     */</span><br><span class="line">    private static final long maxDataCenterId = -1L ^ (-1L &lt;&lt; dataCenterIdBits);</span><br><span class="line">    /**</span><br><span class="line">     * long workerIdBits = 5L;</span><br><span class="line">     * -1L 的二进制: 1111111111111111111111111111111111111111111111111111111111111111</span><br><span class="line">     * -1L&lt;&lt;workerIdBits = -32 ,二进制: 1111111111111111111111111111111111111111111111111111111111100000</span><br><span class="line">     *  workerMask= -1L ^ -32 = 31, 二进制: 11111</span><br><span class="line">     */</span><br><span class="line">    private static long workerMask= -1L ^ (-1L &lt;&lt; workerIdBits);</span><br><span class="line">    //进程编码</span><br><span class="line">    private long processId = 1L;</span><br><span class="line">    private static long processMask=-1L ^ (-1L &lt;&lt; dataCenterIdBits);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    /**</span><br><span class="line">     * 工作机器ID(0~31)</span><br><span class="line">     * snowflake算法给workerId预留了10位，即workId的取值范围为[0, 1023]，</span><br><span class="line">     * 事实上实际生产环境不大可能需要部署1024个分布式ID服务，</span><br><span class="line">     * 所以：将workerId取值范围缩小为[0, 511]，[512, 1023]</span><br><span class="line">     * 这个范围的workerId当做备用workerId。workId为0的备用workerId是512，</span><br><span class="line">     * workId为1的备用workerId是513，以此类推</span><br><span class="line">     */</span><br><span class="line">    private static long workerId;</span><br><span class="line"> </span><br><span class="line">    /**</span><br><span class="line">     * 数据中心ID(0~31)</span><br><span class="line">     */</span><br><span class="line">    private long dataCenterId;</span><br><span class="line"> </span><br><span class="line">    /**</span><br><span class="line">     * 当前毫秒生成的序列</span><br><span class="line">     */</span><br><span class="line">    private long sequence = 0L;</span><br><span class="line"> </span><br><span class="line">    /**</span><br><span class="line">     * 上次生成ID的时间戳</span><br><span class="line">     */</span><br><span class="line">    private long lastTimestamp = -1L;</span><br><span class="line"> </span><br><span class="line">    private long extension = 0L;</span><br><span class="line">    private long maxExtension =  0L;</span><br><span class="line"> </span><br><span class="line">    /**</span><br><span class="line">     * 保留workerId和lastTimestamp, 以及备用workerId和其对应的lastTimestamp</span><br><span class="line">     */</span><br><span class="line">    private static Map&lt;Long, Long&gt; workerIdLastTimeMap = new ConcurrentHashMap&lt;&gt;();</span><br><span class="line"> </span><br><span class="line">    /**</span><br><span class="line">     * 最大容忍时间, 单位毫秒, 即如果时钟只是回拨了该变量指定的时间, 那么等待相应的时间即可;</span><br><span class="line">     * 考虑到sequence服务的高性能, 这个值不易过大</span><br><span class="line">     */</span><br><span class="line">    private static final long MAX_BACKWARD_MS = 3;</span><br><span class="line">    private static SnowflakeIdFactory idWorker;</span><br><span class="line"> </span><br><span class="line">    static &#123;</span><br><span class="line">        idWorker = new SnowflakeIdFactory();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    static &#123;</span><br><span class="line">        Calendar calendar = Calendar.getInstance();</span><br><span class="line">        calendar.set(2018, Calendar.NOVEMBER, 1);</span><br><span class="line">        calendar.set(Calendar.HOUR_OF_DAY, 0);</span><br><span class="line">        calendar.set(Calendar.MINUTE, 0);</span><br><span class="line">        calendar.set(Calendar.SECOND, 0);</span><br><span class="line">        calendar.set(Calendar.MILLISECOND, 0);</span><br><span class="line">        // EPOCH是服务器第一次上线时间点, 设置后不允许修改</span><br><span class="line">        EPOCH = calendar.getTimeInMillis();</span><br><span class="line"> </span><br><span class="line">        // 初始化workerId和其所有备份workerId与lastTimestamp</span><br><span class="line">        // 假设workerId为0且BACKUP_AMOUNT为4, 那么map的值为: &#123;0:0L, 256:0L, 512:0L, 768:0L&#125;</span><br><span class="line">        // 假设workerId为2且BACKUP_AMOUNT为4, 那么map的值为: &#123;2:0L, 258:0L, 514:0L, 770:0L&#125;</span><br><span class="line">       /* for (int i = 0; i&lt;= BACKUP_COUNT; i++)&#123;</span><br><span class="line">            workerIdLastTimeMap.put(workerId + (i * maxWorkerId), 0L);</span><br><span class="line">        &#125;*/</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    //成员类，IdGenUtils的实例对象的保存域</span><br><span class="line">    private static class SnowflakeIdGenHolder &#123;</span><br><span class="line">        private static final SnowflakeIdFactory instance = new SnowflakeIdFactory();</span><br><span class="line">    &#125;</span><br><span class="line">    //外部调用获取IdGenUtils的实例对象，确保不可变</span><br><span class="line">    public static SnowflakeIdFactory getInstance()&#123;</span><br><span class="line">        return SnowflakeIdGenHolder.instance;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    /**</span><br><span class="line">     * 静态工具类</span><br><span class="line">     *</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public static Long generateId()&#123;</span><br><span class="line">        long id = idWorker.nextId();</span><br><span class="line">        return id;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    //初始化构造，无参构造有参函数，默认节点都是0</span><br><span class="line">    public SnowflakeIdFactory()&#123;</span><br><span class="line">        //this(0L, 0L);</span><br><span class="line">        this.dataCenterId = getDataCenterId(maxDataCenterId);</span><br><span class="line">        //获取机器编码</span><br><span class="line">        this.workerId = getWorkerId(dataCenterId, maxWorkerId);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    /**</span><br><span class="line">     * 构造函数</span><br><span class="line">     * @param workerId 工作ID (0~31)</span><br><span class="line">     * @param dataCenterId 数据中心ID (0~31)</span><br><span class="line">     */</span><br><span class="line">    public SnowflakeIdFactory(long workerId, long dataCenterId) &#123;</span><br><span class="line">        if (workerId &gt; maxWorkerId || workerId &lt; 0) &#123;</span><br><span class="line">            throw new IllegalArgumentException(String.format(&quot;worker Id can&#x27;t be greater than %d or less than 0&quot;, maxWorkerId));</span><br><span class="line">        &#125;</span><br><span class="line">        if (dataCenterId &gt; maxDataCenterId || dataCenterId &lt; 0) &#123;</span><br><span class="line">            throw new IllegalArgumentException(String.format(&quot;datacenter Id can&#x27;t be greater than %d or less than 0&quot;, maxDataCenterId));</span><br><span class="line">        &#125;</span><br><span class="line">        this.workerId = workerId;</span><br><span class="line">        this.dataCenterId = dataCenterId;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">   /**</span><br><span class="line">     * 获取带自定义前缀的全局唯一编码</span><br><span class="line">     */</span><br><span class="line">    public String getStrCodingByPrefix(String prefix)&#123;</span><br><span class="line">        Long ele = this.nextId();</span><br><span class="line">        return prefix + ele.toString();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    /**</span><br><span class="line">     * 获得下一个ID (该方法是线程安全的)</span><br><span class="line">     * 在单节点上获得下一个ID，使用Synchronized控制并发，而非CAS的方式，</span><br><span class="line">     * 是因为CAS不适合并发量非常高的场景。</span><br><span class="line">     *</span><br><span class="line">     * 考虑时钟回拨</span><br><span class="line">     * 缺陷: 如果连续两次时钟回拨, 可能还是会有问题, 但是这种概率极低极低</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public synchronized long nextId() &#123;</span><br><span class="line">        long currentTimestamp = timeGen();</span><br><span class="line">        // 当发生时钟回拨时</span><br><span class="line">        if (currentTimestamp &lt; lastTimestamp)&#123;</span><br><span class="line">            // 如果时钟回拨在可接受范围内, 等待即可</span><br><span class="line">            long offset = lastTimestamp - currentTimestamp;</span><br><span class="line">            if ( offset &lt;= MAX_BACKWARD_MS)&#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    //睡（lastTimestamp - currentTimestamp）ms让其追上</span><br><span class="line">                    LockSupport.parkNanos(TimeUnit.MILLISECONDS.toNanos(offset));</span><br><span class="line">                    //时间偏差大小小于5ms，则等待两倍时间</span><br><span class="line">                    //wait(offset &lt;&lt; 1);</span><br><span class="line">                    //Thread.sleep(waitTimestamp);</span><br><span class="line"> </span><br><span class="line">                    currentTimestamp = timeGen();</span><br><span class="line">                    //如果时间还小于当前时间，那么利用扩展字段加1</span><br><span class="line">                    //或者是采用抛异常并上报</span><br><span class="line">                    if (currentTimestamp &lt; lastTimestamp) &#123;</span><br><span class="line">                        //扩展字段</span><br><span class="line">                        //extension += 1;</span><br><span class="line">                        //if (extension &gt; maxExtension) &#123;</span><br><span class="line">                            //服务器时钟被调整了,ID生成器停止服务.</span><br><span class="line">                            throw new RuntimeException(String.format(&quot;Clock moved backwards.  Refusing to generate id for %d milliseconds&quot;, lastTimestamp - currentTimestamp));</span><br><span class="line">                        //&#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; catch (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                //扩展字段</span><br><span class="line">                /*extension += 1;</span><br><span class="line">                if (extension &gt; maxExtension) &#123;</span><br><span class="line">                    //服务器时钟被调整了,ID生成器停止服务.</span><br><span class="line">                    throw new RuntimeException(String.format(&quot;Clock moved backwards.  Refusing to generate id for %d milliseconds&quot;, lastTimestamp - currentTimestamp));</span><br><span class="line">                &#125;*/</span><br><span class="line">                tryGenerateKeyOnBackup(currentTimestamp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //对时钟回拨简单处理</span><br><span class="line">       /* if (currentTimestamp &lt; lastTimestamp) &#123;</span><br><span class="line">            //服务器时钟被调整了,ID生成器停止服务.</span><br><span class="line">            throw new RuntimeException(String.format(&quot;Clock moved backwards.  Refusing to generate id for %d milliseconds&quot;, lastTimestamp - currentTimestamp));</span><br><span class="line">        &#125;*/</span><br><span class="line"> </span><br><span class="line">        // 如果和最后一次请求处于同一毫秒, 那么sequence+1</span><br><span class="line">        if (lastTimestamp == currentTimestamp) &#123;</span><br><span class="line">            // 如果当前生成id的时间还是上次的时间，那么对sequence序列号进行+1</span><br><span class="line">            sequence = (sequence + 1) &amp; sequenceMask;</span><br><span class="line">            if (sequence == 0) &#123;</span><br><span class="line">                //自旋等待到下一毫秒</span><br><span class="line">                currentTimestamp = waitUntilNextTime(lastTimestamp);</span><br><span class="line">            &#125;</span><br><span class="line">            //判断是否溢出,也就是每毫秒内超过4095，当为4096时，与sequenceMask相与，sequence就等于0</span><br><span class="line">            /*if (sequence == sequenceMask) &#123;</span><br><span class="line">                // 当前毫秒生成的序列数已经大于最大值，那么阻塞到下一个毫秒再获取新的时间戳</span><br><span class="line">                currentTimestamp = this.waitUntilNextTime(lastTimestamp);</span><br><span class="line">            &#125;*/</span><br><span class="line"> </span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // 如果是一个更近的时间戳, 那么sequence归零</span><br><span class="line">            sequence = 0L;</span><br><span class="line">        &#125;</span><br><span class="line">        // 更新上次生成id的时间戳</span><br><span class="line">        lastTimestamp = currentTimestamp;</span><br><span class="line"> </span><br><span class="line">        // 更新map中保存的workerId对应的lastTimestamp</span><br><span class="line">        //workerIdLastTimeMap.put(this.workerId, lastTimestamp);</span><br><span class="line"> </span><br><span class="line">        if (log.isDebugEnabled()) &#123;</span><br><span class="line">            log.debug(&quot;&#123;&#125;-&#123;&#125;-&#123;&#125;&quot;, new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss.SSS&quot;).format(new Date(lastTimestamp)), workerId, sequence);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        // 进行移位操作生成int64的唯一ID</span><br><span class="line">        //时间戳右移动23位</span><br><span class="line">        long timestamp = (currentTimestamp - EPOCH) &lt;&lt; timestampLeftShift;</span><br><span class="line"> </span><br><span class="line">        //workerId 右移动10位</span><br><span class="line">        long workerId = this.workerId &lt;&lt; workerIdShift;</span><br><span class="line"> </span><br><span class="line">        //dataCenterId 右移动(sequenceBits + workerIdBits = 17位)</span><br><span class="line">        long dataCenterId = this.dataCenterId &lt;&lt; dataCenterIdShift;</span><br><span class="line">        return timestamp | dataCenterId | workerId | sequence;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    /**</span><br><span class="line">     * 尝试在workerId的备份workerId上生成</span><br><span class="line">     * 核心优化代码在方法tryGenerateKeyOnBackup()中，BACKUP_COUNT即备份workerId数越多，</span><br><span class="line">     * sequence服务避免时钟回拨影响的能力越强，但是可部署的sequence服务越少，</span><br><span class="line">     * 设置BACKUP_COUNT为3，最多可以部署1024/(3+1)即256个sequence服务，完全够用，</span><br><span class="line">     * 抗时钟回拨影响的能力也得到非常大的保障。</span><br><span class="line">     * @param currentMillis 当前时间</span><br><span class="line">     */</span><br><span class="line">    private long tryGenerateKeyOnBackup(long currentMillis)&#123;</span><br><span class="line">        // 遍历所有workerId(包括备用workerId, 查看哪些workerId可用)</span><br><span class="line">        for (Map.Entry&lt;Long, Long&gt; entry:workerIdLastTimeMap.entrySet())&#123;</span><br><span class="line">            this.workerId = entry.getKey();</span><br><span class="line">            // 取得备用workerId的lastTime</span><br><span class="line">            Long tempLastTime = entry.getValue();</span><br><span class="line">            lastTimestamp = tempLastTime==null?0L:tempLastTime;</span><br><span class="line"> </span><br><span class="line">            // 如果找到了合适的workerId</span><br><span class="line">            if (lastTimestamp&lt;=currentMillis)&#123;</span><br><span class="line">                return lastTimestamp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        // 如果所有workerId以及备用workerId都处于时钟回拨, 那么抛出异常</span><br><span class="line">        throw new IllegalStateException(&quot;Clock is moving backwards, current time is &quot;</span><br><span class="line">                +currentMillis+&quot; milliseconds, workerId map = &quot; + workerIdLastTimeMap);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    /**</span><br><span class="line">     * 阻塞到下一个毫秒，直到获得新的时间戳</span><br><span class="line">     * @param lastTimestamp 上次生成ID的时间截</span><br><span class="line">     * @return 当前时间戳</span><br><span class="line">     */</span><br><span class="line">    protected long waitUntilNextTime(long lastTimestamp) &#123;</span><br><span class="line">        long timestamp = timeGen();</span><br><span class="line">        while (timestamp &lt;= lastTimestamp) &#123;</span><br><span class="line">            timestamp = timeGen();</span><br><span class="line">        &#125;</span><br><span class="line">        return timestamp;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    protected long timeGen() &#123;</span><br><span class="line">        return System.currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    /**</span><br><span class="line">     *  获取WorkerId</span><br><span class="line">     * @param dataCenterId</span><br><span class="line">     * @param maxWorkerId</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    protected static long getWorkerId(long dataCenterId, long maxWorkerId) &#123;</span><br><span class="line">        StringBuffer mpid = new StringBuffer();</span><br><span class="line">        mpid.append(dataCenterId);</span><br><span class="line">        String name = ManagementFactory.getRuntimeMXBean().getName();</span><br><span class="line">        if (!name.isEmpty()) &#123;</span><br><span class="line">           // GET jvmPid</span><br><span class="line">           mpid.append(name.split(&quot;@&quot;)[0]);</span><br><span class="line">        &#125;</span><br><span class="line">       // MAC + PID 的 hashcode 获取16个低位</span><br><span class="line">        return (mpid.toString().hashCode() &amp; 0xffff) % (maxWorkerId + 1);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    /**</span><br><span class="line">     * 获取机器编码 用来做数据ID</span><br><span class="line">     * 数据标识id部分 通常不建议采用下面的MAC地址方式，</span><br><span class="line">     * 因为用户通过破解很容易拿到MAC进行破坏</span><br><span class="line">     */</span><br><span class="line">    protected static long getDataCenterId(long tempMaxDataCenterId) &#123;</span><br><span class="line">        if (tempMaxDataCenterId &lt; 0L  || tempMaxDataCenterId &gt; maxDataCenterId) &#123;</span><br><span class="line">            tempMaxDataCenterId = maxDataCenterId;</span><br><span class="line">        &#125;</span><br><span class="line">        long id = 0L;</span><br><span class="line">        try &#123;</span><br><span class="line">            InetAddress ip = InetAddress.getLocalHost();</span><br><span class="line">            NetworkInterface network = NetworkInterface.getByInetAddress(ip);</span><br><span class="line">            if (network == null) &#123;</span><br><span class="line">                id = 1L;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                byte[] mac = network.getHardwareAddress();</span><br><span class="line">                id = ((0x000000FF &amp; (long) mac[mac.length - 1])</span><br><span class="line">                        | (0x0000FF00 &amp; (((long) mac[mac.length - 2]) &lt;&lt; 8))) &gt;&gt; 6;</span><br><span class="line">                id = id % (tempMaxDataCenterId + 1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            System.out.println(&quot; getDatacenterId: &quot; + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">        return id;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    public static void testProductIdByMoreThread(int dataCenterId, int workerId, int n) throws InterruptedException &#123;</span><br><span class="line">        List&lt;Thread&gt; tlist = new ArrayList&lt;&gt;();</span><br><span class="line">        Set&lt;Long&gt; setAll = new HashSet&lt;&gt;();</span><br><span class="line">        CountDownLatch cdLatch = new CountDownLatch(10);</span><br><span class="line">        long start = System.currentTimeMillis();</span><br><span class="line">        int threadNo = dataCenterId;</span><br><span class="line">        Map&lt;String,SnowflakeIdFactory&gt; idFactories = new HashMap&lt;&gt;();</span><br><span class="line">        for(int i=0;i&lt;10;i++)&#123;</span><br><span class="line">            //用线程名称做map key.</span><br><span class="line">            idFactories.put(&quot;snowflake&quot;+i,new SnowflakeIdFactory(workerId, threadNo++));</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i=0;i&lt;10;i++)&#123;</span><br><span class="line">            Thread temp =new Thread(new Runnable() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    Set&lt;Long&gt; setId = new HashSet&lt;&gt;();</span><br><span class="line">                    SnowflakeIdFactory idWorker = idFactories.get(Thread.currentThread().getName());</span><br><span class="line">                    for(int j=0;j&lt;n;j++)&#123;</span><br><span class="line">                        setId.add(idWorker.nextId());</span><br><span class="line">                    &#125;</span><br><span class="line">                    synchronized (setAll)&#123;</span><br><span class="line">                        setAll.addAll(setId);</span><br><span class="line">                        log.info(&quot;&#123;&#125;生产了&#123;&#125;个id,并成功加入到setAll中.&quot;,Thread.currentThread().getName(),n);</span><br><span class="line">                    &#125;</span><br><span class="line">                    cdLatch.countDown();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,&quot;snowflake&quot;+i);</span><br><span class="line">            tlist.add(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        for(int j=0;j&lt;10;j++)&#123;</span><br><span class="line">            tlist.get(j).start();</span><br><span class="line">        &#125;</span><br><span class="line">        cdLatch.await();</span><br><span class="line"> </span><br><span class="line">        long end1 = System.currentTimeMillis() - start;</span><br><span class="line"> </span><br><span class="line">        log.info(&quot;共耗时:&#123;&#125;毫秒,预期应该生产&#123;&#125;个id, 实际合并总计生成ID个数:&#123;&#125;&quot;,end1,10*n,setAll.size());</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public static void testProductId(int dataCenterId, int workerId, int n)&#123;</span><br><span class="line">        SnowflakeIdFactory idWorker = new SnowflakeIdFactory(workerId, dataCenterId);</span><br><span class="line">        SnowflakeIdFactory idWorker2 = new SnowflakeIdFactory(workerId+1, dataCenterId);</span><br><span class="line">        Set&lt;Long&gt; setOne = new HashSet&lt;&gt;();</span><br><span class="line">        Set&lt;Long&gt; setTow = new HashSet&lt;&gt;();</span><br><span class="line">        long start = System.currentTimeMillis();</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            setOne.add(idWorker.nextId());//加入set</span><br><span class="line">        &#125;</span><br><span class="line">        long end1 = System.currentTimeMillis() - start;</span><br><span class="line">        log.info(&quot;第一批ID预计生成&#123;&#125;个,实际生成&#123;&#125;个&lt;&lt;&lt;&lt;*&gt;&gt;&gt;&gt;共耗时:&#123;&#125;&quot;,n,setOne.size(),end1);</span><br><span class="line"> </span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            setTow.add(idWorker2.nextId());//加入set</span><br><span class="line">        &#125;</span><br><span class="line">        long end2 = System.currentTimeMillis() - start;</span><br><span class="line">        log.info(&quot;第二批ID预计生成&#123;&#125;个,实际生成&#123;&#125;个&lt;&lt;&lt;&lt;*&gt;&gt;&gt;&gt;共耗时:&#123;&#125;&quot;,n,setTow.size(),end2);</span><br><span class="line"> </span><br><span class="line">        setOne.addAll(setTow);</span><br><span class="line">        log.info(&quot;合并总计生成ID个数:&#123;&#125;&quot;,setOne.size());</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public static void testPerSecondProductIdNums()&#123;</span><br><span class="line">        SnowflakeIdFactory idWorker = new SnowflakeIdFactory(1, 2);</span><br><span class="line">        long start = System.currentTimeMillis();</span><br><span class="line">        int count = 0;</span><br><span class="line">        for (int i = 0; System.currentTimeMillis()-start&lt;1000; i++,count=i) &#123;</span><br><span class="line">            /**  测试方法一: 此用法纯粹的生产ID,每秒生产ID个数为300w+ */</span><br><span class="line">            idWorker.nextId();</span><br><span class="line">            /**  测试方法二: 在log中打印,同时获取ID,此用法生产ID的能力受限于log.error()的吞吐能力.</span><br><span class="line">             * 每秒徘徊在10万左右. */</span><br><span class="line">            //log.error(&quot;&#123;&#125;&quot;,idWorker.nextId());</span><br><span class="line">        &#125;</span><br><span class="line">        long end = System.currentTimeMillis()-start;</span><br><span class="line">        System.out.println(end);</span><br><span class="line">        System.out.println(count);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        /** case1: 测试每秒生产id个数?</span><br><span class="line">         *   结论: 每秒生产id个数300w+ */</span><br><span class="line">        testPerSecondProductIdNums();</span><br><span class="line"> </span><br><span class="line">        /** case2: 单线程-测试多个生产者同时生产N个id,验证id是否有重复?</span><br><span class="line">         *   结论: 验证通过,没有重复. */</span><br><span class="line">        //testProductId(1,2,10000);//验证通过!</span><br><span class="line">        //testProductId(1,2,20000);//验证通过!</span><br><span class="line"> </span><br><span class="line">        /** case3: 多线程-测试多个生产者同时生产N个id, 全部id在全局范围内是否会重复?</span><br><span class="line">         *   结论: 验证通过,没有重复. */</span><br><span class="line">       /* try &#123;</span><br><span class="line">            testProductIdByMoreThread(1,2,100000);//单机测试此场景,性能损失至少折半!</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;*/</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wetts.github.io/2019/11/20/%E8%AF%AD%E8%A8%80/Python/%E5%85%B6%E4%BB%96/Python%E4%B8%ADTrue%E5%92%8CFalse%E7%9A%84%E5%90%AB%E4%B9%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Zhang Wetts">
      <meta itemprop="description" content="Stay Hungry, Stay Foolish. <br><br><p style="font-size:8px;">[build by hexo/next/gitalk/hexo-generator-search/LaTeX]</p>">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wetts's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/11/20/%E8%AF%AD%E8%A8%80/Python/%E5%85%B6%E4%BB%96/Python%E4%B8%ADTrue%E5%92%8CFalse%E7%9A%84%E5%90%AB%E4%B9%89/" class="post-title-link" itemprop="url">Python中True和False的含义.md</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-11-20 01:06:26" itemprop="dateCreated datePublished" datetime="2019-11-20T01:06:26+08:00">2019-11-20</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Python/" itemprop="url" rel="index"><span itemprop="name">Python</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>在 Python 中，整数 0 代表假，整数 1 代表真。不过，除此之外，Python 也把任何空数据结构视为假，把任何非空数据结构视为真。更一般地，真和假的概念是 Python 中每个对象的固有属性：每个对象非真即假。</p>
<ul>
<li>数字如果等于零则为假，反之则为真。</li>
<li>其他对象如果为空则为假，反之则为真。</li>
<li>空字符串、空列表、空字典都为假。</li>
<li>None 为假。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/7/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><span class="page-number current">8</span><a class="page-number" href="/page/9/">9</a><span class="space">&hellip;</span><a class="page-number" href="/page/69/">69</a><a class="extend next" rel="next" href="/page/9/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Zhang Wetts"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">Zhang Wetts</p>
  <div class="site-description" itemprop="description">Stay Hungry, Stay Foolish. <br><br><p style="font-size:8px;">[build by hexo/next/gitalk/hexo-generator-search/LaTeX]</p></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">686</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">67</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">352</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/wetts" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;wetts" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:zhang.wetts@163.com" title="E-Mail → mailto:zhang.wetts@163.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Zhang Wetts</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

  


<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/hibiki.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"react":{"opacity":0}});</script></body>
</html>
