<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"wetts.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="Stay Hungry, Stay Foolish. [build by hexo&#x2F;next&#x2F;gitalk&#x2F;hexo-generator-search&#x2F;LaTeX]">
<meta property="og:type" content="website">
<meta property="og:title" content="Wetts&#39;s blog">
<meta property="og:url" content="https://wetts.github.io/page/27/index.html">
<meta property="og:site_name" content="Wetts&#39;s blog">
<meta property="og:description" content="Stay Hungry, Stay Foolish. [build by hexo&#x2F;next&#x2F;gitalk&#x2F;hexo-generator-search&#x2F;LaTeX]">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Zhang Wetts">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://wetts.github.io/page/27/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Wetts's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Wetts's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Stay Hungry, Stay Foolish.</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/wetts" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wetts.github.io/2016/12/19/%E8%AF%AD%E8%A8%80/Java/API/%E5%B9%B6%E5%8F%91/%E5%B9%B6%E5%8F%91-%E8%81%8A%E8%81%8A%E5%B9%B6%E5%8F%91/Java-%E8%81%8A%E8%81%8A%E5%B9%B6%E5%8F%91-2.Java%20SE1.6%E4%B8%AD%E7%9A%84Synchronized/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Zhang Wetts">
      <meta itemprop="description" content="Stay Hungry, Stay Foolish. <br><br><p style="font-size:8px;">[build by hexo/next/gitalk/hexo-generator-search/LaTeX]</p>">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wetts's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2016/12/19/%E8%AF%AD%E8%A8%80/Java/API/%E5%B9%B6%E5%8F%91/%E5%B9%B6%E5%8F%91-%E8%81%8A%E8%81%8A%E5%B9%B6%E5%8F%91/Java-%E8%81%8A%E8%81%8A%E5%B9%B6%E5%8F%91-2.Java%20SE1.6%E4%B8%AD%E7%9A%84Synchronized/" class="post-title-link" itemprop="url">Java-聊聊并发-2.Java SE1.6中的Synchronized</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2016-12-19 12:01:52" itemprop="dateCreated datePublished" datetime="2016-12-19T12:01:52+08:00">2016-12-19</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>转自：<a target="_blank" rel="noopener" href="http://ifeve.com/java-synchronized/">http://ifeve.com/java-synchronized/</a></p>
<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>在多线程并发编程中Synchronized一直是元老级角色，很多人都会称呼它为重量级锁，但是随着Java SE1.6对Synchronized进行了各种优化之后，有些情况下它并不那么重了，本文详细介绍了Java SE1.6中为了减少获得锁和释放锁带来的性能消耗而引入的偏向锁和轻量级锁，以及锁的存储结构和升级过程。</p>
<h2 id="术语定义"><a href="#术语定义" class="headerlink" title="术语定义"></a>术语定义</h2><ul>
<li>CAS（Compare and Swap）：比较并设置。用于在硬件层面上提供原子性操作。在 Intel 处理器中，比较并交换通过指令cmpxchg实现。比较是否和给定的数值一致，如果一致则修改，不一致则不修改。</li>
</ul>
<h2 id="同步的基础"><a href="#同步的基础" class="headerlink" title="同步的基础"></a>同步的基础</h2><p>Java中的每一个对象都可以作为锁。</p>
<ul>
<li>对于同步方法，锁是当前实例对象。</li>
<li>对于静态同步方法，锁是当前对象的Class对象。</li>
<li>对于同步方法块，锁是Synchonized括号里配置的对象。</li>
</ul>
<p>当一个线程试图访问同步代码块时，它首先必须得到锁，退出或抛出异常时必须释放锁。那么锁存在哪里呢？锁里面会存储什么信息呢？</p>
<h2 id="同步的原理"><a href="#同步的原理" class="headerlink" title="同步的原理"></a>同步的原理</h2><p>JVM规范规定JVM基于进入和退出Monitor对象来实现方法同步和代码块同步，但两者的实现细节不一样。代码块同步是使用monitorenter和monitorexit指令实现，而方法同步是使用另外一种方式实现的，细节在JVM规范里并没有详细说明，但是方法的同步同样可以使用这两个指令来实现。monitorenter指令是在编译后插入到同步代码块的开始位置，而monitorexit是插入到方法结束处和异常处， JVM要保证每个monitorenter必须有对应的monitorexit与之配对。任何对象都有一个 monitor 与之关联，当且一个monitor 被持有后，它将处于锁定状态。线程执行到 monitorenter 指令时，将会尝试获取对象所对应的 monitor 的所有权，即尝试获得对象的锁。</p>
<h3 id="Java对象头"><a href="#Java对象头" class="headerlink" title="Java对象头"></a>Java对象头</h3><p>锁存在Java对象头里。如果对象是数组类型，则虚拟机用3个Word（字宽）存储对象头，如果对象是非数组类型，则用2字宽存储对象头。在32位虚拟机中，一字宽等于四字节，即32bit。</p>
<table>
<thead>
<tr>
<th align="center">长度</th>
<th align="center">内容</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">32/64bit</td>
<td align="center">Mark Word</td>
<td align="center">存储对象的hashCode或锁信息等。</td>
</tr>
<tr>
<td align="center">32/64bit</td>
<td align="center">Class Metadata Address</td>
<td align="center">存储到对象类型数据的指针</td>
</tr>
<tr>
<td align="center">32/64bit</td>
<td align="center">Array length</td>
<td align="center">数组的长度（如果当前对象是数组）</td>
</tr>
</tbody></table>
<p>Java对象头里的Mark Word里默认存储对象的HashCode，分代年龄和锁标记位。32位JVM的Mark Word的默认存储结构如下：</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">25 bit</th>
<th align="center">4bit</th>
<th align="center">1bit是否是偏向锁</th>
<th align="center">2bit锁标志位</th>
</tr>
</thead>
<tbody><tr>
<td align="center">无锁状态</td>
<td align="center">对象的hashCode</td>
<td align="center">对象分代年龄</td>
<td align="center">0</td>
<td align="center">01</td>
</tr>
</tbody></table>
<p>在运行期间Mark Word里存储的数据会随着锁标志位的变化而变化。Mark Word可能变化为存储以下4种数据：</p>
<table>
<thead>
<tr>
<th align="center">锁状态</th>
<th align="center">25 bit</th>
<th align="center"></th>
<th align="center">4bit</th>
<th align="center">1bit</th>
<th align="center">2bit</th>
</tr>
</thead>
<tbody><tr>
<td align="center">锁状态</td>
<td align="center">23bit</td>
<td align="center">2bit</td>
<td align="center">4bit</td>
<td align="center">是否是偏向锁</td>
<td align="center">锁标志位</td>
</tr>
<tr>
<td align="center">轻量级锁</td>
<td align="center">指向栈中锁记录的指针</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">00</td>
</tr>
<tr>
<td align="center">重量级锁</td>
<td align="center">指向互斥量（重量级锁）的指针</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">10</td>
</tr>
<tr>
<td align="center">GC标记</td>
<td align="center">空</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">11</td>
</tr>
<tr>
<td align="center">偏向锁</td>
<td align="center">线程ID</td>
<td align="center">Epoch</td>
<td align="center">对象分代年龄</td>
<td align="center">1</td>
<td align="center">01</td>
</tr>
</tbody></table>
<p>在64位虚拟机下，Mark Word是64bit大小的，其存储结构如下：</p>
<table>
<thead>
<tr>
<th align="center">锁状态</th>
<th align="center">25bit</th>
<th align="center">31bit</th>
<th align="center">1bit</th>
<th align="center">4bit</th>
<th align="center">1bit</th>
<th align="center">2bit</th>
</tr>
</thead>
<tbody><tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">cms_free</td>
<td align="center">分代年龄</td>
<td align="center">偏向锁</td>
<td align="center">锁标志位</td>
</tr>
<tr>
<td align="center">无锁</td>
<td align="center">unused</td>
<td align="center">hashCode</td>
<td align="center"></td>
<td align="center"></td>
<td align="center">0</td>
<td align="center">01</td>
</tr>
<tr>
<td align="center">偏向锁</td>
<td align="center">ThreadID(54bit)Epoch(2bit)</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">1</td>
<td align="center">01</td>
</tr>
</tbody></table>
<h3 id="锁的升级"><a href="#锁的升级" class="headerlink" title="锁的升级"></a>锁的升级</h3><p>Java SE1.6为了减少获得锁和释放锁所带来的性能消耗，引入了“偏向锁”和“轻量级锁”，所以在Java SE1.6里锁一共有四种状态，无锁状态，偏向锁状态，轻量级锁状态和重量级锁状态，它会随着竞争情况逐渐升级。锁可以升级但不能降级，意味着偏向锁升级成轻量级锁后不能降级成偏向锁。这种锁升级却不能降级的策略，目的是为了提高获得锁和释放锁的效率，下文会详细分析。</p>
<h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><p>Hotspot的作者经过以往的研究发现大多数情况下锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低而引入了偏向锁。当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程ID，以后该线程在进入和退出同步块时不需要花费CAS操作来加锁和解锁，而只需简单的测试一下对象头的Mark Word里是否存储着指向当前线程的偏向锁，如果测试成功，表示线程已经获得了锁，如果测试失败，则需要再测试下Mark Word中偏向锁的标识是否设置成1（表示当前是偏向锁），如果没有设置，则使用CAS竞争锁，如果设置了，则尝试使用CAS将对象头的偏向锁指向当前线程。</p>
<p><strong>偏向锁的撤销</strong>：偏向锁使用了一种等到竞争出现才释放锁的机制，所以当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁。偏向锁的撤销，需要等待全局安全点（在这个时间点上没有字节码正在执行），它会首先暂停拥有偏向锁的线程，然后检查持有偏向锁的线程是否活着，如果线程不处于活动状态，则将对象头设置成无锁状态，如果线程仍然活着，拥有偏向锁的栈会被执行，遍历偏向对象的锁记录，栈中的锁记录和对象头的Mark Word要么重新偏向于其他线程，要么恢复到无锁或者标记对象不适合作为偏向锁，最后唤醒暂停的线程。下图中的线程1演示了偏向锁初始化的流程，线程2演示了偏向锁撤销的流程。</p>
<p>关闭偏向锁：偏向锁在Java 6和Java 7里是默认启用的，但是它在应用程序启动几秒钟之后才激活，如有必要可以使用JVM参数来关闭延迟-XX：BiasedLockingStartupDelay = 0。如果你确定自己应用程序里所有的锁通常情况下处于竞争状态，可以通过JVM参数关闭偏向锁-XX:-UseBiasedLocking=false，那么默认会进入轻量级锁状态。</p>
<h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><p><strong>轻量级锁加锁</strong>：线程在执行同步块之前，JVM会先在当前线程的栈桢中创建用于存储锁记录的空间，并将对象头中的Mark Word复制到锁记录中，官方称为Displaced Mark Word。然后线程尝试使用CAS将对象头中的Mark Word替换为指向锁记录的指针。如果成功，当前线程获得锁，如果失败，表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁。</p>
<p><strong>轻量级锁解锁</strong>：轻量级解锁时，会使用原子的CAS操作来将Displaced Mark Word替换回到对象头，如果成功，则表示没有竞争发生。如果失败，表示当前锁存在竞争，锁就会膨胀成重量级锁。下图是两个线程同时争夺锁，导致锁膨胀的流程图。</p>
<p>![轻量级锁](Java-聊聊并发-2.Java SE1.6中的Synchronized/轻量级锁.png)</p>
<p>因为自旋会消耗CPU，为了避免无用的自旋（比如获得锁的线程被阻塞住了），一旦锁升级成重量级锁，就不会再恢复到轻量级锁状态。当锁处于这个状态下，其他线程试图获取锁时，都会被阻塞住，当持有锁的线程释放锁之后会唤醒这些线程，被唤醒的线程就会进行新一轮的夺锁之争。</p>
<h2 id="锁的优缺点对比"><a href="#锁的优缺点对比" class="headerlink" title="锁的优缺点对比"></a>锁的优缺点对比</h2><table>
<thead>
<tr>
<th align="center">锁</th>
<th align="center">优点</th>
<th align="center">缺点</th>
<th align="center">适用场景</th>
</tr>
</thead>
<tbody><tr>
<td align="center">偏向锁</td>
<td align="center">加锁和解锁不需要额外的消耗，和执行非同步方法比仅存在纳秒级的差距。</td>
<td align="center">如果线程间存在锁竞争，会带来额外的锁撤销的消耗。</td>
<td align="center">适用于只有一个线程访问同步块场景。</td>
</tr>
<tr>
<td align="center">轻量级锁</td>
<td align="center">竞争的线程不会阻塞，提高了程序的响应速度。</td>
<td align="center">如果始终得不到锁竞争的线程使用自旋会消耗CPU。</td>
<td align="center">追求响应时间。同步块执行速度非常快。</td>
</tr>
<tr>
<td align="center">重量级锁</td>
<td align="center">线程竞争不使用自旋，不会消耗CPU。</td>
<td align="center">线程阻塞，响应时间缓慢。</td>
<td align="center">追求吞吐量。同步块执行速度较长。</td>
</tr>
</tbody></table>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wetts.github.io/2016/12/19/%E8%AF%AD%E8%A8%80/Java/API/%E5%B9%B6%E5%8F%91/%E5%B9%B6%E5%8F%91-%E8%81%8A%E8%81%8A%E5%B9%B6%E5%8F%91/Java-%E8%81%8A%E8%81%8A%E5%B9%B6%E5%8F%91-1.%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90Volatile%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Zhang Wetts">
      <meta itemprop="description" content="Stay Hungry, Stay Foolish. <br><br><p style="font-size:8px;">[build by hexo/next/gitalk/hexo-generator-search/LaTeX]</p>">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wetts's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2016/12/19/%E8%AF%AD%E8%A8%80/Java/API/%E5%B9%B6%E5%8F%91/%E5%B9%B6%E5%8F%91-%E8%81%8A%E8%81%8A%E5%B9%B6%E5%8F%91/Java-%E8%81%8A%E8%81%8A%E5%B9%B6%E5%8F%91-1.%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90Volatile%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/" class="post-title-link" itemprop="url">Java-聊聊并发-1.深入分析Volatile的实现原理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2016-12-19 10:25:13" itemprop="dateCreated datePublished" datetime="2016-12-19T10:25:13+08:00">2016-12-19</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>转自：<a target="_blank" rel="noopener" href="http://ifeve.com/volatile/">http://ifeve.com/volatile/</a></p>
<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>在多线程并发编程中synchronized和Volatile都扮演着重要的角色，Volatile是轻量级的synchronized，它在多处理器开发中保证了共享变量的“可见性”。可见性的意思是当一个线程修改一个共享变量时，另外一个线程能读到这个修改的值。它在某些情况下比synchronized的开销更小，本文将深入分析在硬件层面上Inter处理器是如何实现Volatile的，通过深入分析能帮助我们正确的使用Volatile变量。</p>
<h2 id="术语定义"><a href="#术语定义" class="headerlink" title="术语定义"></a>术语定义</h2><ul>
<li>共享变量：在多个线程之间能够被共享的变量被称为共享变量。共享变量包括所有的实例变量，静态变量和数组元素。他们都被存放在堆内存中，Volatile只作用于共享变量。</li>
<li>内存屏障（Memory Barriers）：是一组处理器指令，用于实现对内存操作的顺序限制。</li>
<li>缓冲行（Cache line）：缓存中可以分配的最小存储单位。处理器填写缓存线时会加载整个缓存线，需要使用多个主内存读周期。</li>
<li>原子操作（Atomic operations）：不可中断的一个或一系列操作。</li>
<li>缓存行填充（cache line fill）：当处理器识别到从内存中读取操作数是可缓存的，处理器读取整个缓存行到适当的缓存（L1，L2，L3的或所有）</li>
<li>缓存命中（cache hit）：如果进行高速缓存行填充操作的内存位置仍然是下次处理器访问的地址时，处理器从缓存中读取操作数，而不是从内存。</li>
<li>写命中（write hit）：当处理器将操作数写回到一个内存缓存的区域时，它首先会检查这个缓存的内存地址是否在缓存行中，如果存在一个有效的缓存行，则处理器将这个操作数写回到缓存，而不是写回到内存，这个操作被称为写命中。</li>
<li>写缺失（write misses the cache）：一个有效的缓存行被写入到不存在的内存区域。</li>
</ul>
<h2 id="Volatile的官方定义"><a href="#Volatile的官方定义" class="headerlink" title="Volatile的官方定义"></a>Volatile的官方定义</h2><p>Java语言规范第三版中对volatile的定义如下： java编程语言允许线程访问共享变量，为了确保共享变量能被准确和一致的更新，线程应该确保通过排他锁单独获得这个变量。Java语言提供了volatile，在某些情况下比锁更加方便。如果一个字段被声明成volatile，java线程内存模型确保所有线程看到这个变量的值是一致的。</p>
<h2 id="为什么要使用Volatile"><a href="#为什么要使用Volatile" class="headerlink" title="为什么要使用Volatile"></a>为什么要使用Volatile</h2><p>Volatile变量修饰符如果使用恰当的话，它比synchronized的使用和执行成本会更低，因为它不会引起线程上下文的切换和调度。</p>
<h2 id="Volatile的实现原理"><a href="#Volatile的实现原理" class="headerlink" title="Volatile的实现原理"></a>Volatile的实现原理</h2><p>那么Volatile是如何来保证可见性的呢？在x86处理器下通过工具获取JIT编译器生成的汇编指令来看看对Volatile进行写操作CPU会做什么事情。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Java代码：	instance = new Singleton();//instance是volatile变量</span><br><span class="line">汇编代码：	0x01a3de1d: movb $0x0,0x1104800(%esi);0x01a3de24: lock addl $0x0,(%esp);</span><br></pre></td></tr></table></figure>
<p>有volatile变量修饰的共享变量进行写操作的时候会多第二行汇编代码，通过查IA-32架构软件开发者手册可知，lock前缀的指令在多核处理器下会引发了两件事情。</p>
<ul>
<li>将当前处理器缓存行的数据会写回到系统内存。</li>
<li>这个写回内存的操作会引起在其他CPU里缓存了该内存地址的数据无效。</li>
</ul>
<p>处理器为了提高处理速度，不直接和内存进行通讯，而是先将系统内存的数据读到内部缓存（L1,L2或其他）后再进行操作，但操作完之后不知道何时会写到内存，如果对声明了Volatile变量进行写操作，JVM就会向处理器发送一条Lock前缀的指令，将这个变量所在缓存行的数据写回到系统内存。但是就算写回到内存，如果其他处理器缓存的值还是旧的，再执行计算操作就会有问题，所以在多处理器下，为了保证各个处理器的缓存是一致的，就会实现缓存一致性协议，每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当处理器要对这个数据进行修改操作的时候，会强制重新从系统内存里把数据读到处理器缓存里。</p>
<p>这两件事情在IA-32软件开发者架构手册的第三册的多处理器管理章节（第八章）中有详细阐述。</p>
<p><strong>Lock前缀指令会引起处理器缓存回写到内存</strong>。Lock前缀指令导致在执行指令期间，声言处理器的 LOCK# 信号。在多处理器环境中，LOCK# 信号确保在声言该信号期间，处理器可以独占使用任何共享内存。（因为它会锁住总线，导致其他CPU不能访问总线，不能访问总线就意味着不能访问系统内存），但是在最近的处理器里，LOCK＃信号一般不锁总线，而是锁缓存，毕竟锁总线开销比较大。在8.1.4章节有详细说明锁定操作对处理器缓存的影响，对于Intel486和Pentium处理器，在锁操作时，总是在总线上声言LOCK#信号。但在P6和最近的处理器中，如果访问的内存区域已经缓存在处理器内部，则不会声言LOCK#信号。相反地，它会锁定这块内存区域的缓存并回写到内存，并使用缓存一致性机制来确保修改的原子性，此操作被称为“缓存锁定”，<strong>缓存一致性机制会阻止同时修改被两个以上处理器缓存的内存区域数据</strong>。</p>
<p><strong>一个处理器的缓存回写到内存会导致其他处理器的缓存无效</strong>。IA-32处理器和Intel 64处理器使用MESI（修改，独占，共享，无效）控制协议去维护内部缓存和其他处理器缓存的一致性。在多核处理器系统中进行操作的时候，IA-32 和Intel 64处理器能嗅探其他处理器访问系统内存和它们的内部缓存。它们使用嗅探技术保证它的内部缓存，系统内存和其他处理器的缓存的数据在总线上保持一致。例如在Pentium和P6 family处理器中，如果通过嗅探一个处理器来检测其他处理器打算写内存地址，而这个地址当前处理共享状态，那么正在嗅探的处理器将无效它的缓存行，在下次访问相同内存地址时，强制执行缓存行填充。</p>
<h2 id="Volatile的使用优化"><a href="#Volatile的使用优化" class="headerlink" title="Volatile的使用优化"></a>Volatile的使用优化</h2><p>著名的Java并发编程大师Doug lea在JDK7的并发包里新增一个队列集合类LinkedTransferQueue，他在使用Volatile变量时，用一种追加字节的方式来优化队列出队和入队的性能。</p>
<p><strong>追加字节能优化性能</strong>？这种方式看起来很神奇，但如果深入理解处理器架构就能理解其中的奥秘。让我们先来看看LinkedTransferQueue这个类，它使用一个内部类类型来定义队列的头队列（Head）和尾节点（tail），而这个内部类PaddedAtomicReference相对于父类AtomicReference只做了一件事情，就将共享变量追加到64字节。我们可以来计算下，一个对象的引用占4个字节，它追加了15个变量共占60个字节，再加上父类的Value变量，一共64个字节。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/** head of the queue */</span><br><span class="line">private transient final PaddedAtomicReference&lt;QNode&gt; head;</span><br><span class="line"></span><br><span class="line">/** tail of the queue */</span><br><span class="line">private transient final PaddedAtomicReference&lt;QNode&gt; tail;</span><br><span class="line"></span><br><span class="line">static final class PaddedAtomicReference &lt;T&gt; extends AtomicReference &lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">  // enough padding for 64bytes with 4byte refs</span><br><span class="line">  Object p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, pa, pb, pc, pd, pe;</span><br><span class="line"></span><br><span class="line">  PaddedAtomicReference(T r) &#123;</span><br><span class="line">    super(r);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class AtomicReference &lt;V&gt; implements java.io.Serializable &#123;</span><br><span class="line"></span><br><span class="line">  private volatile V value;</span><br><span class="line"></span><br><span class="line">  //省略其他代码</span><br><span class="line">｝</span><br></pre></td></tr></table></figure>
<p><strong>为什么追加64字节能够提高并发编程的效率呢</strong>？ 因为对于英特尔酷睿i7，酷睿， Atom和NetBurst， Core Solo和Pentium M处理器的L1，L2或L3缓存的高速缓存行是64个字节宽，不支持部分填充缓存行，这意味着如果队列的头节点和尾节点都不足64字节的话，处理器会将它们都读到同一个高速缓存行中，在多处理器下每个处理器都会缓存同样的头尾节点，当一个处理器试图修改头接点时会将整个缓存行锁定，那么在缓存一致性机制的作用下，会导致其他处理器不能访问自己高速缓存中的尾节点，而队列的入队和出队操作是需要不停修改头接点和尾节点，所以在多处理器的情况下将会严重影响到队列的入队和出队效率。Doug lea使用追加到64字节的方式来填满高速缓冲区的缓存行，避免头接点和尾节点加载到同一个缓存行，使得头尾节点在修改时不会互相锁定。</p>
<p>那么是不是在使用Volatile变量时都应该追加到64字节呢？不是的。在两种场景下不应该使用这种方式。</p>
<ul>
<li>第一：缓存行非64字节宽的处理器，如P6系列和奔腾处理器，它们的L1和L2高速缓存行是32个字节宽。</li>
<li>第二：共享变量不会被频繁的写。</li>
</ul>
<p>因为使用追加字节的方式需要处理器读取更多的字节到高速缓冲区，这本身就会带来一定的性能消耗，共享变量如果不被频繁写的话，锁的几率也非常小，就没必要通过追加字节的方式来避免相互锁定。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wetts.github.io/2016/12/19/%E8%AF%AD%E8%A8%80/Java/JavaEE/%E5%85%B6%E4%BB%96/Servlet%E8%BF%87%E6%BB%A4%E5%99%A8%E4%B8%8ESpring%E6%8B%A6%E6%88%AA%E5%99%A8%E7%9A%84%E5%8C%BA%E5%88%AB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Zhang Wetts">
      <meta itemprop="description" content="Stay Hungry, Stay Foolish. <br><br><p style="font-size:8px;">[build by hexo/next/gitalk/hexo-generator-search/LaTeX]</p>">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wetts's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2016/12/19/%E8%AF%AD%E8%A8%80/Java/JavaEE/%E5%85%B6%E4%BB%96/Servlet%E8%BF%87%E6%BB%A4%E5%99%A8%E4%B8%8ESpring%E6%8B%A6%E6%88%AA%E5%99%A8%E7%9A%84%E5%8C%BA%E5%88%AB/" class="post-title-link" itemprop="url">Servlet过滤器与Spring拦截器的区别</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2016-12-19 10:13:21" itemprop="dateCreated datePublished" datetime="2016-12-19T10:13:21+08:00">2016-12-19</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>转自：<a target="_blank" rel="noopener" href="http://blog.csdn.net/chenleixing/article/details/44573495">http://blog.csdn.net/chenleixing/article/details/44573495</a></p>
<p>过滤器和拦截器的区别：</p>
<ol>
<li>拦截器是基于Java的反射机制的，而过滤器是基于函数回调。</li>
<li>拦截器不依赖与servlet容器，过滤器依赖与servlet容器。</li>
<li>拦截器只能对action请求起作用，而过滤器则可以对几乎所有的请求起作用。</li>
<li>拦截器可以访问action上下文、值栈里的对象，而过滤器不能访问。</li>
<li>在action的生命周期中，拦截器可以多次被调用，而过滤器只能在容器初始化时被调用一次。</li>
<li>拦截器可以获取IOC容器中的各个bean，而过滤器就不行，这点很重要，在拦截器里注入一个service，可以调用业务逻辑。</li>
</ol>
<p><img src="/2016/12/19/%E8%AF%AD%E8%A8%80/Java/JavaEE/%E5%85%B6%E4%BB%96/Servlet%E8%BF%87%E6%BB%A4%E5%99%A8%E4%B8%8ESpring%E6%8B%A6%E6%88%AA%E5%99%A8%E7%9A%84%E5%8C%BA%E5%88%AB/Filter%E6%B5%81%E7%A8%8B.png" alt="Filter流程"></p>
<p><img src="/2016/12/19/%E8%AF%AD%E8%A8%80/Java/JavaEE/%E5%85%B6%E4%BB%96/Servlet%E8%BF%87%E6%BB%A4%E5%99%A8%E4%B8%8ESpring%E6%8B%A6%E6%88%AA%E5%99%A8%E7%9A%84%E5%8C%BA%E5%88%AB/Servlet%E8%BF%87%E6%BB%A4%E5%99%A8%E4%B8%8ESpring%E6%8B%A6%E6%88%AA%E5%99%A8%E7%9A%84%E5%8C%BA%E5%88%AB.png" alt="Servlet过滤器与Spring拦截器的区别"></p>
<hr>
<p>增加：2021/04/11 14:23:08</p>
<p>转自：<a target="_blank" rel="noopener" href="https://blog.csdn.net/zzti_erlie/article/details/105438981">https://blog.csdn.net/zzti_erlie/article/details/105438981</a></p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>做 Web 开发，我们经常要和 Servlet Filter，Spring MVC Interceptor 打交道，它们都能对请求进行拦截，那么它们有哪些区别呢？</p>
<h2 id="Servlet-Filter"><a href="#Servlet-Filter" class="headerlink" title="Servlet Filter"></a>Servlet Filter</h2><h3 id="Filter的使用"><a href="#Filter的使用" class="headerlink" title="Filter的使用"></a>Filter的使用</h3><p>可能很多小伙伴没怎么用过 Filter，我就简单演示一下</p>
<ol>
<li><p>在 web.xml 中配置 2 个 Filter</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;filter-mapping&gt;</span><br><span class="line">    &lt;filter-name&gt;logFilter&lt;/filter-name&gt;</span><br><span class="line">    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;</span><br><span class="line">&lt;/filter-mapping&gt;</span><br><span class="line">&lt;filter-mapping&gt;</span><br><span class="line">    &lt;filter-name&gt;imageFilter&lt;/filter-name&gt;</span><br><span class="line">    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;</span><br><span class="line">&lt;/filter-mapping&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>实现如下，略去了 init 方法和 destroy 方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@WebFilter(filterName = &quot;logFilter&quot;)</span><br><span class="line">public class LogFilter implements Filter &#123;</span><br><span class="line"></span><br><span class="line">    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123;</span><br><span class="line">        System.out.println(&quot;LogFilter execute&quot;);</span><br><span class="line">        chain.doFilter(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@WebFilter(filterName = &quot;imageFilter&quot;)</span><br><span class="line">public class ImageFilter implements Filter &#123;</span><br><span class="line"></span><br><span class="line">    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123;</span><br><span class="line">        System.out.println(&quot;ImageFilter execute&quot;);</span><br><span class="line">        chain.doFilter(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>然后你访问任意一个 servlet 方法，LogFilter 和 ImageFilter 的 doFilter 方法都会执行</li>
</ol>
<p>如果你在一个 Filter 方法后不加c <code>hain.doFilter(request, response)</code>，则后续的 Filter 和 Servlet 都不会执行，这是为什么呢？看完我手写的 Demo 你一下就明白了</p>
<p>可以看到 Filter 可以在请求到达 Servlet 之前做处理，如</p>
<ul>
<li>请求编码</li>
<li>敏感词过滤等</li>
</ul>
<p>有兴趣的小伙伴可以看看相关的源码</p>
<h2 id="手写Filter的实现"><a href="#手写Filter的实现" class="headerlink" title="手写Filter的实现"></a>手写Filter的实现</h2><p>Servlet 接口，任何一个 web 请求都会调用 service 方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface Servlet &#123;</span><br><span class="line">    public void service();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class MyServlet implements Servlet &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void service() &#123;</span><br><span class="line">        System.out.println(&quot;MyServlet的service方法执行了&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>拦截器接口</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface Filter &#123;</span><br><span class="line">    public void doFilter(FilterChain chain);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class LogFilter implements Filter &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void doFilter(FilterChain chain) &#123;</span><br><span class="line">        System.out.println(&quot;LogFilter执行了&quot;);</span><br><span class="line">        chain.doFilter();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class ImageFilter implements Filter &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void doFilter(FilterChain chain) &#123;</span><br><span class="line">        System.out.println(&quot;ImageFilter执行了&quot;);</span><br><span class="line">        chain.doFilter();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>拦截器链对象</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface FilterChain &#123;</span><br><span class="line">    public void doFilter();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public class ApplicationFilterChain implements FilterChain &#123;</span><br><span class="line"></span><br><span class="line">    private Filter[] filters = new Filter[10];</span><br><span class="line">    private Servlet servlet = null;</span><br><span class="line"></span><br><span class="line">    // 总共的Filter数目</span><br><span class="line">    private int n;</span><br><span class="line"></span><br><span class="line">    // 当前执行完的filter数目</span><br><span class="line">    private int pos;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void doFilter() &#123;</span><br><span class="line">        if (pos &lt; n) &#123;</span><br><span class="line">            Filter curFilter = filters[pos++];</span><br><span class="line">            curFilter.doFilter(this);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        servlet.service();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void addFilter(Filter filter) &#123;</span><br><span class="line">        // 这里源码有动态扩容的过程，和ArrayList差不多</span><br><span class="line">        // 我就不演示了，直接赋数组大小为10了</span><br><span class="line">        filters[n++] = filter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setServlet(Servlet servlet) &#123;</span><br><span class="line">        this.servlet = servlet;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试例子</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // 在tomcat源码中，会将一个请求封装为一个ApplicationFilterChain对象</span><br><span class="line">        // 然后执行ApplicationFilterChain的doFilter方法</span><br><span class="line">        ApplicationFilterChain applicationFilterChain = new ApplicationFilterChain();</span><br><span class="line">        applicationFilterChain.addFilter(new LogFilter());</span><br><span class="line">        applicationFilterChain.addFilter(new ImageFilter());</span><br><span class="line">        applicationFilterChain.setServlet(new MyServlet());</span><br><span class="line"></span><br><span class="line">        // LogFilter执行了</span><br><span class="line">        // ImageFilter执行了</span><br><span class="line">        // MyServlet的service方法执行了</span><br><span class="line">        applicationFilterChain.doFilter();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果任意一个 Filter 方法的最后不加上 chain.doFilter()，则后面的拦截器及 Servlet 都不会执行了。相信你看完 ApplicationFilterChain 类的 doFilter 方法一下就明白了，就是一个简单的递归调用</p>
<h2 id="Spring-MVC-Interceptor"><a href="#Spring-MVC-Interceptor" class="headerlink" title="Spring MVC Interceptor"></a>Spring MVC Interceptor</h2><h3 id="Interceptor-的使用"><a href="#Interceptor-的使用" class="headerlink" title="Interceptor 的使用"></a>Interceptor 的使用</h3><p>今天就来分析一下拦截器是怎么实现的？可以通过以下方式实现拦截器</p>
<ol>
<li>实现HandlerInterceptor接口</li>
<li>继承HandlerInterceptorAdapter抽象类，按需重写部分实现即可，（HandlerInterceptorAdapter 也实现了 HandlerInterceptor 接口）</li>
</ol>
<p>总而言之拦截器必须必须实现了 HandlerInterceptor 接口</p>
<p>HandlerInterceptor 有如下 3 个方法</p>
<ul>
<li>boolean preHandler()：在 controller 执行之前调用</li>
<li>void postHandler()：controller 执行之后，且页面渲染之前调用</li>
<li>void afterCompletion()：页面渲染之后调用，一般用于资源清理操作</li>
</ul>
<p><img src="/2016/12/19/%E8%AF%AD%E8%A8%80/Java/JavaEE/%E5%85%B6%E4%BB%96/Servlet%E8%BF%87%E6%BB%A4%E5%99%A8%E4%B8%8ESpring%E6%8B%A6%E6%88%AA%E5%99%A8%E7%9A%84%E5%8C%BA%E5%88%AB/1.png" alt="1"></p>
<p>这个图应该很好的显示了一个请求可以被拦截的地方</p>
<ol>
<li>Servlet Filter 是对一个请求到达 Servlet 的过程进行拦截</li>
<li>而 HandlerInterceptor 是当请求到达 DispatcherServlet 后，在 Controller 的方法执行前后进行拦截</li>
</ol>
<h3 id="手写-Interceptor-的实现"><a href="#手写-Interceptor-的实现" class="headerlink" title="手写 Interceptor 的实现"></a>手写 Interceptor 的实现</h3><p>我来手写一个 Demo，你一下就能明白了</p>
<p>拦截接口，为了方便我这里就只定义了一个方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface HandlerInterceptor &#123;</span><br><span class="line">    boolean preHandle();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义如下2个拦截器</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class CostInterceptor implements HandlerInterceptor &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean preHandle() &#123;</span><br><span class="line">        // 这里可以针对传入的参数做一系列事情，我这里就简单返回true了;</span><br><span class="line">        System.out.println(&quot;CostInterceptor 执行了&quot;);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class LoginInterceptor implements HandlerInterceptor &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean preHandle() &#123;</span><br><span class="line">        System.out.println(&quot;LoginInterceptor 执行了&quot;);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>存放拦截器的容器</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class HandlerExecutionChain &#123;</span><br><span class="line"></span><br><span class="line">    private List&lt;HandlerInterceptor&gt; interceptorList = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    public void addInterceptor(HandlerInterceptor interceptor) &#123;</span><br><span class="line">        interceptorList.add(interceptor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean applyPreHandle() &#123;</span><br><span class="line">        for (int i = 0; i &lt; interceptorList.size(); i++) &#123;</span><br><span class="line">            HandlerInterceptor interceptor = interceptorList.get(i);</span><br><span class="line">            if (!interceptor.preHandle()) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>演示 DispatcherServlet 的调用过程</p>
<figure class="highlight plaintext"><figcaption><span>class Main &#123;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // Spring MVC会根据请求返回一个HandlerExecutionChain对象</span><br><span class="line">        // 然后执行HandlerExecutionChain的applyPreHandle方法，controller中的方法</span><br><span class="line">        HandlerExecutionChain chain = new HandlerExecutionChain();</span><br><span class="line">        chain.addInterceptor(new CostInterceptor());</span><br><span class="line">        chain.addInterceptor(new LoginInterceptor());</span><br><span class="line"></span><br><span class="line">        // 只有拦截器都返回true，才会调用controller的方法</span><br><span class="line">        // CostInterceptor 执行了</span><br><span class="line">        // LoginInterceptor 执行了</span><br><span class="line">        if (!chain.applyPreHandle()) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        result();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void result() &#123;</span><br><span class="line">        System.out.println(&quot;这是controller的方法&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>如果任意一个 Interceptor 返回 false，则后续的 Interceptor 和 Controller 中的方法都不会执行</strong>原因在 Demo 中显而易见</p>
<p>当想对请求增加新的过滤逻辑时，只需要定义一个拦截器即可，完全符合开闭原则。</p>
<p>不知道你意识到没有 <strong>Servlet Filter 和 Spring MVC Interceptor 都是用责任链模式实现的</strong></p>
<p>来看看 DispatcherServlet 是怎么做的？和我们上面写的 demo 一模一样</p>
<p>我们用 servlet 写 web 应用时，一个请求地址写一个 Servlet 类。</p>
<p>而用了 spring mvc 后，整个应用程序只有一个 Servlet 即 DispatcherServlet，所有的请求都发送到DispatcherServlet，然后通过方法调用的方式执行 controller 的方法</p>
<p>DispatcherServlet 的 doDispatch 方法源码如下，省略了一部分逻辑（所有的请求都会执行这个方法）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">protected void doDispatch() &#123;</span><br><span class="line"></span><br><span class="line">	// 执行所有HandlerInterceptor的preHandle方法</span><br><span class="line">	if (!mappedHandler.applyPreHandle(processedRequest, response)) &#123;</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// 执行controller中的方法</span><br><span class="line">	mv = ha.handle(processedRequest, response, mappedHandler.getHandler());</span><br><span class="line"></span><br><span class="line">	// 执行所有HandlerInterceptor的postHandle方法</span><br><span class="line">	mappedHandler.applyPostHandle(processedRequest, response, mv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Interceptor 可以有如下用处</p>
<ul>
<li>记录接口响应时间</li>
<li>判断用户是否登陆</li>
<li>权限校验等</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>Servlet Filter 和 Spring MVC Interceptor 都能对请求进行拦截，只不过时机不同，Servlet Filter 在请求到达 Servlet 之前拦截，Spring MVC Interceptor 在请求到达 DispatcherServlet 之后拦截</li>
<li>Servlet Filter 是 Servlet 的规范，而 Spring MVC Interceptor 只能在 Spring MVC 中使用</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wetts.github.io/2016/12/17/%E7%B3%BB%E7%BB%9F&%E6%9C%8D%E5%8A%A1%E5%99%A8/Nginx/Nginx-%E8%AF%AD%E6%B3%95-rewrite%E5%92%8Cproxy_pass%E7%9A%84%E5%8C%BA%E5%88%AB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Zhang Wetts">
      <meta itemprop="description" content="Stay Hungry, Stay Foolish. <br><br><p style="font-size:8px;">[build by hexo/next/gitalk/hexo-generator-search/LaTeX]</p>">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wetts's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2016/12/17/%E7%B3%BB%E7%BB%9F&%E6%9C%8D%E5%8A%A1%E5%99%A8/Nginx/Nginx-%E8%AF%AD%E6%B3%95-rewrite%E5%92%8Cproxy_pass%E7%9A%84%E5%8C%BA%E5%88%AB/" class="post-title-link" itemprop="url">Nginx-语法-proxy_pass中的路径问题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2016-12-17 15:21:17" itemprop="dateCreated datePublished" datetime="2016-12-17T15:21:17+08:00">2016-12-17</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/" itemprop="url" rel="index"><span itemprop="name">服务器</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h1><h2 id="rewrit"><a href="#rewrit" class="headerlink" title="rewrit"></a>rewrit</h2><ul>
<li>地址栏地址会变</li>
<li>可以用正则表达式重写地址</li>
<li>可以用老query的串</li>
</ul>
<h2 id="proxy-pass"><a href="#proxy-pass" class="headerlink" title="proxy_pass"></a>proxy_pass</h2><ul>
<li>地址栏地址不会变</li>
<li>不能用正则表达式</li>
<li>不能用老query串的参数</li>
</ul>
<h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><p>nginx配置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">    root   html;</span><br><span class="line">    index  index.html index.htm;</span><br><span class="line">    rewrite  &quot;^/search/(.*)$&quot;  http://www.baidu.com/s?wd=$1 break;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location ^~ /demo1/ &#123;</span><br><span class="line">    proxy_pass https://www.baidu.com/s?wd=;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>用<code>http://localhost/search/hehe</code>访问，会跳转到<code>https://www.baidu.com/s?wd=hehe&amp;tn=99190945_s_hao_pg</code></li>
<li>用<code>http://localhost/demo1/hehe</code>访问，不会跳转，但是页面会显示与上面相同的结果</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wetts.github.io/2016/12/16/%E8%AF%AD%E8%A8%80/Java/API/%E5%AE%B9%E5%99%A8/Java-API-%E5%AE%B9%E5%99%A8-list%E3%80%81set%E3%80%81map/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Zhang Wetts">
      <meta itemprop="description" content="Stay Hungry, Stay Foolish. <br><br><p style="font-size:8px;">[build by hexo/next/gitalk/hexo-generator-search/LaTeX]</p>">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wetts's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2016/12/16/%E8%AF%AD%E8%A8%80/Java/API/%E5%AE%B9%E5%99%A8/Java-API-%E5%AE%B9%E5%99%A8-list%E3%80%81set%E3%80%81map/" class="post-title-link" itemprop="url">Java-API-容器-list、set、map</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2016-12-16 16:43:21" itemprop="dateCreated datePublished" datetime="2016-12-16T16:43:21+08:00">2016-12-16</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><img src="/2016/12/16/%E8%AF%AD%E8%A8%80/Java/API/%E5%AE%B9%E5%99%A8/Java-API-%E5%AE%B9%E5%99%A8-list%E3%80%81set%E3%80%81map/%E5%AE%B9%E5%99%A8.png" alt="容器"></p>
<p>Java中的容器主要分为两类：</p>
<ul>
<li><p>Collection：存放列表的</p>
</li>
<li><p>Map：存放键值对的</p>
</li>
<li><p>链表（Linked）</p>
<ul>
<li>有序</li>
<li>增加或删除元素比较快</li>
<li>通过存在元素中的指针联系到一起</li>
</ul>
</li>
<li><p>数组（Array）</p>
<ul>
<li>有序</li>
<li>找需要的元素比较快</li>
<li>元素在内存中连续存放</li>
</ul>
</li>
<li><p>哈希（Hash）</p>
<ul>
<li>无序</li>
</ul>
</li>
</ul>
<h2 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h2><ul>
<li>Array：数组实现</li>
<li>Linked：链表实现</li>
</ul>
<h3 id="Queue：队列接口"><a href="#Queue：队列接口" class="headerlink" title="Queue：队列接口"></a>Queue：队列接口</h3><ul>
<li>Queue：队列接口<ul>
<li>ArrayBlockingQueue<ul>
<li>线程安全的</li>
<li>固定大小，有界阻塞队列</li>
</ul>
</li>
<li>LinkedBlockingQueue<ul>
<li>线程安全的</li>
<li>要想支持阻塞功能，队列的容量一定是固定的</li>
<li>实现取数据和读数据的锁分离</li>
</ul>
</li>
<li>PriorityQueue<ul>
<li>线程不安全的</li>
<li>大小不固定，有界阻塞队列</li>
</ul>
</li>
<li>PriorityBlockingQueue<ul>
<li>线程安全的</li>
<li>大小不固定，有界阻塞队列</li>
<li>可以根据任务自身的优先级顺序先后执行</li>
</ul>
</li>
<li>LinkedTransferQueue</li>
<li>SynchronousQueue<ul>
<li>没有容量，每个插入操作都要等待一个相应的删除操作</li>
<li>在线程池中使用该队列，通常要设置很大的maximumPoolSize值，否则很容易执行拒绝策略</li>
</ul>
</li>
</ul>
</li>
<li>Deque：双端队列接口<ul>
<li>LinkedBlockingDeque：<ul>
<li>线程安全的</li>
<li>有界阻塞队列</li>
</ul>
</li>
<li>ConcurrentLinkedDeque<ul>
<li>线程安全的</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="List：有序的列表"><a href="#List：有序的列表" class="headerlink" title="List：有序的列表"></a>List：有序的列表</h3><ul>
<li>ArrayList<ul>
<li>Vector<ul>
<li>线程安全的</li>
<li>内部的方法基本都是synchronized（<strong>不推荐使用</strong>）</li>
<li>非常类似ArrayList</li>
</ul>
</li>
<li>Stack<ul>
<li>继承自Vector</li>
<li>实现一个后进先出的堆栈。Stack提供5个额外的方法使得Vector得以被当作堆栈使用。</li>
</ul>
</li>
<li>CopyOnWriteArrayList<ul>
<li>线程安全的</li>
<li>多运用在读多写少的场景</li>
</ul>
</li>
</ul>
</li>
<li>LinkedList：实现了Deque接口<ul>
<li>ConcurrentLinkedQueue<ul>
<li>线程安全的</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Set：不重复的列表"><a href="#Set：不重复的列表" class="headerlink" title="Set：不重复的列表"></a>Set：不重复的列表</h3><ul>
<li>HashSet<ul>
<li>线程不安全的</li>
<li>无序的</li>
<li>哈希表实现</li>
</ul>
</li>
<li>TreeSet<ul>
<li>线程不安全的</li>
<li>有序的，自然顺序，也可以指定比较函数</li>
<li>通过TreeMap实现的，红黑树实现</li>
</ul>
</li>
<li>LinkedHashSet<ul>
<li>有序的</li>
<li>也是一个hash表，但是同时维护了一个双链表来记录插入的顺序。基本方法的复杂度为O(1)。</li>
</ul>
</li>
<li>ConcurrentSkipListSet<ul>
<li>线程安全</li>
<li>有序的</li>
<li>通过ConcurrentSkipListMap实现的</li>
</ul>
</li>
<li>CopyOnWriteArraySet<ul>
<li>线程安全的</li>
</ul>
</li>
</ul>
<h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><ul>
<li>HashMap：线程不安全的，哈希表实现<ul>
<li>WeakHashMap<ul>
<li>一种改进的HashMap，它对key实行“弱引用”，如果一个key不再被外部所引用，那么该key可以被GC回收。</li>
</ul>
</li>
<li>LinkedHashMap<ul>
<li>有序的HashMap</li>
<li>也是一个hash表，但是同时维护了一个双链表来记录插入的顺序。基本方法的复杂度为O(1)。</li>
</ul>
</li>
<li>ConcurrentHashMap：<ul>
<li>线程安全的HashMap</li>
<li>内部分成若干个小的HashMap，称之为段（SEGMENT），写操作对某个段加锁就行</li>
</ul>
</li>
</ul>
</li>
<li>TreeMap：<ul>
<li>线程不安全的</li>
<li>有序的，自然顺序，也可以指定比较函数</li>
<li>红黑树实现</li>
</ul>
</li>
<li>HashTable<ul>
<li>线程安全的</li>
<li>内部的方法基本都是synchronized（<strong>不推荐使用</strong>）</li>
</ul>
</li>
<li>ConcurrentSkipListMap<ul>
<li>有序的</li>
<li>线程安全的</li>
<li>内部是SkipList（跳表）结构，在理论上能够在O(log(n))时间内完成查找、插入、删除操作</li>
<li>在非多线程的情况下，应当尽量使用TreeMap。</li>
<li>此外对于并发性相对较低的并行程序可以使用Collections.synchronizedSortedMap将TreeMap进行包装，也可以提供较好的效率。</li>
<li>对于高并发程序，应当使用ConcurrentSkipListMap，能够提供更高的并发度。</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wetts.github.io/2016/12/16/%E8%AF%AD%E8%A8%80/Java/API/%E5%AE%B9%E5%99%A8/Java-API-%E5%AE%B9%E5%99%A8-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84ArrayList/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Zhang Wetts">
      <meta itemprop="description" content="Stay Hungry, Stay Foolish. <br><br><p style="font-size:8px;">[build by hexo/next/gitalk/hexo-generator-search/LaTeX]</p>">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wetts's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2016/12/16/%E8%AF%AD%E8%A8%80/Java/API/%E5%AE%B9%E5%99%A8/Java-API-%E5%AE%B9%E5%99%A8-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84ArrayList/" class="post-title-link" itemprop="url">Java-API-容器-线程安全的ArrayList</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2016-12-16 15:51:17" itemprop="dateCreated datePublished" datetime="2016-12-16T15:51:17+08:00">2016-12-16</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Java中ArrayList不是线程安全的对象。如果需要线程安全的ArrayList有三种方式：</p>
<ol>
<li>Vector</li>
<li>CopyOnWriteArrayList</li>
<li>Collections.synchronizedList(list)</li>
</ol>
<h2 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h2><p>从JDK1.0开始，Vector便存在JDK中，Vector是一个线程安全的列表，采用数组实现。其线程安全的实现方式是对所有操作都加上了synchronized关键字，这种方式严重影响效率，因此，不再推荐使用Vector了。</p>
<h2 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h2><p>写操作性能较差，而多线程的读操作性能较好。</p>
<p>因为该对象写操作的时候，会拷贝一个新的数组，在新的数组中进行写操作，操作完毕之后，将引用指向新的对象上。</p>
<h2 id="Collections-synchronizedList-list"><a href="#Collections-synchronizedList-list" class="headerlink" title="Collections.synchronizedList(list)"></a>Collections.synchronizedList(list)</h2><p>其实现线程安全的方式是建立了list的包装类，对部分操作加上了synchronized关键字以保证线程安全。</p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>CopyOnWriteArrayList，发生修改时候做copy，新老版本分离，保证读的高性能，适用于以读为主，读操作远远大于写操作的场景中使用，比如缓存。而Collections.synchronizedList则可以用在CopyOnWriteArrayList不适用，但是有需要同步列表的地方，读写操作都比较均匀的地方。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wetts.github.io/2016/12/16/%E8%AF%AD%E8%A8%80/Java/API/%E5%AE%B9%E5%99%A8/Why%20is%20Java%20Vector%20class%20considered%20obsolete%20or%20deprecated/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Zhang Wetts">
      <meta itemprop="description" content="Stay Hungry, Stay Foolish. <br><br><p style="font-size:8px;">[build by hexo/next/gitalk/hexo-generator-search/LaTeX]</p>">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wetts's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2016/12/16/%E8%AF%AD%E8%A8%80/Java/API/%E5%AE%B9%E5%99%A8/Why%20is%20Java%20Vector%20class%20considered%20obsolete%20or%20deprecated/" class="post-title-link" itemprop="url">Why is Java Vector class considered obsolete or deprecated</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2016-12-16 15:44:29" itemprop="dateCreated datePublished" datetime="2016-12-16T15:44:29+08:00">2016-12-16</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>转自：<a target="_blank" rel="noopener" href="http://stackoverflow.com/questions/1386275/why-is-java-vector-class-considered-obsolete-or-deprecated">http://stackoverflow.com/questions/1386275/why-is-java-vector-class-considered-obsolete-or-deprecated</a></p>
<p>问题是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Why is Java Vector considered a legacy class, obsolete or deprecated?</span><br><span class="line"></span><br><span class="line">Isn&#x27;t its use valid when working with concurrency?</span><br><span class="line"></span><br><span class="line">And if I don&#x27;t want to manually synchronize objects and just want to use a thread-safe collection without needing to make fresh copies of the underlying array (as CopyOnWriteArrayList does), then is it fine to use Vector?</span><br><span class="line"></span><br><span class="line">What about Stack, which is a subclass of Vector, what should I use instead of it?</span><br></pre></td></tr></table></figure>

<p>解答：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Vector synchronizes on each individual operation. That&#x27;s almost never what you want to do.</span><br><span class="line"></span><br><span class="line">Generally you want to synchronize a whole sequence of operations. Synchronizing individual operations is both less safe (if you iterate over a Vector, for instance, you still need to take out a lock to avoid anyone else changing the collection at the same time, which would cause a ConcurrentModificationException in the iterating thread) but also slower (why take out a lock repeatedly when once will be enough)?</span><br><span class="line"></span><br><span class="line">Of course, it also has the overhead of locking even when you don&#x27;t need to.</span><br><span class="line"></span><br><span class="line">Basically, it&#x27;s a very flawed approach to synchronization in most situations. As Mr Brian Henk pointed out, you can decorate a collection using the calls such as Collections.synchronizedList - the fact that Vector combines both the &quot;resized array&quot; collection implementation with the &quot;synchronize every operation&quot; bit is another example of poor design; the decoration approach gives cleaner separation of concerns.</span><br><span class="line"></span><br><span class="line">As for a Stack equivalent - I&#x27;d look at Deque/ArrayDeque to start with.</span><br></pre></td></tr></table></figure>

<p>从JDK1.0开始，Vector便存在JDK中，Vector是一个线程安全的列表，采用数组实现。其线程安全的实现方式是对所有操作都加上了synchronized关键字，这种方式严重影响效率，因此，不再推荐使用Vector了。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wetts.github.io/2016/12/15/%E5%B7%A5%E5%85%B7/IntelliJ/IntelliJ-debug-%E5%A4%9A%E7%BA%BF%E7%A8%8Bdebug/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Zhang Wetts">
      <meta itemprop="description" content="Stay Hungry, Stay Foolish. <br><br><p style="font-size:8px;">[build by hexo/next/gitalk/hexo-generator-search/LaTeX]</p>">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wetts's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2016/12/15/%E5%B7%A5%E5%85%B7/IntelliJ/IntelliJ-debug-%E5%A4%9A%E7%BA%BF%E7%A8%8Bdebug/" class="post-title-link" itemprop="url">Intellij-debug-多线程debug</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2016-12-15 17:00:13" itemprop="dateCreated datePublished" datetime="2016-12-15T17:00:13+08:00">2016-12-15</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%B7%A5%E5%85%B7/" itemprop="url" rel="index"><span itemprop="name">工具</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="右键断点或者断点设置"><a href="#右键断点或者断点设置" class="headerlink" title="右键断点或者断点设置"></a>右键断点或者断点设置</h3><p><img src="/2016/12/15/%E5%B7%A5%E5%85%B7/IntelliJ/IntelliJ-debug-%E5%A4%9A%E7%BA%BF%E7%A8%8Bdebug/1.1.png" alt="1.1"><br>或者<br><img src="/2016/12/15/%E5%B7%A5%E5%85%B7/IntelliJ/IntelliJ-debug-%E5%A4%9A%E7%BA%BF%E7%A8%8Bdebug/1.2.png" alt="1.2"></p>
<h3 id="debug运行"><a href="#debug运行" class="headerlink" title="debug运行"></a>debug运行</h3><p>在箭头处切换线程</p>
<p><img src="/2016/12/15/%E5%B7%A5%E5%85%B7/IntelliJ/IntelliJ-debug-%E5%A4%9A%E7%BA%BF%E7%A8%8Bdebug/2.png" alt="2"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wetts.github.io/2016/12/14/%E8%AF%AD%E8%A8%80/Java/%E8%99%9A%E6%8B%9F%E6%9C%BA/%E5%85%B6%E4%BB%96/JVM%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E8%AF%A6%E8%A7%A3%EF%BC%88Eden%20Space%E3%80%81Survivor%20Space%E3%80%81Old%20Gen%E3%80%81Code%20Cache%E5%92%8CPerm%20Gen%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Zhang Wetts">
      <meta itemprop="description" content="Stay Hungry, Stay Foolish. <br><br><p style="font-size:8px;">[build by hexo/next/gitalk/hexo-generator-search/LaTeX]</p>">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wetts's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2016/12/14/%E8%AF%AD%E8%A8%80/Java/%E8%99%9A%E6%8B%9F%E6%9C%BA/%E5%85%B6%E4%BB%96/JVM%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E8%AF%A6%E8%A7%A3%EF%BC%88Eden%20Space%E3%80%81Survivor%20Space%E3%80%81Old%20Gen%E3%80%81Code%20Cache%E5%92%8CPerm%20Gen%EF%BC%89/" class="post-title-link" itemprop="url">JVM内存区域详解（Eden Space、Survivor Space、Old Gen、Code Cache和Perm Gen）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2016-12-14 20:04:11" itemprop="dateCreated datePublished" datetime="2016-12-14T20:04:11+08:00">2016-12-14</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>JVM区域总体分两类，heap区和非heap区。 </p>
<p>heap区又分为： </p>
<ul>
<li>Eden Space（伊甸园）、 </li>
<li>Survivor Space(幸存者区)、 </li>
<li>Old Gen（老年代）。</li>
</ul>
<p>非heap区又分： </p>
<ul>
<li>Code Cache(代码缓存区)； </li>
<li>Perm Gen（永久代）； </li>
<li>Jvm Stack(Java虚拟机栈)； </li>
<li>Local Method Statck(本地方法栈)；</li>
</ul>
<p>下面我们对每一个内存区域做详细介绍。 </p>
<h3 id="Eden-Space"><a href="#Eden-Space" class="headerlink" title="Eden Space"></a>Eden Space</h3><p>字面意思是伊甸园，对象被创建的时候首先放到这个区域，进行垃圾回收后，不能被回收的对象被放入到空的survivor区域。</p>
<h3 id="Survivor-Space"><a href="#Survivor-Space" class="headerlink" title="Survivor Space"></a>Survivor Space</h3><p>幸存者区，用于保存在eden space内存区域中经过垃圾回收后没有被回收的对象。Survivor有两个，分别为To Survivor、 From Survivor，这个两个区域的空间大小是一样的。执行垃圾回收的时候Eden区域不能被回收的对象被放入到空的survivor（也就是To Survivor，同时Eden区域的内存会在垃圾回收的过程中全部释放），另一个survivor（即From Survivor）里不能被回收的对象也会被放入这个survivor（即To Survivor），然后To Survivor 和 From Survivor的标记会互换，始终保证一个survivor是空的。</p>
<p><img src="/2016/12/14/%E8%AF%AD%E8%A8%80/Java/%E8%99%9A%E6%8B%9F%E6%9C%BA/%E5%85%B6%E4%BB%96/JVM%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E8%AF%A6%E8%A7%A3%EF%BC%88Eden%20Space%E3%80%81Survivor%20Space%E3%80%81Old%20Gen%E3%80%81Code%20Cache%E5%92%8CPerm%20Gen%EF%BC%89/1.png" alt="1"></p>
<p>Eden Space和Survivor Space都属于新生代，新生代中执行的垃圾回收被称之为Minor GC（因为是对新生代进行垃圾回收，所以又被称为Young GC），每一次Young GC后留下来的对象age加1。</p>
<p>注：GC为Garbage Collection，垃圾回收。</p>
<h3 id="Old-Gen"><a href="#Old-Gen" class="headerlink" title="Old Gen"></a>Old Gen</h3><p>老年代，用于存放新生代中经过多次垃圾回收仍然存活的对象，也有可能是新生代分配不了内存的大对象会直接进入老年代。经过多次垃圾回收都没有被回收的对象，这些对象的年代已经足够old了，就会放入到老年代。</p>
<p>当老年代被放满的之后，虚拟机会进行垃圾回收，称之为Major GC。由于Major GC除并发GC外均需对整个堆进行扫描和回收，因此又称为Full GC。</p>
<p>heap区即堆内存，整个堆大小=年轻代大小 + 老年代大小。堆内存默认为物理内存的1/64(&lt;1GB)；默认空余堆内存小于40%时，JVM就会增大堆直到-Xmx的最大限制，可以通过MinHeapFreeRatio参数进行调整；默认空余堆内存大于70%时，JVM会减少堆直到-Xms的最小限制，可以通过MaxHeapFreeRatio参数进行调整。</p>
<p>下面我们来认识下非堆内存（非heap区） </p>
<h3 id="Code-Cache"><a href="#Code-Cache" class="headerlink" title="Code Cache"></a>Code Cache</h3><p>代码缓存区，它主要用于存放JIT所编译的代码。CodeCache代码缓冲区的大小在client模式下默认最大是32m，在server模式下默认是48m，这个值也是可以设置的，它所对应的JVM参数为ReservedCodeCacheSize 和 InitialCodeCacheSize，可以通过如下的方式来为Java程序设置。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:ReservedCodeCacheSize=128m</span><br></pre></td></tr></table></figure>
<p>CodeCache缓存区是可能被充满的，当CodeCache满时，后台会收到CodeCache is full的警告信息，如下所示：<code>“CompilerThread0” java.lang.OutOfMemoryError: requested 2854248 bytes for Chunk::new. Out of swap space?</code></p>
<p>注：JIT编译器是在程序运行期间，将Java字节码编译成平台相关的二进制代码。正因为此编译行为发生在程序运行期间，所以该编译器被称为Just-In-Time编译器。</p>
<h3 id="Perm-Gen"><a href="#Perm-Gen" class="headerlink" title="Perm Gen"></a>Perm Gen</h3><p>全称是Permanent Generation space，是指内存的永久保存区域，因而称之为永久代。这个内存区域用于存放Class和Meta的信息，Class在被 Load的时候被放入这个区域。因为Perm里存储的东西永远不会被JVM垃圾回收的，所以如果你的应用程序LOAD很多CLASS的话，就很可能出现PermGen space错误。默认大小为物理内存的1/64。</p>
<hr>
<p>简单来讲，jvm的内存回收过程是这样的：</p>
<p>对象在Eden Space创建，当Eden Space满了的时候，gc就把所有在Eden Space中的对象扫描一次，把所有有效的对象复制到第一个Survivor Space，同时把无效的对象所占用的空间释放。当Eden Space再次变满了的时候，就启动移动程序把Eden Space中有效的对象复制到第二个Survivor Space，同时，也将第一个Survivor Space中的有效对象复制到第二个Survivor Space。如果填充到第二个Survivor Space中的有效对象被第一个Survivor Space或Eden Space中的对象引用，那么这些对象就是长期存在的，此时这些对象将被复制到Permanent Generation。</p>
<p>若垃圾收集器依据这种小幅度的调整收集不能腾出足够的空间，就会运行Full GC，此时jvm gc停止所有在堆中运行的线程并执行清除动作。</p>
<p><img src="/2016/12/14/%E8%AF%AD%E8%A8%80/Java/%E8%99%9A%E6%8B%9F%E6%9C%BA/%E5%85%B6%E4%BB%96/JVM%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E8%AF%A6%E8%A7%A3%EF%BC%88Eden%20Space%E3%80%81Survivor%20Space%E3%80%81Old%20Gen%E3%80%81Code%20Cache%E5%92%8CPerm%20Gen%EF%BC%89/2.png" alt="2"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wetts.github.io/2016/12/14/%E8%AF%AD%E8%A8%80/Java/%E8%99%9A%E6%8B%9F%E6%9C%BA/GC/GC%E7%AE%97%E6%B3%95&%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Zhang Wetts">
      <meta itemprop="description" content="Stay Hungry, Stay Foolish. <br><br><p style="font-size:8px;">[build by hexo/next/gitalk/hexo-generator-search/LaTeX]</p>">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wetts's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2016/12/14/%E8%AF%AD%E8%A8%80/Java/%E8%99%9A%E6%8B%9F%E6%9C%BA/GC/GC%E7%AE%97%E6%B3%95&%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/" class="post-title-link" itemprop="url">GC算法&垃圾收集器</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2016-12-14 17:44:23" itemprop="dateCreated datePublished" datetime="2016-12-14T17:44:23+08:00">2016-12-14</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>垃圾收集 Garbage Collection 通常被称为“GC”，它诞生于1960年 MIT 的 Lisp 语言，经过半个多世纪，目前已经十分成熟了。</p>
<p>jvm 中，程序计数器、虚拟机栈、本地方法栈都是随线程而生随线程而灭，栈帧随着方法的进入和退出做入栈和出栈操作，实现了自动的内存清理，因此，我们的内存垃圾回收主要集中于 java 堆和方法区中，在程序运行期间，这部分内存的分配和使用都是动态的.</p>
<h2 id="对象存活判断"><a href="#对象存活判断" class="headerlink" title="对象存活判断"></a>对象存活判断</h2><p>判断对象是否存活一般有两种方式：</p>
<ul>
<li>引用计数：每个对象有一个引用计数属性，新增一个引用时计数加1，引用释放时计数减1，计数为0时可以回收。此方法简单，无法解决对象相互循环引用的问题。（JVM没有采用这种，因为互相引用，会导致回收不了）</li>
<li>可达性分析（Reachability Analysis）：从GC Roots开始向下搜索，搜索所走过的路径称为引用链。当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。不可达对象。</li>
</ul>
<p>在Java语言中，GC Roots包括：</p>
<ul>
<li>虚拟机栈中引用的对象。</li>
<li>方法区中类静态属性实体引用的对象。</li>
<li>方法区中常量引用的对象。</li>
<li>本地方法栈中JNI引用的对象。</li>
</ul>
<h2 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h2><h3 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h3><p>“标记-清除”（Mark-Sweep）算法，如它的名字一样，算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收掉所有被标记的对象。之所以说它是最基础的收集算法，是因为后续的收集算法都是基于这种思路并对其缺点进行改进而得到的。</p>
<p>它的主要缺点有两个：一个是效率问题，标记和清除过程的效率都不高；另外一个是空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致，当程序在以后的运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。</p>
<p><img src="/2016/12/14/%E8%AF%AD%E8%A8%80/Java/%E8%99%9A%E6%8B%9F%E6%9C%BA/GC/GC%E7%AE%97%E6%B3%95&%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/%E6%A0%87%E8%AE%B0-%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95.png" alt="标记-清除算法"></p>
<h3 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h3><p>“复制”（Copying）的收集算法，它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。</p>
<p>这样使得每次都是对其中的一块进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。只是这种算法的代价是将内存缩小为原来的一半，持续复制长生存期的对象则导致效率降低。</p>
<p><img src="/2016/12/14/%E8%AF%AD%E8%A8%80/Java/%E8%99%9A%E6%8B%9F%E6%9C%BA/GC/GC%E7%AE%97%E6%B3%95&%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95.png" alt="复制算法"></p>
<h3 id="标记-压缩算法"><a href="#标记-压缩算法" class="headerlink" title="标记-压缩算法"></a>标记-压缩算法</h3><p>复制收集算法在对象存活率较高时就要执行较多的复制操作，效率将会变低。更关键的是，如果不想浪费50%的空间，就需要有额外的空间进行分配担保，以应对被使用的内存中所有对象都100%存活的极端情况，所以在老年代一般不能直接选用这种算法。</p>
<p>根据老年代的特点，有人提出了另外一种“标记-整理”（Mark-Compact）算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存</p>
<p><img src="/2016/12/14/%E8%AF%AD%E8%A8%80/Java/%E8%99%9A%E6%8B%9F%E6%9C%BA/GC/GC%E7%AE%97%E6%B3%95&%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/%E6%A0%87%E8%AE%B0-%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95.png" alt="标记-压缩算法"></p>
<h3 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h3><p>GC分代的基本假设：绝大部分对象的生命周期都非常短暂，存活时间短。</p>
<p>“分代收集”（Generational Collection）算法，把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记-清理”或“标记-整理”算法来进行回收。</p>
<h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><p>如果说收集算法是内存回收的方法论，垃圾收集器就是内存回收的具体实现</p>
<h3 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h3><p>串行收集器是最古老，最稳定以及效率高的收集器，可能会产生较长的停顿，只使用一个线程去回收。新生代、老年代使用串行回收；新生代复制算法、老年代标记-压缩；垃圾收集的过程中会Stop The World（服务暂停）</p>
<p>参数控制：</p>
<ul>
<li><strong>-XX:+UseSerialGC</strong> 串行收集器</li>
</ul>
<p><img src="/2016/12/14/%E8%AF%AD%E8%A8%80/Java/%E8%99%9A%E6%8B%9F%E6%9C%BA/GC/GC%E7%AE%97%E6%B3%95&%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/Serial%E6%94%B6%E9%9B%86%E5%99%A8.png" alt="Serial收集器"></p>
<h3 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h3><p>ParNew收集器其实就是Serial收集器的多线程版本。新生代并行，老年代串行；新生代复制算法、老年代标记-压缩</p>
<p>参数控制：</p>
<ul>
<li><strong>-XX:+UseParNewGC</strong> ParNew收集器</li>
<li><strong>-XX:ParallelGCThreads</strong> 限制线程数量</li>
</ul>
<p><img src="/2016/12/14/%E8%AF%AD%E8%A8%80/Java/%E8%99%9A%E6%8B%9F%E6%9C%BA/GC/GC%E7%AE%97%E6%B3%95&%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/ParNew%E6%94%B6%E9%9B%86%E5%99%A8.png" alt="ParNew收集器"></p>
<h3 id="Parallel收集器"><a href="#Parallel收集器" class="headerlink" title="Parallel收集器"></a>Parallel收集器</h3><p>Parallel Scavenge收集器类似ParNew收集器，Parallel收集器更关注系统的吞吐量。可以通过参数来打开自适应调节策略，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或最大的吞吐量；也可以通过参数控制GC的时间不大于多少毫秒或者比例；新生代复制算法、老年代标记-压缩</p>
<p>参数控制：</p>
<ul>
<li><strong>-XX:+UseParallelGC</strong> 使用Parallel收集器+ 老年代串行</li>
</ul>
<h3 id="Parallel-Old-收集器"><a href="#Parallel-Old-收集器" class="headerlink" title="Parallel Old 收集器"></a>Parallel Old 收集器</h3><p>Parallel Old是Parallel Scavenge收集器的老年代版本，使用多线程和“标记－整理”算法。这个收集器是在JDK 1.6中才开始提供</p>
<p>参数控制：</p>
<ul>
<li><strong>-XX:+UseParallelOldGC</strong> 使用Parallel收集器+ 老年代并行</li>
</ul>
<h3 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h3><p>CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。目前很大一部分的Java应用都集中在互联网站或B/S系统的服务端上，这类应用尤其重视服务的响应速度，希望系统停顿时间最短，以给用户带来较好的体验。</p>
<p>从名字（包含“Mark Sweep”）上就可以看出CMS收集器是基于“标记-清除”算法实现的，它的运作过程相对于前面几种收集器来说要更复杂一些，整个过程分为4个步骤，包括： </p>
<ul>
<li>初始标记（CMS initial mark）</li>
<li>并发标记（CMS concurrent mark）</li>
<li>重新标记（CMS remark）</li>
<li>并发清除（CMS concurrent sweep）</li>
</ul>
<p>其中初始标记、重新标记这两个步骤仍然需要“Stop The World”。初始标记仅仅只是标记一下GC Roots能直接关联到的对象，速度很快，并发标记阶段就是进行GC Roots Tracing的过程，而重新标记阶段则是为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记的时间短。 </p>
<p>由于整个过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以与用户线程一起工作，所以总体上来说，CMS收集器的内存回收过程是与用户线程一起并发地执行。老年代收集器（新生代使用ParNew）</p>
<p>优点:并发收集、低停顿 </p>
<p>缺点：产生大量空间碎片、并发阶段会降低吞吐量</p>
<p>参数控制：</p>
<ul>
<li><strong>-XX:+UseConcMarkSweepGC</strong> 使用CMS收集器</li>
<li><strong>-XX:+ UseCMSCompactAtFullCollection</strong> Full GC后，进行一次碎片整理；整理过程是独占的，会引起停顿时间变长</li>
<li><strong>-XX:+CMSFullGCsBeforeCompaction</strong> 设置进行几次Full GC后，进行一次碎片整理</li>
<li><strong>-XX:ParallelCMSThreads</strong> 设定CMS的线程数量（一般情况约等于可用CPU数量）</li>
</ul>
<p><img src="/2016/12/14/%E8%AF%AD%E8%A8%80/Java/%E8%99%9A%E6%8B%9F%E6%9C%BA/GC/GC%E7%AE%97%E6%B3%95&%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/CMS%E6%94%B6%E9%9B%86%E5%99%A8.png" alt="CMS收集器"></p>
<h3 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h3><p>G1是目前技术发展的最前沿成果之一，HotSpot开发团队赋予它的使命是未来可以替换掉JDK1.5中发布的CMS收集器。与CMS收集器相比G1收集器有以下特点：</p>
<ol>
<li>空间整合，G1收集器采用标记整理算法，不会产生内存空间碎片。分配大对象时不会因为无法找到连续空间而提前触发下一次GC。</li>
<li>可预测停顿，这是G1的另一大优势，降低停顿时间是G1和CMS的共同关注点，但G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为N毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒，这几乎已经是实时Java（RTSJ）的垃圾收集器的特征了。</li>
</ol>
<p>上面提到的垃圾收集器，收集的范围都是整个新生代或者老年代，而G1不再是这样。使用G1收集器时，Java堆的内存布局与其他收集器有很大差别，它将整个Java堆划分为多个大小相等的独立区域（Region），虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔阂了，它们都是一部分（可以不连续）Region的集合。</p>
<p><img src="/2016/12/14/%E8%AF%AD%E8%A8%80/Java/%E8%99%9A%E6%8B%9F%E6%9C%BA/GC/GC%E7%AE%97%E6%B3%95&%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/G1%E6%94%B6%E9%9B%86%E5%99%A8.png" alt="G1收集器"></p>
<p>G1的新生代收集跟ParNew类似，当新生代占用达到一定比例的时候，开始出发收集。和CMS类似，G1收集器收集老年代对象会有短暂停顿。</p>
<p>收集步骤：</p>
<ol>
<li><p>标记阶段，首先初始标记(Initial-Mark),这个阶段是停顿的(Stop the World Event)，并且会触发一次普通Mintor GC。对应GC log:GC pause (young) (inital-mark)</p>
</li>
<li><p>Root Region Scanning，程序运行过程中会回收survivor区(存活到老年代)，这一过程必须在young GC之前完成。</p>
</li>
<li><p>Concurrent Marking，在整个堆中进行并发标记(和应用程序并发执行)，此过程可能被young GC中断。在并发标记阶段，若发现区域对象中的所有对象都是垃圾，那个这个区域会被立即回收(图中打X)。同时，并发标记过程中，会计算每个区域的对象活性(区域中存活对象的比例)。</p>
<p> ![Concurrent Marking](GC算法&amp;垃圾收集器/Concurrent Marking.png)</p>
</li>
<li><p>Remark, 再标记，会有短暂停顿(STW)。再标记阶段是用来收集 并发标记阶段 产生新的垃圾(并发阶段和应用程序一同运行)；G1中采用了比CMS更快的初始快照算法:snapshot-at-the-beginning (SATB)。</p>
</li>
<li><p>Copy/Clean up，多线程清除失活对象，会有STW。G1将回收区域的存活对象拷贝到新区域，清除Remember Sets，并发清空回收区域并把它返回到空闲区域链表中。</p>
</li>
</ol>
<p>![Copy&amp;Clean up](GC算法&amp;垃圾收集器/Copy&amp;Clean up.png)</p>
<ol start="6">
<li>复制/清除过程后。回收区域的活性对象已经被集中回收到深蓝色和深绿色区域。</li>
</ol>
<p><img src="/2016/12/14/%E8%AF%AD%E8%A8%80/Java/%E8%99%9A%E6%8B%9F%E6%9C%BA/GC/GC%E7%AE%97%E6%B3%95&%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/%E5%A4%8D%E5%88%B6&%E6%B8%85%E9%99%A4.png" alt="复制&amp;清除"></p>
<h2 id="常用的收集器组合"><a href="#常用的收集器组合" class="headerlink" title="常用的收集器组合"></a>常用的收集器组合</h2><table>
<thead>
<tr>
<th align="center"></th>
<th align="center">新生代GC策略</th>
<th align="center">年老代GC策略</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">组合1</td>
<td align="center">Serial</td>
<td align="center">Serial Old</td>
<td align="center">Serial和Serial Old都是单线程进行GC，特点就是GC时暂停所有应用线程。</td>
</tr>
<tr>
<td align="center">组合2</td>
<td align="center">Serial</td>
<td align="center">CMS+Serial Old</td>
<td align="center">CMS（Concurrent Mark Sweep）是并发GC，实现GC线程和应用线程并发工作，不需要暂停所有应用线程。另外，当CMS进行GC失败时，会自动使用Serial Old策略进行GC。</td>
</tr>
<tr>
<td align="center">组合3</td>
<td align="center">ParNew</td>
<td align="center">CMS</td>
<td align="center">使用-XX:+UseParNewGC选项来开启。ParNew是Serial的并行版本，可以指定GC线程数，默认GC线程数为CPU的数量。可以使用-XX:ParallelGCThreads选项指定GC的线程数。 \n如果指定了选项-XX:+UseConcMarkSweepGC选项，则新生代默认使用ParNew GC策略。</td>
</tr>
<tr>
<td align="center">组合4</td>
<td align="center">ParNew</td>
<td align="center">Serial Old</td>
<td align="center">使用-XX:+UseParNewGC选项来开启。新生代使用ParNew GC策略，年老代默认使用Serial Old GC策略。</td>
</tr>
<tr>
<td align="center">组合5</td>
<td align="center">Parallel Scavenge</td>
<td align="center">Serial Old</td>
<td align="center">Parallel Scavenge策略主要是关注一个可控的吞吐量：应用程序运行时间 / (应用程序运行时间 + GC时间)，可见这会使得CPU的利用率尽可能的高，适用于后台持久运行的应用程序，而不适用于交互较多的应用程序。</td>
</tr>
<tr>
<td align="center">组合6</td>
<td align="center">Parallel Scavenge</td>
<td align="center">Parallel Old</td>
<td align="center">Parallel Old是Serial Old的并行版本</td>
</tr>
<tr>
<td align="center">组合7</td>
<td align="center">G1GC</td>
<td align="center">G1GC</td>
<td align="center">-XX:+UnlockExperimentalVMOptions -XX:+UseG1GC #开启 \n -XX:MaxGCPauseMillis =50 #暂停时间目标 \n -XX:GCPauseIntervalMillis =200 #暂停间隔目标 \n -XX:+G1YoungGenSize=512m #年轻代大小 \n -XX:SurvivorRatio=6 #幸存区比例</td>
</tr>
</tbody></table>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/26/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/26/">26</a><span class="page-number current">27</span><a class="page-number" href="/page/28/">28</a><span class="space">&hellip;</span><a class="page-number" href="/page/69/">69</a><a class="extend next" rel="next" href="/page/28/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Zhang Wetts"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">Zhang Wetts</p>
  <div class="site-description" itemprop="description">Stay Hungry, Stay Foolish. <br><br><p style="font-size:8px;">[build by hexo/next/gitalk/hexo-generator-search/LaTeX]</p></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">687</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">65</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">340</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/wetts" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;wetts" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:zhang.wetts@163.com" title="E-Mail → mailto:zhang.wetts@163.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Zhang Wetts</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

  


<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/hibiki.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"react":{"opacity":0.7}});</script></body>
</html>
