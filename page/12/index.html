<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"wetts.github.io","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="Stay Hungry, Stay Foolish. [build by hexo&#x2F;next&#x2F;gitalk&#x2F;hexo-generator-search&#x2F;LaTeX]">
<meta property="og:type" content="website">
<meta property="og:title" content="Wetts&#39;s blog">
<meta property="og:url" content="https://wetts.github.io/page/12/index.html">
<meta property="og:site_name" content="Wetts&#39;s blog">
<meta property="og:description" content="Stay Hungry, Stay Foolish. [build by hexo&#x2F;next&#x2F;gitalk&#x2F;hexo-generator-search&#x2F;LaTeX]">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Zhang Wetts">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://wetts.github.io/page/12/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Wetts's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Wetts's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Stay Hungry, Stay Foolish.</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/wetts" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wetts.github.io/2019/07/23/artificial_intelligence/%E8%AF%AF%E5%B7%AE&%E4%BC%98%E5%8C%96/%E6%9F%A5%E5%87%86%E7%8E%87%E3%80%81%E6%9F%A5%E5%85%A8%E7%8E%87%E3%80%81F1%E3%80%81ROC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Zhang Wetts">
      <meta itemprop="description" content="Stay Hungry, Stay Foolish. <br><br><p style="font-size:8px;">[build by hexo/next/gitalk/hexo-generator-search/LaTeX]</p>">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wetts's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/07/23/artificial_intelligence/%E8%AF%AF%E5%B7%AE&%E4%BC%98%E5%8C%96/%E6%9F%A5%E5%87%86%E7%8E%87%E3%80%81%E6%9F%A5%E5%85%A8%E7%8E%87%E3%80%81F1%E3%80%81ROC/" class="post-title-link" itemprop="url">查准率、查全率、F1、ROC</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-07-23 21:18:29" itemprop="dateCreated datePublished" datetime="2019-07-23T21:18:29+08:00">2019-07-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-03-28 18:08:12" itemprop="dateModified" datetime="2020-03-28T18:08:12+08:00">2020-03-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">机器学习</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="accuracy、查准率、查全率"><a href="#accuracy、查准率、查全率" class="headerlink" title="accuracy、查准率、查全率"></a>accuracy、查准率、查全率</h4><p><img src="/2019/07/23/artificial_intelligence/%E8%AF%AF%E5%B7%AE&%E4%BC%98%E5%8C%96/%E6%9F%A5%E5%87%86%E7%8E%87%E3%80%81%E6%9F%A5%E5%85%A8%E7%8E%87%E3%80%81F1%E3%80%81ROC/1.png" alt="1"></p>
<ul>
<li>准确率（accuracy）：= 预测对的/所有 = (TP+TN)/(TP+FN+FP+TN)</li>
<li>查准率（precision）：P=TP/(TP+FP)（预测结果和真实结果都为正的样本占总的预测结果为正的样本的比例）（挑出的西瓜种有多少比例是好瓜）</li>
<li>查全率（recall）：R=TP/(TP+FN)（预测结果和真实结果都为正的样本占总的正样本的比例）（所有好瓜中有多少比例被挑了出来）</li>
</ul>
<p>查准率和查全率是一对矛盾的度量，一般来说，查准率高时，查全率往往偏低；而查全率高时，查准率往往偏低。在信息检索中，查准率就是检索出的信息有多少比例是用户感兴趣的；查全率则是用户感兴趣的信息有多少被检索出来。查准率分母中就包含了那些不是用户感兴趣的信息，但仍被预测为是用户感兴趣的而被检索出来；查全率分母中则包含了那些是用户感兴趣的信息，但为被预测为用户感兴趣而被抛弃未检索出来。</p>
<p>对于差准率和查全率的使用是需要按情况来确定那个更重要，例如地震的预测查全率更重要，不希望遗漏哪一次地震，但是对于给用户推荐的广告查准率更重要，要推荐给用户更愿意点击的广告。</p>
<h4 id="P-R曲线"><a href="#P-R曲线" class="headerlink" title="P-R曲线"></a>P-R曲线</h4><p>可根据学习器的预测结果对样例进行排序，排在前面的是学习器认为最可能是正例的样本，排在最后的则是学习器认为最不可能是正例的样本。按此顺序逐个把样本作为正例进行预测，则每次可以计算出当前的查全率、查准率，并以查准率为纵轴、查全率为横轴构造查准率-查全率曲线，简称P-R曲线。</p>
<p>P-R曲线是非单调、不平滑的。P-R曲线可用来评估学习器的优劣。若一个学习器的P-R曲线被另一个学习器的P-R曲线完全包住，则后者的性能优于前者。如果两个学习器的曲线发生交叉，则通过二者面积的大小来比较，面积大的表示查全率和查准率双高比较优秀，但不太容易计算曲线（不平滑）的面积，因此通过平衡点（Break-Even Point，简称BEP）来度量。BEP是坐标上查准率等于查全率时的点，平衡点值越大，学习器越优秀。</p>
<p>用了简单的图来说明，红色的点就是三条P-R曲线的BEP点，学习器A的曲线被C包住，C比较优秀，而C和B交叉，用面积计算难以估算，但C的BEP值大于B，所以C比较优秀。</p>
<p><img src="/2019/07/23/artificial_intelligence/%E8%AF%AF%E5%B7%AE&%E4%BC%98%E5%8C%96/%E6%9F%A5%E5%87%86%E7%8E%87%E3%80%81%E6%9F%A5%E5%85%A8%E7%8E%87%E3%80%81F1%E3%80%81ROC/PR.png" alt="1"></p>
<p>BEP过于简化，定义F1常量来比较学习器P-R曲线的性能：</p>
<ul>
<li>F1度量：<code>F1=(2*P*R)/(P+R)=2*TP/(样例总数+TP-TN)</code></li>
</ul>
<p>F1是基于查准率与查全率的调和平均（harmonic mean）定义的：<code>1/F1=1/2*(1/P+1/R)</code></p>
<p>更一般的形式：<code>Fβ=(1+β^2)*P*R/((β^2*P)+R）</code></p>
<p>其中β&gt;0度量了查全率对查准率的相对重要性；β=1时就是标准的F1；β&gt;1时偏好查全率；β&lt;1时偏好查准率。</p>
<p>Fβ则是加权调和平均：<code>1/Fβ=(1/P+β^2/R)/(1+β^2)</code></p>
<h4 id="ROC、AUC"><a href="#ROC、AUC" class="headerlink" title="ROC、AUC"></a>ROC、AUC</h4><p>ROC和AUC类似，也是通过绘制两个变量的概率图像来解释分类器效果的评判准则,ROC曲线的纵轴是“真正例率”TPR，横轴是“假正例率”FPR。其中：</p>
<ul>
<li>真正例率(True Postive Rate)TPR: <code>TP/(TP+FN)</code>,代表分类器预测的正类中实际正实例占所有正实例的比例。Sensitivity</li>
<li>假正例率(False Postive Rate)FPR: <code>FP/(FP+TN)</code>，代表分类器预测的正类中实际负实例占所有负实例的比例。1-Specificity</li>
<li>真负例率(True Negative Rate)TNR: <code>TN/(FP+TN)</code>,代表分类器预测的负类中实际负实例占所有负实例的比例，TNR=1-FPR。Specificity</li>
</ul>
<p>AUC的几何意义ROC曲线下的面积。</p>
<p>概率学上的意义：随机选取一个正例和一个负例，分类器给正例的打分大于分类器给负例的打分的概率。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wetts.github.io/2019/07/11/%E8%AF%AD%E8%A8%80/Python/%E5%AF%B9%E8%B1%A1/Python%E4%B8%AD%E7%9A%84%E8%A3%85%E9%A5%B0%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Zhang Wetts">
      <meta itemprop="description" content="Stay Hungry, Stay Foolish. <br><br><p style="font-size:8px;">[build by hexo/next/gitalk/hexo-generator-search/LaTeX]</p>">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wetts's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/07/11/%E8%AF%AD%E8%A8%80/Python/%E5%AF%B9%E8%B1%A1/Python%E4%B8%AD%E7%9A%84%E8%A3%85%E9%A5%B0%E5%99%A8/" class="post-title-link" itemprop="url">Python中的装饰器</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2019-07-11 13:20:40 / 修改时间：13:28:31" itemprop="dateCreated datePublished" datetime="2019-07-11T13:20:40+08:00">2019-07-11</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Python/" itemprop="url" rel="index"><span itemprop="name">Python</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>转自：<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_41179709/article/details/81879601">https://blog.csdn.net/weixin_41179709/article/details/81879601</a></p>
<h2 id="装饰器介绍"><a href="#装饰器介绍" class="headerlink" title="装饰器介绍"></a>装饰器介绍</h2><p>装饰器就是对被装饰的对象（函数、类）进行重构的，其可以在不改变原来对象的情况下调用对象时执行重构后的行为 </p>
<ol>
<li>解决问题：在函数执行之前和执行之后添加功能，调用函数的方式改变了 </li>
<li>不改变原有函数的调用方法:函数里面嵌套函数，并且返回嵌套的函数 </li>
</ol>
<p>例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">##引题：当登陆某系统时常常会有欢迎语，但修改时将在登陆函数中修改，可能会出现问题，所以避免直接侵入原函数修改。</span><br><span class="line">def login():</span><br><span class="line">    print(&quot;中秋快乐&quot;)</span><br><span class="line">    print(&quot;login....&quot;)</span><br><span class="line">    print(&quot;欢迎您下次光临....&quot;)</span><br><span class="line">login()</span><br><span class="line"></span><br><span class="line">##为了避免在大的函数块中操作，将欢迎语独立出来，另建函数。</span><br><span class="line">def desc(fun):</span><br><span class="line">    def add_info():</span><br><span class="line">        print(&quot;中秋快乐&quot;)</span><br><span class="line">        fun()</span><br><span class="line">        print(&quot;欢迎您下次光临&quot;)</span><br><span class="line">    return add_info</span><br><span class="line">def login():</span><br><span class="line">    print(&quot;login....&quot;)</span><br><span class="line">login = desc(login)</span><br><span class="line">login()</span><br></pre></td></tr></table></figure>

<h2 id="装饰器语法糖"><a href="#装饰器语法糖" class="headerlink" title="装饰器语法糖"></a>装饰器语法糖</h2><p>在Python中，可以使用”@”语法糖来精简装饰器的代码，把 decorator 置于函数的定义处，免去给函数重新赋值(即function = decorator(funtion)) </p>
<p>例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import functools           #functools 标准库</span><br><span class="line">import time                #time 时间函数</span><br><span class="line"></span><br><span class="line">def add_log(fun):</span><br><span class="line">    @functools.wraps(fun)           #不用此模块add(x,y)函数的__name__，__doc__都会丢失</span><br><span class="line">    def wrapper(*args,**kwargs):   #*args为元组  **kwargs为字典</span><br><span class="line">        start_time = time.time()</span><br><span class="line">        res = fun(*args,**kwargs)</span><br><span class="line">        end_time = time.time()</span><br><span class="line">        print(&quot;[%s] 函数名：%s, 运行时间 ：%.5f ,运行返回值：% d&quot;</span><br><span class="line">              %(time.ctime(),fun.__name__,end_time- start_time,res))</span><br><span class="line">        return res                  #返回值为所要装饰的函数</span><br><span class="line">    return wrapper                 #返回值为所要修饰函数所添加的模块</span><br><span class="line">@add_log                            ##调用语法糖</span><br><span class="line">def add(x,y):</span><br><span class="line">    time.sleep(0.1)</span><br><span class="line">    return x+y</span><br><span class="line">print(add(1,2))</span><br></pre></td></tr></table></figure>

<h2 id="装饰的函数有返回值"><a href="#装饰的函数有返回值" class="headerlink" title="装饰的函数有返回值"></a>装饰的函数有返回值</h2><p>解决办法：给返回值赋值</p>
<p>例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">def timeit(fun):</span><br><span class="line">    def wrapper(*args,**kwargs):    #接收可变参数和关键字参数</span><br><span class="line">        #args:元组 kwargs：字典  args=(5,)</span><br><span class="line">        #原函数执行之前</span><br><span class="line">        start_time = time.time()</span><br><span class="line">        #执行函数</span><br><span class="line">        res = fun(*args,**kwargs)   #args解包</span><br><span class="line">        #执行函数</span><br><span class="line">        end_time = time.time()</span><br><span class="line">        print(&quot;运行时间为:%.6f&quot; % (end_time - start_time))</span><br><span class="line">    return res</span><br><span class="line">    return wrapper</span><br><span class="line"></span><br><span class="line">@timeit</span><br><span class="line">def list_create(n):</span><br><span class="line">    return(i*2 for i in range(n)])</span><br><span class="line"></span><br><span class="line">@timeit</span><br><span class="line">def map_create(n):</span><br><span class="line">    return(list(map(lambda x:x*2,range(n))))</span><br><span class="line"></span><br><span class="line">list_create(5)</span><br><span class="line">map_create(5)</span><br><span class="line">print(list_create(100))     ##wrapper(100)</span><br></pre></td></tr></table></figure>

<h2 id="保留被装饰的函数的函数名和帮助文档信息"><a href="#保留被装饰的函数的函数名和帮助文档信息" class="headerlink" title="保留被装饰的函数的函数名和帮助文档信息"></a>保留被装饰的函数的函数名和帮助文档信息</h2><p>解决办法：导入functools标准库,使用functools.wraps函数，保留被装饰的函数的函数名和帮助文档信息。</p>
<p>例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">import  functools</span><br><span class="line">def timeit(fun):</span><br><span class="line">    &quot;&quot;&quot;这是一个装饰器timeit&quot;&quot;&quot;    </span><br><span class="line">    @functools.wraps(fun)       ##内置装饰器</span><br><span class="line">    可以保留被装饰的函数的函数名和帮助文档信息   </span><br><span class="line">    def wrapper(*args,**kwargs):    #接收可变参数和关键字参数</span><br><span class="line">        &quot;&quot;&quot;这是一个wrapper函数&quot;&quot;&quot;</span><br><span class="line">        #args:元组 kwargs：字典  args=(5,)</span><br><span class="line">        #原函数执行之前</span><br><span class="line">        start_time = time.time()</span><br><span class="line">        #执行函数</span><br><span class="line">        res = fun(*args,**kwargs)   #args解包</span><br><span class="line">        #执行函数</span><br><span class="line">        end_time = time.time()</span><br><span class="line">        print(&quot;运行时间为:%.6f&quot; % (end_time - start_time))</span><br><span class="line">    return res</span><br><span class="line">    return wrapper</span><br><span class="line">@timeit</span><br><span class="line">def fun():</span><br><span class="line">    print(&quot;hello&quot;)</span><br><span class="line">print(fun_list.__name__)</span><br><span class="line">print(fun_list.__doc__)</span><br></pre></td></tr></table></figure>

<h2 id="装饰器中不同条件下执行不同的函数"><a href="#装饰器中不同条件下执行不同的函数" class="headerlink" title="装饰器中不同条件下执行不同的函数"></a>装饰器中不同条件下执行不同的函数</h2><p>用实例说明：需求: 用户来CSDN登陆验证的装饰器is_login</p>
<ol>
<li>如果用户登陆成功, 则执行被装饰的函数;</li>
<li>如果用户登陆不成功, 则执行登陆函数</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">import functools</span><br><span class="line">login_users = [&#x27;admin&#x27;, &#x27;root&#x27;]</span><br><span class="line"></span><br><span class="line">def is_login(fun):  # fun: writeBlog</span><br><span class="line">    @functools.wraps(fun)</span><br><span class="line">    def wrapper(*args, **kwargs):   # name=&quot;admin&quot;  # kwargs=&#123;&quot;name&quot;:&quot;admin&quot;&#125;</span><br><span class="line">        # 判断写博客的这个用户是否登陆成功;</span><br><span class="line">        if kwargs.get(&quot;name&quot;) in login_users:</span><br><span class="line">            res = fun(*args, **kwargs)</span><br><span class="line">            return res</span><br><span class="line">        else:</span><br><span class="line">            res=login()</span><br><span class="line">        return res</span><br><span class="line"></span><br><span class="line">    return wrapper</span><br><span class="line"></span><br><span class="line"># 必须登陆成功</span><br><span class="line">@is_login    # writeBlog = is_login(writeBlog)</span><br><span class="line">def writeBlog(name):</span><br><span class="line">    return &quot;编写博客&quot;</span><br><span class="line"></span><br><span class="line">def login():</span><br><span class="line">    return &quot;登陆。。。。&quot;</span><br><span class="line"></span><br><span class="line"># 是否登陆成功都可以执行代码</span><br><span class="line">def news():</span><br><span class="line">    print(&quot;新闻......&quot;)</span><br><span class="line"></span><br><span class="line">print(writeBlog(name=&quot;admin&quot;))</span><br></pre></td></tr></table></figure>

<h2 id="多个装饰器"><a href="#多个装饰器" class="headerlink" title="多个装饰器"></a>多个装饰器</h2><p>若有两个装饰器，从上到下调用装饰器，wrapper内容也是为由上向下执行 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">def makebold(fun):</span><br><span class="line">    print(&quot;bold1&quot;)</span><br><span class="line">    def wrapper1(*args, **kwargs):</span><br><span class="line">        print(&quot;bold2&quot;)</span><br><span class="line">        return  fun(*args, **kwargs)  # wrapper</span><br><span class="line">    return  wrapper1</span><br><span class="line">def makei(fun):   # fun=login</span><br><span class="line">    print(&quot;i1&quot;)</span><br><span class="line">    def wrapper(*args, **kwargs):</span><br><span class="line">        print(&quot;i2&quot;)</span><br><span class="line">        return  fun(*args, **kwargs)</span><br><span class="line">    return  wrapper</span><br><span class="line"># 当有多个装饰器时，从上到下调用装饰器</span><br><span class="line"># 真实wrapper内容执行是从上到下执行</span><br><span class="line">@makebold   #login = makebold(login)    #login为wrapper1</span><br><span class="line">@makei      #login = makei(login)       #login为wrapper</span><br><span class="line">def login():</span><br><span class="line">    return &quot;登陆&quot;</span><br><span class="line">print(login())</span><br></pre></td></tr></table></figure>

<h2 id="带有参数的装饰器"><a href="#带有参数的装饰器" class="headerlink" title="带有参数的装饰器"></a>带有参数的装饰器</h2><p>创建装饰器， 要求如下：</p>
<ol>
<li>创建add_log装饰器， 被装饰的函数打印日志信息；</li>
<li>日志格式为: <code>[字符串时间] 函数名: xxx， 运行时间：xxx, 运行返回值结果:xxx</code></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"># 创建装饰器， 要求如下：</span><br><span class="line"># 1. 创建add_log装饰器， 被装饰的函数打印日志信息；</span><br><span class="line"># 2. 日志格式为: [字符串时间] 函数名: xxx， 运行时间：xxx, 运行返回值结果:xxx</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import functools</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line"># format</span><br><span class="line">def log(kind):  # kind=&quot;debug&quot;</span><br><span class="line">    def add_log(fun):</span><br><span class="line">        @functools.wraps(fun)</span><br><span class="line">        def wrapper(*args, **kwargs):</span><br><span class="line">            start_time = time.time()</span><br><span class="line">            res = fun(*args, **kwargs)</span><br><span class="line">            end_time = time.time()</span><br><span class="line">            print(&quot;&lt;%s&gt; [%s] 函数名: %s， 运行时间：%.5f, 运行返回值结果:%d&quot;</span><br><span class="line">                  %(kind, time.ctime(), fun.__name__, end_time-start_time, res )</span><br><span class="line">                  )</span><br><span class="line">            return res</span><br><span class="line">        return wrapper</span><br><span class="line">    return  add_log</span><br><span class="line">@log(&quot;debug&quot;)</span><br><span class="line">#  log(&quot;debug&quot;)==&gt; 返回值是add_log</span><br><span class="line">#  add=add_log(add)</span><br><span class="line">def add(x,y):</span><br><span class="line">    time.sleep(0.1)</span><br><span class="line">    return x+y</span><br><span class="line">print(add(14214124124,1241231231313))</span><br><span class="line"># wrapper(14214124124,1241231231313)</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wetts.github.io/2019/07/06/%E8%AF%AD%E8%A8%80/Python/%E5%AF%B9%E8%B1%A1/Python%E4%B8%AD%E7%9A%84%E7%94%9F%E6%88%90%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Zhang Wetts">
      <meta itemprop="description" content="Stay Hungry, Stay Foolish. <br><br><p style="font-size:8px;">[build by hexo/next/gitalk/hexo-generator-search/LaTeX]</p>">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wetts's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/07/06/%E8%AF%AD%E8%A8%80/Python/%E5%AF%B9%E8%B1%A1/Python%E4%B8%AD%E7%9A%84%E7%94%9F%E6%88%90%E5%99%A8/" class="post-title-link" itemprop="url">Python中的生成器</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2019-07-06 11:39:43 / 修改时间：21:40:09" itemprop="dateCreated datePublished" datetime="2019-07-06T11:39:43+08:00">2019-07-06</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Python/" itemprop="url" rel="index"><span itemprop="name">Python</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>转自：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/deeper/p/7565571.html">https://www.cnblogs.com/deeper/p/7565571.html</a></p>
<p>理解了迭代器以后，生成器就会简单很多，因为生成器其实是一种特殊的迭代器。不过这种迭代器更加优雅。它不需要再像上面的类一样写<code>__iter__()</code>和<code>__next__()</code>方法了，只需要一个yiled关键字。 生成器一定是迭代器（反之不成立），因此任何生成器也是以一种懒加载的模式生成值。</p>
<p>语法上说，生成器函数是一个带yield关键字的函数。</p>
<p>调用生成器函数后会得到一个生成器对象，这个生成器对象实际上就是一个特殊的迭代器，拥有<code>__iter__()</code>和<code>__next__()</code>方法</p>
<p>我们先用一个例子说明一下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def generator_winter():</span><br><span class="line">...   i = 1</span><br><span class="line">...   while i &lt;= 3:</span><br><span class="line">...     yield i</span><br><span class="line">...     i += 1</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; generator_winter</span><br><span class="line">&lt;function generator_winter at 0x000000000323B9D8&gt;</span><br><span class="line">&gt;&gt;&gt; generator_iter = generator_winter()</span><br><span class="line">&gt;&gt;&gt; generator_iter</span><br><span class="line">&lt;generator object generator_winter at 0x0000000002D9CAF0&gt;</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">&gt;&gt;&gt; generator_iter.__next__()</span><br><span class="line">1</span><br><span class="line">&gt;&gt;&gt; generator_iter.__next__()</span><br><span class="line">2</span><br><span class="line">&gt;&gt;&gt; generator_iter.__next__()</span><br><span class="line">3</span><br><span class="line">&gt;&gt;&gt; generator_iter.__next__()</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">StopIteration</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p>现在解释一下上面的代码：</p>
<ol>
<li>首先我们创建了一个含有yield关键字的函数generator_winter，这是一个生成器函数</li>
<li>然后，我们调用了这个生成器函数，并且将返回值赋值给了generator_iter，generator_iter是一个生成器对象；__注意generator_iter = generator_winter()时，函数体中的代码并不会执行，只有显示或隐示地调用next的时候才会真正执行里面的代码__。</li>
<li>生成器对象就是一个迭代器，所以我们可以调用对象的__next__方法来每次返回一个迭代器的值；迭代器的值通过yield返回；并且迭代完最后一个元素后，触发StopIteration异常；</li>
</ol>
<p>既然生成器对象是一个迭代器，我们就可以使用for循环来迭代这个生成器对象：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def generator_winter():</span><br><span class="line">...   i = 1</span><br><span class="line">...   while i &lt;= 3:</span><br><span class="line">...     yield i</span><br><span class="line">...     i += 1</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">&gt;&gt;&gt; for item in generator_winter():</span><br><span class="line">...   print(item)</span><br><span class="line">...</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>我们注意到迭代器不是使用return来返回值，而是采用yield返回值；那么这个yield有什么特别之处呢？</p>
<h4 id="yield"><a href="#yield" class="headerlink" title="yield"></a>yield</h4><p>我们知道，一个函数只能返回一次，即return以后，这次函数调用就结束了；</p>
<p>但是生成器函数可以暂停执行，并且通过yield返回一个中间值，当生成器对象的<code>__next__()</code>方法再次被调用的时候，生成器函数可以从上一次暂停的地方继续执行，直到触发一个StopIteration</p>
<p>上例中，当执行到yield i后，函数返回i值，然后print这个值，下一次循环，又调用<code>__next__()</code>方法，回到生成器函数，并从yield i的下一句继续执行；</p>
<p>摘一段&lt;python核心编程&gt;的内容：</p>
<blockquote>
<p>生成器的另外一个方面甚至更加强力—-协同程序的概念。协同程序是可以运行的独立函数调用，可以暂停或者挂起，并从程序离开的地方继续或者重新开始。在有调用者和(被调用的)协同程序也有通信。举例来说，当协同程序暂停时，我们仍可以从其中获得一个中间的返回值，当调用回到程序中时，能够传入额外或者改变了的参数，但是仍然能够从我们上次离开的地方继续，并且所有状态完整。挂起返回出中间值并多次继续的协同程序被称为生成器，那就是python的生成真正在做的事情。这些提升让生成器更加接近一个完全的协同程序，因为允许值(和异常)能传回到一个继续的函数中，同样的，当等待一个生成器的时候，生成器现在能返回控制，在调用的生成器能挂起(返回一个结果)之前，调用生成器返回一个结果而不是阻塞的等待那个结果返回。</p>
</blockquote>
<h4 id="什么情况会触发StopIteration"><a href="#什么情况会触发StopIteration" class="headerlink" title="什么情况会触发StopIteration"></a>什么情况会触发StopIteration</h4><p>两种情况会触发StopIteration</p>
<ol>
<li>如果没有return，则默认执行到函数完毕时返回StopIteration；</li>
<li>如果在执行过程中 return，则直接抛出 StopIteration 终止迭代；如果在return后返回一个值，那么这个值为StopIteration异常的说明，不是程序的返回值。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def generator_winter():</span><br><span class="line">...   yield &#x27;hello world&#x27;</span><br><span class="line">...   return &#x27;again&#x27;</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">&gt;&gt;&gt; winter = generator_winter()</span><br><span class="line">&gt;&gt;&gt; winter.__next__()</span><br><span class="line">&#x27;hello world&#x27;</span><br><span class="line">&gt;&gt;&gt; winter.__next__()</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">StopIteration: again</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="生成器的作用"><a href="#生成器的作用" class="headerlink" title="生成器的作用"></a>生成器的作用</h4><p>说了这么多，生成器有什么用呢？作为python主要特性之一，这是个极其牛逼的东西，由于它是惰性的，在处理大型数据时，可以节省大量内存空间；</p>
<p>当你需要迭代一个巨大的数据集合，比如创建一个有规律的100万个数字，如果采用列表来存储访问，那么会占用大量的内存空间；而且如果我们只是访问这个列表的前几个元素，那么后边大部分元素占据的内存空间就白白浪费了；这时，如果采用生成器，则不必创建完整的列表，一次循环返回一个希望得到的值，这样就可以大量节省内存空间；</p>
<p>这里在举例之前，我们先介绍一个生成器表达式（类似于列表推导式，只是把[]换成()），这样就创建了一个生成器。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; gen = (x for x in range(10))</span><br><span class="line">&gt;&gt;&gt; gen</span><br><span class="line">&lt;generator object &lt;genexpr&gt; at 0x0000000002A923B8&gt;</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>生成器表达式的语法如下：<code>(expr for iter_var in iterable if cond_expr)</code><br>用生成器来实现斐波那契数列</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def fib(n):</span><br><span class="line">    a, b = 0, 1</span><br><span class="line">    while b &lt;= n:</span><br><span class="line">        yield b</span><br><span class="line">        a, b = b, a+b</span><br><span class="line"></span><br><span class="line">f = fib(10)</span><br><span class="line">for item in f:</span><br><span class="line">    print(item)</span><br></pre></td></tr></table></figure>

<h4 id="生成器方法"><a href="#生成器方法" class="headerlink" title="生成器方法"></a>生成器方法</h4><p>直接看生成器源代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class __generator(object):</span><br><span class="line">    &#x27;&#x27;&#x27;A mock class representing the generator function type.&#x27;&#x27;&#x27;</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.gi_code = None</span><br><span class="line">        self.gi_frame = None</span><br><span class="line">        self.gi_running = 0</span><br><span class="line"></span><br><span class="line">    def __iter__(self):</span><br><span class="line">        &#x27;&#x27;&#x27;Defined to support iteration over container.&#x27;&#x27;&#x27;</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">    def __next__(self):</span><br><span class="line">        &#x27;&#x27;&#x27;Return the next item from the container.&#x27;&#x27;&#x27;</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">    def close(self):</span><br><span class="line">        &#x27;&#x27;&#x27;Raises new GeneratorExit exception inside the generator to terminate the iteration.&#x27;&#x27;&#x27;</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">    def send(self, value):</span><br><span class="line">        &#x27;&#x27;&#x27;Resumes the generator and &quot;sends&quot; a value that becomes the result of the current yield-expression.&#x27;&#x27;&#x27;</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">    def throw(self, type, value=None, traceback=None):</span><br><span class="line">        &#x27;&#x27;&#x27;Used to raise an exception inside the generator.&#x27;&#x27;&#x27;</span><br><span class="line">        pass</span><br></pre></td></tr></table></figure>
<p>首先看到了生成器是自带<code>__iter__</code>和<code>__next__</code>魔术方法的；</p>
<h5 id="send"><a href="#send" class="headerlink" title="send"></a>send</h5><p>生成器函数最大的特点是可以接受外部传入的一个变量，并根据变量内容计算结果后返回。这是生成器函数最难理解的地方，也是最重要的地方，协程的实现就全靠它了。</p>
<p>看一个小猫吃鱼的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def cat():</span><br><span class="line">    print(&#x27;我是一只hello kitty&#x27;)</span><br><span class="line">    while True:</span><br><span class="line">        food = yield</span><br><span class="line">        if food == &#x27;鱼肉&#x27;:</span><br><span class="line">            yield &#x27;好开心&#x27;</span><br><span class="line">        else:</span><br><span class="line">            yield &#x27;不开心，人家要吃鱼肉啦&#x27;</span><br></pre></td></tr></table></figure>

<p>中间有个赋值语句food = yield，可以通过send方法来传参数给food，试一下：</p>
<p> 情况1）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">miao = cat()    #只是用于返回一个生成器对象，cat函数不会执行</span><br><span class="line">print(&#x27;&#x27;.center(50,&#x27;-&#x27;))</span><br><span class="line">print(miao.send(&#x27;鱼肉&#x27;))</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">--------------------------------------------------</span><br><span class="line">  File &quot;C:/Users//Desktop/Python/cnblogs/subModule.py&quot;, line 67, in &lt;module&gt;</span><br><span class="line">    print(miao.send(&#x27;鱼肉&#x27;))</span><br><span class="line">TypeError: can&#x27;t send non-None value to a just-started generator</span><br></pre></td></tr></table></figure>
<p>看到了两个信息：</p>
<ol>
<li>miao = cat() ，只是用于返回一个生成器对象，cat函数不会执行</li>
<li>can’t send non-None value to a just-started generator；不能给一个刚创建的生成器对象直接send值</li>
</ol>
<p>改一下</p>
<p>情况2）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">miao = cat()</span><br><span class="line">miao.__next__()</span><br><span class="line">print(miao.send(&#x27;鱼肉&#x27;))</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">我是一只hello kitty</span><br><span class="line">好开心</span><br></pre></td></tr></table></figure>
<p>没毛病，那么到底send()做了什么呢？send()的帮助文档写的很清楚，<code>&#39;&#39;&#39;Resumes the generator and &quot;sends&quot; a value that becomes the result of the current yield-expression.&#39;&#39;&#39;</code>；可以看到send依次做了两件事：</p>
<ol>
<li>回到生成器挂起的位置，继续执行</li>
<li>并将send(arg)中的参数赋值给对应的变量，如果没有变量接收值，那么就只是回到生成器挂起的位置</li>
</ol>
<p>但是，我认为send还做了第三件事：<br>3. 兼顾<code>__next__()</code>作用，挂起程序并返回值，所以我们在<code>print(miao.send(&#39;鱼肉&#39;))</code>时，才会看到’好开心’；其实<code>__next__()</code>等价于<code>send(None)</code></p>
<p>所以当我们尝试这样做的时候：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">def cat():</span><br><span class="line">    print(&#x27;我是一只hello kitty&#x27;)</span><br><span class="line">    while True:</span><br><span class="line">        food = yield</span><br><span class="line">        if food == &#x27;鱼肉&#x27;:</span><br><span class="line">            yield &#x27;好开心&#x27;</span><br><span class="line">        else:</span><br><span class="line">            yield &#x27;不开心，人家要吃鱼肉啦&#x27;</span><br><span class="line"></span><br><span class="line">miao = cat()</span><br><span class="line">print(miao.__next__())</span><br><span class="line">print(miao.send(&#x27;鱼肉&#x27;))</span><br><span class="line">print(miao.send(&#x27;骨头&#x27;))</span><br><span class="line">print(miao.send(&#x27;鸡肉&#x27;))</span><br></pre></td></tr></table></figure>
<p>就会得到这个结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">我是一只hello kitty</span><br><span class="line">None</span><br><span class="line">好开心</span><br><span class="line">None</span><br><span class="line">不开心，人家要吃鱼肉啦</span><br></pre></td></tr></table></figure>
<p>我们按步骤分析一下：</p>
<ol>
<li>执行到<code>print(miao.__next__())</code>，执行cat()函数，print了”我是一只hello kitty”，然后在food = yield挂起，并返回了None，打印None</li>
<li>接着执行<code>print(miao.send(&#39;鱼肉&#39;))</code>，回到food = yield，并将’鱼肉’赋值给food，生成器函数恢复执行；直到运行到<code>yield &#39;好开心&#39;</code>，程序挂起，返回’好开心’，并print ‘好开心’</li>
<li>接着执行<code>print(miao.send(&#39;骨头&#39;))</code>，回到<code>yield &#39;好开心&#39;</code>，这时没有变量接收参数’骨头’，生成器函数恢复执行；直到<code>food = yield</code>，程序挂起，返回None，并print None</li>
<li>接着执行<code>print(miao.send(&#39;鸡肉&#39;))</code>，回到food = yield，并将’鸡肉’赋值给food，生成器函数恢复执行；直到运行到<code>yield &#39;不开心，人家要吃鱼肉啦&#39;</code>，程序挂起，返回’不开心，人家要吃鱼肉啦’，，并print ‘不开心，人家要吃鱼肉啦’</li>
</ol>
<p>大功告成；那我们优化一下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">def cat():</span><br><span class="line">    msg = &#x27;我是一只hello kitty&#x27;</span><br><span class="line">    while True:</span><br><span class="line">        food = yield msg</span><br><span class="line">        if food == &#x27;鱼肉&#x27;:</span><br><span class="line">            msg = &#x27;好开心&#x27;</span><br><span class="line">        else:</span><br><span class="line">            msg = &#x27;不开心，人家要吃鱼啦&#x27;</span><br><span class="line"></span><br><span class="line">miao = cat()</span><br><span class="line">print(miao.__next__())</span><br><span class="line">print(miao.send(&#x27;鱼肉&#x27;))</span><br><span class="line">print(miao.send(&#x27;鸡肉&#x27;))</span><br></pre></td></tr></table></figure>
<p>我们再看一个更实用的例子，一个计数器</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">def counter(start_at = 0):</span><br><span class="line">    count = start_at</span><br><span class="line">    while True:</span><br><span class="line">        val = (yield count)</span><br><span class="line">        if val is not None:</span><br><span class="line">            count = val</span><br><span class="line">        else:</span><br><span class="line">            count += 1</span><br><span class="line"></span><br><span class="line">count = counter(5)</span><br><span class="line">print(count.__next__())</span><br><span class="line">print(count.__next__())</span><br><span class="line">print(count.send(0))</span><br><span class="line">print(count.__next__())</span><br><span class="line">print(count.__next__())</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">6</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">2</span><br></pre></td></tr></table></figure>

<h5 id="close"><a href="#close" class="headerlink" title="close"></a>close</h5><p>帮助文档：<code>&#39;&#39;&#39;Raises new GeneratorExit exception inside the generator to terminate the iteration.&#39;&#39;&#39;</code></p>
<p>手动关闭生成器函数，后面的调用会直接返回StopIteration异常</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def gene():</span><br><span class="line">...   while True:</span><br><span class="line">...     yield &#x27;ok&#x27;</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; g = gene()</span><br><span class="line">&gt;&gt;&gt; g.__next__()</span><br><span class="line">&#x27;ok&#x27;</span><br><span class="line">&gt;&gt;&gt; g.__next__()</span><br><span class="line">&#x27;ok&#x27;</span><br><span class="line">&gt;&gt;&gt; g.close()</span><br><span class="line">&gt;&gt;&gt; g.__next__()</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">StopIteration</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>在close以后再执行<code>__next__</code>会触发StopIteration异常</p>
<h5 id="throw"><a href="#throw" class="headerlink" title="throw"></a>throw</h5><p>用来向生成器函数送入一个异常，throw()后直接抛出异常并结束程序，或者消耗掉一个yield，或者在没有下一个yield的时候直接进行到程序的结尾。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def gene():</span><br><span class="line">...   while True:</span><br><span class="line">...     try:</span><br><span class="line">...       yield &#x27;normal value&#x27;</span><br><span class="line">...     except ValueError:</span><br><span class="line">...       yield &#x27;we got ValueError here&#x27;</span><br><span class="line">...     except TypeError:</span><br><span class="line">...       break</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; g = gene()</span><br><span class="line">&gt;&gt;&gt; print(g.__next__())</span><br><span class="line">normal value</span><br><span class="line">&gt;&gt;&gt; print(g.__next__())</span><br><span class="line">normal value</span><br><span class="line">&gt;&gt;&gt; print(g.throw(ValueError))</span><br><span class="line">we got ValueError here</span><br><span class="line">&gt;&gt;&gt; print(g.__next__())</span><br><span class="line">normal value</span><br><span class="line">&gt;&gt;&gt; print(g.throw(TypeError))</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">StopIteration</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<h4 id="通过yield实现单线程情况下的异步并发效果"><a href="#通过yield实现单线程情况下的异步并发效果" class="headerlink" title="通过yield实现单线程情况下的异步并发效果"></a>通过yield实现单线程情况下的异步并发效果</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">def consumer(name):</span><br><span class="line">    print(&#x27;%s准备吃包子了&#x27; % name)</span><br><span class="line">    while True:</span><br><span class="line">        baozi_name = yield</span><br><span class="line">        print(&#x27;[%s]来了，被[%s]吃了&#x27;% (baozi_name, name))</span><br><span class="line"></span><br><span class="line">def producer(*name):</span><br><span class="line">    c1 = consumer(name[0])</span><br><span class="line">    c2 = consumer(name[1])</span><br><span class="line">    c1.__next__()</span><br><span class="line">    c2.__next__()</span><br><span class="line">    for times in range(5):</span><br><span class="line">        print(&#x27;做了两个包子&#x27;)</span><br><span class="line">        c1.send(&#x27;豆沙包%s&#x27;%times)</span><br><span class="line">        c2.send(&#x27;菜包%s&#x27;%times)</span><br><span class="line"></span><br><span class="line">producer(&#x27;winter&#x27;, &#x27;elly&#x27;)</span><br></pre></td></tr></table></figure>
<p>效果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">winter准备吃包子了</span><br><span class="line">elly准备吃包子了</span><br><span class="line">做了两个包子</span><br><span class="line">[豆沙包0]来了，被[winter]吃了</span><br><span class="line">[菜包0]来了，被[elly]吃了</span><br><span class="line">做了两个包子</span><br><span class="line">[豆沙包1]来了，被[winter]吃了</span><br><span class="line">[菜包1]来了，被[elly]吃了</span><br><span class="line">做了两个包子</span><br><span class="line">[豆沙包2]来了，被[winter]吃了</span><br><span class="line">[菜包2]来了，被[elly]吃了</span><br><span class="line">做了两个包子</span><br><span class="line">[豆沙包3]来了，被[winter]吃了</span><br><span class="line">[菜包3]来了，被[elly]吃了</span><br><span class="line">做了两个包子</span><br><span class="line">[豆沙包4]来了，被[winter]吃了</span><br><span class="line">[菜包4]来了，被[elly]吃了</span><br></pre></td></tr></table></figure>

<p>创建了两个独立的生成器，很有趣，很吊；</p>
<h4 id="补充几个小例子："><a href="#补充几个小例子：" class="headerlink" title="补充几个小例子："></a>补充几个小例子：</h4><h5 id="使用生成器创建一个range"><a href="#使用生成器创建一个range" class="headerlink" title="使用生成器创建一个range"></a>使用生成器创建一个range</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def range(n):</span><br><span class="line">    count = 0</span><br><span class="line">    while count &lt; n:</span><br><span class="line">        yield count</span><br><span class="line">        count += 1</span><br></pre></td></tr></table></figure>

<h5 id="使用生成器监听文件输入"><a href="#使用生成器监听文件输入" class="headerlink" title="使用生成器监听文件输入"></a>使用生成器监听文件输入</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def fileTail(filename):</span><br><span class="line">    with open(filename) as f:</span><br><span class="line">        while True:</span><br><span class="line">            tail = f.readline()</span><br><span class="line">            if line:</span><br><span class="line">                yield tail</span><br><span class="line">            else:</span><br><span class="line">                time.sleep(0.1)</span><br></pre></td></tr></table></figure>

<h5 id="计算移动平均值"><a href="#计算移动平均值" class="headerlink" title="计算移动平均值"></a>计算移动平均值</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def averager(start_with = 0):</span><br><span class="line">    count = 0</span><br><span class="line">    aver = start_with</span><br><span class="line">    total = start_with</span><br><span class="line">    while True:</span><br><span class="line">        val = yield aver</span><br><span class="line">        total += val</span><br><span class="line">        count += 1</span><br><span class="line">        aver = total/count</span><br></pre></td></tr></table></figure>
<p>有个弊端，需要通过<code>__next__</code>或<code>next()</code>初始化一次，通过预激解决</p>
<h5 id="预激计算移动平均值"><a href="#预激计算移动平均值" class="headerlink" title="预激计算移动平均值"></a>预激计算移动平均值</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">def init(f):</span><br><span class="line">    def wrapper(start_with = 0):</span><br><span class="line">        g_aver = f(start_with)</span><br><span class="line">        g_aver.__next__()</span><br><span class="line">        return g_aver</span><br><span class="line">    return wrapper</span><br><span class="line"></span><br><span class="line">@init</span><br><span class="line">def averager(start_with = 0):</span><br><span class="line">    count = 0</span><br><span class="line">    aver = start_with</span><br><span class="line">    total = start_with</span><br><span class="line">    while True:</span><br><span class="line">        val = yield aver</span><br><span class="line">        total += val</span><br><span class="line">        count += 1</span><br><span class="line">        aver = total/count</span><br></pre></td></tr></table></figure>

<h5 id="读取文件字符数最多的行的字符数"><a href="#读取文件字符数最多的行的字符数" class="headerlink" title="读取文件字符数最多的行的字符数"></a>读取文件字符数最多的行的字符数</h5><p>最传统的写法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def longestLine(filename):</span><br><span class="line">    with open(filename, &#x27;r&#x27;, encoding=&#x27;utf-8&#x27;) as f:</span><br><span class="line">        alllines = [len(x.strip()) for x in f]</span><br><span class="line">        return max(alllines)</span><br></pre></td></tr></table></figure>
<p>使用生成器以后的写法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def longestLine(filename):</span><br><span class="line">    return max(len(x.strip()) for x in open(filename))</span><br></pre></td></tr></table></figure>

<h5 id="多生成器迭代"><a href="#多生成器迭代" class="headerlink" title="多生成器迭代"></a>多生成器迭代</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; g = (i for i in range(5))</span><br><span class="line">&gt;&gt;&gt; for j in g:</span><br><span class="line">...   print(j)</span><br><span class="line">...</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">&gt;&gt;&gt; for j in g:</span><br><span class="line">...   print(j)</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>因为for j in g， 每次循环执行一次g.<strong>next</strong>()；直到结束，触发StopIteration；</p>
<p>主意下面结果的输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; g = (i for i in range(4))</span><br><span class="line">&gt;&gt;&gt; g1 = (x for x in g)</span><br><span class="line">&gt;&gt;&gt; g2 = (y for y in g1)</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">&gt;&gt;&gt; print(list(g1))</span><br><span class="line">[0, 1, 2, 3]</span><br><span class="line">&gt;&gt;&gt; print(list(g2))</span><br><span class="line">[]</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>为什么print(list(g2))为空呢？理一下，不然会乱：</p>
<p>看下面的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">def g():</span><br><span class="line">    print(&#x27;1.1&#x27;)</span><br><span class="line">    for i in range(2):</span><br><span class="line">        print(&#x27;1.2&#x27;)</span><br><span class="line">        yield i</span><br><span class="line">        print(&#x27;1.3&#x27;)</span><br><span class="line"></span><br><span class="line">def g1():</span><br><span class="line">    print(&#x27;2.1&#x27;)</span><br><span class="line">    for x in s:</span><br><span class="line">        print(&#x27;2.2&#x27;)</span><br><span class="line">        yield x</span><br><span class="line">        print(&#x27;2.3&#x27;)</span><br><span class="line"></span><br><span class="line">def g2():</span><br><span class="line">    print(&#x27;3.1&#x27;)</span><br><span class="line">    for y in s1:</span><br><span class="line">        print(&#x27;3.2&#x27;)</span><br><span class="line">        yield y</span><br><span class="line">        print(&#x27;3.3&#x27;)</span><br><span class="line"></span><br><span class="line">s = g()</span><br><span class="line">s1 = g1()</span><br><span class="line">s2 = g2()</span><br><span class="line">print(&#x27;start first list&#x27;)</span><br><span class="line">print(list(s1))</span><br><span class="line">print(&#x27;start second list&#x27;)</span><br><span class="line">print(list(s2))</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">start first list</span><br><span class="line">2.1</span><br><span class="line">1.1</span><br><span class="line">1.2</span><br><span class="line">2.2</span><br><span class="line">2.3</span><br><span class="line">1.3</span><br><span class="line">1.2</span><br><span class="line">2.2</span><br><span class="line">2.3</span><br><span class="line">1.3</span><br><span class="line">[0, 1]</span><br><span class="line">start second list</span><br><span class="line">3.1</span><br><span class="line">[]</span><br></pre></td></tr></table></figure>
<p>注意第11行之后，g触发了StopIteration，被<code>for x in s</code>捕捉，即不能继续<code>s.__next__()</code>了；同样的g1触发StopIteration，被list捕捉，即不能继续<code>s1.__next__()</code>了；于是打印[0,1]</p>
<p>当进行<code>print(list(s2))</code>时，执行<code>s2.__next__()</code>，停留在代码的第17行for y in s1，但是这是不能继续<code>s1.__next__()</code>了；于是直接触发了StopIteration；结果为[]</p>
<p>再看一个有意思的输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def add(n,i):</span><br><span class="line">    return n+i</span><br><span class="line"></span><br><span class="line">g = (i for i in range(4))</span><br><span class="line"></span><br><span class="line">for n in [1,10]:</span><br><span class="line">    g = (add(n,i) for i in g)</span><br><span class="line"></span><br><span class="line">print(list(g))</span><br></pre></td></tr></table></figure>
<p>输出为：<code>[20, 21, 22, 23]</code></p>
<p>其实上面的代码翻译如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">def add(n,i):</span><br><span class="line">    return n+i</span><br><span class="line"></span><br><span class="line">def g1():</span><br><span class="line">    for i in g:</span><br><span class="line">        yield add(n,i)</span><br><span class="line"></span><br><span class="line">def g2():</span><br><span class="line">    for i in s1:</span><br><span class="line">        yield add(n,i)</span><br><span class="line"></span><br><span class="line">n = 1</span><br><span class="line">s1 = g1()</span><br><span class="line">n = 10</span><br><span class="line">s2 = g2()</span><br><span class="line">print(list(s2))</span><br></pre></td></tr></table></figure>
<p>最终n用的是10,</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wetts.github.io/2019/07/06/%E8%AF%AD%E8%A8%80/Python/%E5%AF%B9%E8%B1%A1/Python%E4%B8%AD%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Zhang Wetts">
      <meta itemprop="description" content="Stay Hungry, Stay Foolish. <br><br><p style="font-size:8px;">[build by hexo/next/gitalk/hexo-generator-search/LaTeX]</p>">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wetts's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/07/06/%E8%AF%AD%E8%A8%80/Python/%E5%AF%B9%E8%B1%A1/Python%E4%B8%AD%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%99%A8/" class="post-title-link" itemprop="url">Python中的迭代器</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-07-06 11:22:32" itemprop="dateCreated datePublished" datetime="2019-07-06T11:22:32+08:00">2019-07-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-08-18 23:43:34" itemprop="dateModified" datetime="2019-08-18T23:43:34+08:00">2019-08-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Python/" itemprop="url" rel="index"><span itemprop="name">Python</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>转自：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/deeper/p/7565571.html">https://www.cnblogs.com/deeper/p/7565571.html</a></p>
<p>迭代器是访问集合元素的一种方式。迭代器对象从集合的第一个元素开始访问，直到所有的元素被访问完结束。迭代器只能往前不会后退，不过这也没什么，因为人们很少在迭代途中往后退。另外，迭代器的一大优点是不要求事先准备好整个迭代过程中所有的元素。迭代器仅仅在迭代到某个元素时才计算该元素，而在这之前或之后，元素可以不存在或者被销毁。这个特点使得它特别适合用于遍历一些巨大的或是无限的集合，比如几个G的文件。</p>
<p>特点：</p>
<ol>
<li>访问者不需要关心迭代器内部的结构，仅需通过next()方法或不断去取下一个内容</li>
<li>不能随机访问集合中的某个值 ，只能从头到尾依次访问</li>
<li>访问到一半时不能往回退</li>
<li>便于循环比较大的数据集合，节省内存</li>
<li>也不能复制一个迭代器。如果要再次（或者同时）迭代同一个对象，只能去创建另一个迭代器对象。enumerate()的返回值就是一个迭代器，我们以enumerate为例：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = enumerate([&#x27;a&#x27;,&#x27;b&#x27;])</span><br><span class="line"></span><br><span class="line">for i in range(2):    #迭代两次enumerate对象</span><br><span class="line">     for x, y in a:</span><br><span class="line">         print(x,y)</span><br><span class="line">     print(&#x27;&#x27;.center(50,&#x27;-&#x27;)) </span><br></pre></td></tr></table></figure>
结果：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0 a</span><br><span class="line">1 b</span><br><span class="line">--------------------------------------------------</span><br><span class="line">--------------------------------------------------</span><br></pre></td></tr></table></figure></li>
</ol>
<p>可以看到再次迭代enumerate对象时，没有返回值；</p>
<p>我们可以用linux的文件处理命令vim和cat来理解一下：</p>
<ol>
<li>读取很大的文件时，vim需要很久，cat是毫秒级；因为vim是一次性把文件全部加载到内存中读取；而cat是加载一行显示一行</li>
<li>vim读写文件时可以前进，后退，可以跳转到任意一行；而cat只能向下翻页，不能倒退，不能直接跳转到文件的某一页（因为读取的时候这个“某一页“可能还没有加载到内存中）</li>
</ol>
<p>正式进入python迭代器之前，我们先要区分两个容易混淆的概念：可迭代对象和迭代器；</p>
<ul>
<li>可以直接作用于for循环的对象统称为 __可迭代对象(Iterable)__。</li>
<li>可以被next()函数调用并不断返回下一个值的对象称为 __迭代器(Iterator)__。</li>
</ul>
<p>所有的Iterable均可以通过内置函数iter()来转变为Iterator。</p>
<h4 id="可迭代对象"><a href="#可迭代对象" class="headerlink" title="可迭代对象"></a>可迭代对象</h4><p>首先，可迭代对象是一个对象，不是一个函数；是一个什么样的对象呢？就是只要它定义了可以返回一个迭代器的<code>__iter__</code>方法，或者定义了可以支持下标索引的<code>__getitem__</code>方法，那么它就是一个可迭代对象。</p>
<p>python中大部分对象都是可迭代的，比如list，tuple等。如果给一个准确的定义的话，看一下list，tuple类的源码，都有<code>__iter__(self)</code>方法。</p>
<p>常见的可迭代对象：</p>
<ol>
<li>集合数据类型，如list、tuple、dict、set、str等；</li>
<li>generator，包括生成器和带yield的generator function。</li>
</ol>
<p>注意：生成器都是Iterator对象，但list、dict、str虽然是Iterable，却不是Iterator</p>
<p>如何判断一个对象是可迭代对象呢？可以通过collections模块的Iterable类型判断：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from collections import Iterable</span><br><span class="line">&gt;&gt;&gt; isinstance([], Iterable)</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; isinstance(&#123;&#125;, Iterable)</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; isinstance(&#x27;abc&#x27;, Iterable)</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; isinstance((x for x in range(10)), Iterable)</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; isinstance(100, Iterable)</span><br><span class="line">False</span><br></pre></td></tr></table></figure>

<h4 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h4><p>一个可迭代对象是不能独立进行迭代的，Python中，迭代是通过for … in来完成的。</p>
<p>for循环在迭代一个可迭代对象的过程中都做了什么呢？</p>
<ol>
<li>当for循环迭代一个可迭代对象时，首先会调用可迭代对象的<code>__iter__()</code>方法，然我们看看源码中关于list类的<code>__iter__()</code>方法的定义：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def __iter__(self, *args, **kwargs): # real signature unknown</span><br><span class="line">    &quot;&quot;&quot; Implement iter(self). &quot;&quot;&quot;</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure>
<code>__iter__()</code>方法调用了<code>iter(self)</code>函数，我们再来看一下iter()函数的定义：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">def iter(source, sentinel=None): # known special case of iter</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    iter(iterable) -&gt; iterator</span><br><span class="line">    iter(callable, sentinel) -&gt; iterator</span><br><span class="line">    </span><br><span class="line">    Get an iterator from an object.  In the first form, the argument must</span><br><span class="line">    supply its own iterator, or be a sequence.</span><br><span class="line">    In the second form, the callable is called until it returns the sentinel.</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure>
<p><code>iter()</code>函数的参数是一个可迭代对象，最终返回一个迭代器</p>
<ol start="2">
<li>for循环会不断调用迭代器对象的<code>__next__()</code>方法(python2.x中是next()方法)，每次循环，都返回迭代器对象的下一个值，直到遇到StopIteration异常。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; lst_iter = iter([1,2,3])</span><br><span class="line">&gt;&gt;&gt; lst_iter.__next__()</span><br><span class="line">1</span><br><span class="line">&gt;&gt;&gt; lst_iter.__next__()</span><br><span class="line">2</span><br><span class="line">&gt;&gt;&gt; lst_iter.__next__()</span><br><span class="line">3</span><br><span class="line">&gt;&gt;&gt; lst_iter.__next__()</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">StopIteration</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>这里注意：这里的<code>__next__()</code>方法和内置函数<code>next(iterator, default=None)</code>不是一个东西；(内置函数<code>next(iterator, default=None)</code>也可以返回迭代器的下一个值）</p>
<ol start="3">
<li>而for循环可以捕获StopIteration异常并结束循环；</li>
</ol>
<p>总结一下：</p>
<ol>
<li>for….in iterable，会通过调用<code>iter(iterable)</code>函数（实际上，首先调用的对象的<code>__iter__()</code>方法），返回一个迭代器iterator;</li>
<li>每次循环，调用一次对象的<code>__next__(self)</code>，直到最后一个值，再次调用会触发StopIteration</li>
<li>for循环捕捉到StopIteration，从而结束循环</li>
</ol>
<p>上面说了这么多，到底什么是迭代器Iterator呢？</p>
<p>任何实现了<code>__iter__</code>和<code>__next__()</code>（python2中实现<code>next()</code>）方法的对象都是迭代器，<code>__iter__</code>返回迭代器自身，<code>__next__</code>返回容器中的下一个值；</p>
<p>既然知道了什么迭代器，那我们自定义一个迭代器玩玩：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Iterator_test(object):</span><br><span class="line">    def __init__(self, data):</span><br><span class="line">        self.data = data</span><br><span class="line">        self.index = len(data)</span><br><span class="line"></span><br><span class="line">    def __iter__(self):</span><br><span class="line">        return self</span><br><span class="line"></span><br><span class="line">    def __next__(self):</span><br><span class="line">        if self.index &lt;= 0 :</span><br><span class="line">            raise StopIteration</span><br><span class="line">        self.index -= 1</span><br><span class="line">        return self.data[self.index]</span><br><span class="line"></span><br><span class="line">iterator_winter = Iterator_test(&#x27;abcde&#x27;)</span><br><span class="line"></span><br><span class="line">for item in iterator_winter:</span><br><span class="line">    print(item)</span><br></pre></td></tr></table></figure>
<p>如何判断一个对象是一个迭代器对象呢？两个方法：</p>
<ol>
<li>通过内置函数next(iterator, default=None)，可以看到next的第一个参数必须是迭代器；所以迭代器也可以认为是可以被next()函数调用的对象</li>
<li>通过collection中的Iterator类型判断<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from collections import Iterator</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">&gt;&gt;&gt; isinstance([1,2,3], Iterator)</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; isinstance(iter([1,2,3]), Iterator)</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; isinstance([1,2,3].__iter__(), Iterator)</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>这里大家会不会有个疑问：</p>
<p>对于迭代器而言，看上去作用的不就是<code>__next__</code>方法嘛，<code>__iter__</code>好像没什么卵用，干嘛还需要<code>__iter__</code>方法呢？</p>
<p>我们知道，python中迭代是通过for循环实现的，而for循环的循环对象必须是一个可迭代对象Iterable，而Iterable必须是一个实现了__iter__方法的对象；知道为什么需要<code>__iter__</code>魔术方法了吧；</p>
<p>那么我就是想自定义一个没有实现<code>__iter__</code>方法的迭代器可以吗？可以，像下面这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Iterable_test(object):</span><br><span class="line">    def __init__(self, data):</span><br><span class="line">        self.data = data</span><br><span class="line"></span><br><span class="line">    def __iter__(self):</span><br><span class="line">        return Iterator_test(self.data)</span><br><span class="line"></span><br><span class="line">class Iterator_test(object):</span><br><span class="line">    def __init__(self, data):</span><br><span class="line">        self.data = data</span><br><span class="line">        self.index = len(data)</span><br><span class="line"></span><br><span class="line">    def __next__(self):</span><br><span class="line">        if self.index &lt;= 0 :</span><br><span class="line">            raise StopIteration</span><br><span class="line">        self.index -= 1</span><br><span class="line">        return self.data[self.index]</span><br><span class="line"></span><br><span class="line">iterator_winter = Iterable_test(&#x27;abcde&#x27;)</span><br><span class="line"></span><br><span class="line">for item in iterator_winter:</span><br><span class="line">    print(item)</span><br></pre></td></tr></table></figure>

<p>先定义一个可迭代对象（包含<code>__iter__</code>方法），然后该对象返回一个迭代器；这样看上去是不是很麻烦？是不是同时带有<code>__iter__</code>和<code>__next__</code>魔术方法的迭代器更好呢！</p>
<p>同时，这里要纠正之前的一个迭代器概念：只要<code>__next__()</code>（python2中实现next()）方法的对象都是迭代器；</p>
<p>既然这样，只需要迭代器Iterator接口就够了，为什么还要设计可迭代对象Iterable呢？</p>
<p>这个和迭代器不能重复使用有关，下面统一讲解：</p>
<h4 id="总结和一些重要知识点"><a href="#总结和一些重要知识点" class="headerlink" title="总结和一些重要知识点"></a>总结和一些重要知识点</h4><h5 id="如何复制迭代器"><a href="#如何复制迭代器" class="headerlink" title="如何复制迭代器"></a>如何复制迭代器</h5><p>之前在使用enumerate时，我们说过enumerate对象通过for循环迭代一次后就不能再被迭代：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; e = enumerate([1,2,3])</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">&gt;&gt;&gt; for x,y in e:</span><br><span class="line">...   print(x,y)</span><br><span class="line">...</span><br><span class="line">0 1</span><br><span class="line">1 2</span><br><span class="line">2 3</span><br><span class="line">&gt;&gt;&gt; for x,y in e:</span><br><span class="line">...   print(x,y)</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>这是因为enumerate是一个迭代器；</p>
<p>迭代器是一次性消耗品，当循环以后就空了。不能再次使用；通过深拷贝可以解决；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import copy</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">&gt;&gt;&gt; e = enumerate([1,2,3])</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">&gt;&gt;&gt; e_deepcopy = copy.deepcopy(e)</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">&gt;&gt;&gt; for x,y in e:</span><br><span class="line">...   print(x,y)</span><br><span class="line">...</span><br><span class="line">0 1</span><br><span class="line">1 2</span><br><span class="line">2 3</span><br><span class="line">&gt;&gt;&gt; for x,y in e_deepcopy:</span><br><span class="line">...   print(x,y)</span><br><span class="line">...</span><br><span class="line">0 1</span><br><span class="line">1 2</span><br><span class="line">2 3</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<h5 id="为什么不只保留Iterator的接口而还需要设计Iterable呢？"><a href="#为什么不只保留Iterator的接口而还需要设计Iterable呢？" class="headerlink" title="为什么不只保留Iterator的接口而还需要设计Iterable呢？"></a>为什么不只保留Iterator的接口而还需要设计Iterable呢？</h5><p>因为迭代器迭代一次以后就空了，那么如果list，dict也是一个迭代器，迭代一次就不能再继续被迭代了，这显然是反人类的；所以通过<code>__iter__</code>每次返回一个独立的迭代器，就可以保证不同的迭代过程不会互相影响。而生成器表达式之类的结果往往是一次性的，不可以重复遍历，所以直接返回一个Iterator就好。让Iterator也实现Iterable的兼容就可以很灵活地选择返回哪一种。</p>
<p>总结说，Iterator实现的<code>__iter__</code>是为了兼容Iterable的接口，从而让Iterator成为Iterable的一种实现。</p>
<p>另外，迭代器是惰性的，只有在需要返回下一个数据时它才会计算。就像一个懒加载的工厂，等到有人需要的时候才给它生成值返回，没调用的时候就处于休眠状态等待下一次调用。所以，Iterator甚至可以表示一个无限大的数据流，例如全体自然数。而使用list是永远不可能存储全体自然数的。</p>
<h5 id="通过-getitem-来实现for循环"><a href="#通过-getitem-来实现for循环" class="headerlink" title="通过__getitem__来实现for循环"></a>通过<code>__getitem__</code>来实现for循环</h5><p>前面关于可迭代对象的定义是这样的：定义了可以返回一个迭代器的<code>__iter__</code>方法，或者定义了可以支持下标索引的<code>__getitem__</code>方法，那么它就是一个可迭代对象。</p>
<p>但是如果对象没有<code>__iter__</code>，但是实现了<code>__getitem__</code>，会改用下标迭代的方式。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class NoIterable(object):</span><br><span class="line">    def __init__(self, data):</span><br><span class="line">        self.data = data</span><br><span class="line">    def __getitem__(self, item):</span><br><span class="line">        return self.data[item]</span><br><span class="line"></span><br><span class="line">no_iter = NoIterable(&#x27;abcde&#x27;)</span><br><span class="line">for item in no_iter:</span><br><span class="line">    print(item)</span><br></pre></td></tr></table></figure>
<p>当for发现没有<code>__iter__</code>但是有<code>__getitem__</code>的时候，会从0开始依次读取相应的下标，直到发生IndexError为止，这是一种旧的迭代方法。iter方法也会处理这种情况，在不存在<code>__iter__</code>的时候，返回一个下标迭代的iterator对象来代替。</p>
<h4 id="一张图总结迭代器"><a href="#一张图总结迭代器" class="headerlink" title="一张图总结迭代器"></a>一张图总结迭代器</h4><p><img src="/2019/07/06/%E8%AF%AD%E8%A8%80/Python/%E5%AF%B9%E8%B1%A1/Python%E4%B8%AD%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%99%A8/1.png" alt="迭代器"></p>
<h4 id="使用迭代器来实现一个斐波那契数列"><a href="#使用迭代器来实现一个斐波那契数列" class="headerlink" title="使用迭代器来实现一个斐波那契数列"></a>使用迭代器来实现一个斐波那契数列</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Fib(object):</span><br><span class="line">    def __init__(self, limit):</span><br><span class="line">        self.a, self.b = 0, 1</span><br><span class="line">        self.limit = limit</span><br><span class="line"></span><br><span class="line">    def __iter__(self):</span><br><span class="line">        return self</span><br><span class="line"></span><br><span class="line">    def __next__(self):</span><br><span class="line">        self.a, self.b = self.b, self.a+self.b</span><br><span class="line">        while self.a &gt; self.limit:</span><br><span class="line">            raise StopIteration</span><br><span class="line">        return self.a</span><br><span class="line"></span><br><span class="line">for n in Fib(1000):</span><br><span class="line">    print(n)</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wetts.github.io/2019/07/06/%E8%AF%AD%E8%A8%80/Python/%E5%85%B6%E4%BB%96/Python-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3yield/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Zhang Wetts">
      <meta itemprop="description" content="Stay Hungry, Stay Foolish. <br><br><p style="font-size:8px;">[build by hexo/next/gitalk/hexo-generator-search/LaTeX]</p>">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wetts's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/07/06/%E8%AF%AD%E8%A8%80/Python/%E5%85%B6%E4%BB%96/Python-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3yield/" class="post-title-link" itemprop="url">Python-深入理解yield</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-07-06 10:41:43" itemprop="dateCreated datePublished" datetime="2019-07-06T10:41:43+08:00">2019-07-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-10-11 21:21:33" itemprop="dateModified" datetime="2019-10-11T21:21:33+08:00">2019-10-11</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Python/" itemprop="url" rel="index"><span itemprop="name">Python</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>转自：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/coderzh/articles/1202040.html">https://www.cnblogs.com/coderzh/articles/1202040.html</a></p>
<p>yield的英文单词意思是生产，刚接触Python的时候感到非常困惑，一直没弄明白yield的用法。只是粗略的知道yield可以用来为一个函数返回值塞数据，比如下面的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def addlist(alist):</span><br><span class="line">    for i in alist:</span><br><span class="line">        yield i + 1</span><br></pre></td></tr></table></figure>
<p>取出alist的每一项，然后把i + 1塞进去。然后通过调用取出每一项：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">alist = [1, 2, 3, 4]</span><br><span class="line">for x in addlist(alist):</span><br><span class="line">    print x,</span><br></pre></td></tr></table></figure>
<p>这的确是yield应用的一个例子。</p>
<h3 id="包含yield的函数"><a href="#包含yield的函数" class="headerlink" title="包含yield的函数"></a>包含yield的函数</h3><p>假如你看到某个函数包含了yield，这意味着这个函数已经是一个Generator，它的执行会和其他普通的函数有很多不同。比如下面的简单的函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def h():</span><br><span class="line">    print &#x27;To be brave&#x27;</span><br><span class="line">    yield 5</span><br><span class="line"></span><br><span class="line">h()</span><br></pre></td></tr></table></figure>
<p>可以看到，调用h()之后，print 语句并没有执行！这就是yield，那么，如何让print 语句执行呢？这就是后面要讨论的问题，通过后面的讨论和学习，就会明白yield的工作原理了。</p>
<h3 id="yield是一个表达式"><a href="#yield是一个表达式" class="headerlink" title="yield是一个表达式"></a>yield是一个表达式</h3><p>Python2.5以前，yield是一个语句，但现在2.5中，yield是一个表达式(Expression)，比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m = yield 5</span><br></pre></td></tr></table></figure>
<p>表达式(yield 5)的返回值将赋值给m，所以，认为 m = 5 是错误的。那么如何获取(yield 5)的返回值呢？需要用到后面要介绍的send(msg)方法。</p>
<h3 id="透过next-语句看原理"><a href="#透过next-语句看原理" class="headerlink" title="透过next()语句看原理"></a>透过next()语句看原理</h3><p>现在，我们来揭晓yield的工作原理。我们知道，我们上面的h()被调用后并没有执行，因为它有yield表达式，因此，我们通过next()语句让它执行。next()语句将恢复Generator执行，并直到下一个yield表达式处。比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def h():</span><br><span class="line">    print &#x27;Wen Chuan&#x27;</span><br><span class="line">    yield 5</span><br><span class="line">    print &#x27;Fighting!&#x27;</span><br><span class="line"></span><br><span class="line">c = h()</span><br><span class="line">c.next()</span><br></pre></td></tr></table></figure>
<p>c.next()调用后，h()开始执行，直到遇到yield 5，因此输出结果：<code>Wen Chuan</code></p>
<p>当我们再次调用c.next()时，会继续执行，直到找到下一个yield表达式。由于后面没有yield了，因此会拋出异常：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Wen Chuan</span><br><span class="line">Fighting!</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;/home/evergreen/Codes/yidld.py&quot;, line 11, in &lt;module&gt;</span><br><span class="line">    c.next()</span><br><span class="line">StopIteration</span><br></pre></td></tr></table></figure>

<h3 id="send-msg-与-next"><a href="#send-msg-与-next" class="headerlink" title="send(msg) 与 next()"></a>send(msg) 与 next()</h3><p>了解了next()如何让包含yield的函数执行后，我们再来看另外一个非常重要的函数send(msg)。其实next()和send()在一定意义上作用是相似的，区别是send()可以传递yield表达式的值进去，而next()不能传递特定的值，只能传递None进去。因此，我们可以看做</p>
<p>c.next() 和 c.send(None) 作用是一样的。</p>
<p>来看这个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">def h():</span><br><span class="line">    print &#x27;Wen Chuan&#x27;,</span><br><span class="line">    m = yield 5  # Fighting!</span><br><span class="line">    print m</span><br><span class="line">    d = yield 12</span><br><span class="line">    print &#x27;We are together!&#x27;</span><br><span class="line"></span><br><span class="line">c = h()</span><br><span class="line">c.next()  #相当于c.send(None)</span><br><span class="line">c.send(&#x27;Fighting!&#x27;)  #(yield 5)表达式被赋予了&#x27;Fighting!&#x27;</span><br></pre></td></tr></table></figure>

<p>输出的结果为：<code>Wen Chuan Fighting!</code></p>
<p>需要提醒的是，第一次调用时，请使用next()语句或是send(None)，不能使用send发送一个非None的值，否则会出错的，因为没有yield语句来接收这个值。</p>
<h3 id="send-msg-与-next-的返回值"><a href="#send-msg-与-next-的返回值" class="headerlink" title="send(msg) 与 next()的返回值"></a>send(msg) 与 next()的返回值</h3><p>send(msg) 和 next()是有返回值的，它们的返回值很特殊，返回的是下一个yield表达式的参数。比如yield 5，则返回 5 。到这里，是不是明白了一些什么东西？本文第一个例子中，通过for i in alist 遍历 Generator，其实是每次都调用了alist.Next()，而每次alist.Next()的返回值正是yield的参数，即我们开始认为被压进去的东东。我们再延续上面的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">def h():</span><br><span class="line">    print &#x27;Wen Chuan&#x27;,</span><br><span class="line">    m = yield 5  # Fighting!</span><br><span class="line">    print m</span><br><span class="line">    d = yield 12</span><br><span class="line">    print &#x27;We are together!&#x27;</span><br><span class="line"></span><br><span class="line">c = h()</span><br><span class="line">m = c.next()  #m 获取了yield 5 的参数值 5</span><br><span class="line">d = c.send(&#x27;Fighting!&#x27;)  #d 获取了yield 12 的参数值12</span><br><span class="line">print &#x27;We will never forget the date&#x27;, m, &#x27;.&#x27;, d</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Wen Chuan Fighting!</span><br><span class="line">We will never forget the date 5 . 12</span><br></pre></td></tr></table></figure>

<h3 id="throw-与-close-中断-Generator"><a href="#throw-与-close-中断-Generator" class="headerlink" title="throw() 与 close()中断 Generator"></a>throw() 与 close()中断 Generator</h3><p>中断Generator是一个非常灵活的技巧，可以通过throw抛出一个GeneratorExit异常来终止Generator。Close()方法作用是一样的，其实内部它是调用了throw(GeneratorExit)的。我们看：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def close(self):</span><br><span class="line">    try:</span><br><span class="line">        self.throw(GeneratorExit)</span><br><span class="line">    except (GeneratorExit, StopIteration):</span><br><span class="line">        pass</span><br><span class="line">    else:</span><br><span class="line">        raise RuntimeError(&quot;generator ignored GeneratorExit&quot;)</span><br><span class="line"># Other exceptions are not caught</span><br></pre></td></tr></table></figure>
<p>因此，当我们调用了close()方法后，再调用next()或是send(msg)的话会抛出一个异常：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;/home/evergreen/Codes/yidld.py&quot;, line 14, in &lt;module&gt;</span><br><span class="line">    d = c.send(&#x27;Fighting!&#x27;)  #d 获取了yield 12 的参数值12</span><br><span class="line">StopIteration</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wetts.github.io/2019/07/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C%E4%B8%8E%E9%80%9A%E4%BF%A1/TCP%E3%80%81UDP%E7%BB%91%E5%AE%9A%E5%90%8C%E4%B8%80%E7%AB%AF%E5%8F%A3%E9%80%9A%E4%BF%A1%E7%9A%84%E8%A7%A3%E9%87%8A/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Zhang Wetts">
      <meta itemprop="description" content="Stay Hungry, Stay Foolish. <br><br><p style="font-size:8px;">[build by hexo/next/gitalk/hexo-generator-search/LaTeX]</p>">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wetts's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/07/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C%E4%B8%8E%E9%80%9A%E4%BF%A1/TCP%E3%80%81UDP%E7%BB%91%E5%AE%9A%E5%90%8C%E4%B8%80%E7%AB%AF%E5%8F%A3%E9%80%9A%E4%BF%A1%E7%9A%84%E8%A7%A3%E9%87%8A/" class="post-title-link" itemprop="url">TCP、UDP绑定同一端口通信的解释</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2019-07-05 16:24:22 / 修改时间：16:25:49" itemprop="dateCreated datePublished" datetime="2019-07-05T16:24:22+08:00">2019-07-05</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BD%91%E7%BB%9C%E4%B8%8E%E9%80%9A%E4%BF%A1/" itemprop="url" rel="index"><span itemprop="name">网络与通信</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>转自：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/MY0213/p/8798926.html">https://www.cnblogs.com/MY0213/p/8798926.html</a></p>
<p>TCP、UDP可以绑定同一端口来进行通信：</p>
<p>网络中可以被命名和寻址的通信端口，是操作系统可分配的一种资源。 </p>
<p>按照OSI七层协议的描述，传输层与网络层在功能上的最大区别是传输层提供进程通信能力。从这个意义上讲，网络通信的最终地址就不仅仅是主机地址了，还包括可以描述进程的某种标识符。为此，TCP/IP协议提出了协议端口（protocol port，简称端口）的概念，用于标识通信的进程。 </p>
<p>端口是一种抽象的软件结构（包括一些数据结构和I/O缓冲区）。应用程序（即进程）通过系统调用与某端口建立连接（binding）后，传输层传给该端口的数据都被相应进程所接收，相应进程发给传输层的数据都通过该端口输出。在TCP/IP协议的实现中，端口操作类似于一般的I/O操作，进程获取一个端口，相当于获取本地唯一的I/O文件，可以用一般的读写原语访问之。 </p>
<p>类似于文件描述符，每个端口都拥有一个叫端口号（port   number）的整数型标识符，用于区别不同端口。由于TCP/IP传输层的两个协议TCP和UDP是完全独立的两个软件模块，因此各自的端口号也相互独立，如TCP有一个255号端口，UDP也可以有一个255号端口，二者并不冲突。 </p>
<p>端口号的分配是一个重要问题。有两种基本分配方式：第一种叫全局分配，这是一种集中控制方式，由一个公认的中央机构根据用户需要进行统一分配，并将结果公布于众。第二种是本地分配，又称动态连接，即进程需要访问传输层服务时，向本地操作系统提出申请，操作系统返回一个本地唯一的端口号，进程再通过合适的系统调用将自己与该端口号联系起来（绑扎）。TCP/IP端口号的分配中综合了上述两种方式。TCP/IP将端口号分为两部分，少量的作为保留端口，以全局方式分配给服务进程。因此，每一个标准服务器都拥有一个全局公认的端口（即周知口，well-known port），即使在不同机器上，其端口号也相同。剩余的为自由端口，以本地方式进行分配。TCP和UDP均规定，小于256的端口号才能作保留端口。</p>
<p>再讨论一下，一个服务器监控一个端口，比如80端口，它为什么可以建立上成千上万的连接？</p>
<p>首先， 一个TCP连接需要由四元组来形成，即(src_ip,src_port,dst_ip,dst_port)。当一个连接请求过来的时候，服务端调用accept函数，新生成一个socket，这个socket所占用的本地端口依然是80端口。由四元组就很容易分析到了，同一个(src_ip,src_port)，它所对应的(dst_ip,dst_port)可以无穷变化，这样就可以建立很多个客户端的请求了。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wetts.github.io/2019/07/05/%E8%AF%AD%E8%A8%80/Python/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/Python%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%89%8D%E9%9D%A2%E5%8A%A0%E4%B8%8A'r'%E7%9A%84%E4%BD%9C%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Zhang Wetts">
      <meta itemprop="description" content="Stay Hungry, Stay Foolish. <br><br><p style="font-size:8px;">[build by hexo/next/gitalk/hexo-generator-search/LaTeX]</p>">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wetts's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/07/05/%E8%AF%AD%E8%A8%80/Python/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/Python%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%89%8D%E9%9D%A2%E5%8A%A0%E4%B8%8A'r'%E7%9A%84%E4%BD%9C%E7%94%A8/" class="post-title-link" itemprop="url">Python字符串前面加上'r'的作用</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2019-07-05 11:15:44 / 修改时间：11:17:16" itemprop="dateCreated datePublished" datetime="2019-07-05T11:15:44+08:00">2019-07-05</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Python/" itemprop="url" rel="index"><span itemprop="name">Python</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>在 Python 的 string 前面加上 <code>r</code>， 是为了告诉编译器这个 string 是个 raw string，不要转义。</p>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">s=r&#x27;\tt&#x27;</span><br><span class="line">print(s)</span><br><span class="line">Output:</span><br><span class="line">&#x27;\tt&#x27;</span><br><span class="line"> </span><br><span class="line">s=&#x27;\tt&#x27;</span><br><span class="line">print(s)</span><br><span class="line">Output:</span><br><span class="line">&#x27;        t&#x27;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wetts.github.io/2019/07/04/%E8%AF%AD%E8%A8%80/Python/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/Python-dict%E5%92%8Clist%E5%AF%B9%E6%AF%94/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Zhang Wetts">
      <meta itemprop="description" content="Stay Hungry, Stay Foolish. <br><br><p style="font-size:8px;">[build by hexo/next/gitalk/hexo-generator-search/LaTeX]</p>">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wetts's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/07/04/%E8%AF%AD%E8%A8%80/Python/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/Python-dict%E5%92%8Clist%E5%AF%B9%E6%AF%94/" class="post-title-link" itemprop="url">Python-dict和list对比</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-07-04 16:29:48" itemprop="dateCreated datePublished" datetime="2019-07-04T16:29:48+08:00">2019-07-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-10-11 21:22:52" itemprop="dateModified" datetime="2019-10-11T21:22:52+08:00">2019-10-11</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Python/" itemprop="url" rel="index"><span itemprop="name">Python</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>和 list 比较，dict 有以下几个特点：</p>
<ol>
<li>查找和插入的速度极快，不会随着key的增加而变慢；</li>
<li>需要占用大量的内存，内存浪费多。</li>
</ol>
<p>而 list 相反：</p>
<ol>
<li>查找和插入的时间随着元素的增加而增加；</li>
<li>占用空间小，浪费内存很少。</li>
</ol>
<p>所以，dict 是用空间来换取时间的一种方法。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wetts.github.io/2019/07/04/%E8%AF%AD%E8%A8%80/Python/%E6%A8%A1%E5%9D%97/Python%E4%B8%AD%E7%9A%84types%E6%A8%A1%E5%9D%97%E7%9A%84%E5%87%BD%E6%95%B0%E5%B8%B8%E9%87%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Zhang Wetts">
      <meta itemprop="description" content="Stay Hungry, Stay Foolish. <br><br><p style="font-size:8px;">[build by hexo/next/gitalk/hexo-generator-search/LaTeX]</p>">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wetts's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/07/04/%E8%AF%AD%E8%A8%80/Python/%E6%A8%A1%E5%9D%97/Python%E4%B8%AD%E7%9A%84types%E6%A8%A1%E5%9D%97%E7%9A%84%E5%87%BD%E6%95%B0%E5%B8%B8%E9%87%8F/" class="post-title-link" itemprop="url">Python中的types模块的函数常量</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-07-04 11:49:55" itemprop="dateCreated datePublished" datetime="2019-07-04T11:49:55+08:00">2019-07-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-07-05 11:14:22" itemprop="dateModified" datetime="2019-07-05T11:14:22+08:00">2019-07-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Python/" itemprop="url" rel="index"><span itemprop="name">Python</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>types模块中提供了四个常量</p>
<ul>
<li>types.FunctionType：函数</li>
<li>types.BuiltinFunctionType：内建函数</li>
<li>types.LambdaType：匿名函数</li>
<li>types.GeneratorType：生成器类型</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wetts.github.io/2019/07/03/%E8%AF%AD%E8%A8%80/Python/%E5%AF%B9%E8%B1%A1/Python%E4%B8%AD%E7%9A%84Iterable%E5%92%8CIterator/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Zhang Wetts">
      <meta itemprop="description" content="Stay Hungry, Stay Foolish. <br><br><p style="font-size:8px;">[build by hexo/next/gitalk/hexo-generator-search/LaTeX]</p>">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wetts's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/07/03/%E8%AF%AD%E8%A8%80/Python/%E5%AF%B9%E8%B1%A1/Python%E4%B8%AD%E7%9A%84Iterable%E5%92%8CIterator/" class="post-title-link" itemprop="url">Python中的Iterable和Iterator</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-07-03 14:44:20" itemprop="dateCreated datePublished" datetime="2019-07-03T14:44:20+08:00">2019-07-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-07-06 11:39:27" itemprop="dateModified" datetime="2019-07-06T11:39:27+08:00">2019-07-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Python/" itemprop="url" rel="index"><span itemprop="name">Python</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>可使用for进行迭代的数据类型分为以下两种：</p>
<ol>
<li>集合数据类型：如 dict、list、tuple、set、str 等；</li>
<li>generator：包括生成器和 yield 的 generator function;</li>
</ol>
<p>Python 的 Iterator 对象表示的是一个数据流，Iterator 对象可以被 next() 函数调用并不断返回下一个数据，直到没有数据时抛出 StopIteration 错误。可以把这个数据流看做是一个有序序列，但我们却不能提前知道序列的长度，只能不断通过 next() 函数实现按需计算下一个数据，所以 Iterator 的计算是惰性的，只有在需要返回下一个数据时它才会计算。</p>
<p>把 list、dict、str 等 Iterable 变成 Iterator 可以使用 iter() 函数。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/11/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/11/">11</a><span class="page-number current">12</span><a class="page-number" href="/page/13/">13</a><span class="space">&hellip;</span><a class="page-number" href="/page/69/">69</a><a class="extend next" rel="next" href="/page/13/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Zhang Wetts"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">Zhang Wetts</p>
  <div class="site-description" itemprop="description">Stay Hungry, Stay Foolish. <br><br><p style="font-size:8px;">[build by hexo/next/gitalk/hexo-generator-search/LaTeX]</p></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">683</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">63</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">338</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/wetts" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;wetts" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:zhang.wetts@163.com" title="E-Mail → mailto:zhang.wetts@163.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Zhang Wetts</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

  


<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/hibiki.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"react":{"opacity":0.7}});</script></body>
</html>
