<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"wetts.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="Stay Hungry, Stay Foolish. [build by hexo&#x2F;next&#x2F;gitalk&#x2F;hexo-generator-search&#x2F;LaTeX]">
<meta property="og:type" content="website">
<meta property="og:title" content="Wetts&#39;s blog">
<meta property="og:url" content="https://wetts.github.io/page/12/index.html">
<meta property="og:site_name" content="Wetts&#39;s blog">
<meta property="og:description" content="Stay Hungry, Stay Foolish. [build by hexo&#x2F;next&#x2F;gitalk&#x2F;hexo-generator-search&#x2F;LaTeX]">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Zhang Wetts">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://wetts.github.io/page/12/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Wetts's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Wetts's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Stay Hungry, Stay Foolish.</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/wetts" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wetts.github.io/2019/08/17/%E9%98%85%E8%AF%BB/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/%E7%AC%AC3%E7%AB%A0-k%E8%BF%91%E9%82%BB%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Zhang Wetts">
      <meta itemprop="description" content="Stay Hungry, Stay Foolish. <br><br><p style="font-size:8px;">[build by hexo/next/gitalk/hexo-generator-search/LaTeX]</p>">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wetts's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/08/17/%E9%98%85%E8%AF%BB/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/%E7%AC%AC3%E7%AB%A0-k%E8%BF%91%E9%82%BB%E6%B3%95/" class="post-title-link" itemprop="url">统计学系方法-第3章-k近邻法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-08-17 20:11:05" itemprop="dateCreated datePublished" datetime="2019-08-17T20:11:05+08:00">2019-08-17</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">读书笔记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>k 近邻法（k-nearest neighbor, k-NN）是一种基本分类与回归方法。</p>
<h2 id="k-近邻算法"><a href="#k-近邻算法" class="headerlink" title="k 近邻算法"></a>k 近邻算法</h2><p>k 近邻算法简单、直观：给定一个训练数据集，对新的输入实例，在训练数据集中找到与该实例最临近的 k 个 实例，这 k 个实例的多数属于某个类，就把该输入实例分为这个类。</p>
<p><img src="/2019/08/17/%E9%98%85%E8%AF%BB/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/%E7%AC%AC3%E7%AB%A0-k%E8%BF%91%E9%82%BB%E6%B3%95/k%E8%BF%91%E9%82%BB%E6%B3%95.png" alt="k近邻法"></p>
<p>k 近邻法的特殊情况是 k=1 的情形，称为最近邻算法。</p>
<h2 id="k-近邻模型"><a href="#k-近邻模型" class="headerlink" title="k 近邻模型"></a>k 近邻模型</h2><p>k 近邻法使用的模型实际上对应于对特征空间的划分。模型由三个基本要素——距离度量、k 值的选择和分类决策规则决定。</p>
<h3 id="距离度量"><a href="#距离度量" class="headerlink" title="距离度量"></a>距离度量</h3><p>特征空间中两个实例点的距离是两个实例点相似程度的反映。k 近邻模型的特征空间一般是 n 维实数向量空间 Rn。使用的距离是欧式距离，但也可以是其他距离。</p>
<p><img src="/2019/08/17/%E9%98%85%E8%AF%BB/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/%E7%AC%AC3%E7%AB%A0-k%E8%BF%91%E9%82%BB%E6%B3%95/%E8%B7%9D%E7%A6%BB.png" alt="距离"></p>
<h3 id="k-值的选择"><a href="#k-值的选择" class="headerlink" title="k 值的选择"></a>k 值的选择</h3><p>k 值的选择会对 k 近邻法的结果产生重大影响。</p>
<p>如果选择较小的 k 值，就相当于用较小的领域中的训练实例进行预测，“学习”的近似误差（approximation error）会减小，只有输入实例较近的（相似的）训练实例才会对预测结果起作用。但缺点是“学习”的估计误差（estimation error）会增大，预测结果会对近邻的实例点非常敏感。如果近邻的实例点恰好是噪声，预测就会出错。换句话说，k 值的减小就意味着整体模型变得复杂，容易发生过拟合。</p>
<p>如果选择较大的 k 值，就相当于用较大领域中的训练实例进行预测。其有点是可以减小学习的估计误差。但缺点是学习的近邻误差会增大。这时与输入实例较远的（不相似的）训练实例也会对预测起作用，使预测发生错误。k 值的增大就意味着整体的模型变得简单。</p>
<p>在应用中，k 值一般取一个比较小的数值。通常采用交叉验证法来选取最优的 k 值。</p>
<h3 id="分类决策规则"><a href="#分类决策规则" class="headerlink" title="分类决策规则"></a>分类决策规则</h3><p>k 近邻法的分类决策规则往往是多数表决，即由输入实例的 k 个近邻的训练实例中的多数类决定输入实例的类。</p>
<h2 id="k-近邻法的实现：kd-树"><a href="#k-近邻法的实现：kd-树" class="headerlink" title="k 近邻法的实现：kd 树"></a>k 近邻法的实现：kd 树</h2><p>k 近邻法最简单的实现方法是线性扫描（linear scan）。这时计算输入实例与每一个训练实例的距离。当训练集很大时，计算非常耗时，这种方法是不可行的。</p>
<p>为了提高 k 近邻搜索的效率，可以考虑使用特殊的结构存储训练数据，以减少计算距离的次数。</p>
<h3 id="构造-kd-树"><a href="#构造-kd-树" class="headerlink" title="构造 kd 树"></a>构造 kd 树</h3><p>kd 树是一种对 k 维空间中的实例点进行存储以便对其进行快速检索的树形数据结构。kd 树是二叉树，表示对 k 维空间的一个划分（partition）。构造 kd 树相当于不断地用垂直于坐标轴的超平面将 k 维空间切分，构成一系列的 k 维超矩形区域。kd 树的每个结点对应于一个 k 维超矩形区域。</p>
<p>构造 kd 树的方法如下：构造根结点，使根结点对应于 k 维空间中包含所有实例点的超矩形区域；通过下面的递归方法，不断地对 k 维空间进行切分，生成子节点。在超矩形区域（结点）上选择一个坐标轴和在此坐标轴上的一个切分点，确定一个超平面，这个超平面通过选定的切分点并垂直于选定的坐标轴，将当前超矩形区域切分为左右两个子区域（子节点）；这时，实例被分到两个子区域。这个过程直到子区域内没有实例时终止（终止时的结点为叶结点）。在此过程中，将实例保存在相应的结点上。</p>
<p>通常，依次选择坐标轴对空间切分，选择训练实例点在选定坐标轴上的中位数（median）为切分点，这样得到的 kd 树是平衡的。注意，平衡的 kd 树搜索时的效率未必是最优的。</p>
<p><img src="/2019/08/17/%E9%98%85%E8%AF%BB/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/%E7%AC%AC3%E7%AB%A0-k%E8%BF%91%E9%82%BB%E6%B3%95/%E6%9E%84%E9%80%A0kd%E6%A0%911.png" alt="构造kd树1"><br><img src="/2019/08/17/%E9%98%85%E8%AF%BB/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/%E7%AC%AC3%E7%AB%A0-k%E8%BF%91%E9%82%BB%E6%B3%95/%E6%9E%84%E9%80%A0kd%E6%A0%912.png" alt="构造kd树2"></p>
<h3 id="搜索-kd-树"><a href="#搜索-kd-树" class="headerlink" title="搜索 kd 树"></a>搜索 kd 树</h3><p>给定一个目标点，搜索其最近邻。首选找到包含目标点的叶结点；然后从该叶结点出发，依次回退到父节点；不断查找与目标点最邻近的结点，当确定不可能存在更近的结点时终止。这样搜索就被限制在空间的局部区域上，效率大为提高。</p>
<p>包含目标点的叶结点对应包含目标点的最小超矩形区域。依次叶结点的实例点作为当前最近点。目标点的最近邻一定在以目标点为中心并通过当前最近点的超球体的内部。然后返回当前结点的父节点，如果父节点的另一子节点的超矩形区域与超球体相交，那么在相交的区域内寻找与目标点更近的实例点。如果存在这样的点，将此点作为新的当前最近点。算法赚到更上一级的父节点，继续上述过程。如果父节点的另一子节点的超矩形区域与超球体不相交，或不存在比当前最近点更近的点，则停止搜索。</p>
<p><img src="/2019/08/17/%E9%98%85%E8%AF%BB/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/%E7%AC%AC3%E7%AB%A0-k%E8%BF%91%E9%82%BB%E6%B3%95/%E6%9C%80%E8%BF%91%E9%82%BB%E6%90%9C%E7%B4%A21.png" alt="最近邻搜索1"><br><img src="/2019/08/17/%E9%98%85%E8%AF%BB/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/%E7%AC%AC3%E7%AB%A0-k%E8%BF%91%E9%82%BB%E6%B3%95/%E6%9C%80%E8%BF%91%E9%82%BB%E6%90%9C%E7%B4%A22.png" alt="最近邻搜索2">  </p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wetts.github.io/2019/08/16/%E8%AF%AD%E8%A8%80/Python/%E5%85%B6%E4%BB%96/Python-%E4%B8%8B%E5%88%92%E7%BA%BF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Zhang Wetts">
      <meta itemprop="description" content="Stay Hungry, Stay Foolish. <br><br><p style="font-size:8px;">[build by hexo/next/gitalk/hexo-generator-search/LaTeX]</p>">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wetts's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/08/16/%E8%AF%AD%E8%A8%80/Python/%E5%85%B6%E4%BB%96/Python-%E4%B8%8B%E5%88%92%E7%BA%BF/" class="post-title-link" itemprop="url">Python-下划线</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-08-16 14:13:40" itemprop="dateCreated datePublished" datetime="2019-08-16T14:13:40+08:00">2019-08-16</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Python/" itemprop="url" rel="index"><span itemprop="name">Python</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>参考：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/36173202">https://zhuanlan.zhihu.com/p/36173202</a></p>
<ul>
<li>单前导下划线：<code>_var</code></li>
<li>单末尾下划线：<code>var_</code></li>
<li>双前导下划线：<code>__var</code></li>
<li>双前导和末尾下划线：<code>__var__</code></li>
<li>单下划线：<code>_</code></li>
</ul>
<h3 id="单前导下划线-var"><a href="#单前导下划线-var" class="headerlink" title="单前导下划线 _var"></a>单前导下划线 <code>_var</code></h3><p>下划线前缀的含义是告知其他程序员：以单个下划线开头的变量或方法仅供内部使用。 该约定在PEP 8中有定义。</p>
<p>这不是Python强制规定的。 Python不像Java那样在“私有”和“公共”变量之间有很强的区别。</p>
<p>看看下面的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class Test:</span><br><span class="line">   def __init__(self):</span><br><span class="line">       self.foo = 11</span><br><span class="line">       self._bar = 23</span><br></pre></td></tr></table></figure>
<p>如果你实例化此类，并尝试访问在<code>__init__</code>构造函数中定义的foo和_bar属性，会发生什么情况？ 让我们来看看：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; t = Test()</span><br><span class="line">&gt;&gt;&gt; t.foo</span><br><span class="line">11</span><br><span class="line">&gt;&gt;&gt; t._bar</span><br><span class="line">23</span><br></pre></td></tr></table></figure>
<p>你会看到_bar中的单个下划线并没有阻止我们“进入”类并访问该变量的值。</p>
<p>这是因为Python中的单个下划线前缀仅仅是一个约定 - 至少相对于变量和方法名而言。</p>
<p>但是，前导下划线的确会影响从模块中导入名称的方式。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># This is my_module.py:</span><br><span class="line"></span><br><span class="line">def external_func():</span><br><span class="line">   return 23</span><br><span class="line"></span><br><span class="line">def _internal_func():</span><br><span class="line">   return 42</span><br></pre></td></tr></table></figure>
<p>现在，如果使用通配符从模块中导入所有名称，则Python不会导入带有前导下划线的名称（除非模块定义了覆盖此行为的<code>__all__</code>列表）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from my_module import *</span><br><span class="line">&gt;&gt;&gt; external_func()</span><br><span class="line">23</span><br><span class="line">&gt;&gt;&gt; _internal_func()</span><br><span class="line">NameError: &quot;name &#x27;_internal_func&#x27; is not defined&quot;</span><br></pre></td></tr></table></figure>
<p>顺便说一下，应该避免通配符导入，因为它们使名称空间中存在哪些名称不清楚。 为了清楚起见，坚持常规导入更好。</p>
<p>与通配符导入不同，常规导入不受前导单个下划线命名约定的影响：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import my_module</span><br><span class="line">&gt;&gt;&gt; my_module.external_func()</span><br><span class="line">23</span><br><span class="line">&gt;&gt;&gt; my_module._internal_func()</span><br><span class="line">42</span><br></pre></td></tr></table></figure>
<p>我知道这一点可能有点令人困惑。 如果你遵循PEP 8推荐，避免通配符导入，那么你真正需要记住的只有这个：</p>
<blockquote>
<p>单个下划线是一个Python命名约定，表示这个名称是供内部使用的。 它通常不由Python解释器强制执行，仅仅作为一种对程序员的提示。</p>
</blockquote>
<h3 id="单末尾下划线-var"><a href="#单末尾下划线-var" class="headerlink" title="单末尾下划线 var_"></a>单末尾下划线 <code>var_</code></h3><p>有时候，一个变量的最合适的名称已经被一个关键字所占用。 因此，像class或def这样的名称不能用作Python中的变量名称。 在这种情况下，你可以附加一个下划线来解决命名冲突：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def make_object(name, class):</span><br><span class="line">SyntaxError: &quot;invalid syntax&quot;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; def make_object(name, class_):</span><br><span class="line">...    pass</span><br></pre></td></tr></table></figure>
<p>总之，单个末尾下划线（后缀）是一个约定，用来避免与Python关键字产生命名冲突。 PEP 8解释了这个约定。</p>
<h3 id="双前导下划线-var"><a href="#双前导下划线-var" class="headerlink" title="双前导下划线 __var"></a>双前导下划线 <code>__var</code></h3><p>双下划线前缀会导致Python解释器重写属性名称，以避免子类中的命名冲突。</p>
<p>这也叫做名称修饰（name mangling） - 解释器更改变量的名称，以便在类被扩展的时候不容易产生冲突。</p>
<p>我知道这听起来很抽象。 因此，我组合了一个小小的代码示例来予以说明：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Test:</span><br><span class="line">   def __init__(self):</span><br><span class="line">       self.foo = 11</span><br><span class="line">       self._bar = 23</span><br><span class="line">       self.__baz = 23</span><br></pre></td></tr></table></figure>
<p>让我们用内置的dir()函数来看看这个对象的属性：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; t = Test()</span><br><span class="line">&gt;&gt;&gt; dir(t)</span><br><span class="line">[&#x27;_Test__baz&#x27;, &#x27;__class__&#x27;, &#x27;__delattr__&#x27;, &#x27;__dict__&#x27;, &#x27;__dir__&#x27;,</span><br><span class="line">&#x27;__doc__&#x27;, &#x27;__eq__&#x27;, &#x27;__format__&#x27;, &#x27;__ge__&#x27;, &#x27;__getattribute__&#x27;,</span><br><span class="line">&#x27;__gt__&#x27;, &#x27;__hash__&#x27;, &#x27;__init__&#x27;, &#x27;__le__&#x27;, &#x27;__lt__&#x27;, &#x27;__module__&#x27;,</span><br><span class="line">&#x27;__ne__&#x27;, &#x27;__new__&#x27;, &#x27;__reduce__&#x27;, &#x27;__reduce_ex__&#x27;, &#x27;__repr__&#x27;,</span><br><span class="line">&#x27;__setattr__&#x27;, &#x27;__sizeof__&#x27;, &#x27;__str__&#x27;, &#x27;__subclasshook__&#x27;,</span><br><span class="line">&#x27;__weakref__&#x27;, &#x27;_bar&#x27;, &#x27;foo&#x27;]</span><br></pre></td></tr></table></figure>
<p>以上是这个对象属性的列表。 让我们来看看这个列表，并寻找我们的原始变量名称<code>foo</code>，<code>_bar</code>和<code>__baz</code> - 我保证你会注意到一些有趣的变化。</p>
<ul>
<li><code>self.foo</code>变量在属性列表中显示为未修改为<code>foo</code>。</li>
<li><code>self._bar</code>的行为方式相同 - 它以<code>_bar</code>的形式显示在类上。 就像我之前说过的，在这种情况下，前导下划线仅仅是一个约定。 给程序员一个提示而已。</li>
<li>然而，对于<code>self.__baz</code>而言，情况看起来有点不同。 当你在该列表中搜索<code>__baz</code>时，你会看不到有这个名字的变量。<br><code>__baz</code>出什么情况了？</li>
</ul>
<p>如果你仔细观察，你会看到此对象上有一个名为<code>_Test__baz</code>的属性。 这就是Python解释器所做的名称修饰。 它这样做是为了防止变量在子类中被重写。</p>
<p>让我们创建另一个扩展Test类的类，并尝试重写构造函数中添加的现有属性：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class ExtendedTest(Test):</span><br><span class="line">   def __init__(self):</span><br><span class="line">       super().__init__()</span><br><span class="line">       self.foo = &#x27;overridden&#x27;</span><br><span class="line">       self._bar = &#x27;overridden&#x27;</span><br><span class="line">       self.__baz = &#x27;overridden&#x27;</span><br></pre></td></tr></table></figure>
<p>现在，你认为<code>foo</code>，<code>_bar</code>和<code>__baz</code>的值会出现在这个ExtendedTest类的实例上吗？ 我们来看一看：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; t2 = ExtendedTest()</span><br><span class="line">&gt;&gt;&gt; t2.foo</span><br><span class="line">&#x27;overridden&#x27;</span><br><span class="line">&gt;&gt;&gt; t2._bar</span><br><span class="line">&#x27;overridden&#x27;</span><br><span class="line">&gt;&gt;&gt; t2.__baz</span><br><span class="line">AttributeError: &quot;&#x27;ExtendedTest&#x27; object has no attribute &#x27;__baz&#x27;&quot;</span><br></pre></td></tr></table></figure>
<p>等一下，当我们尝试查看<code>t2.__baz</code>的值时，为什么我们会得到AttributeError？ 名称修饰被再次触发了！ 事实证明，这个对象甚至没有<code>__baz</code>属性：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; dir(t2)</span><br><span class="line">[&#x27;_ExtendedTest__baz&#x27;, &#x27;_Test__baz&#x27;, &#x27;__class__&#x27;, &#x27;__delattr__&#x27;,</span><br><span class="line">&#x27;__dict__&#x27;, &#x27;__dir__&#x27;, &#x27;__doc__&#x27;, &#x27;__eq__&#x27;, &#x27;__format__&#x27;, &#x27;__ge__&#x27;,</span><br><span class="line">&#x27;__getattribute__&#x27;, &#x27;__gt__&#x27;, &#x27;__hash__&#x27;, &#x27;__init__&#x27;, &#x27;__le__&#x27;,</span><br><span class="line">&#x27;__lt__&#x27;, &#x27;__module__&#x27;, &#x27;__ne__&#x27;, &#x27;__new__&#x27;, &#x27;__reduce__&#x27;,</span><br><span class="line">&#x27;__reduce_ex__&#x27;, &#x27;__repr__&#x27;, &#x27;__setattr__&#x27;, &#x27;__sizeof__&#x27;, &#x27;__str__&#x27;,</span><br><span class="line">&#x27;__subclasshook__&#x27;, &#x27;__weakref__&#x27;, &#x27;_bar&#x27;, &#x27;foo&#x27;, &#x27;get_vars&#x27;]</span><br></pre></td></tr></table></figure>
<p>正如你可以看到<code>__baz</code>变成<code>_ExtendedTest__baz</code>以防止意外修改：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; t2._ExtendedTest__baz</span><br><span class="line">&#x27;overridden&#x27;</span><br></pre></td></tr></table></figure>
<p>但原来的<code>_Test__baz</code>还在：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; t2._Test__baz</span><br><span class="line">42</span><br></pre></td></tr></table></figure>
<p>双下划线名称修饰对程序员是完全透明的。 下面的例子证实了这一点：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class ManglingTest:</span><br><span class="line">   def __init__(self):</span><br><span class="line">       self.__mangled = &#x27;hello&#x27;</span><br><span class="line"></span><br><span class="line">   def get_mangled(self):</span><br><span class="line">       return self.__mangled</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; ManglingTest().get_mangled()</span><br><span class="line">&#x27;hello&#x27;</span><br><span class="line">&gt;&gt;&gt; ManglingTest().__mangled</span><br><span class="line">AttributeError: &quot;&#x27;ManglingTest&#x27; object has no attribute &#x27;__mangled&#x27;&quot;</span><br></pre></td></tr></table></figure>
<p>名称修饰是否也适用于方法名称？ 是的，也适用。名称修饰会影响在一个类的上下文中，以两个下划线字符（”dunders”）开头的所有名称：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class MangledMethod:</span><br><span class="line">   def __method(self):</span><br><span class="line">       return 42</span><br><span class="line"></span><br><span class="line">   def call_it(self):</span><br><span class="line">       return self.__method()</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; MangledMethod().__method()</span><br><span class="line">AttributeError: &quot;&#x27;MangledMethod&#x27; object has no attribute &#x27;__method&#x27;&quot;</span><br><span class="line">&gt;&gt;&gt; MangledMethod().call_it()</span><br><span class="line">42</span><br></pre></td></tr></table></figure>
<p>这是另一个也许令人惊讶的运用名称修饰的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">_MangledGlobal__mangled = 23</span><br><span class="line"></span><br><span class="line">class MangledGlobal:</span><br><span class="line">   def test(self):</span><br><span class="line">       return __mangled</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; MangledGlobal().test()</span><br><span class="line">23</span><br></pre></td></tr></table></figure>
<p>在这个例子中，我声明了一个名为<code>_MangledGlobal__mangled</code>的全局变量。然后我在名为MangledGlobal的类的上下文中访问变量。由于名称修饰，我能够在类的test()方法内，以<code>__mangled</code>来引用<code>_MangledGlobal__mangled</code>全局变量。</p>
<p>Python解释器自动将名称<code>__mangled</code>扩展为<code>_MangledGlobal__mangled</code>，因为它以两个下划线字符开头。这表明名称修饰不是专门与类属性关联的。它适用于在类上下文中使用的两个下划线字符开头的任何名称。</p>
<h3 id="双前导和双末尾下划线-var"><a href="#双前导和双末尾下划线-var" class="headerlink" title="双前导和双末尾下划线 __var__"></a>双前导和双末尾下划线 <code>__var__</code></h3><p>也许令人惊讶的是，如果一个名字同时以双下划线开始和结束，则不会应用名称修饰。 由双下划线前缀和后缀包围的变量不会被Python解释器修改：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class PrefixPostfixTest:</span><br><span class="line">   def __init__(self):</span><br><span class="line">       self.__bam__ = 42</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; PrefixPostfixTest().__bam__</span><br><span class="line">42</span><br></pre></td></tr></table></figure>
<p>但是，Python保留了有双前导和双末尾下划线的名称，用于特殊用途。 这样的例子有，<code>__init__</code>对象构造函数，或<code>__call__</code> — 它使得一个对象可以被调用。</p>
<p>这些dunder方法通常被称为神奇方法。</p>
<p>最好避免在自己的程序中使用以双下划线（“dunders”）开头和结尾的名称，以避免与将来Python语言的变化产生冲突。</p>
<h3 id="单下划线"><a href="#单下划线" class="headerlink" title="单下划线 _"></a>单下划线 <code>_</code></h3><p>按照习惯，有时候单个独立下划线是用作一个名字，来表示某个变量是临时的或无关紧要的。</p>
<p>例如，在下面的循环中，我们不需要访问正在运行的索引，我们可以使用“_”来表示它只是一个临时值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; for _ in range(32):</span><br><span class="line">...    print(&#x27;Hello, World.&#x27;)</span><br></pre></td></tr></table></figure>
<p>你也可以在拆分(unpacking)表达式中将单个下划线用作“不关心的”变量，以忽略特定的值。 同样，这个含义只是“依照约定”，并不会在Python解释器中触发特殊的行为。 单个下划线仅仅是一个有效的变量名称，会有这个用途而已。</p>
<p>在下面的代码示例中，我将汽车元组拆分为单独的变量，但我只对颜色和里程值感兴趣。 但是，为了使拆分表达式成功运行，我需要将包含在元组中的所有值分配给变量。 在这种情况下，“_”作为占位符变量可以派上用场：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; car = (&#x27;red&#x27;, &#x27;auto&#x27;, 12, 3812.4)</span><br><span class="line">&gt;&gt;&gt; color, _, _, mileage = car</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; color</span><br><span class="line">&#x27;red&#x27;</span><br><span class="line">&gt;&gt;&gt; mileage</span><br><span class="line">3812.4</span><br><span class="line">&gt;&gt;&gt; _</span><br><span class="line">12</span><br></pre></td></tr></table></figure>
<p>除了用作临时变量之外，“_”是大多数Python REPL中的一个特殊变量，它表示由解释器评估的最近一个表达式的结果。</p>
<p>这样就很方便了，比如你可以在一个解释器会话中访问先前计算的结果，或者，你是在动态构建多个对象并与它们交互，无需事先给这些对象分配名字：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; 20 + 3</span><br><span class="line">23</span><br><span class="line">&gt;&gt;&gt; _</span><br><span class="line">23</span><br><span class="line">&gt;&gt;&gt; print(_)</span><br><span class="line">23</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; list()</span><br><span class="line">[]</span><br><span class="line">&gt;&gt;&gt; _.append(1)</span><br><span class="line">&gt;&gt;&gt; _.append(2)</span><br><span class="line">&gt;&gt;&gt; _.append(3)</span><br><span class="line">&gt;&gt;&gt; _</span><br><span class="line">[1, 2, 3]</span><br></pre></td></tr></table></figure>

<h3 id="Python下划线命名模式-小结"><a href="#Python下划线命名模式-小结" class="headerlink" title="Python下划线命名模式 - 小结"></a>Python下划线命名模式 - 小结</h3><p><img src="/2019/08/16/%E8%AF%AD%E8%A8%80/Python/%E5%85%B6%E4%BB%96/Python-%E4%B8%8B%E5%88%92%E7%BA%BF/1.png" alt="1"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wetts.github.io/2019/08/15/%E9%98%85%E8%AF%BB/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E6%9C%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Zhang Wetts">
      <meta itemprop="description" content="Stay Hungry, Stay Foolish. <br><br><p style="font-size:8px;">[build by hexo/next/gitalk/hexo-generator-search/LaTeX]</p>">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wetts's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/08/15/%E9%98%85%E8%AF%BB/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E6%9C%BA/" class="post-title-link" itemprop="url">统计学系方法-第2章-感知机</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-08-15 13:43:22" itemprop="dateCreated datePublished" datetime="2019-08-15T13:43:22+08:00">2019-08-15</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">读书笔记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>感知机（perceptron）是二类分类的线性分类模型，其输入为实例的特征向量，输出为实例的类别，取 +1 和 -1 二值。感知机对应于输入空间（特征空间）中将实例划分为正负两类的分离超平面，属于判别模型。</p>
<h2 id="感知机模型"><a href="#感知机模型" class="headerlink" title="感知机模型"></a>感知机模型</h2><p>由输入空间到输出空间的如下函数 <img src="/2019/08/15/%E9%98%85%E8%AF%BB/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E6%9C%BA/%E6%84%9F%E7%9F%A5%E6%9C%BA%E6%A8%A1%E5%9E%8B.png" alt="感知机模型"> 称为感知机。其中，w 和 b 为感知机模型参数， w 叫作权值（weight）或权值向量（weight vector），b 叫作偏置（bias）。sign 是符号函数，即 <img src="/2019/08/15/%E9%98%85%E8%AF%BB/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E6%9C%BA/%E7%AC%A6%E5%8F%B7%E5%87%BD%E6%95%B0.png" alt="符号函数"></p>
<h2 id="感知机学习策略"><a href="#感知机学习策略" class="headerlink" title="感知机学习策略"></a>感知机学习策略</h2><h3 id="数据集的线性可分性"><a href="#数据集的线性可分性" class="headerlink" title="数据集的线性可分性"></a>数据集的线性可分性</h3><p>如果存在某个超平面 S 能够将数据集的正实例点和负实例点完全正确地划分到超平面的两侧，则称数据集 T 为线性可分数据集（linearly separable data set）；否则，称数据集 T 线性不可分。</p>
<h3 id="感知机学习策略-1"><a href="#感知机学习策略-1" class="headerlink" title="感知机学习策略"></a>感知机学习策略</h3><p>感知机的损失函数定义为 <img src="/2019/08/15/%E9%98%85%E8%AF%BB/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E6%9C%BA/%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0.png" alt="损失函数"> 其中 M 为误分类点的集合。这个损失函数就是感知机学习的经验风险函数。</p>
<p>显然，损失函数 L(w, b) 是非负的。如果没有误分类点，损失函数值是 0.而且，误分类点越少，误分类点离超平面越近，损失函数值越小。</p>
<p>感知机学习的策略是在假设空间中选取使损失函数式最小的模型参数 w 和 b，即感知机模型。</p>
<h2 id="感知机学习算法"><a href="#感知机学习算法" class="headerlink" title="感知机学习算法"></a>感知机学习算法</h2><p>感知机学习问题转化为求解损失函数式的最优化问题，最优化的方法是随机梯度下降法。</p>
<h3 id="感知机学习算法的原始形式"><a href="#感知机学习算法的原始形式" class="headerlink" title="感知机学习算法的原始形式"></a>感知机学习算法的原始形式</h3><p><img src="/2019/08/15/%E9%98%85%E8%AF%BB/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E6%9C%BA/%E7%AE%97%E6%B3%95%E5%8E%9F%E5%A7%8B%E5%BD%A2%E5%BC%8F.png" alt="算法原始形式"></p>
<p>这种学习算法直观上有如下解释：当一个实例点被误分类，即位于分离超平面的错误一侧时，则调整 w, b 的值，使分离超平面向该误分类点的一侧移动，以减小该误分离点与超平面间的距离，直至超平面越过该误分类点使其被正确分类。</p>
<h3 id="算法的收敛性"><a href="#算法的收敛性" class="headerlink" title="算法的收敛性"></a>算法的收敛性</h3><p><img src="/2019/08/15/%E9%98%85%E8%AF%BB/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E6%9C%BA/%E7%AE%97%E6%B3%95%E7%9A%84%E6%94%B6%E6%95%9B%E6%80%A7.png" alt="算法的收敛性"></p>
<h3 id="感知机学习算法的对偶形式"><a href="#感知机学习算法的对偶形式" class="headerlink" title="感知机学习算法的对偶形式"></a>感知机学习算法的对偶形式</h3><p><img src="/2019/08/15/%E9%98%85%E8%AF%BB/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E6%9C%BA/%E5%AF%B9%E5%81%B6%E5%BD%A2%E5%BC%8F%E7%9A%84%E6%80%9D%E8%B7%AF.png" alt="对偶形式的思路"></p>
<p>实例点更新次数越多，意味着它距离分离超平面越近，也就越难正确分类（越容易分错，超平面一动不多就容易将这些点分错），换句话说，这样的实例对学习结果影响最大（在支持向量机中，这些点代表着支持向量）。</p>
<p><img src="/2019/08/15/%E9%98%85%E8%AF%BB/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E6%9C%BA/%E7%AE%97%E6%B3%95%E5%AF%B9%E5%81%B6%E5%BD%A2%E5%BC%8F1.png" alt="算法对偶形式1"><br><img src="/2019/08/15/%E9%98%85%E8%AF%BB/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/%E7%AC%AC2%E7%AB%A0-%E6%84%9F%E7%9F%A5%E6%9C%BA/%E7%AE%97%E6%B3%95%E5%AF%B9%E5%81%B6%E5%BD%A2%E5%BC%8F2.png" alt="算法对偶形式2"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wetts.github.io/2019/08/14/%E6%95%B0%E5%AD%A6/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%90%91%E9%87%8F%E7%82%B9%E4%B9%98%EF%BC%88%E5%86%85%E7%A7%AF%EF%BC%89%E5%92%8C%E5%8F%89%E4%B9%98%EF%BC%88%E5%A4%96%E7%A7%AF%E3%80%81%E5%90%91%E9%87%8F%E7%A7%AF%EF%BC%89%E6%A6%82%E5%BF%B5%E5%8F%8A%E5%87%A0%E4%BD%95%E6%84%8F%E4%B9%89%E8%A7%A3%E8%AF%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Zhang Wetts">
      <meta itemprop="description" content="Stay Hungry, Stay Foolish. <br><br><p style="font-size:8px;">[build by hexo/next/gitalk/hexo-generator-search/LaTeX]</p>">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wetts's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/08/14/%E6%95%B0%E5%AD%A6/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%90%91%E9%87%8F%E7%82%B9%E4%B9%98%EF%BC%88%E5%86%85%E7%A7%AF%EF%BC%89%E5%92%8C%E5%8F%89%E4%B9%98%EF%BC%88%E5%A4%96%E7%A7%AF%E3%80%81%E5%90%91%E9%87%8F%E7%A7%AF%EF%BC%89%E6%A6%82%E5%BF%B5%E5%8F%8A%E5%87%A0%E4%BD%95%E6%84%8F%E4%B9%89%E8%A7%A3%E8%AF%BB/" class="post-title-link" itemprop="url">向量点乘（内积）和叉乘（外积、向量积）概念及几何意义解读</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-08-14 15:12:22" itemprop="dateCreated datePublished" datetime="2019-08-14T15:12:22+08:00">2019-08-14</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E5%AD%A6/" itemprop="url" rel="index"><span itemprop="name">数学</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>转自：<a target="_blank" rel="noopener" href="https://blog.csdn.net/dcrmg/article/details/52416832">https://blog.csdn.net/dcrmg/article/details/52416832</a></p>
<p>向量是由n个实数组成的一个 n 行 1 列（n<em>1）或一个 1 行 n 列（1</em>n）的有序数组；</p>
<p>向量的点乘,也叫向量的内积、数量积，对两个向量执行点乘运算，就是对这两个向量对应位一一相乘之后求和的操作，点乘的结果是一个标量。</p>
<h2 id="点乘"><a href="#点乘" class="headerlink" title="点乘"></a>点乘</h2><h3 id="点乘公式"><a href="#点乘公式" class="headerlink" title="点乘公式"></a>点乘公式</h3><p>对于向量a和向量b：<img src="/2019/08/14/%E6%95%B0%E5%AD%A6/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%90%91%E9%87%8F%E7%82%B9%E4%B9%98%EF%BC%88%E5%86%85%E7%A7%AF%EF%BC%89%E5%92%8C%E5%8F%89%E4%B9%98%EF%BC%88%E5%A4%96%E7%A7%AF%E3%80%81%E5%90%91%E9%87%8F%E7%A7%AF%EF%BC%89%E6%A6%82%E5%BF%B5%E5%8F%8A%E5%87%A0%E4%BD%95%E6%84%8F%E4%B9%89%E8%A7%A3%E8%AF%BB/%E5%90%91%E9%87%8Fa.png" alt="向量a">  <img src="/2019/08/14/%E6%95%B0%E5%AD%A6/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%90%91%E9%87%8F%E7%82%B9%E4%B9%98%EF%BC%88%E5%86%85%E7%A7%AF%EF%BC%89%E5%92%8C%E5%8F%89%E4%B9%98%EF%BC%88%E5%A4%96%E7%A7%AF%E3%80%81%E5%90%91%E9%87%8F%E7%A7%AF%EF%BC%89%E6%A6%82%E5%BF%B5%E5%8F%8A%E5%87%A0%E4%BD%95%E6%84%8F%E4%B9%89%E8%A7%A3%E8%AF%BB/%E5%90%91%E9%87%8Fb.png" alt="向量b"></p>
<p>a和b的点积公式为：<img src="/2019/08/14/%E6%95%B0%E5%AD%A6/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%90%91%E9%87%8F%E7%82%B9%E4%B9%98%EF%BC%88%E5%86%85%E7%A7%AF%EF%BC%89%E5%92%8C%E5%8F%89%E4%B9%98%EF%BC%88%E5%A4%96%E7%A7%AF%E3%80%81%E5%90%91%E9%87%8F%E7%A7%AF%EF%BC%89%E6%A6%82%E5%BF%B5%E5%8F%8A%E5%87%A0%E4%BD%95%E6%84%8F%E4%B9%89%E8%A7%A3%E8%AF%BB/%E7%82%B9%E4%B9%98%E5%85%AC%E5%BC%8F.png" alt="点乘公式"></p>
<p>要求一维向量a和向量b的行列数相同。</p>
<h3 id="点乘几何意义"><a href="#点乘几何意义" class="headerlink" title="点乘几何意义"></a>点乘几何意义</h3><p>点乘的几何意义是可以用来表征或计算两个向量之间的夹角，以及在b向量在a向量方向上的投影，有公式：<img src="/2019/08/14/%E6%95%B0%E5%AD%A6/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%90%91%E9%87%8F%E7%82%B9%E4%B9%98%EF%BC%88%E5%86%85%E7%A7%AF%EF%BC%89%E5%92%8C%E5%8F%89%E4%B9%98%EF%BC%88%E5%A4%96%E7%A7%AF%E3%80%81%E5%90%91%E9%87%8F%E7%A7%AF%EF%BC%89%E6%A6%82%E5%BF%B5%E5%8F%8A%E5%87%A0%E4%BD%95%E6%84%8F%E4%B9%89%E8%A7%A3%E8%AF%BB/%E7%82%B9%E4%B9%98%E5%A4%B9%E8%A7%92.png" alt="点乘夹角"></p>
<p>推导过程如下，首先看一下向量组成：<img src="/2019/08/14/%E6%95%B0%E5%AD%A6/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%90%91%E9%87%8F%E7%82%B9%E4%B9%98%EF%BC%88%E5%86%85%E7%A7%AF%EF%BC%89%E5%92%8C%E5%8F%89%E4%B9%98%EF%BC%88%E5%A4%96%E7%A7%AF%E3%80%81%E5%90%91%E9%87%8F%E7%A7%AF%EF%BC%89%E6%A6%82%E5%BF%B5%E5%8F%8A%E5%87%A0%E4%BD%95%E6%84%8F%E4%B9%89%E8%A7%A3%E8%AF%BB/%E7%82%B9%E4%B9%98%E5%9B%BE.png" alt="点乘图"></p>
<h2 id="叉乘"><a href="#叉乘" class="headerlink" title="叉乘"></a>叉乘</h2><h3 id="叉乘公式"><a href="#叉乘公式" class="headerlink" title="叉乘公式"></a>叉乘公式</h3><p>两个向量的叉乘，又叫向量积、外积、叉积，叉乘的运算结果是一个向量而不是一个标量。并且两个向量的叉积与这两个向量组成的坐标平面垂直。</p>
<p>对于向量a和向量b：<img src="/2019/08/14/%E6%95%B0%E5%AD%A6/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%90%91%E9%87%8F%E7%82%B9%E4%B9%98%EF%BC%88%E5%86%85%E7%A7%AF%EF%BC%89%E5%92%8C%E5%8F%89%E4%B9%98%EF%BC%88%E5%A4%96%E7%A7%AF%E3%80%81%E5%90%91%E9%87%8F%E7%A7%AF%EF%BC%89%E6%A6%82%E5%BF%B5%E5%8F%8A%E5%87%A0%E4%BD%95%E6%84%8F%E4%B9%89%E8%A7%A3%E8%AF%BB/%E5%90%91%E9%87%8Fab.png" alt="向量ab"> </p>
<p>a和b的叉乘公式为：<img src="/2019/08/14/%E6%95%B0%E5%AD%A6/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%90%91%E9%87%8F%E7%82%B9%E4%B9%98%EF%BC%88%E5%86%85%E7%A7%AF%EF%BC%89%E5%92%8C%E5%8F%89%E4%B9%98%EF%BC%88%E5%A4%96%E7%A7%AF%E3%80%81%E5%90%91%E9%87%8F%E7%A7%AF%EF%BC%89%E6%A6%82%E5%BF%B5%E5%8F%8A%E5%87%A0%E4%BD%95%E6%84%8F%E4%B9%89%E8%A7%A3%E8%AF%BB/%E5%8F%89%E4%B9%98%E5%85%AC%E5%BC%8F.png" alt="叉乘公式"> </p>
<p>其中：<img src="/2019/08/14/%E6%95%B0%E5%AD%A6/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%90%91%E9%87%8F%E7%82%B9%E4%B9%98%EF%BC%88%E5%86%85%E7%A7%AF%EF%BC%89%E5%92%8C%E5%8F%89%E4%B9%98%EF%BC%88%E5%A4%96%E7%A7%AF%E3%80%81%E5%90%91%E9%87%8F%E7%A7%AF%EF%BC%89%E6%A6%82%E5%BF%B5%E5%8F%8A%E5%87%A0%E4%BD%95%E6%84%8F%E4%B9%89%E8%A7%A3%E8%AF%BB/%E5%9F%BA.png" alt="基"> </p>
<h3 id="叉乘几何意义"><a href="#叉乘几何意义" class="headerlink" title="叉乘几何意义"></a>叉乘几何意义</h3><p>在三维几何中，向量a和向量b的叉乘结果是一个向量，更为熟知的叫法是法向量，该向量垂直于a和b向量构成的平面。</p>
<p>在3D图像学中，叉乘的概念非常有用，可以通过两个向量的叉乘，生成第三个垂直于a，b的法向量，从而构建X、Y、Z坐标系。如下图所示：<img src="/2019/08/14/%E6%95%B0%E5%AD%A6/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E5%90%91%E9%87%8F%E7%82%B9%E4%B9%98%EF%BC%88%E5%86%85%E7%A7%AF%EF%BC%89%E5%92%8C%E5%8F%89%E4%B9%98%EF%BC%88%E5%A4%96%E7%A7%AF%E3%80%81%E5%90%91%E9%87%8F%E7%A7%AF%EF%BC%89%E6%A6%82%E5%BF%B5%E5%8F%8A%E5%87%A0%E4%BD%95%E6%84%8F%E4%B9%89%E8%A7%A3%E8%AF%BB/%E5%8F%89%E4%B9%98%E5%9B%BE.png" alt="叉乘图"> </p>
<p>在二维空间中，叉乘还有另外一个几何意义就是：aXb等于由向量a和向量b构成的平行四边形的面积。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wetts.github.io/2019/08/11/%E9%98%85%E8%AF%BB/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/%E7%AC%AC1%E7%AB%A0-%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%E6%A6%82%E8%AE%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Zhang Wetts">
      <meta itemprop="description" content="Stay Hungry, Stay Foolish. <br><br><p style="font-size:8px;">[build by hexo/next/gitalk/hexo-generator-search/LaTeX]</p>">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wetts's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/08/11/%E9%98%85%E8%AF%BB/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/%E7%AC%AC1%E7%AB%A0-%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%E6%A6%82%E8%AE%BA/" class="post-title-link" itemprop="url">统计学系方法-第1章-统计学习方法概论</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-08-11 21:29:48" itemprop="dateCreated datePublished" datetime="2019-08-11T21:29:48+08:00">2019-08-11</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">读书笔记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="统计学习"><a href="#统计学习" class="headerlink" title="统计学习"></a>统计学习</h2><p>统计学习主要特点：</p>
<ol>
<li>统计学习以计算机及网络为平台，是建立在计算机及网络之上的；</li>
<li>统计学习以数据为研究对象，是数据驱动的学科；</li>
<li>统计学习的目的是对数据进行预测与分析；</li>
<li>统计学习以方法为中心，统计学习方法构建模型并应用模型进行预测与分析；</li>
<li>统计学习是概率论、统计学、信息论、计算理论、最优化理论及计算机科学等多个领域的交叉学科，并且在发展中逐步形成独立的理论体现与方法论。</li>
</ol>
<p>统计学习的组成：</p>
<ul>
<li>监督学习（supervised learning）</li>
<li>非监督学习（unsupervised learning）</li>
<li>半监督学习（semi-supervised learning）</li>
<li>强化学习（reinforcement learning）</li>
</ul>
<p>统计学习方法的三要素：</p>
<ul>
<li>模型（model）</li>
<li>策略（strategy）</li>
<li>算法（algorithm）</li>
</ul>
<h2 id="监督学习"><a href="#监督学习" class="headerlink" title="监督学习"></a>监督学习</h2><p>监督学习的任务是学习一个模型，使模型能够对任意给定的输入，对其相应的输出做出一个好的预测。</p>
<h2 id="统计学习三要素"><a href="#统计学习三要素" class="headerlink" title="统计学习三要素"></a>统计学习三要素</h2><h3 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h3><p>在监督学习过程中，模型就是所要学习的条件概率分布或决策函数。模型的假设空间（hypothesis space）包含所有可能的条件概率分布或决策函数。</p>
<h3 id="策略"><a href="#策略" class="headerlink" title="策略"></a>策略</h3><h4 id="损失函数和风险函数"><a href="#损失函数和风险函数" class="headerlink" title="损失函数和风险函数"></a>损失函数和风险函数</h4><h5 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h5><p>监督学习问题是在假设空间 F 中选取模型 f 作为决策函数，对于给定的输入 X，由 f(X) 给出相应的输出 Y，这个输出的预测值 f(X) 与真实值 Y 可能一致也可能不一致，用一个损失函数（loss function）或代价函数（cost function）来度量预测错误的程度。损失函数是 f(x) 和 Y 的非负实值函数，记作 <code>L(Y, f(X))</code>。</p>
<p>常用的损失函数：</p>
<ol>
<li>0-1损失函数（0-1 loss function)<br><img src="/2019/08/11/%E9%98%85%E8%AF%BB/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/%E7%AC%AC1%E7%AB%A0-%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%E6%A6%82%E8%AE%BA/01.png" alt="0-1损失函数"></li>
<li>平方损失函数(quadratic loss function)<br><img src="/2019/08/11/%E9%98%85%E8%AF%BB/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/%E7%AC%AC1%E7%AB%A0-%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%E6%A6%82%E8%AE%BA/quadratic.png" alt="平方损失函数"></li>
<li>绝对损失函数（absolute loss function）<br><img src="/2019/08/11/%E9%98%85%E8%AF%BB/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/%E7%AC%AC1%E7%AB%A0-%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%E6%A6%82%E8%AE%BA/absolute.png" alt="绝对损失函数"></li>
<li>对数损失函数（logarithmic loss function）或对数似然损失函数（loglikelihood loss function）<br><img src="/2019/08/11/%E9%98%85%E8%AF%BB/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/%E7%AC%AC1%E7%AB%A0-%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%E6%A6%82%E8%AE%BA/logarithmic.png" alt="对数损失函数"></li>
</ol>
<h5 id="风险函数"><a href="#风险函数" class="headerlink" title="风险函数"></a>风险函数</h5><p>损失函数数值越小，模型就越好。由于模型的输入、输出 (X, Y) 是随机变量，遵循联合分布 P(X, Y)，所以损失函数的期望是<img src="/2019/08/11/%E9%98%85%E8%AF%BB/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/%E7%AC%AC1%E7%AB%A0-%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%E6%A6%82%E8%AE%BA/%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0%E7%9A%84%E6%9C%9F%E6%9C%9B.png" alt="损失函数的期望"></p>
<p>这是理论上模型 f(X) 关于联合分布 P(X, Y) 的平均意义下的损失，称为风险函数（risk funciton）或期望损失（expected loss）。</p>
<p>学习的目标就是选择期望风险最小的模型。由于联合分布是未知的，所以损失函数的期望不能直接计算。</p>
<p>给定一个训练数据集<img src="/2019/08/11/%E9%98%85%E8%AF%BB/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/%E7%AC%AC1%E7%AB%A0-%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%E6%A6%82%E8%AE%BA/%E8%AE%AD%E7%BB%83%E6%95%B0%E6%8D%AE%E9%9B%86T.png" alt="训练数据集T">。模型 f(X) 关于训练数据集的平均损失称为经验风险（empirical risk）或经验损失风险（empirical loss），记作：<img src="/2019/08/11/%E9%98%85%E8%AF%BB/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/%E7%AC%AC1%E7%AB%A0-%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%E6%A6%82%E8%AE%BA/%E7%BB%8F%E9%AA%8C%E6%8D%9F%E5%A4%B1%E9%A3%8E%E9%99%A9.png" alt="经验损失风险"></p>
<p>根据大数定律，当样本容量 N 趋于无穷时，经验风险趋于期望风险。</p>
<h4 id="经验风险最小化与结构风险最小化"><a href="#经验风险最小化与结构风险最小化" class="headerlink" title="经验风险最小化与结构风险最小化"></a>经验风险最小化与结构风险最小化</h4><h5 id="经验风险"><a href="#经验风险" class="headerlink" title="经验风险"></a>经验风险</h5><p>在假设空间、损失函数以及训练数据集确定的情况下，经验风险函数式就可以确定。经验风险最小化（empirical risk minimization，ERM）的策略认为，经验风险最小的模型是最优的模型。</p>
<p>当样本容量足够大时，经验风险最小化能保证有很好的学习效果。比如，极大似然估计（maximum likelihood estimation）就是经验风险最小化的例子。当模型是条件概率分布，损失函数是对数损失函数时，经验风险最小化就等驾驭极大似然估计。</p>
<p>但是，当样本容量很小时，经验风险最小化学习的效果就未必很好，就产生“过拟合（over-fitting）“现象。</p>
<h4 id="结构风险"><a href="#结构风险" class="headerlink" title="结构风险"></a>结构风险</h4><p>结构风险最小化（structural risk minimization，SRM）是为了防止过拟合而提出来的策略。结构风险最小化等价于正则化（regularization）。结构风险在经验风险上加上表示模型复杂度的正则化项（regularizer）或罚项（penalty term）。在假设空间、损失函数以及训练数据集确定的情况下，结构风险的定义是：<img src="/2019/08/11/%E9%98%85%E8%AF%BB/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/%E7%AC%AC1%E7%AB%A0-%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%E6%A6%82%E8%AE%BA/%E7%BB%93%E6%9E%84%E9%A3%8E%E9%99%A9.png" alt="结构风险">。其中 J(f) 为模型的复杂度，是定义在假设空间 F 上的泛函。模型 f 越复杂，复杂度 J(f) 就越大；反之，模型 f 越简单，复杂度 J(f) 就越小。</p>
<p>比如，贝叶斯估计中的最大后验概率估计（maximum posterior probability estimation，MAP）就是结构风险最小化的例子。当模型是条件概率分布、损失函数是对数损失函数、模型复杂度由模型的先验概率表示时，结构风险最小化就等驾驭最大后验概率估计。</p>
<h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p>算法是指学习模型的具体计算方法。</p>
<h2 id="模型评估与模型选择"><a href="#模型评估与模型选择" class="headerlink" title="模型评估与模型选择"></a>模型评估与模型选择</h2><h3 id="训练误差与测试误差"><a href="#训练误差与测试误差" class="headerlink" title="训练误差与测试误差"></a>训练误差与测试误差</h3><p>统计学习方法具体采用的损失函数未必是评估时使用的损失函数。当然，让两者一致是比较理想的。</p>
<h3 id="过拟合与模型选择"><a href="#过拟合与模型选择" class="headerlink" title="过拟合与模型选择"></a>过拟合与模型选择</h3><p>如果一味追求提高对训练数据的预测能力，所选模型的复杂度则往往会比真模型更高，这种现象称为过拟合（over-fitting）。过拟合是指学习时选择的模型所包含的参数过多，以至于出现这一模型对已知数据预测得很好，但对未知数据预测得很差的现象。</p>
<p><img src="/2019/08/11/%E9%98%85%E8%AF%BB/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/%E7%AC%AC1%E7%AB%A0-%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%E6%A6%82%E8%AE%BA/%E8%AE%AD%E7%BB%83%E8%AF%AF%E5%B7%AE%E4%B8%8E%E6%B5%8B%E8%AF%95%E8%AF%AF%E5%B7%AE.png" alt="训练误差与测试误差"></p>
<p>当模型的复杂度增大时，训练误差会逐渐减小并趋向于0；而测试误差会先减小，达到最小值后又增大。当选择的模型复杂度过于大时，过拟合现象就会发生。这样，在学习时就要防止过拟合，进行最优的模型选择，即选择复杂度适当的模型，以达到使测试误差最小的学习目的。下面介绍两种常用的模型选择方法：正则化与交叉验证。</p>
<h3 id="正则化与交叉验证"><a href="#正则化与交叉验证" class="headerlink" title="正则化与交叉验证"></a>正则化与交叉验证</h3><h4 id="正则化"><a href="#正则化" class="headerlink" title="正则化"></a>正则化</h4><p>模型选择的典型方法使正则化（regularization）。正则化是结构风险最小化策略的实现，是在经验风险上加一个正则化项（regularizer）或罚项（penalty term）。正则化项一般是模型复杂度的单调递增函数，模型越复杂，正则化值越大。</p>
<p>正则化符合奥卡姆剃刀（Occam’s razor）原理。奥卡姆剃刀原理应用于模型选择时为以下想法：在所有可能选择的模型中，能够很好地解释已知数据并且十分简单才是最好的模型，也就是应该选择的模型。从贝叶斯估计的角度来看，正则化项对应于模型的先验概率。可以假设复杂的模型有较小的先验概率，简单的模型有较大的先验概率。</p>
<h4 id="交叉验证"><a href="#交叉验证" class="headerlink" title="交叉验证"></a>交叉验证</h4><p>如果给定的样本数据充足，进行模型选择的一种简单方法是随机地将数据集切分成三部分，分为训练集（training set）、验证集（validation set）和测试集（test set）。训练集用来训练模型，验证集用于模型的选择，而测试集用于最终学习方法的评估。</p>
<p>但是，在许多实际应用中数据是不充足的。为了选择好的模型，可以采用交叉验证方法。交叉验证的基本想法是重复地使用数据；把给定的数据进行切分，将切分的数据集组合为训练集与测试集，在此基础上反复地进行训练、测试以及模型选择。</p>
<h5 id="简单交叉验证"><a href="#简单交叉验证" class="headerlink" title="简单交叉验证"></a>简单交叉验证</h5><p>简单交叉验证方法是：首先随机地将已给数据分为两部分，一部分作为训练集，另一部分作为测试集；然后用训练集在各种条件下训练模型，从而得到不同的模型；在测试集上评价各个模型的测试误差，选出测试误差最小的模型。</p>
<h5 id="S-折交叉验证"><a href="#S-折交叉验证" class="headerlink" title="S 折交叉验证"></a>S 折交叉验证</h5><p>应用最多的是 S 折交叉验证（S-flod cross validation)，方法如下：首先随机地将已给数据切分为 S 个互不相交的大小相同的子集；然后利用 S-1 个子集的数据训练模型，利用余下的子集测试模型；将这一过程对可能的 S 种选择重复进行；最后选出 S 次评测中平均测试误差最小的模型。</p>
<h5 id="留一交叉验证"><a href="#留一交叉验证" class="headerlink" title="留一交叉验证"></a>留一交叉验证</h5><p>S 折交叉验证的特殊情形是 S=N，称为留一交叉验证（leave-one-out cross validation），往往在数据缺乏的情况下使用。这里，N 是给定数据集的容量。</p>
<h3 id="泛化能力"><a href="#泛化能力" class="headerlink" title="泛化能力"></a>泛化能力</h3><h4 id="泛化误差"><a href="#泛化误差" class="headerlink" title="泛化误差"></a>泛化误差</h4><p>学习方法的泛化能力（generalization ability）是指由该方法学习到的模型对未知数据的预测能力，是学习方法本质上重要的性质。现实中采用最多的办法是通过测试误差来评价学习方法的泛化能力。</p>
<p>事实上，泛化误差就是所学习到的模型的期望风险。</p>
<h4 id="泛化误差上界"><a href="#泛化误差上界" class="headerlink" title="泛化误差上界"></a>泛化误差上界</h4><p>学习方法的泛化能力分析往往是通过研究泛化误差的概率上界进行的，简称为泛化误差上界（generalizaiton error bound）。具体来说，就是通过比较两种学习方法的泛化误差上界的大小来比较它们的优劣。泛化误差上界通常具有以下性质：它是样本容量的函数，当样本容量增加时，泛化上界趋于0；它是假设空间容量（capacity）的函数，假设空间容量越大，模型就越难学，泛化误差上界就越大。</p>
<h3 id="生成模型与判别模型"><a href="#生成模型与判别模型" class="headerlink" title="生成模型与判别模型"></a>生成模型与判别模型</h3><p>监督学习的任务就是学习一个模型，应用这一模型，对给定的输入预测相应的输出。这个模型的一般形式为决策函数：Y=f(X) 或者条件概率分布：P(Y|X)。</p>
<p>监督学习方法又可分为生成方法（generative approach）和判别方法（discriminative approach）。所学习到的模型分别称为生成模型（generative model）和判别模型（discriminative model）。</p>
<p>生成方法由数据学习联合概率分布 P(X, Y)，然后求出条件概率分布 P(Y|X) 作为预测的模型。这样的方法之所以称为生成方法。是因为模型表示了给定输入 X 产生输出 Y 的生成关系。典型的生成模型由：朴素贝叶斯法和隐马尔可夫模型。</p>
<p>判别方法由数据直接学习决策函数 f(X) 或者条件概率分布 P(Y|X) 作为预测的模型，即判别模型。判别方法关系的是对给定的输入 X，应该预测什么样的输出 Y。典型的判别模型包括：k 近邻法、感知机、决策树、逻辑斯蒂回归模型、最大熵模型、支持向量机、提升方法和条件随机场等。</p>
<p>生成方法的特点：生成方法可以还原出联合概率分布 P(X, Y)，而判别方法则不能；生成方法的学习收敛更快，即当样本容量增加的时候，学习的模型可以更快地收敛于真实模型；当存在隐变量时，仍可以用生成方法学习，此时判断方法就不能用。</p>
<p>判别方法的忒点：判别方法直接学习的是条件概率 P(Y|X) 或决策函数 f(X)，直接面对预测，往往学习的准确率更高；由于直接学习 P(Y|X) 或 f(X)，可以对数据进行个各种程度上的抽象、定义特征并使用特征，因此可以简化学习问题。</p>
<h3 id="分类问题"><a href="#分类问题" class="headerlink" title="分类问题"></a>分类问题</h3><p>在监督学习中，当输入变量 Y 取有限个离散值时，预测问题便称为分类问题。这时，输入变量 X 可以是离散的，也可以是连续的。监督学习从数据中学习一个分离诶模型或分类决策函数，称为分类器（classifier）。分类器对新的输入进行输出的预测（prediction），称为分类（classification）。可能的输出称为类（class）。分类的类别为多个时，称为多类分类问题。</p>
<p>评价分类器性能的指标一般是分类准确率（accuracy），其定义是：对于给定的测试数据集，分类器正确分类的样本数与总样本数之比。也就是损失函数是 0-1 损失时测试数据集上的准确率。</p>
<h3 id="标注问题"><a href="#标注问题" class="headerlink" title="标注问题"></a>标注问题</h3><p>标注（tagging）也是一个监督学习问题。可以认为标注问题是分类问题的一个推广，标注问题又是更复杂的结构预测（structure prediction）问题的简单形式。标注问题的输入是一个观测序列，输出是一个标记序列或状态序列。标注问题的目标在于学一个模型，使它能够对观测序列给出标记序列作为预测。注意，可能的标记个数是有限的，但其组合所成的标记序列的个数是依序列长度呈指数级增长的。</p>
<p>标注常用的统计学习方法有：隐马尔可夫模型、条件随机场。</p>
<h3 id="回归问题"><a href="#回归问题" class="headerlink" title="回归问题"></a>回归问题</h3><p>回归用于预测输入变量（自变量）和输出变量（因变量）之间的关系，特别是当输入变量的值发生变化时，输出变量的值随之发生的变化。</p>
<p>回归问题按照输入变量的个数，分为一元回归和多元回归；按照输入变量和输出变量之前的关系的类型即模型的类型，分类线性回归和非线性回归。</p>
<p>回归学习最常用的损失函数是平方损失函数，在此情况下，回归问题可以由著名的最小二乘法（least squares）求解。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wetts.github.io/2019/07/23/artificial_intelligence/%E8%AF%AF%E5%B7%AE&%E4%BC%98%E5%8C%96/%E6%9F%A5%E5%87%86%E7%8E%87%E3%80%81%E6%9F%A5%E5%85%A8%E7%8E%87%E3%80%81F1%E3%80%81ROC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Zhang Wetts">
      <meta itemprop="description" content="Stay Hungry, Stay Foolish. <br><br><p style="font-size:8px;">[build by hexo/next/gitalk/hexo-generator-search/LaTeX]</p>">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wetts's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/07/23/artificial_intelligence/%E8%AF%AF%E5%B7%AE&%E4%BC%98%E5%8C%96/%E6%9F%A5%E5%87%86%E7%8E%87%E3%80%81%E6%9F%A5%E5%85%A8%E7%8E%87%E3%80%81F1%E3%80%81ROC/" class="post-title-link" itemprop="url">查准率、查全率、F1、ROC</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-07-23 21:18:29" itemprop="dateCreated datePublished" datetime="2019-07-23T21:18:29+08:00">2019-07-23</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">机器学习</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="accuracy、查准率、查全率"><a href="#accuracy、查准率、查全率" class="headerlink" title="accuracy、查准率、查全率"></a>accuracy、查准率、查全率</h4><p><img src="/2019/07/23/artificial_intelligence/%E8%AF%AF%E5%B7%AE&%E4%BC%98%E5%8C%96/%E6%9F%A5%E5%87%86%E7%8E%87%E3%80%81%E6%9F%A5%E5%85%A8%E7%8E%87%E3%80%81F1%E3%80%81ROC/1.png" alt="1"></p>
<ul>
<li>准确率（accuracy）：= 预测对的/所有 = (TP+TN)/(TP+FN+FP+TN)</li>
<li>查准率（precision）：P=TP/(TP+FP)（预测结果和真实结果都为正的样本占总的预测结果为正的样本的比例）（挑出的西瓜种有多少比例是好瓜）</li>
<li>查全率（recall）：R=TP/(TP+FN)（预测结果和真实结果都为正的样本占总的正样本的比例）（所有好瓜中有多少比例被挑了出来）</li>
</ul>
<p>查准率和查全率是一对矛盾的度量，一般来说，查准率高时，查全率往往偏低；而查全率高时，查准率往往偏低。在信息检索中，查准率就是检索出的信息有多少比例是用户感兴趣的；查全率则是用户感兴趣的信息有多少被检索出来。查准率分母中就包含了那些不是用户感兴趣的信息，但仍被预测为是用户感兴趣的而被检索出来；查全率分母中则包含了那些是用户感兴趣的信息，但为被预测为用户感兴趣而被抛弃未检索出来。</p>
<p>对于差准率和查全率的使用是需要按情况来确定那个更重要，例如地震的预测查全率更重要，不希望遗漏哪一次地震，但是对于给用户推荐的广告查准率更重要，要推荐给用户更愿意点击的广告。</p>
<h4 id="P-R曲线"><a href="#P-R曲线" class="headerlink" title="P-R曲线"></a>P-R曲线</h4><p>可根据学习器的预测结果对样例进行排序，排在前面的是学习器认为最可能是正例的样本，排在最后的则是学习器认为最不可能是正例的样本。按此顺序逐个把样本作为正例进行预测，则每次可以计算出当前的查全率、查准率，并以查准率为纵轴、查全率为横轴构造查准率-查全率曲线，简称P-R曲线。</p>
<p>P-R曲线是非单调、不平滑的。P-R曲线可用来评估学习器的优劣。若一个学习器的P-R曲线被另一个学习器的P-R曲线完全包住，则后者的性能优于前者。如果两个学习器的曲线发生交叉，则通过二者面积的大小来比较，面积大的表示查全率和查准率双高比较优秀，但不太容易计算曲线（不平滑）的面积，因此通过平衡点（Break-Even Point，简称BEP）来度量。BEP是坐标上查准率等于查全率时的点，平衡点值越大，学习器越优秀。</p>
<p>用了简单的图来说明，红色的点就是三条P-R曲线的BEP点，学习器A的曲线被C包住，C比较优秀，而C和B交叉，用面积计算难以估算，但C的BEP值大于B，所以C比较优秀。</p>
<p><img src="/2019/07/23/artificial_intelligence/%E8%AF%AF%E5%B7%AE&%E4%BC%98%E5%8C%96/%E6%9F%A5%E5%87%86%E7%8E%87%E3%80%81%E6%9F%A5%E5%85%A8%E7%8E%87%E3%80%81F1%E3%80%81ROC/PR.png" alt="1"></p>
<p>BEP过于简化，定义F1常量来比较学习器P-R曲线的性能：</p>
<ul>
<li>F1度量：<code>F1=(2*P*R)/(P+R)=2*TP/(样例总数+TP-TN)</code></li>
</ul>
<p>F1是基于查准率与查全率的调和平均（harmonic mean）定义的：<code>1/F1=1/2*(1/P+1/R)</code></p>
<p>更一般的形式：<code>Fβ=(1+β^2)*P*R/((β^2*P)+R）</code></p>
<p>其中β&gt;0度量了查全率对查准率的相对重要性；β=1时就是标准的F1；β&gt;1时偏好查全率；β&lt;1时偏好查准率。</p>
<p>Fβ则是加权调和平均：<code>1/Fβ=(1/P+β^2/R)/(1+β^2)</code></p>
<h4 id="ROC、AUC"><a href="#ROC、AUC" class="headerlink" title="ROC、AUC"></a>ROC、AUC</h4><p>ROC和AUC类似，也是通过绘制两个变量的概率图像来解释分类器效果的评判准则,ROC曲线的纵轴是“真正例率”TPR，横轴是“假正例率”FPR。其中：</p>
<ul>
<li>真正例率(True Postive Rate)TPR: <code>TP/(TP+FN)</code>,代表分类器预测的正类中实际正实例占所有正实例的比例。Sensitivity</li>
<li>假正例率(False Postive Rate)FPR: <code>FP/(FP+TN)</code>，代表分类器预测的正类中实际负实例占所有负实例的比例。1-Specificity</li>
<li>真负例率(True Negative Rate)TNR: <code>TN/(FP+TN)</code>,代表分类器预测的负类中实际负实例占所有负实例的比例，TNR=1-FPR。Specificity</li>
</ul>
<p>AUC的几何意义ROC曲线下的面积。</p>
<p>概率学上的意义：随机选取一个正例和一个负例，分类器给正例的打分大于分类器给负例的打分的概率。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wetts.github.io/2019/07/11/%E8%AF%AD%E8%A8%80/Python/%E5%AF%B9%E8%B1%A1/Python%E4%B8%AD%E7%9A%84%E8%A3%85%E9%A5%B0%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Zhang Wetts">
      <meta itemprop="description" content="Stay Hungry, Stay Foolish. <br><br><p style="font-size:8px;">[build by hexo/next/gitalk/hexo-generator-search/LaTeX]</p>">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wetts's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/07/11/%E8%AF%AD%E8%A8%80/Python/%E5%AF%B9%E8%B1%A1/Python%E4%B8%AD%E7%9A%84%E8%A3%85%E9%A5%B0%E5%99%A8/" class="post-title-link" itemprop="url">Python中的装饰器</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-07-11 13:20:40" itemprop="dateCreated datePublished" datetime="2019-07-11T13:20:40+08:00">2019-07-11</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Python/" itemprop="url" rel="index"><span itemprop="name">Python</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>转自：<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_41179709/article/details/81879601">https://blog.csdn.net/weixin_41179709/article/details/81879601</a></p>
<h2 id="装饰器介绍"><a href="#装饰器介绍" class="headerlink" title="装饰器介绍"></a>装饰器介绍</h2><p>装饰器就是对被装饰的对象（函数、类）进行重构的，其可以在不改变原来对象的情况下调用对象时执行重构后的行为 </p>
<ol>
<li>解决问题：在函数执行之前和执行之后添加功能，调用函数的方式改变了 </li>
<li>不改变原有函数的调用方法:函数里面嵌套函数，并且返回嵌套的函数 </li>
</ol>
<p>例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">##引题：当登陆某系统时常常会有欢迎语，但修改时将在登陆函数中修改，可能会出现问题，所以避免直接侵入原函数修改。</span><br><span class="line">def login():</span><br><span class="line">    print(&quot;中秋快乐&quot;)</span><br><span class="line">    print(&quot;login....&quot;)</span><br><span class="line">    print(&quot;欢迎您下次光临....&quot;)</span><br><span class="line">login()</span><br><span class="line"></span><br><span class="line">##为了避免在大的函数块中操作，将欢迎语独立出来，另建函数。</span><br><span class="line">def desc(fun):</span><br><span class="line">    def add_info():</span><br><span class="line">        print(&quot;中秋快乐&quot;)</span><br><span class="line">        fun()</span><br><span class="line">        print(&quot;欢迎您下次光临&quot;)</span><br><span class="line">    return add_info</span><br><span class="line">def login():</span><br><span class="line">    print(&quot;login....&quot;)</span><br><span class="line">login = desc(login)</span><br><span class="line">login()</span><br></pre></td></tr></table></figure>

<h2 id="装饰器语法糖"><a href="#装饰器语法糖" class="headerlink" title="装饰器语法糖"></a>装饰器语法糖</h2><p>在Python中，可以使用”@”语法糖来精简装饰器的代码，把 decorator 置于函数的定义处，免去给函数重新赋值(即function = decorator(funtion)) </p>
<p>例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import functools           #functools 标准库</span><br><span class="line">import time                #time 时间函数</span><br><span class="line"></span><br><span class="line">def add_log(fun):</span><br><span class="line">    @functools.wraps(fun)           #不用此模块add(x,y)函数的__name__，__doc__都会丢失</span><br><span class="line">    def wrapper(*args,**kwargs):   #*args为元组  **kwargs为字典</span><br><span class="line">        start_time = time.time()</span><br><span class="line">        res = fun(*args,**kwargs)</span><br><span class="line">        end_time = time.time()</span><br><span class="line">        print(&quot;[%s] 函数名：%s, 运行时间 ：%.5f ,运行返回值：% d&quot;</span><br><span class="line">              %(time.ctime(),fun.__name__,end_time- start_time,res))</span><br><span class="line">        return res                  #返回值为所要装饰的函数</span><br><span class="line">    return wrapper                 #返回值为所要修饰函数所添加的模块</span><br><span class="line">@add_log                            ##调用语法糖</span><br><span class="line">def add(x,y):</span><br><span class="line">    time.sleep(0.1)</span><br><span class="line">    return x+y</span><br><span class="line">print(add(1,2))</span><br></pre></td></tr></table></figure>

<h2 id="装饰的函数有返回值"><a href="#装饰的函数有返回值" class="headerlink" title="装饰的函数有返回值"></a>装饰的函数有返回值</h2><p>解决办法：给返回值赋值</p>
<p>例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">def timeit(fun):</span><br><span class="line">    def wrapper(*args,**kwargs):    #接收可变参数和关键字参数</span><br><span class="line">        #args:元组 kwargs：字典  args=(5,)</span><br><span class="line">        #原函数执行之前</span><br><span class="line">        start_time = time.time()</span><br><span class="line">        #执行函数</span><br><span class="line">        res = fun(*args,**kwargs)   #args解包</span><br><span class="line">        #执行函数</span><br><span class="line">        end_time = time.time()</span><br><span class="line">        print(&quot;运行时间为:%.6f&quot; % (end_time - start_time))</span><br><span class="line">    return res</span><br><span class="line">    return wrapper</span><br><span class="line"></span><br><span class="line">@timeit</span><br><span class="line">def list_create(n):</span><br><span class="line">    return(i*2 for i in range(n)])</span><br><span class="line"></span><br><span class="line">@timeit</span><br><span class="line">def map_create(n):</span><br><span class="line">    return(list(map(lambda x:x*2,range(n))))</span><br><span class="line"></span><br><span class="line">list_create(5)</span><br><span class="line">map_create(5)</span><br><span class="line">print(list_create(100))     ##wrapper(100)</span><br></pre></td></tr></table></figure>

<h2 id="保留被装饰的函数的函数名和帮助文档信息"><a href="#保留被装饰的函数的函数名和帮助文档信息" class="headerlink" title="保留被装饰的函数的函数名和帮助文档信息"></a>保留被装饰的函数的函数名和帮助文档信息</h2><p>解决办法：导入functools标准库,使用functools.wraps函数，保留被装饰的函数的函数名和帮助文档信息。</p>
<p>例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">import  functools</span><br><span class="line">def timeit(fun):</span><br><span class="line">    &quot;&quot;&quot;这是一个装饰器timeit&quot;&quot;&quot;    </span><br><span class="line">    @functools.wraps(fun)       ##内置装饰器</span><br><span class="line">    可以保留被装饰的函数的函数名和帮助文档信息   </span><br><span class="line">    def wrapper(*args,**kwargs):    #接收可变参数和关键字参数</span><br><span class="line">        &quot;&quot;&quot;这是一个wrapper函数&quot;&quot;&quot;</span><br><span class="line">        #args:元组 kwargs：字典  args=(5,)</span><br><span class="line">        #原函数执行之前</span><br><span class="line">        start_time = time.time()</span><br><span class="line">        #执行函数</span><br><span class="line">        res = fun(*args,**kwargs)   #args解包</span><br><span class="line">        #执行函数</span><br><span class="line">        end_time = time.time()</span><br><span class="line">        print(&quot;运行时间为:%.6f&quot; % (end_time - start_time))</span><br><span class="line">    return res</span><br><span class="line">    return wrapper</span><br><span class="line">@timeit</span><br><span class="line">def fun():</span><br><span class="line">    print(&quot;hello&quot;)</span><br><span class="line">print(fun_list.__name__)</span><br><span class="line">print(fun_list.__doc__)</span><br></pre></td></tr></table></figure>

<h2 id="装饰器中不同条件下执行不同的函数"><a href="#装饰器中不同条件下执行不同的函数" class="headerlink" title="装饰器中不同条件下执行不同的函数"></a>装饰器中不同条件下执行不同的函数</h2><p>用实例说明：需求: 用户来CSDN登陆验证的装饰器is_login</p>
<ol>
<li>如果用户登陆成功, 则执行被装饰的函数;</li>
<li>如果用户登陆不成功, 则执行登陆函数</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">import functools</span><br><span class="line">login_users = [&#x27;admin&#x27;, &#x27;root&#x27;]</span><br><span class="line"></span><br><span class="line">def is_login(fun):  # fun: writeBlog</span><br><span class="line">    @functools.wraps(fun)</span><br><span class="line">    def wrapper(*args, **kwargs):   # name=&quot;admin&quot;  # kwargs=&#123;&quot;name&quot;:&quot;admin&quot;&#125;</span><br><span class="line">        # 判断写博客的这个用户是否登陆成功;</span><br><span class="line">        if kwargs.get(&quot;name&quot;) in login_users:</span><br><span class="line">            res = fun(*args, **kwargs)</span><br><span class="line">            return res</span><br><span class="line">        else:</span><br><span class="line">            res=login()</span><br><span class="line">        return res</span><br><span class="line"></span><br><span class="line">    return wrapper</span><br><span class="line"></span><br><span class="line"># 必须登陆成功</span><br><span class="line">@is_login    # writeBlog = is_login(writeBlog)</span><br><span class="line">def writeBlog(name):</span><br><span class="line">    return &quot;编写博客&quot;</span><br><span class="line"></span><br><span class="line">def login():</span><br><span class="line">    return &quot;登陆。。。。&quot;</span><br><span class="line"></span><br><span class="line"># 是否登陆成功都可以执行代码</span><br><span class="line">def news():</span><br><span class="line">    print(&quot;新闻......&quot;)</span><br><span class="line"></span><br><span class="line">print(writeBlog(name=&quot;admin&quot;))</span><br></pre></td></tr></table></figure>

<h2 id="多个装饰器"><a href="#多个装饰器" class="headerlink" title="多个装饰器"></a>多个装饰器</h2><p>若有两个装饰器，从上到下调用装饰器，wrapper内容也是为由上向下执行 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">def makebold(fun):</span><br><span class="line">    print(&quot;bold1&quot;)</span><br><span class="line">    def wrapper1(*args, **kwargs):</span><br><span class="line">        print(&quot;bold2&quot;)</span><br><span class="line">        return  fun(*args, **kwargs)  # wrapper</span><br><span class="line">    return  wrapper1</span><br><span class="line">def makei(fun):   # fun=login</span><br><span class="line">    print(&quot;i1&quot;)</span><br><span class="line">    def wrapper(*args, **kwargs):</span><br><span class="line">        print(&quot;i2&quot;)</span><br><span class="line">        return  fun(*args, **kwargs)</span><br><span class="line">    return  wrapper</span><br><span class="line"># 当有多个装饰器时，从上到下调用装饰器</span><br><span class="line"># 真实wrapper内容执行是从上到下执行</span><br><span class="line">@makebold   #login = makebold(login)    #login为wrapper1</span><br><span class="line">@makei      #login = makei(login)       #login为wrapper</span><br><span class="line">def login():</span><br><span class="line">    return &quot;登陆&quot;</span><br><span class="line">print(login())</span><br></pre></td></tr></table></figure>

<h2 id="带有参数的装饰器"><a href="#带有参数的装饰器" class="headerlink" title="带有参数的装饰器"></a>带有参数的装饰器</h2><p>创建装饰器， 要求如下：</p>
<ol>
<li>创建add_log装饰器， 被装饰的函数打印日志信息；</li>
<li>日志格式为: <code>[字符串时间] 函数名: xxx， 运行时间：xxx, 运行返回值结果:xxx</code></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"># 创建装饰器， 要求如下：</span><br><span class="line"># 1. 创建add_log装饰器， 被装饰的函数打印日志信息；</span><br><span class="line"># 2. 日志格式为: [字符串时间] 函数名: xxx， 运行时间：xxx, 运行返回值结果:xxx</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import functools</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line"># format</span><br><span class="line">def log(kind):  # kind=&quot;debug&quot;</span><br><span class="line">    def add_log(fun):</span><br><span class="line">        @functools.wraps(fun)</span><br><span class="line">        def wrapper(*args, **kwargs):</span><br><span class="line">            start_time = time.time()</span><br><span class="line">            res = fun(*args, **kwargs)</span><br><span class="line">            end_time = time.time()</span><br><span class="line">            print(&quot;&lt;%s&gt; [%s] 函数名: %s， 运行时间：%.5f, 运行返回值结果:%d&quot;</span><br><span class="line">                  %(kind, time.ctime(), fun.__name__, end_time-start_time, res )</span><br><span class="line">                  )</span><br><span class="line">            return res</span><br><span class="line">        return wrapper</span><br><span class="line">    return  add_log</span><br><span class="line">@log(&quot;debug&quot;)</span><br><span class="line">#  log(&quot;debug&quot;)==&gt; 返回值是add_log</span><br><span class="line">#  add=add_log(add)</span><br><span class="line">def add(x,y):</span><br><span class="line">    time.sleep(0.1)</span><br><span class="line">    return x+y</span><br><span class="line">print(add(14214124124,1241231231313))</span><br><span class="line"># wrapper(14214124124,1241231231313)</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wetts.github.io/2019/07/06/%E8%AF%AD%E8%A8%80/Python/%E5%AF%B9%E8%B1%A1/Python%E4%B8%AD%E7%9A%84%E7%94%9F%E6%88%90%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Zhang Wetts">
      <meta itemprop="description" content="Stay Hungry, Stay Foolish. <br><br><p style="font-size:8px;">[build by hexo/next/gitalk/hexo-generator-search/LaTeX]</p>">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wetts's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/07/06/%E8%AF%AD%E8%A8%80/Python/%E5%AF%B9%E8%B1%A1/Python%E4%B8%AD%E7%9A%84%E7%94%9F%E6%88%90%E5%99%A8/" class="post-title-link" itemprop="url">Python中的生成器</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-07-06 11:39:43" itemprop="dateCreated datePublished" datetime="2019-07-06T11:39:43+08:00">2019-07-06</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Python/" itemprop="url" rel="index"><span itemprop="name">Python</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>转自：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/deeper/p/7565571.html">https://www.cnblogs.com/deeper/p/7565571.html</a></p>
<p>理解了迭代器以后，生成器就会简单很多，因为生成器其实是一种特殊的迭代器。不过这种迭代器更加优雅。它不需要再像上面的类一样写<code>__iter__()</code>和<code>__next__()</code>方法了，只需要一个yiled关键字。 生成器一定是迭代器（反之不成立），因此任何生成器也是以一种懒加载的模式生成值。</p>
<p>语法上说，生成器函数是一个带yield关键字的函数。</p>
<p>调用生成器函数后会得到一个生成器对象，这个生成器对象实际上就是一个特殊的迭代器，拥有<code>__iter__()</code>和<code>__next__()</code>方法</p>
<p>我们先用一个例子说明一下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def generator_winter():</span><br><span class="line">...   i = 1</span><br><span class="line">...   while i &lt;= 3:</span><br><span class="line">...     yield i</span><br><span class="line">...     i += 1</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; generator_winter</span><br><span class="line">&lt;function generator_winter at 0x000000000323B9D8&gt;</span><br><span class="line">&gt;&gt;&gt; generator_iter = generator_winter()</span><br><span class="line">&gt;&gt;&gt; generator_iter</span><br><span class="line">&lt;generator object generator_winter at 0x0000000002D9CAF0&gt;</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">&gt;&gt;&gt; generator_iter.__next__()</span><br><span class="line">1</span><br><span class="line">&gt;&gt;&gt; generator_iter.__next__()</span><br><span class="line">2</span><br><span class="line">&gt;&gt;&gt; generator_iter.__next__()</span><br><span class="line">3</span><br><span class="line">&gt;&gt;&gt; generator_iter.__next__()</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">StopIteration</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p>现在解释一下上面的代码：</p>
<ol>
<li>首先我们创建了一个含有yield关键字的函数generator_winter，这是一个生成器函数</li>
<li>然后，我们调用了这个生成器函数，并且将返回值赋值给了generator_iter，generator_iter是一个生成器对象；__注意generator_iter = generator_winter()时，函数体中的代码并不会执行，只有显示或隐示地调用next的时候才会真正执行里面的代码__。</li>
<li>生成器对象就是一个迭代器，所以我们可以调用对象的__next__方法来每次返回一个迭代器的值；迭代器的值通过yield返回；并且迭代完最后一个元素后，触发StopIteration异常；</li>
</ol>
<p>既然生成器对象是一个迭代器，我们就可以使用for循环来迭代这个生成器对象：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def generator_winter():</span><br><span class="line">...   i = 1</span><br><span class="line">...   while i &lt;= 3:</span><br><span class="line">...     yield i</span><br><span class="line">...     i += 1</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">&gt;&gt;&gt; for item in generator_winter():</span><br><span class="line">...   print(item)</span><br><span class="line">...</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>我们注意到迭代器不是使用return来返回值，而是采用yield返回值；那么这个yield有什么特别之处呢？</p>
<h4 id="yield"><a href="#yield" class="headerlink" title="yield"></a>yield</h4><p>我们知道，一个函数只能返回一次，即return以后，这次函数调用就结束了；</p>
<p>但是生成器函数可以暂停执行，并且通过yield返回一个中间值，当生成器对象的<code>__next__()</code>方法再次被调用的时候，生成器函数可以从上一次暂停的地方继续执行，直到触发一个StopIteration</p>
<p>上例中，当执行到yield i后，函数返回i值，然后print这个值，下一次循环，又调用<code>__next__()</code>方法，回到生成器函数，并从yield i的下一句继续执行；</p>
<p>摘一段&lt;python核心编程&gt;的内容：</p>
<blockquote>
<p>生成器的另外一个方面甚至更加强力—-协同程序的概念。协同程序是可以运行的独立函数调用，可以暂停或者挂起，并从程序离开的地方继续或者重新开始。在有调用者和(被调用的)协同程序也有通信。举例来说，当协同程序暂停时，我们仍可以从其中获得一个中间的返回值，当调用回到程序中时，能够传入额外或者改变了的参数，但是仍然能够从我们上次离开的地方继续，并且所有状态完整。挂起返回出中间值并多次继续的协同程序被称为生成器，那就是python的生成真正在做的事情。这些提升让生成器更加接近一个完全的协同程序，因为允许值(和异常)能传回到一个继续的函数中，同样的，当等待一个生成器的时候，生成器现在能返回控制，在调用的生成器能挂起(返回一个结果)之前，调用生成器返回一个结果而不是阻塞的等待那个结果返回。</p>
</blockquote>
<h4 id="什么情况会触发StopIteration"><a href="#什么情况会触发StopIteration" class="headerlink" title="什么情况会触发StopIteration"></a>什么情况会触发StopIteration</h4><p>两种情况会触发StopIteration</p>
<ol>
<li>如果没有return，则默认执行到函数完毕时返回StopIteration；</li>
<li>如果在执行过程中 return，则直接抛出 StopIteration 终止迭代；如果在return后返回一个值，那么这个值为StopIteration异常的说明，不是程序的返回值。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def generator_winter():</span><br><span class="line">...   yield &#x27;hello world&#x27;</span><br><span class="line">...   return &#x27;again&#x27;</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">&gt;&gt;&gt; winter = generator_winter()</span><br><span class="line">&gt;&gt;&gt; winter.__next__()</span><br><span class="line">&#x27;hello world&#x27;</span><br><span class="line">&gt;&gt;&gt; winter.__next__()</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">StopIteration: again</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="生成器的作用"><a href="#生成器的作用" class="headerlink" title="生成器的作用"></a>生成器的作用</h4><p>说了这么多，生成器有什么用呢？作为python主要特性之一，这是个极其牛逼的东西，由于它是惰性的，在处理大型数据时，可以节省大量内存空间；</p>
<p>当你需要迭代一个巨大的数据集合，比如创建一个有规律的100万个数字，如果采用列表来存储访问，那么会占用大量的内存空间；而且如果我们只是访问这个列表的前几个元素，那么后边大部分元素占据的内存空间就白白浪费了；这时，如果采用生成器，则不必创建完整的列表，一次循环返回一个希望得到的值，这样就可以大量节省内存空间；</p>
<p>这里在举例之前，我们先介绍一个生成器表达式（类似于列表推导式，只是把[]换成()），这样就创建了一个生成器。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; gen = (x for x in range(10))</span><br><span class="line">&gt;&gt;&gt; gen</span><br><span class="line">&lt;generator object &lt;genexpr&gt; at 0x0000000002A923B8&gt;</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>生成器表达式的语法如下：<code>(expr for iter_var in iterable if cond_expr)</code><br>用生成器来实现斐波那契数列</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def fib(n):</span><br><span class="line">    a, b = 0, 1</span><br><span class="line">    while b &lt;= n:</span><br><span class="line">        yield b</span><br><span class="line">        a, b = b, a+b</span><br><span class="line"></span><br><span class="line">f = fib(10)</span><br><span class="line">for item in f:</span><br><span class="line">    print(item)</span><br></pre></td></tr></table></figure>

<h4 id="生成器方法"><a href="#生成器方法" class="headerlink" title="生成器方法"></a>生成器方法</h4><p>直接看生成器源代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class __generator(object):</span><br><span class="line">    &#x27;&#x27;&#x27;A mock class representing the generator function type.&#x27;&#x27;&#x27;</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.gi_code = None</span><br><span class="line">        self.gi_frame = None</span><br><span class="line">        self.gi_running = 0</span><br><span class="line"></span><br><span class="line">    def __iter__(self):</span><br><span class="line">        &#x27;&#x27;&#x27;Defined to support iteration over container.&#x27;&#x27;&#x27;</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">    def __next__(self):</span><br><span class="line">        &#x27;&#x27;&#x27;Return the next item from the container.&#x27;&#x27;&#x27;</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">    def close(self):</span><br><span class="line">        &#x27;&#x27;&#x27;Raises new GeneratorExit exception inside the generator to terminate the iteration.&#x27;&#x27;&#x27;</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">    def send(self, value):</span><br><span class="line">        &#x27;&#x27;&#x27;Resumes the generator and &quot;sends&quot; a value that becomes the result of the current yield-expression.&#x27;&#x27;&#x27;</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">    def throw(self, type, value=None, traceback=None):</span><br><span class="line">        &#x27;&#x27;&#x27;Used to raise an exception inside the generator.&#x27;&#x27;&#x27;</span><br><span class="line">        pass</span><br></pre></td></tr></table></figure>
<p>首先看到了生成器是自带<code>__iter__</code>和<code>__next__</code>魔术方法的；</p>
<h5 id="send"><a href="#send" class="headerlink" title="send"></a>send</h5><p>生成器函数最大的特点是可以接受外部传入的一个变量，并根据变量内容计算结果后返回。这是生成器函数最难理解的地方，也是最重要的地方，协程的实现就全靠它了。</p>
<p>看一个小猫吃鱼的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def cat():</span><br><span class="line">    print(&#x27;我是一只hello kitty&#x27;)</span><br><span class="line">    while True:</span><br><span class="line">        food = yield</span><br><span class="line">        if food == &#x27;鱼肉&#x27;:</span><br><span class="line">            yield &#x27;好开心&#x27;</span><br><span class="line">        else:</span><br><span class="line">            yield &#x27;不开心，人家要吃鱼肉啦&#x27;</span><br></pre></td></tr></table></figure>

<p>中间有个赋值语句food = yield，可以通过send方法来传参数给food，试一下：</p>
<p> 情况1）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">miao = cat()    #只是用于返回一个生成器对象，cat函数不会执行</span><br><span class="line">print(&#x27;&#x27;.center(50,&#x27;-&#x27;))</span><br><span class="line">print(miao.send(&#x27;鱼肉&#x27;))</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">--------------------------------------------------</span><br><span class="line">  File &quot;C:/Users//Desktop/Python/cnblogs/subModule.py&quot;, line 67, in &lt;module&gt;</span><br><span class="line">    print(miao.send(&#x27;鱼肉&#x27;))</span><br><span class="line">TypeError: can&#x27;t send non-None value to a just-started generator</span><br></pre></td></tr></table></figure>
<p>看到了两个信息：</p>
<ol>
<li>miao = cat() ，只是用于返回一个生成器对象，cat函数不会执行</li>
<li>can’t send non-None value to a just-started generator；不能给一个刚创建的生成器对象直接send值</li>
</ol>
<p>改一下</p>
<p>情况2）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">miao = cat()</span><br><span class="line">miao.__next__()</span><br><span class="line">print(miao.send(&#x27;鱼肉&#x27;))</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">我是一只hello kitty</span><br><span class="line">好开心</span><br></pre></td></tr></table></figure>
<p>没毛病，那么到底send()做了什么呢？send()的帮助文档写的很清楚，<code>&#39;&#39;&#39;Resumes the generator and &quot;sends&quot; a value that becomes the result of the current yield-expression.&#39;&#39;&#39;</code>；可以看到send依次做了两件事：</p>
<ol>
<li>回到生成器挂起的位置，继续执行</li>
<li>并将send(arg)中的参数赋值给对应的变量，如果没有变量接收值，那么就只是回到生成器挂起的位置</li>
</ol>
<p>但是，我认为send还做了第三件事：<br>3. 兼顾<code>__next__()</code>作用，挂起程序并返回值，所以我们在<code>print(miao.send(&#39;鱼肉&#39;))</code>时，才会看到’好开心’；其实<code>__next__()</code>等价于<code>send(None)</code></p>
<p>所以当我们尝试这样做的时候：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">def cat():</span><br><span class="line">    print(&#x27;我是一只hello kitty&#x27;)</span><br><span class="line">    while True:</span><br><span class="line">        food = yield</span><br><span class="line">        if food == &#x27;鱼肉&#x27;:</span><br><span class="line">            yield &#x27;好开心&#x27;</span><br><span class="line">        else:</span><br><span class="line">            yield &#x27;不开心，人家要吃鱼肉啦&#x27;</span><br><span class="line"></span><br><span class="line">miao = cat()</span><br><span class="line">print(miao.__next__())</span><br><span class="line">print(miao.send(&#x27;鱼肉&#x27;))</span><br><span class="line">print(miao.send(&#x27;骨头&#x27;))</span><br><span class="line">print(miao.send(&#x27;鸡肉&#x27;))</span><br></pre></td></tr></table></figure>
<p>就会得到这个结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">我是一只hello kitty</span><br><span class="line">None</span><br><span class="line">好开心</span><br><span class="line">None</span><br><span class="line">不开心，人家要吃鱼肉啦</span><br></pre></td></tr></table></figure>
<p>我们按步骤分析一下：</p>
<ol>
<li>执行到<code>print(miao.__next__())</code>，执行cat()函数，print了”我是一只hello kitty”，然后在food = yield挂起，并返回了None，打印None</li>
<li>接着执行<code>print(miao.send(&#39;鱼肉&#39;))</code>，回到food = yield，并将’鱼肉’赋值给food，生成器函数恢复执行；直到运行到<code>yield &#39;好开心&#39;</code>，程序挂起，返回’好开心’，并print ‘好开心’</li>
<li>接着执行<code>print(miao.send(&#39;骨头&#39;))</code>，回到<code>yield &#39;好开心&#39;</code>，这时没有变量接收参数’骨头’，生成器函数恢复执行；直到<code>food = yield</code>，程序挂起，返回None，并print None</li>
<li>接着执行<code>print(miao.send(&#39;鸡肉&#39;))</code>，回到food = yield，并将’鸡肉’赋值给food，生成器函数恢复执行；直到运行到<code>yield &#39;不开心，人家要吃鱼肉啦&#39;</code>，程序挂起，返回’不开心，人家要吃鱼肉啦’，，并print ‘不开心，人家要吃鱼肉啦’</li>
</ol>
<p>大功告成；那我们优化一下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">def cat():</span><br><span class="line">    msg = &#x27;我是一只hello kitty&#x27;</span><br><span class="line">    while True:</span><br><span class="line">        food = yield msg</span><br><span class="line">        if food == &#x27;鱼肉&#x27;:</span><br><span class="line">            msg = &#x27;好开心&#x27;</span><br><span class="line">        else:</span><br><span class="line">            msg = &#x27;不开心，人家要吃鱼啦&#x27;</span><br><span class="line"></span><br><span class="line">miao = cat()</span><br><span class="line">print(miao.__next__())</span><br><span class="line">print(miao.send(&#x27;鱼肉&#x27;))</span><br><span class="line">print(miao.send(&#x27;鸡肉&#x27;))</span><br></pre></td></tr></table></figure>
<p>我们再看一个更实用的例子，一个计数器</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">def counter(start_at = 0):</span><br><span class="line">    count = start_at</span><br><span class="line">    while True:</span><br><span class="line">        val = (yield count)</span><br><span class="line">        if val is not None:</span><br><span class="line">            count = val</span><br><span class="line">        else:</span><br><span class="line">            count += 1</span><br><span class="line"></span><br><span class="line">count = counter(5)</span><br><span class="line">print(count.__next__())</span><br><span class="line">print(count.__next__())</span><br><span class="line">print(count.send(0))</span><br><span class="line">print(count.__next__())</span><br><span class="line">print(count.__next__())</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">6</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">2</span><br></pre></td></tr></table></figure>

<h5 id="close"><a href="#close" class="headerlink" title="close"></a>close</h5><p>帮助文档：<code>&#39;&#39;&#39;Raises new GeneratorExit exception inside the generator to terminate the iteration.&#39;&#39;&#39;</code></p>
<p>手动关闭生成器函数，后面的调用会直接返回StopIteration异常</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def gene():</span><br><span class="line">...   while True:</span><br><span class="line">...     yield &#x27;ok&#x27;</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; g = gene()</span><br><span class="line">&gt;&gt;&gt; g.__next__()</span><br><span class="line">&#x27;ok&#x27;</span><br><span class="line">&gt;&gt;&gt; g.__next__()</span><br><span class="line">&#x27;ok&#x27;</span><br><span class="line">&gt;&gt;&gt; g.close()</span><br><span class="line">&gt;&gt;&gt; g.__next__()</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">StopIteration</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>在close以后再执行<code>__next__</code>会触发StopIteration异常</p>
<h5 id="throw"><a href="#throw" class="headerlink" title="throw"></a>throw</h5><p>用来向生成器函数送入一个异常，throw()后直接抛出异常并结束程序，或者消耗掉一个yield，或者在没有下一个yield的时候直接进行到程序的结尾。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def gene():</span><br><span class="line">...   while True:</span><br><span class="line">...     try:</span><br><span class="line">...       yield &#x27;normal value&#x27;</span><br><span class="line">...     except ValueError:</span><br><span class="line">...       yield &#x27;we got ValueError here&#x27;</span><br><span class="line">...     except TypeError:</span><br><span class="line">...       break</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; g = gene()</span><br><span class="line">&gt;&gt;&gt; print(g.__next__())</span><br><span class="line">normal value</span><br><span class="line">&gt;&gt;&gt; print(g.__next__())</span><br><span class="line">normal value</span><br><span class="line">&gt;&gt;&gt; print(g.throw(ValueError))</span><br><span class="line">we got ValueError here</span><br><span class="line">&gt;&gt;&gt; print(g.__next__())</span><br><span class="line">normal value</span><br><span class="line">&gt;&gt;&gt; print(g.throw(TypeError))</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">StopIteration</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<h4 id="通过yield实现单线程情况下的异步并发效果"><a href="#通过yield实现单线程情况下的异步并发效果" class="headerlink" title="通过yield实现单线程情况下的异步并发效果"></a>通过yield实现单线程情况下的异步并发效果</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">def consumer(name):</span><br><span class="line">    print(&#x27;%s准备吃包子了&#x27; % name)</span><br><span class="line">    while True:</span><br><span class="line">        baozi_name = yield</span><br><span class="line">        print(&#x27;[%s]来了，被[%s]吃了&#x27;% (baozi_name, name))</span><br><span class="line"></span><br><span class="line">def producer(*name):</span><br><span class="line">    c1 = consumer(name[0])</span><br><span class="line">    c2 = consumer(name[1])</span><br><span class="line">    c1.__next__()</span><br><span class="line">    c2.__next__()</span><br><span class="line">    for times in range(5):</span><br><span class="line">        print(&#x27;做了两个包子&#x27;)</span><br><span class="line">        c1.send(&#x27;豆沙包%s&#x27;%times)</span><br><span class="line">        c2.send(&#x27;菜包%s&#x27;%times)</span><br><span class="line"></span><br><span class="line">producer(&#x27;winter&#x27;, &#x27;elly&#x27;)</span><br></pre></td></tr></table></figure>
<p>效果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">winter准备吃包子了</span><br><span class="line">elly准备吃包子了</span><br><span class="line">做了两个包子</span><br><span class="line">[豆沙包0]来了，被[winter]吃了</span><br><span class="line">[菜包0]来了，被[elly]吃了</span><br><span class="line">做了两个包子</span><br><span class="line">[豆沙包1]来了，被[winter]吃了</span><br><span class="line">[菜包1]来了，被[elly]吃了</span><br><span class="line">做了两个包子</span><br><span class="line">[豆沙包2]来了，被[winter]吃了</span><br><span class="line">[菜包2]来了，被[elly]吃了</span><br><span class="line">做了两个包子</span><br><span class="line">[豆沙包3]来了，被[winter]吃了</span><br><span class="line">[菜包3]来了，被[elly]吃了</span><br><span class="line">做了两个包子</span><br><span class="line">[豆沙包4]来了，被[winter]吃了</span><br><span class="line">[菜包4]来了，被[elly]吃了</span><br></pre></td></tr></table></figure>

<p>创建了两个独立的生成器，很有趣，很吊；</p>
<h4 id="补充几个小例子："><a href="#补充几个小例子：" class="headerlink" title="补充几个小例子："></a>补充几个小例子：</h4><h5 id="使用生成器创建一个range"><a href="#使用生成器创建一个range" class="headerlink" title="使用生成器创建一个range"></a>使用生成器创建一个range</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def range(n):</span><br><span class="line">    count = 0</span><br><span class="line">    while count &lt; n:</span><br><span class="line">        yield count</span><br><span class="line">        count += 1</span><br></pre></td></tr></table></figure>

<h5 id="使用生成器监听文件输入"><a href="#使用生成器监听文件输入" class="headerlink" title="使用生成器监听文件输入"></a>使用生成器监听文件输入</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def fileTail(filename):</span><br><span class="line">    with open(filename) as f:</span><br><span class="line">        while True:</span><br><span class="line">            tail = f.readline()</span><br><span class="line">            if line:</span><br><span class="line">                yield tail</span><br><span class="line">            else:</span><br><span class="line">                time.sleep(0.1)</span><br></pre></td></tr></table></figure>

<h5 id="计算移动平均值"><a href="#计算移动平均值" class="headerlink" title="计算移动平均值"></a>计算移动平均值</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def averager(start_with = 0):</span><br><span class="line">    count = 0</span><br><span class="line">    aver = start_with</span><br><span class="line">    total = start_with</span><br><span class="line">    while True:</span><br><span class="line">        val = yield aver</span><br><span class="line">        total += val</span><br><span class="line">        count += 1</span><br><span class="line">        aver = total/count</span><br></pre></td></tr></table></figure>
<p>有个弊端，需要通过<code>__next__</code>或<code>next()</code>初始化一次，通过预激解决</p>
<h5 id="预激计算移动平均值"><a href="#预激计算移动平均值" class="headerlink" title="预激计算移动平均值"></a>预激计算移动平均值</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">def init(f):</span><br><span class="line">    def wrapper(start_with = 0):</span><br><span class="line">        g_aver = f(start_with)</span><br><span class="line">        g_aver.__next__()</span><br><span class="line">        return g_aver</span><br><span class="line">    return wrapper</span><br><span class="line"></span><br><span class="line">@init</span><br><span class="line">def averager(start_with = 0):</span><br><span class="line">    count = 0</span><br><span class="line">    aver = start_with</span><br><span class="line">    total = start_with</span><br><span class="line">    while True:</span><br><span class="line">        val = yield aver</span><br><span class="line">        total += val</span><br><span class="line">        count += 1</span><br><span class="line">        aver = total/count</span><br></pre></td></tr></table></figure>

<h5 id="读取文件字符数最多的行的字符数"><a href="#读取文件字符数最多的行的字符数" class="headerlink" title="读取文件字符数最多的行的字符数"></a>读取文件字符数最多的行的字符数</h5><p>最传统的写法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def longestLine(filename):</span><br><span class="line">    with open(filename, &#x27;r&#x27;, encoding=&#x27;utf-8&#x27;) as f:</span><br><span class="line">        alllines = [len(x.strip()) for x in f]</span><br><span class="line">        return max(alllines)</span><br></pre></td></tr></table></figure>
<p>使用生成器以后的写法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def longestLine(filename):</span><br><span class="line">    return max(len(x.strip()) for x in open(filename))</span><br></pre></td></tr></table></figure>

<h5 id="多生成器迭代"><a href="#多生成器迭代" class="headerlink" title="多生成器迭代"></a>多生成器迭代</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; g = (i for i in range(5))</span><br><span class="line">&gt;&gt;&gt; for j in g:</span><br><span class="line">...   print(j)</span><br><span class="line">...</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">&gt;&gt;&gt; for j in g:</span><br><span class="line">...   print(j)</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>因为for j in g， 每次循环执行一次g.<strong>next</strong>()；直到结束，触发StopIteration；</p>
<p>主意下面结果的输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; g = (i for i in range(4))</span><br><span class="line">&gt;&gt;&gt; g1 = (x for x in g)</span><br><span class="line">&gt;&gt;&gt; g2 = (y for y in g1)</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">&gt;&gt;&gt; print(list(g1))</span><br><span class="line">[0, 1, 2, 3]</span><br><span class="line">&gt;&gt;&gt; print(list(g2))</span><br><span class="line">[]</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>为什么print(list(g2))为空呢？理一下，不然会乱：</p>
<p>看下面的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">def g():</span><br><span class="line">    print(&#x27;1.1&#x27;)</span><br><span class="line">    for i in range(2):</span><br><span class="line">        print(&#x27;1.2&#x27;)</span><br><span class="line">        yield i</span><br><span class="line">        print(&#x27;1.3&#x27;)</span><br><span class="line"></span><br><span class="line">def g1():</span><br><span class="line">    print(&#x27;2.1&#x27;)</span><br><span class="line">    for x in s:</span><br><span class="line">        print(&#x27;2.2&#x27;)</span><br><span class="line">        yield x</span><br><span class="line">        print(&#x27;2.3&#x27;)</span><br><span class="line"></span><br><span class="line">def g2():</span><br><span class="line">    print(&#x27;3.1&#x27;)</span><br><span class="line">    for y in s1:</span><br><span class="line">        print(&#x27;3.2&#x27;)</span><br><span class="line">        yield y</span><br><span class="line">        print(&#x27;3.3&#x27;)</span><br><span class="line"></span><br><span class="line">s = g()</span><br><span class="line">s1 = g1()</span><br><span class="line">s2 = g2()</span><br><span class="line">print(&#x27;start first list&#x27;)</span><br><span class="line">print(list(s1))</span><br><span class="line">print(&#x27;start second list&#x27;)</span><br><span class="line">print(list(s2))</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">start first list</span><br><span class="line">2.1</span><br><span class="line">1.1</span><br><span class="line">1.2</span><br><span class="line">2.2</span><br><span class="line">2.3</span><br><span class="line">1.3</span><br><span class="line">1.2</span><br><span class="line">2.2</span><br><span class="line">2.3</span><br><span class="line">1.3</span><br><span class="line">[0, 1]</span><br><span class="line">start second list</span><br><span class="line">3.1</span><br><span class="line">[]</span><br></pre></td></tr></table></figure>
<p>注意第11行之后，g触发了StopIteration，被<code>for x in s</code>捕捉，即不能继续<code>s.__next__()</code>了；同样的g1触发StopIteration，被list捕捉，即不能继续<code>s1.__next__()</code>了；于是打印[0,1]</p>
<p>当进行<code>print(list(s2))</code>时，执行<code>s2.__next__()</code>，停留在代码的第17行for y in s1，但是这是不能继续<code>s1.__next__()</code>了；于是直接触发了StopIteration；结果为[]</p>
<p>再看一个有意思的输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def add(n,i):</span><br><span class="line">    return n+i</span><br><span class="line"></span><br><span class="line">g = (i for i in range(4))</span><br><span class="line"></span><br><span class="line">for n in [1,10]:</span><br><span class="line">    g = (add(n,i) for i in g)</span><br><span class="line"></span><br><span class="line">print(list(g))</span><br></pre></td></tr></table></figure>
<p>输出为：<code>[20, 21, 22, 23]</code></p>
<p>其实上面的代码翻译如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">def add(n,i):</span><br><span class="line">    return n+i</span><br><span class="line"></span><br><span class="line">def g1():</span><br><span class="line">    for i in g:</span><br><span class="line">        yield add(n,i)</span><br><span class="line"></span><br><span class="line">def g2():</span><br><span class="line">    for i in s1:</span><br><span class="line">        yield add(n,i)</span><br><span class="line"></span><br><span class="line">n = 1</span><br><span class="line">s1 = g1()</span><br><span class="line">n = 10</span><br><span class="line">s2 = g2()</span><br><span class="line">print(list(s2))</span><br></pre></td></tr></table></figure>
<p>最终n用的是10,</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wetts.github.io/2019/07/06/%E8%AF%AD%E8%A8%80/Python/%E5%AF%B9%E8%B1%A1/Python%E4%B8%AD%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Zhang Wetts">
      <meta itemprop="description" content="Stay Hungry, Stay Foolish. <br><br><p style="font-size:8px;">[build by hexo/next/gitalk/hexo-generator-search/LaTeX]</p>">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wetts's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/07/06/%E8%AF%AD%E8%A8%80/Python/%E5%AF%B9%E8%B1%A1/Python%E4%B8%AD%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%99%A8/" class="post-title-link" itemprop="url">Python中的迭代器</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-07-06 11:22:32" itemprop="dateCreated datePublished" datetime="2019-07-06T11:22:32+08:00">2019-07-06</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Python/" itemprop="url" rel="index"><span itemprop="name">Python</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>转自：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/deeper/p/7565571.html">https://www.cnblogs.com/deeper/p/7565571.html</a></p>
<p>迭代器是访问集合元素的一种方式。迭代器对象从集合的第一个元素开始访问，直到所有的元素被访问完结束。迭代器只能往前不会后退，不过这也没什么，因为人们很少在迭代途中往后退。另外，迭代器的一大优点是不要求事先准备好整个迭代过程中所有的元素。迭代器仅仅在迭代到某个元素时才计算该元素，而在这之前或之后，元素可以不存在或者被销毁。这个特点使得它特别适合用于遍历一些巨大的或是无限的集合，比如几个G的文件。</p>
<p>特点：</p>
<ol>
<li>访问者不需要关心迭代器内部的结构，仅需通过next()方法或不断去取下一个内容</li>
<li>不能随机访问集合中的某个值 ，只能从头到尾依次访问</li>
<li>访问到一半时不能往回退</li>
<li>便于循环比较大的数据集合，节省内存</li>
<li>也不能复制一个迭代器。如果要再次（或者同时）迭代同一个对象，只能去创建另一个迭代器对象。enumerate()的返回值就是一个迭代器，我们以enumerate为例：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = enumerate([&#x27;a&#x27;,&#x27;b&#x27;])</span><br><span class="line"></span><br><span class="line">for i in range(2):    #迭代两次enumerate对象</span><br><span class="line">     for x, y in a:</span><br><span class="line">         print(x,y)</span><br><span class="line">     print(&#x27;&#x27;.center(50,&#x27;-&#x27;)) </span><br></pre></td></tr></table></figure>
结果：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0 a</span><br><span class="line">1 b</span><br><span class="line">--------------------------------------------------</span><br><span class="line">--------------------------------------------------</span><br></pre></td></tr></table></figure></li>
</ol>
<p>可以看到再次迭代enumerate对象时，没有返回值；</p>
<p>我们可以用linux的文件处理命令vim和cat来理解一下：</p>
<ol>
<li>读取很大的文件时，vim需要很久，cat是毫秒级；因为vim是一次性把文件全部加载到内存中读取；而cat是加载一行显示一行</li>
<li>vim读写文件时可以前进，后退，可以跳转到任意一行；而cat只能向下翻页，不能倒退，不能直接跳转到文件的某一页（因为读取的时候这个“某一页“可能还没有加载到内存中）</li>
</ol>
<p>正式进入python迭代器之前，我们先要区分两个容易混淆的概念：可迭代对象和迭代器；</p>
<ul>
<li>可以直接作用于for循环的对象统称为 __可迭代对象(Iterable)__。</li>
<li>可以被next()函数调用并不断返回下一个值的对象称为 __迭代器(Iterator)__。</li>
</ul>
<p>所有的Iterable均可以通过内置函数iter()来转变为Iterator。</p>
<h4 id="可迭代对象"><a href="#可迭代对象" class="headerlink" title="可迭代对象"></a>可迭代对象</h4><p>首先，可迭代对象是一个对象，不是一个函数；是一个什么样的对象呢？就是只要它定义了可以返回一个迭代器的<code>__iter__</code>方法，或者定义了可以支持下标索引的<code>__getitem__</code>方法，那么它就是一个可迭代对象。</p>
<p>python中大部分对象都是可迭代的，比如list，tuple等。如果给一个准确的定义的话，看一下list，tuple类的源码，都有<code>__iter__(self)</code>方法。</p>
<p>常见的可迭代对象：</p>
<ol>
<li>集合数据类型，如list、tuple、dict、set、str等；</li>
<li>generator，包括生成器和带yield的generator function。</li>
</ol>
<p>注意：生成器都是Iterator对象，但list、dict、str虽然是Iterable，却不是Iterator</p>
<p>如何判断一个对象是可迭代对象呢？可以通过collections模块的Iterable类型判断：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from collections import Iterable</span><br><span class="line">&gt;&gt;&gt; isinstance([], Iterable)</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; isinstance(&#123;&#125;, Iterable)</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; isinstance(&#x27;abc&#x27;, Iterable)</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; isinstance((x for x in range(10)), Iterable)</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; isinstance(100, Iterable)</span><br><span class="line">False</span><br></pre></td></tr></table></figure>

<h4 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h4><p>一个可迭代对象是不能独立进行迭代的，Python中，迭代是通过for … in来完成的。</p>
<p>for循环在迭代一个可迭代对象的过程中都做了什么呢？</p>
<ol>
<li>当for循环迭代一个可迭代对象时，首先会调用可迭代对象的<code>__iter__()</code>方法，然我们看看源码中关于list类的<code>__iter__()</code>方法的定义：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def __iter__(self, *args, **kwargs): # real signature unknown</span><br><span class="line">    &quot;&quot;&quot; Implement iter(self). &quot;&quot;&quot;</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure>
<code>__iter__()</code>方法调用了<code>iter(self)</code>函数，我们再来看一下iter()函数的定义：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">def iter(source, sentinel=None): # known special case of iter</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    iter(iterable) -&gt; iterator</span><br><span class="line">    iter(callable, sentinel) -&gt; iterator</span><br><span class="line">    </span><br><span class="line">    Get an iterator from an object.  In the first form, the argument must</span><br><span class="line">    supply its own iterator, or be a sequence.</span><br><span class="line">    In the second form, the callable is called until it returns the sentinel.</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure>
<p><code>iter()</code>函数的参数是一个可迭代对象，最终返回一个迭代器</p>
<ol start="2">
<li>for循环会不断调用迭代器对象的<code>__next__()</code>方法(python2.x中是next()方法)，每次循环，都返回迭代器对象的下一个值，直到遇到StopIteration异常。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; lst_iter = iter([1,2,3])</span><br><span class="line">&gt;&gt;&gt; lst_iter.__next__()</span><br><span class="line">1</span><br><span class="line">&gt;&gt;&gt; lst_iter.__next__()</span><br><span class="line">2</span><br><span class="line">&gt;&gt;&gt; lst_iter.__next__()</span><br><span class="line">3</span><br><span class="line">&gt;&gt;&gt; lst_iter.__next__()</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">StopIteration</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>这里注意：这里的<code>__next__()</code>方法和内置函数<code>next(iterator, default=None)</code>不是一个东西；(内置函数<code>next(iterator, default=None)</code>也可以返回迭代器的下一个值）</p>
<ol start="3">
<li>而for循环可以捕获StopIteration异常并结束循环；</li>
</ol>
<p>总结一下：</p>
<ol>
<li>for….in iterable，会通过调用<code>iter(iterable)</code>函数（实际上，首先调用的对象的<code>__iter__()</code>方法），返回一个迭代器iterator;</li>
<li>每次循环，调用一次对象的<code>__next__(self)</code>，直到最后一个值，再次调用会触发StopIteration</li>
<li>for循环捕捉到StopIteration，从而结束循环</li>
</ol>
<p>上面说了这么多，到底什么是迭代器Iterator呢？</p>
<p>任何实现了<code>__iter__</code>和<code>__next__()</code>（python2中实现<code>next()</code>）方法的对象都是迭代器，<code>__iter__</code>返回迭代器自身，<code>__next__</code>返回容器中的下一个值；</p>
<p>既然知道了什么迭代器，那我们自定义一个迭代器玩玩：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Iterator_test(object):</span><br><span class="line">    def __init__(self, data):</span><br><span class="line">        self.data = data</span><br><span class="line">        self.index = len(data)</span><br><span class="line"></span><br><span class="line">    def __iter__(self):</span><br><span class="line">        return self</span><br><span class="line"></span><br><span class="line">    def __next__(self):</span><br><span class="line">        if self.index &lt;= 0 :</span><br><span class="line">            raise StopIteration</span><br><span class="line">        self.index -= 1</span><br><span class="line">        return self.data[self.index]</span><br><span class="line"></span><br><span class="line">iterator_winter = Iterator_test(&#x27;abcde&#x27;)</span><br><span class="line"></span><br><span class="line">for item in iterator_winter:</span><br><span class="line">    print(item)</span><br></pre></td></tr></table></figure>
<p>如何判断一个对象是一个迭代器对象呢？两个方法：</p>
<ol>
<li>通过内置函数next(iterator, default=None)，可以看到next的第一个参数必须是迭代器；所以迭代器也可以认为是可以被next()函数调用的对象</li>
<li>通过collection中的Iterator类型判断<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from collections import Iterator</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">&gt;&gt;&gt; isinstance([1,2,3], Iterator)</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; isinstance(iter([1,2,3]), Iterator)</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; isinstance([1,2,3].__iter__(), Iterator)</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>这里大家会不会有个疑问：</p>
<p>对于迭代器而言，看上去作用的不就是<code>__next__</code>方法嘛，<code>__iter__</code>好像没什么卵用，干嘛还需要<code>__iter__</code>方法呢？</p>
<p>我们知道，python中迭代是通过for循环实现的，而for循环的循环对象必须是一个可迭代对象Iterable，而Iterable必须是一个实现了__iter__方法的对象；知道为什么需要<code>__iter__</code>魔术方法了吧；</p>
<p>那么我就是想自定义一个没有实现<code>__iter__</code>方法的迭代器可以吗？可以，像下面这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Iterable_test(object):</span><br><span class="line">    def __init__(self, data):</span><br><span class="line">        self.data = data</span><br><span class="line"></span><br><span class="line">    def __iter__(self):</span><br><span class="line">        return Iterator_test(self.data)</span><br><span class="line"></span><br><span class="line">class Iterator_test(object):</span><br><span class="line">    def __init__(self, data):</span><br><span class="line">        self.data = data</span><br><span class="line">        self.index = len(data)</span><br><span class="line"></span><br><span class="line">    def __next__(self):</span><br><span class="line">        if self.index &lt;= 0 :</span><br><span class="line">            raise StopIteration</span><br><span class="line">        self.index -= 1</span><br><span class="line">        return self.data[self.index]</span><br><span class="line"></span><br><span class="line">iterator_winter = Iterable_test(&#x27;abcde&#x27;)</span><br><span class="line"></span><br><span class="line">for item in iterator_winter:</span><br><span class="line">    print(item)</span><br></pre></td></tr></table></figure>

<p>先定义一个可迭代对象（包含<code>__iter__</code>方法），然后该对象返回一个迭代器；这样看上去是不是很麻烦？是不是同时带有<code>__iter__</code>和<code>__next__</code>魔术方法的迭代器更好呢！</p>
<p>同时，这里要纠正之前的一个迭代器概念：只要<code>__next__()</code>（python2中实现next()）方法的对象都是迭代器；</p>
<p>既然这样，只需要迭代器Iterator接口就够了，为什么还要设计可迭代对象Iterable呢？</p>
<p>这个和迭代器不能重复使用有关，下面统一讲解：</p>
<h4 id="总结和一些重要知识点"><a href="#总结和一些重要知识点" class="headerlink" title="总结和一些重要知识点"></a>总结和一些重要知识点</h4><h5 id="如何复制迭代器"><a href="#如何复制迭代器" class="headerlink" title="如何复制迭代器"></a>如何复制迭代器</h5><p>之前在使用enumerate时，我们说过enumerate对象通过for循环迭代一次后就不能再被迭代：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; e = enumerate([1,2,3])</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">&gt;&gt;&gt; for x,y in e:</span><br><span class="line">...   print(x,y)</span><br><span class="line">...</span><br><span class="line">0 1</span><br><span class="line">1 2</span><br><span class="line">2 3</span><br><span class="line">&gt;&gt;&gt; for x,y in e:</span><br><span class="line">...   print(x,y)</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>这是因为enumerate是一个迭代器；</p>
<p>迭代器是一次性消耗品，当循环以后就空了。不能再次使用；通过深拷贝可以解决；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import copy</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">&gt;&gt;&gt; e = enumerate([1,2,3])</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">&gt;&gt;&gt; e_deepcopy = copy.deepcopy(e)</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">&gt;&gt;&gt; for x,y in e:</span><br><span class="line">...   print(x,y)</span><br><span class="line">...</span><br><span class="line">0 1</span><br><span class="line">1 2</span><br><span class="line">2 3</span><br><span class="line">&gt;&gt;&gt; for x,y in e_deepcopy:</span><br><span class="line">...   print(x,y)</span><br><span class="line">...</span><br><span class="line">0 1</span><br><span class="line">1 2</span><br><span class="line">2 3</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<h5 id="为什么不只保留Iterator的接口而还需要设计Iterable呢？"><a href="#为什么不只保留Iterator的接口而还需要设计Iterable呢？" class="headerlink" title="为什么不只保留Iterator的接口而还需要设计Iterable呢？"></a>为什么不只保留Iterator的接口而还需要设计Iterable呢？</h5><p>因为迭代器迭代一次以后就空了，那么如果list，dict也是一个迭代器，迭代一次就不能再继续被迭代了，这显然是反人类的；所以通过<code>__iter__</code>每次返回一个独立的迭代器，就可以保证不同的迭代过程不会互相影响。而生成器表达式之类的结果往往是一次性的，不可以重复遍历，所以直接返回一个Iterator就好。让Iterator也实现Iterable的兼容就可以很灵活地选择返回哪一种。</p>
<p>总结说，Iterator实现的<code>__iter__</code>是为了兼容Iterable的接口，从而让Iterator成为Iterable的一种实现。</p>
<p>另外，迭代器是惰性的，只有在需要返回下一个数据时它才会计算。就像一个懒加载的工厂，等到有人需要的时候才给它生成值返回，没调用的时候就处于休眠状态等待下一次调用。所以，Iterator甚至可以表示一个无限大的数据流，例如全体自然数。而使用list是永远不可能存储全体自然数的。</p>
<h5 id="通过-getitem-来实现for循环"><a href="#通过-getitem-来实现for循环" class="headerlink" title="通过__getitem__来实现for循环"></a>通过<code>__getitem__</code>来实现for循环</h5><p>前面关于可迭代对象的定义是这样的：定义了可以返回一个迭代器的<code>__iter__</code>方法，或者定义了可以支持下标索引的<code>__getitem__</code>方法，那么它就是一个可迭代对象。</p>
<p>但是如果对象没有<code>__iter__</code>，但是实现了<code>__getitem__</code>，会改用下标迭代的方式。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class NoIterable(object):</span><br><span class="line">    def __init__(self, data):</span><br><span class="line">        self.data = data</span><br><span class="line">    def __getitem__(self, item):</span><br><span class="line">        return self.data[item]</span><br><span class="line"></span><br><span class="line">no_iter = NoIterable(&#x27;abcde&#x27;)</span><br><span class="line">for item in no_iter:</span><br><span class="line">    print(item)</span><br></pre></td></tr></table></figure>
<p>当for发现没有<code>__iter__</code>但是有<code>__getitem__</code>的时候，会从0开始依次读取相应的下标，直到发生IndexError为止，这是一种旧的迭代方法。iter方法也会处理这种情况，在不存在<code>__iter__</code>的时候，返回一个下标迭代的iterator对象来代替。</p>
<h4 id="一张图总结迭代器"><a href="#一张图总结迭代器" class="headerlink" title="一张图总结迭代器"></a>一张图总结迭代器</h4><p><img src="/2019/07/06/%E8%AF%AD%E8%A8%80/Python/%E5%AF%B9%E8%B1%A1/Python%E4%B8%AD%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%99%A8/1.png" alt="迭代器"></p>
<h4 id="使用迭代器来实现一个斐波那契数列"><a href="#使用迭代器来实现一个斐波那契数列" class="headerlink" title="使用迭代器来实现一个斐波那契数列"></a>使用迭代器来实现一个斐波那契数列</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Fib(object):</span><br><span class="line">    def __init__(self, limit):</span><br><span class="line">        self.a, self.b = 0, 1</span><br><span class="line">        self.limit = limit</span><br><span class="line"></span><br><span class="line">    def __iter__(self):</span><br><span class="line">        return self</span><br><span class="line"></span><br><span class="line">    def __next__(self):</span><br><span class="line">        self.a, self.b = self.b, self.a+self.b</span><br><span class="line">        while self.a &gt; self.limit:</span><br><span class="line">            raise StopIteration</span><br><span class="line">        return self.a</span><br><span class="line"></span><br><span class="line">for n in Fib(1000):</span><br><span class="line">    print(n)</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wetts.github.io/2019/07/06/%E8%AF%AD%E8%A8%80/Python/%E5%85%B6%E4%BB%96/Python-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3yield/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Zhang Wetts">
      <meta itemprop="description" content="Stay Hungry, Stay Foolish. <br><br><p style="font-size:8px;">[build by hexo/next/gitalk/hexo-generator-search/LaTeX]</p>">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wetts's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/07/06/%E8%AF%AD%E8%A8%80/Python/%E5%85%B6%E4%BB%96/Python-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3yield/" class="post-title-link" itemprop="url">Python-深入理解yield</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-07-06 10:41:43" itemprop="dateCreated datePublished" datetime="2019-07-06T10:41:43+08:00">2019-07-06</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Python/" itemprop="url" rel="index"><span itemprop="name">Python</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>转自：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/coderzh/articles/1202040.html">https://www.cnblogs.com/coderzh/articles/1202040.html</a></p>
<p>yield的英文单词意思是生产，刚接触Python的时候感到非常困惑，一直没弄明白yield的用法。只是粗略的知道yield可以用来为一个函数返回值塞数据，比如下面的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def addlist(alist):</span><br><span class="line">    for i in alist:</span><br><span class="line">        yield i + 1</span><br></pre></td></tr></table></figure>
<p>取出alist的每一项，然后把i + 1塞进去。然后通过调用取出每一项：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">alist = [1, 2, 3, 4]</span><br><span class="line">for x in addlist(alist):</span><br><span class="line">    print x,</span><br></pre></td></tr></table></figure>
<p>这的确是yield应用的一个例子。</p>
<h3 id="包含yield的函数"><a href="#包含yield的函数" class="headerlink" title="包含yield的函数"></a>包含yield的函数</h3><p>假如你看到某个函数包含了yield，这意味着这个函数已经是一个Generator，它的执行会和其他普通的函数有很多不同。比如下面的简单的函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def h():</span><br><span class="line">    print &#x27;To be brave&#x27;</span><br><span class="line">    yield 5</span><br><span class="line"></span><br><span class="line">h()</span><br></pre></td></tr></table></figure>
<p>可以看到，调用h()之后，print 语句并没有执行！这就是yield，那么，如何让print 语句执行呢？这就是后面要讨论的问题，通过后面的讨论和学习，就会明白yield的工作原理了。</p>
<h3 id="yield是一个表达式"><a href="#yield是一个表达式" class="headerlink" title="yield是一个表达式"></a>yield是一个表达式</h3><p>Python2.5以前，yield是一个语句，但现在2.5中，yield是一个表达式(Expression)，比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m = yield 5</span><br></pre></td></tr></table></figure>
<p>表达式(yield 5)的返回值将赋值给m，所以，认为 m = 5 是错误的。那么如何获取(yield 5)的返回值呢？需要用到后面要介绍的send(msg)方法。</p>
<h3 id="透过next-语句看原理"><a href="#透过next-语句看原理" class="headerlink" title="透过next()语句看原理"></a>透过next()语句看原理</h3><p>现在，我们来揭晓yield的工作原理。我们知道，我们上面的h()被调用后并没有执行，因为它有yield表达式，因此，我们通过next()语句让它执行。next()语句将恢复Generator执行，并直到下一个yield表达式处。比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def h():</span><br><span class="line">    print &#x27;Wen Chuan&#x27;</span><br><span class="line">    yield 5</span><br><span class="line">    print &#x27;Fighting!&#x27;</span><br><span class="line"></span><br><span class="line">c = h()</span><br><span class="line">c.next()</span><br></pre></td></tr></table></figure>
<p>c.next()调用后，h()开始执行，直到遇到yield 5，因此输出结果：<code>Wen Chuan</code></p>
<p>当我们再次调用c.next()时，会继续执行，直到找到下一个yield表达式。由于后面没有yield了，因此会拋出异常：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Wen Chuan</span><br><span class="line">Fighting!</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;/home/evergreen/Codes/yidld.py&quot;, line 11, in &lt;module&gt;</span><br><span class="line">    c.next()</span><br><span class="line">StopIteration</span><br></pre></td></tr></table></figure>

<h3 id="send-msg-与-next"><a href="#send-msg-与-next" class="headerlink" title="send(msg) 与 next()"></a>send(msg) 与 next()</h3><p>了解了next()如何让包含yield的函数执行后，我们再来看另外一个非常重要的函数send(msg)。其实next()和send()在一定意义上作用是相似的，区别是send()可以传递yield表达式的值进去，而next()不能传递特定的值，只能传递None进去。因此，我们可以看做</p>
<p>c.next() 和 c.send(None) 作用是一样的。</p>
<p>来看这个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">def h():</span><br><span class="line">    print &#x27;Wen Chuan&#x27;,</span><br><span class="line">    m = yield 5  # Fighting!</span><br><span class="line">    print m</span><br><span class="line">    d = yield 12</span><br><span class="line">    print &#x27;We are together!&#x27;</span><br><span class="line"></span><br><span class="line">c = h()</span><br><span class="line">c.next()  #相当于c.send(None)</span><br><span class="line">c.send(&#x27;Fighting!&#x27;)  #(yield 5)表达式被赋予了&#x27;Fighting!&#x27;</span><br></pre></td></tr></table></figure>

<p>输出的结果为：<code>Wen Chuan Fighting!</code></p>
<p>需要提醒的是，第一次调用时，请使用next()语句或是send(None)，不能使用send发送一个非None的值，否则会出错的，因为没有yield语句来接收这个值。</p>
<h3 id="send-msg-与-next-的返回值"><a href="#send-msg-与-next-的返回值" class="headerlink" title="send(msg) 与 next()的返回值"></a>send(msg) 与 next()的返回值</h3><p>send(msg) 和 next()是有返回值的，它们的返回值很特殊，返回的是下一个yield表达式的参数。比如yield 5，则返回 5 。到这里，是不是明白了一些什么东西？本文第一个例子中，通过for i in alist 遍历 Generator，其实是每次都调用了alist.Next()，而每次alist.Next()的返回值正是yield的参数，即我们开始认为被压进去的东东。我们再延续上面的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">def h():</span><br><span class="line">    print &#x27;Wen Chuan&#x27;,</span><br><span class="line">    m = yield 5  # Fighting!</span><br><span class="line">    print m</span><br><span class="line">    d = yield 12</span><br><span class="line">    print &#x27;We are together!&#x27;</span><br><span class="line"></span><br><span class="line">c = h()</span><br><span class="line">m = c.next()  #m 获取了yield 5 的参数值 5</span><br><span class="line">d = c.send(&#x27;Fighting!&#x27;)  #d 获取了yield 12 的参数值12</span><br><span class="line">print &#x27;We will never forget the date&#x27;, m, &#x27;.&#x27;, d</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Wen Chuan Fighting!</span><br><span class="line">We will never forget the date 5 . 12</span><br></pre></td></tr></table></figure>

<h3 id="throw-与-close-中断-Generator"><a href="#throw-与-close-中断-Generator" class="headerlink" title="throw() 与 close()中断 Generator"></a>throw() 与 close()中断 Generator</h3><p>中断Generator是一个非常灵活的技巧，可以通过throw抛出一个GeneratorExit异常来终止Generator。Close()方法作用是一样的，其实内部它是调用了throw(GeneratorExit)的。我们看：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def close(self):</span><br><span class="line">    try:</span><br><span class="line">        self.throw(GeneratorExit)</span><br><span class="line">    except (GeneratorExit, StopIteration):</span><br><span class="line">        pass</span><br><span class="line">    else:</span><br><span class="line">        raise RuntimeError(&quot;generator ignored GeneratorExit&quot;)</span><br><span class="line"># Other exceptions are not caught</span><br></pre></td></tr></table></figure>
<p>因此，当我们调用了close()方法后，再调用next()或是send(msg)的话会抛出一个异常：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;/home/evergreen/Codes/yidld.py&quot;, line 14, in &lt;module&gt;</span><br><span class="line">    d = c.send(&#x27;Fighting!&#x27;)  #d 获取了yield 12 的参数值12</span><br><span class="line">StopIteration</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/11/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/11/">11</a><span class="page-number current">12</span><a class="page-number" href="/page/13/">13</a><span class="space">&hellip;</span><a class="page-number" href="/page/70/">70</a><a class="extend next" rel="next" href="/page/13/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Zhang Wetts"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">Zhang Wetts</p>
  <div class="site-description" itemprop="description">Stay Hungry, Stay Foolish. <br><br><p style="font-size:8px;">[build by hexo/next/gitalk/hexo-generator-search/LaTeX]</p></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">694</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">65</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">343</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/wetts" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;wetts" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:zhang.wetts@163.com" title="E-Mail → mailto:zhang.wetts@163.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Zhang Wetts</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

  


<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/hibiki.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"react":{"opacity":0.7}});</script></body>
</html>
