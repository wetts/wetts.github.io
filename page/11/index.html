<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"wetts.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="Stay Hungry, Stay Foolish. [build by hexo&#x2F;next&#x2F;gitalk&#x2F;hexo-generator-search&#x2F;LaTeX]">
<meta property="og:type" content="website">
<meta property="og:title" content="Wetts&#39;s blog">
<meta property="og:url" content="https://wetts.github.io/page/11/index.html">
<meta property="og:site_name" content="Wetts&#39;s blog">
<meta property="og:description" content="Stay Hungry, Stay Foolish. [build by hexo&#x2F;next&#x2F;gitalk&#x2F;hexo-generator-search&#x2F;LaTeX]">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Zhang Wetts">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://wetts.github.io/page/11/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Wetts's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Wetts's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Stay Hungry, Stay Foolish.</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/wetts" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wetts.github.io/2019/09/11/%E6%95%B0%E5%AD%A6/%E5%85%B6%E4%BB%96/%E4%BB%BF%E5%B0%84%E5%87%BD%E6%95%B0%E5%92%8C%E7%BA%BF%E6%80%A7%E5%87%BD%E6%95%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Zhang Wetts">
      <meta itemprop="description" content="Stay Hungry, Stay Foolish. <br><br><p style="font-size:8px;">[build by hexo/next/gitalk/hexo-generator-search/LaTeX]</p>">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wetts's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/09/11/%E6%95%B0%E5%AD%A6/%E5%85%B6%E4%BB%96/%E4%BB%BF%E5%B0%84%E5%87%BD%E6%95%B0%E5%92%8C%E7%BA%BF%E6%80%A7%E5%87%BD%E6%95%B0/" class="post-title-link" itemprop="url">仿射函数和线性函数</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-09-11 14:07:48" itemprop="dateCreated datePublished" datetime="2019-09-11T14:07:48+08:00">2019-09-11</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E5%AD%A6/" itemprop="url" rel="index"><span itemprop="name">数学</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>仿射函数即由 1 阶多项式构成的函数，一般形式为 <code>f(x)=Ax+b</code>，这里，A 是一个 m×k 矩阵，x 是一个 k 向量，b 是一个 m 向量，实际上反映了一种从 k 维到 m 维的空间映射关系。设 f 是一个矢性（值）函数，若它可以表示为 <code>f(x1,x2,…,xn)=A1x1+A2x2+…+Anxn+b</code>，其中 Ai 可以是标量，也可以是矩阵，则称f是仿射函数。其中的特例是，标性（值）函数 <code>f(x)=ax+b</code>，其中 a、x、b 都是标量。此时严格讲，只有 b=0 时，仿射函数才可以叫“线性函数”（“正比例”关系）。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wetts.github.io/2019/09/10/%E6%95%B0%E5%AD%A6/%E5%BE%AE%E7%A7%AF%E5%88%86/%E5%BE%AE%E7%A7%AF%E5%88%86-%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E5%AF%B9%E5%81%B6%E6%80%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Zhang Wetts">
      <meta itemprop="description" content="Stay Hungry, Stay Foolish. <br><br><p style="font-size:8px;">[build by hexo/next/gitalk/hexo-generator-search/LaTeX]</p>">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wetts's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/09/10/%E6%95%B0%E5%AD%A6/%E5%BE%AE%E7%A7%AF%E5%88%86/%E5%BE%AE%E7%A7%AF%E5%88%86-%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E5%AF%B9%E5%81%B6%E6%80%A7/" class="post-title-link" itemprop="url">微积分-拉格朗日对偶性</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-09-10 13:45:42" itemprop="dateCreated datePublished" datetime="2019-09-10T13:45:42+08:00">2019-09-10</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E5%AD%A6/" itemprop="url" rel="index"><span itemprop="name">数学</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>在约束最优化问题中，常常利用拉格朗日对偶性（Lagrange duality）将原始问题转换为对偶问题，通常解对偶问题而得到原始问题的解。该方法应用在许多统计学习方法中，例如，最大熵模型与支持向量机。</p>
<h3 id="原始问题"><a href="#原始问题" class="headerlink" title="原始问题"></a>原始问题</h3><p><img src="/2019/09/10/%E6%95%B0%E5%AD%A6/%E5%BE%AE%E7%A7%AF%E5%88%86/%E5%BE%AE%E7%A7%AF%E5%88%86-%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E5%AF%B9%E5%81%B6%E6%80%A7/%E5%8E%9F%E5%A7%8B%E9%97%AE%E9%A2%98.png" alt="原始问题"></p>
<p><img src="/2019/09/10/%E6%95%B0%E5%AD%A6/%E5%BE%AE%E7%A7%AF%E5%88%86/%E5%BE%AE%E7%A7%AF%E5%88%86-%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E5%AF%B9%E5%81%B6%E6%80%A7/%E5%8E%9F%E5%A7%8B%E9%97%AE%E9%A2%982.png" alt="原始问题2"></p>
<p><img src="/2019/09/10/%E6%95%B0%E5%AD%A6/%E5%BE%AE%E7%A7%AF%E5%88%86/%E5%BE%AE%E7%A7%AF%E5%88%86-%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E5%AF%B9%E5%81%B6%E6%80%A7/%E5%8E%9F%E5%A7%8B%E9%97%AE%E9%A2%983.png" alt="原始问题3"></p>
<p><img src="/2019/09/10/%E6%95%B0%E5%AD%A6/%E5%BE%AE%E7%A7%AF%E5%88%86/%E5%BE%AE%E7%A7%AF%E5%88%86-%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E5%AF%B9%E5%81%B6%E6%80%A7/%E5%8E%9F%E5%A7%8B%E9%97%AE%E9%A2%984.png" alt="原始问题4"></p>
<h3 id="对偶问题"><a href="#对偶问题" class="headerlink" title="对偶问题"></a>对偶问题</h3><p><img src="/2019/09/10/%E6%95%B0%E5%AD%A6/%E5%BE%AE%E7%A7%AF%E5%88%86/%E5%BE%AE%E7%A7%AF%E5%88%86-%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E5%AF%B9%E5%81%B6%E6%80%A7/%E5%AF%B9%E5%81%B6%E9%97%AE%E9%A2%98.png" alt="对偶问题"></p>
<h3 id="原始问题和对偶问题的关系"><a href="#原始问题和对偶问题的关系" class="headerlink" title="原始问题和对偶问题的关系"></a>原始问题和对偶问题的关系</h3><p><img src="/2019/09/10/%E6%95%B0%E5%AD%A6/%E5%BE%AE%E7%A7%AF%E5%88%86/%E5%BE%AE%E7%A7%AF%E5%88%86-%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E5%AF%B9%E5%81%B6%E6%80%A7/%E5%8E%9F%E5%A7%8B%E9%97%AE%E9%A2%98%E4%B8%8E%E5%AF%B9%E5%81%B6%E9%97%AE%E9%A2%98%E6%9C%80%E4%BC%98%E5%80%BC.png" alt="原始问题与对偶问题最优值"></p>
<p><img src="/2019/09/10/%E6%95%B0%E5%AD%A6/%E5%BE%AE%E7%A7%AF%E5%88%86/%E5%BE%AE%E7%A7%AF%E5%88%86-%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E5%AF%B9%E5%81%B6%E6%80%A7/%E5%8E%9F%E5%A7%8B%E9%97%AE%E9%A2%98%E4%B8%8E%E5%AF%B9%E5%81%B6%E9%97%AE%E9%A2%98%E6%8E%A8%E8%AE%BA1.png" alt="原始问题与对偶问题推论1"></p>
<p><img src="/2019/09/10/%E6%95%B0%E5%AD%A6/%E5%BE%AE%E7%A7%AF%E5%88%86/%E5%BE%AE%E7%A7%AF%E5%88%86-%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E5%AF%B9%E5%81%B6%E6%80%A7/%E5%8E%9F%E5%A7%8B%E9%97%AE%E9%A2%98%E4%B8%8E%E5%AF%B9%E5%81%B6%E9%97%AE%E9%A2%98%E5%AE%9A%E7%90%862.png" alt="原始问题与对偶问题定理2"></p>
<p><img src="/2019/09/10/%E6%95%B0%E5%AD%A6/%E5%BE%AE%E7%A7%AF%E5%88%86/%E5%BE%AE%E7%A7%AF%E5%88%86-%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E5%AF%B9%E5%81%B6%E6%80%A7/%E5%8E%9F%E5%A7%8B%E9%97%AE%E9%A2%98%E4%B8%8E%E5%AF%B9%E5%81%B6%E9%97%AE%E9%A2%98%E5%AE%9A%E7%90%863-1.png" alt="原始问题与对偶问题定理3-1"></p>
<p><img src="/2019/09/10/%E6%95%B0%E5%AD%A6/%E5%BE%AE%E7%A7%AF%E5%88%86/%E5%BE%AE%E7%A7%AF%E5%88%86-%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E5%AF%B9%E5%81%B6%E6%80%A7/%E5%8E%9F%E5%A7%8B%E9%97%AE%E9%A2%98%E4%B8%8E%E5%AF%B9%E5%81%B6%E9%97%AE%E9%A2%98%E5%AE%9A%E7%90%863-2.png" alt="原始问题与对偶问题定理3-2"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wetts.github.io/2019/09/05/%E6%95%B0%E5%AD%A6/%E5%85%B6%E4%BB%96/%E7%9F%A9%E9%98%B5%E6%B1%82%E5%AF%BC%E5%AE%9E%E4%BE%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Zhang Wetts">
      <meta itemprop="description" content="Stay Hungry, Stay Foolish. <br><br><p style="font-size:8px;">[build by hexo/next/gitalk/hexo-generator-search/LaTeX]</p>">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wetts's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/09/05/%E6%95%B0%E5%AD%A6/%E5%85%B6%E4%BB%96/%E7%9F%A9%E9%98%B5%E6%B1%82%E5%AF%BC%E5%AE%9E%E4%BE%8B/" class="post-title-link" itemprop="url">矩阵求导实例</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-09-05 17:30:48" itemprop="dateCreated datePublished" datetime="2019-09-05T17:30:48+08:00">2019-09-05</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E5%AD%A6/" itemprop="url" rel="index"><span itemprop="name">数学</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>转自：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/wlzy/p/8007045.html">https://www.cnblogs.com/wlzy/p/8007045.html</a></p>
<h2 id="前提及说明"><a href="#前提及说明" class="headerlink" title="前提及说明"></a>前提及说明</h2><p>第一次遇见矩阵求导，大多数人都是一头雾水，而搜了维基百科看也还是云里雾里，一堆的名词和一堆的表格到底都是什么呢？这里总结了我个人的学习经验，并且通过一个例子可以让你感受如何进行矩阵求导，下次再遇到需要进行矩阵求导的地方就不会措手不及。</p>
<p>在进行概念的解说之前，首先大家需要先知道下面的这个前提：</p>
<blockquote>
<p>前提： 若 x 为向量，则默认 x 为列向量， xT 为行向量</p>
</blockquote>
<h2 id="布局的概念"><a href="#布局的概念" class="headerlink" title="布局的概念"></a>布局的概念</h2><p>布局简单地理解就是分子 y 、分母 x 是行向量还是列向量。</p>
<ul>
<li>分子布局（Numerator-layout）：分子为 y 或者分母为 xT (即，分子为列向量或者分母为行向量)</li>
<li>分母布局（Denominator-layout）：分子为 yT 或者分母为 x (即，分子为行向量或者分母为列向量)</li>
</ul>
<p>为了更加深刻地理解两种布局的特点和区别，下面是从维基百科中布局部分拿来的例子</p>
<h3 id="分子布局"><a href="#分子布局" class="headerlink" title="分子布局"></a>分子布局</h3><ul>
<li>标量/向量：<img src="/2019/09/05/%E6%95%B0%E5%AD%A6/%E5%85%B6%E4%BB%96/%E7%9F%A9%E9%98%B5%E6%B1%82%E5%AF%BC%E5%AE%9E%E4%BE%8B/%E5%88%86%E5%AD%90%E5%B8%83%E5%B1%80-%E6%A0%87%E9%87%8Fd%E5%90%91%E9%87%8F.png" alt="分子布局-标量d向量">（分母的向量为行向量）</li>
<li>向量/标量：<img src="/2019/09/05/%E6%95%B0%E5%AD%A6/%E5%85%B6%E4%BB%96/%E7%9F%A9%E9%98%B5%E6%B1%82%E5%AF%BC%E5%AE%9E%E4%BE%8B/%E5%88%86%E5%AD%90%E5%B8%83%E5%B1%80-%E5%90%91%E9%87%8Fd%E6%A0%87%E9%87%8F.png" alt="分子布局-向量d标量">（分子的向量为列向量）</li>
<li>向量/向量：<img src="/2019/09/05/%E6%95%B0%E5%AD%A6/%E5%85%B6%E4%BB%96/%E7%9F%A9%E9%98%B5%E6%B1%82%E5%AF%BC%E5%AE%9E%E4%BE%8B/%E5%88%86%E5%AD%90%E5%B8%83%E5%B1%80-%E5%90%91%E9%87%8Fd%E5%90%91%E9%87%8F.png" alt="分子布局-向量d向量">（分子为列向量横向平铺，分母为行向量纵向平铺）</li>
<li>标量/矩阵：<img src="/2019/09/05/%E6%95%B0%E5%AD%A6/%E5%85%B6%E4%BB%96/%E7%9F%A9%E9%98%B5%E6%B1%82%E5%AF%BC%E5%AE%9E%E4%BE%8B/%E5%88%86%E5%AD%90%E5%B8%83%E5%B1%80-%E6%A0%87%E9%87%8Fd%E7%9F%A9%E9%98%B5.png" alt="分子布局-标量d矩阵">（注意这个矩阵部分是转置的，而下面的分母布局是非转置的）</li>
<li>矩阵/标量：<img src="/2019/09/05/%E6%95%B0%E5%AD%A6/%E5%85%B6%E4%BB%96/%E7%9F%A9%E9%98%B5%E6%B1%82%E5%AF%BC%E5%AE%9E%E4%BE%8B/%E5%88%86%E5%AD%90%E5%B8%83%E5%B1%80-%E7%9F%A9%E9%98%B5d%E6%A0%87%E9%87%8F.png" alt="分子布局-矩阵d标量"></li>
</ul>
<h3 id="分母布局"><a href="#分母布局" class="headerlink" title="分母布局"></a>分母布局</h3><ul>
<li>标量/向量：<img src="/2019/09/05/%E6%95%B0%E5%AD%A6/%E5%85%B6%E4%BB%96/%E7%9F%A9%E9%98%B5%E6%B1%82%E5%AF%BC%E5%AE%9E%E4%BE%8B/%E5%88%86%E6%AF%8D%E5%B8%83%E5%B1%80-%E6%A0%87%E9%87%8Fd%E5%90%91%E9%87%8F.png" alt="分母布局-标量d向量">（分母的向量为列向量）</li>
<li>向量/标量：<img src="/2019/09/05/%E6%95%B0%E5%AD%A6/%E5%85%B6%E4%BB%96/%E7%9F%A9%E9%98%B5%E6%B1%82%E5%AF%BC%E5%AE%9E%E4%BE%8B/%E5%88%86%E6%AF%8D%E5%B8%83%E5%B1%80-%E5%90%91%E9%87%8Fd%E6%A0%87%E9%87%8F.png" alt="分母布局-向量d标量">（分子的向量为行向量）</li>
<li>向量/向量：<img src="/2019/09/05/%E6%95%B0%E5%AD%A6/%E5%85%B6%E4%BB%96/%E7%9F%A9%E9%98%B5%E6%B1%82%E5%AF%BC%E5%AE%9E%E4%BE%8B/%E5%88%86%E6%AF%8D%E5%B8%83%E5%B1%80-%E5%90%91%E9%87%8Fd%E5%90%91%E9%87%8F.png" alt="分母布局-向量d向量">（分子为行向量纵向平铺，分母为列向量横向平铺）</li>
<li>标量/矩阵：<img src="/2019/09/05/%E6%95%B0%E5%AD%A6/%E5%85%B6%E4%BB%96/%E7%9F%A9%E9%98%B5%E6%B1%82%E5%AF%BC%E5%AE%9E%E4%BE%8B/%E5%88%86%E6%AF%8D%E5%B8%83%E5%B1%80-%E6%A0%87%E9%87%8Fd%E7%9F%A9%E9%98%B5.png" alt="分母布局-标量d矩阵">（矩阵部分为原始矩阵）</li>
</ul>
<h2 id="一个求导的例子"><a href="#一个求导的例子" class="headerlink" title="一个求导的例子"></a>一个求导的例子</h2><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p><img src="/2019/09/05/%E6%95%B0%E5%AD%A6/%E5%85%B6%E4%BB%96/%E7%9F%A9%E9%98%B5%E6%B1%82%E5%AF%BC%E5%AE%9E%E4%BE%8B/%E9%97%AE%E9%A2%98.png" alt="问题"></p>
<blockquote>
<p>说明： y、w为列向量，X为矩阵</p>
</blockquote>
<h3 id="式子演化"><a href="#式子演化" class="headerlink" title="式子演化"></a>式子演化</h3><p>看到这个例子不要急着去查表求导，先看看它的形式，是 <img src="/2019/09/05/%E6%95%B0%E5%AD%A6/%E5%85%B6%E4%BB%96/%E7%9F%A9%E9%98%B5%E6%B1%82%E5%AF%BC%E5%AE%9E%E4%BE%8B/%E5%BC%8F%E5%AD%90%E6%BC%94%E5%8C%96.png" alt="式子演化"> 的形式，这种形式一般求导较为复杂，因此为了简化运算，我们先把式子展开成下面的样子（注意：<img src="/2019/09/05/%E6%95%B0%E5%AD%A6/%E5%85%B6%E4%BB%96/%E7%9F%A9%E9%98%B5%E6%B1%82%E5%AF%BC%E5%AE%9E%E4%BE%8B/%E5%BC%8F%E5%AD%90%E6%BC%94%E5%8C%962.png" alt="式子演化2"> ： ）</p>
<p><img src="/2019/09/05/%E6%95%B0%E5%AD%A6/%E5%85%B6%E4%BB%96/%E7%9F%A9%E9%98%B5%E6%B1%82%E5%AF%BC%E5%AE%9E%E4%BE%8B/%E5%BC%8F%E5%AD%90%E6%BC%94%E5%8C%963.png" alt="式子演化3"></p>
<p>然后就可以写成四个部分求导的形式如下（累加后求导=求导后累加）： </p>
<p><img src="/2019/09/05/%E6%95%B0%E5%AD%A6/%E5%85%B6%E4%BB%96/%E7%9F%A9%E9%98%B5%E6%B1%82%E5%AF%BC%E5%AE%9E%E4%BE%8B/%E5%BC%8F%E5%AD%90%E6%BC%94%E5%8C%964.png" alt="式子演化4"></p>
<h3 id="求导"><a href="#求导" class="headerlink" title="求导"></a>求导</h3><ul>
<li><img src="/2019/09/05/%E6%95%B0%E5%AD%A6/%E5%85%B6%E4%BB%96/%E7%9F%A9%E9%98%B5%E6%B1%82%E5%AF%BC%E5%AE%9E%E4%BE%8B/%E6%B1%82%E5%AF%BC1.png" alt="求导1"></li>
</ul>
<p>说明：分子部分为标量，分母部分为向量，找到维基百科中的Scalar-by-vector identities表格，在表格中匹配形式到第1行的位置，因为分母为列向量，因此为分母布局，对应的求导结果就是 0 。</p>
<ul>
<li><img src="/2019/09/05/%E6%95%B0%E5%AD%A6/%E5%85%B6%E4%BB%96/%E7%9F%A9%E9%98%B5%E6%B1%82%E5%AF%BC%E5%AE%9E%E4%BE%8B/%E6%B1%82%E5%AF%BC2.png" alt="求导2"></li>
</ul>
<p>说明：同样的，在维基百科中的Scalar-by-vector identities表格，在表格中匹配形式到第11行的位置。</p>
<ul>
<li><img src="/2019/09/05/%E6%95%B0%E5%AD%A6/%E5%85%B6%E4%BB%96/%E7%9F%A9%E9%98%B5%E6%B1%82%E5%AF%BC%E5%AE%9E%E4%BE%8B/%E6%B1%82%E5%AF%BC3.png" alt="求导3"></li>
</ul>
<p>说明：因为分子为标量，标量的转置等于本身，所以对分子进行转置操作，其等价于第二部分。</p>
<ul>
<li><img src="/2019/09/05/%E6%95%B0%E5%AD%A6/%E5%85%B6%E4%BB%96/%E7%9F%A9%E9%98%B5%E6%B1%82%E5%AF%BC%E5%AE%9E%E4%BE%8B/%E6%B1%82%E5%AF%BC4.png" alt="求导4"></li>
</ul>
<p>说明：同样的，在维基百科中的Scalar-by-vector identities表格，在表格中匹配形式到第13行的位置。</p>
<h3 id="整合"><a href="#整合" class="headerlink" title="整合"></a>整合</h3><p>把四个部分求导结果进行相应的加减就可以得到最终的结果： </p>
<ul>
<li><img src="/2019/09/05/%E6%95%B0%E5%AD%A6/%E5%85%B6%E4%BB%96/%E7%9F%A9%E9%98%B5%E6%B1%82%E5%AF%BC%E5%AE%9E%E4%BE%8B/%E6%95%B4%E5%90%88.png" alt="整合"></li>
</ul>
<hr>
<ul>
<li><p>分子布局，即按照 y 和xT (相比较于x)的布局。（求导结果中分子保持原始形式，分母为转置形式）</p>
</li>
<li><p>分母布局, 即按照 yT 和 x (相比较于y)。（求导结果中分子为转置形式，分母保持原始形式）</p>
</li>
<li><p><img src="/2019/09/05/%E6%95%B0%E5%AD%A6/%E5%85%B6%E4%BB%96/%E7%9F%A9%E9%98%B5%E6%B1%82%E5%AF%BC%E5%AE%9E%E4%BE%8B/%E8%A1%A8%E6%A0%BC1.png" alt="表格1"></p>
</li>
<li><p><img src="/2019/09/05/%E6%95%B0%E5%AD%A6/%E5%85%B6%E4%BB%96/%E7%9F%A9%E9%98%B5%E6%B1%82%E5%AF%BC%E5%AE%9E%E4%BE%8B/%E8%A1%A8%E6%A0%BC2.png" alt="表格2"></p>
</li>
<li><p><img src="/2019/09/05/%E6%95%B0%E5%AD%A6/%E5%85%B6%E4%BB%96/%E7%9F%A9%E9%98%B5%E6%B1%82%E5%AF%BC%E5%AE%9E%E4%BE%8B/%E8%A1%A8%E6%A0%BC3.png" alt="表格3"></p>
</li>
<li><p><img src="/2019/09/05/%E6%95%B0%E5%AD%A6/%E5%85%B6%E4%BB%96/%E7%9F%A9%E9%98%B5%E6%B1%82%E5%AF%BC%E5%AE%9E%E4%BE%8B/%E8%A1%A8%E6%A0%BC4.png" alt="表格4"></p>
</li>
<li><p><img src="/2019/09/05/%E6%95%B0%E5%AD%A6/%E5%85%B6%E4%BB%96/%E7%9F%A9%E9%98%B5%E6%B1%82%E5%AF%BC%E5%AE%9E%E4%BE%8B/%E8%A1%A8%E6%A0%BC5.png" alt="表格5"></p>
</li>
<li><p><img src="/2019/09/05/%E6%95%B0%E5%AD%A6/%E5%85%B6%E4%BB%96/%E7%9F%A9%E9%98%B5%E6%B1%82%E5%AF%BC%E5%AE%9E%E4%BE%8B/%E8%A1%A8%E6%A0%BC6.png" alt="表格6"></p>
</li>
<li><p><img src="/2019/09/05/%E6%95%B0%E5%AD%A6/%E5%85%B6%E4%BB%96/%E7%9F%A9%E9%98%B5%E6%B1%82%E5%AF%BC%E5%AE%9E%E4%BE%8B/%E8%A1%A8%E6%A0%BC7.png" alt="表格7"></p>
</li>
<li><p><img src="/2019/09/05/%E6%95%B0%E5%AD%A6/%E5%85%B6%E4%BB%96/%E7%9F%A9%E9%98%B5%E6%B1%82%E5%AF%BC%E5%AE%9E%E4%BE%8B/%E8%A1%A8%E6%A0%BC8.png" alt="表格8"></p>
</li>
<li><p><img src="/2019/09/05/%E6%95%B0%E5%AD%A6/%E5%85%B6%E4%BB%96/%E7%9F%A9%E9%98%B5%E6%B1%82%E5%AF%BC%E5%AE%9E%E4%BE%8B/%E8%A1%A8%E6%A0%BC9.png" alt="表格9"></p>
</li>
<li><p><img src="/2019/09/05/%E6%95%B0%E5%AD%A6/%E5%85%B6%E4%BB%96/%E7%9F%A9%E9%98%B5%E6%B1%82%E5%AF%BC%E5%AE%9E%E4%BE%8B/%E8%A1%A8%E6%A0%BC10.png" alt="表格10"></p>
</li>
<li><p><img src="/2019/09/05/%E6%95%B0%E5%AD%A6/%E5%85%B6%E4%BB%96/%E7%9F%A9%E9%98%B5%E6%B1%82%E5%AF%BC%E5%AE%9E%E4%BE%8B/%E8%A1%A8%E6%A0%BC11.png" alt="表格11"></p>
</li>
</ul>
<hr>
<h2 id="附录：公式推导"><a href="#附录：公式推导" class="headerlink" title="附录：公式推导"></a>附录：公式推导</h2><h3 id="公式一"><a href="#公式一" class="headerlink" title="公式一"></a>公式一</h3><p>对任意行向量 $\mathbf{w} = (w_1, w_2, \cdots w_n)$ 都有<br>$$<br>\left.\frac{\partial(\mathbf{w} \mathbf{x})}{\partial \mathbf{x}}=\left[\begin{array}{c}{\frac{\partial(\mathbf{w} \mathbf{x})}{x_{1}}} \ {\frac{\partial(\mathbf{w} \mathbf{x})}{x_{2}}} \ {\vdots} \ {\frac{\partial(\mathbf{w} \mathbf{x})}{x_{n}}}\end{array}\right]=\left[\begin{array}{c}{\frac{\partial\left(w_1 x_1+w_2 x_{2}+\cdots+w_{n} x_{n}\right)}{x_{1}}} \ {\frac{\partial\left(w_{1} x_{1}+w_{2} x_{2}+\cdots+w_{n} x_{n}\right)}{x_{2}}} \ {\vdots} \ {\frac{\partial\left(w_1 x_1+w_2 x_{2}+\cdots+w_{n} x_{n}\right)}{x_{n}}}\end{array}\right]=\left[\begin{array}{c}{w_{1}} \ {w_{2}} \ {\vdots} \ {w_{n}}\end{array}\right]=\mathbf{w}^{T}\right.<br>$$<br>同时注意,如果 $\mathbf{w}$ 表示一个列向量，则<br>$$<br>\frac{\partial\left(\mathbf{x}^{\mathrm{T}} \mathbf{w}\right)}{\partial \mathbf{x}}=\mathbf{w}<br>$$</p>
<h3 id="公式二"><a href="#公式二" class="headerlink" title="公式二"></a>公式二</h3><p>$\mathbf{A}$ 表示一个矩阵，其中 $\mathbf{a_1, a_2, \cdots a_n}$ 表示行向量<br>$$<br>\mathbf{A}=\left(\mathbf{a}<em>{\mathbf{1}}, \mathbf{a}</em>{2}, \cdots, \mathbf{a}<em>{\mathbf{n}}\right)^{T}<br>$$<br>都有<br>$$<br>\frac{\partial(\mathbf{A} \mathbf{x})}{\partial \mathbf{x}}=\frac{\partial\left(\mathbf{a}</em>{1} \mathbf{x}, \mathbf{a}<em>{2} \mathbf{x}, \cdots, \mathbf{a}</em>{\mathbf{n}} \mathbf{x}\right)^{T}}{\partial \mathbf{x}}=\left(\mathbf{a}<em>{1}^{T}, \mathbf{a}</em>{2}^{T}, \cdots, \mathbf{a}<em>{\mathbf{n}}^{T}\right)=\mathbf{A}^{T}<br>$$<br>$\mathbf{B}$ 表示一个矩阵，其中 $\mathbf{b_1, b_2, \cdots b_n}$ 表示列向量<br>$$<br>\mathbf{B}=\left(\mathbf{b}</em>{\mathbf{1}}, \mathbf{b}<em>{2}, \cdots, \mathbf{b}</em>{\mathbf{n}}\right)<br>$$<br>都有<br>$$<br>\frac{\partial\left(\mathbf{x}^{\mathrm{T}} \mathbf{B}\right)}{\partial \mathbf{x}}=\frac{\partial\left(\mathbf{x}^{\mathrm{T}} \mathbf{b}<em>{1}, \mathbf{x}^{\mathrm{T}} \mathbf{b}</em>{2}, \cdots, \mathbf{x}^{\mathrm{T}} \mathbf{b}<em>{\mathbf{n}}\right)}{\partial \mathbf{x}}=\left(\mathbf{b}</em>{1}, \mathbf{b}<em>{2}, \cdots, \mathbf{b}</em>{\mathbf{n}}\right)=\mathbf{B}<br>$$</p>
<h3 id="公式三"><a href="#公式三" class="headerlink" title="公式三"></a>公式三</h3><p>$$<br>\frac{\partial\left(\mathbf{x}^{\mathrm{T}} \mathbf{x}\right)}{\partial \mathbf{x}}=\left[\begin{array}{c}{\frac{\partial \mathbf{x}^{\mathrm{T}} \mathbf{x}}{x_{1}}} \ {\frac{\partial \mathbf{x}^{\mathrm{T}} \mathbf{x}}{x_2}} \ {\vdots} \ {\frac{\partial \mathbf{x}^{\mathrm{T}} \mathbf{x}}{x_{n}}}\end{array}\right]=\left[\begin{array}{c}{\frac{\partial\left(x_{1}^{2}+x_{2}^{2}+\cdots+x_{n}^{2}\right)}{x_{1}}} \ {\frac{\partial\left(x_{1}^{2}+x_{2}^{2}+\cdots+x_{n}^{2}\right)}{x_{2}}} \ {\vdots} \ {\frac{\partial\left(x_{1}^{2}+x_{2}^{2}+\cdots+x_{n}^{2}\right)}{x_{n}}}\end{array}\right]=\left[\begin{array}{c}{2 x_{1}} \ {2 x_{2}} \ {\vdots} \ {2 x_{n}}\end{array}\right]=2 \mathbf{x}<br>$$</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wetts.github.io/2019/09/04/%E8%AF%AD%E8%A8%80/Java/JVM/Java-JVM-0-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Zhang Wetts">
      <meta itemprop="description" content="Stay Hungry, Stay Foolish. <br><br><p style="font-size:8px;">[build by hexo/next/gitalk/hexo-generator-search/LaTeX]</p>">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wetts's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/09/04/%E8%AF%AD%E8%A8%80/Java/JVM/Java-JVM-0-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/" class="post-title-link" itemprop="url">Java-JVM-0-知识点汇总.md</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-09-04 23:46:32" itemprop="dateCreated datePublished" datetime="2019-09-04T23:46:32+08:00">2019-09-04</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><h3 id="JDK"><a href="#JDK" class="headerlink" title="JDK"></a>JDK</h3><ul>
<li>JDK1.8<ul>
<li>Lambda 表达式</li>
<li>函数式接口</li>
<li>法引用和构造器调用</li>
<li>Stream API</li>
<li>接口中的默认方法和静态方法</li>
<li>新时间日期 API</li>
</ul>
</li>
</ul>
<h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><ul>
<li>前端编译：源代码到字节码<ul>
<li>把 Java 源码文件（.java）编译成 Class 文件（.class）的过程。</li>
<li>JDK 的安装目录里有一个 javac 工具，就是它将 Java 代码翻译成字节码，这个工具我们叫做编译器。相对于后面要讲的其他编译器，其因为处于编译的前期，因此又被成为前端编译器。</li>
<li>编译器的处理过程：<ol>
<li>词法、语法分析<ul>
<li>在这个阶段，JVM 会对源代码的字符进行一次扫描，最终生成一个抽象的语法树。简单地说，在这个阶段 JVM 会搞懂我们的代码到底想要干嘛。就像我们分析一个句子一样，我们会对句子划分主谓宾，弄清楚这个句子要表达的意思一样。</li>
</ul>
</li>
<li>填充符号表<ul>
<li>我们知道类之间是会互相引用的，但在编译阶段，我们无法确定其具体的地址，所以我们会使用一个符号来替代。在这个阶段做的就是类似的事情，即对抽象的类或接口进行符号填充。等到类加载阶段，JVM 会将符号替换成具体的内存地址。</li>
</ul>
</li>
<li>注解处理<ul>
<li>我们知道 Java 是支持注解的，因此在这个阶段会对注解进行分析，根据注解的作用将其还原成具体的指令集。</li>
</ul>
</li>
<li>分析与字节码生成<ul>
<li>到了这个阶段，JVM 便会根据上面几个阶段分析出来的结果，进行字节码的生成，最终输出为 class 文件。</li>
</ul>
</li>
</ol>
</li>
<li>常见的前端编译器有 Sun 的 javac，Eclipse JDT 的增量式编译器（ECJ）。</li>
</ul>
</li>
<li>后端编译/即时（JIT）编译：字节码到机器码<ul>
<li>在运行时把 Class 文件字节码编译成本地机器码的过程。</li>
<li>当源代码转化为字节码之后，其实要运行程序，有两种选择。<strong>一种是使用 Java 解释器解释执行字节码，另一种则是使用 JIT 编译器将字节码转化为本地机器代码。前者启动速度快但运行速度慢，而后者启动速度慢但运行速度快</strong>。</li>
<li>解释器不需要像 JIT 编译器一样，将所有字节码都转化为机器码，自然就少去了优化的时间。而当 JIT 编译器完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用。而我们知道，机器码的运行效率肯定是高于 Java 解释器的。所以在实际情况中，为了运行速度以及效率，我们通常采用两者相结合的方式进行 Java 代码的编译执行。</li>
<li>通过 <code>java -version</code> 可以看到 JVM 都是 mixed mode（混合模式，也就是解释器和编译器混合使用）。</li>
<li>现在主流的商用虚拟机（如 Sun HotSpot、IBM J9）中几乎都同时包含解释器和编译器（三大商用虚拟机之一的 JRockit 是个例外，它内部没有解释器，因此会有启动相应时间长之类的缺点，但它主要是面向服务端的应用，这类应用一般不会重点关注启动时间）。</li>
<li>与前端编译相比，二者各有优势<ul>
<li><strong>当程序需要迅速启动和执行时，解释器可以首先发挥作用，省去编译的时间，立即执行；当程序运行后，随着时间的推移，编译器逐渐会返回作用，把越来越多的代码编译成本地代码后，可以获取更高的执行效率。解释执行可以节约内存，而编译执行可以提升效率。</strong></li>
<li>两种情况，编译器都是以整个方法作为编译对象，这种编译也是虚拟机中标准的编译方式。</li>
</ul>
</li>
<li>要知道一段代码或方法是不是热点代码，是不是需要触发即时编译，需要进行 Hot Spot Detection（热点探测）。目前主要的热点判定方式有以下两种：<ul>
<li>基于采样的热点探测<ul>
<li>采用这种方法的虚拟机会周期性地检查各个线程的栈顶，如果发现某些方法经常出现在栈顶，那这段方法代码就是“热点代码”。这种探测方法的好处是实现简单高效，还可以很容易地获取方法调用关系，缺点是很难精确地确认一个方法的热度，容易因为受到线程阻塞或别的外界因素的影响而扰乱热点探测。</li>
</ul>
</li>
<li>基于计数器的热点探测<ul>
<li>采用这种方法的虚拟机会为每个方法，甚至是代码块建立计数器，统计方法的执行次数，如果执行次数超过一定的阀值，就认为它是“热点方法”。这种统计方法实现复杂一些，需要为每个方法建立并维护计数器，而且不能直接获取到方法的调用关系，但是它的统计结果相对更加精确严谨。</li>
<li>两个计数器<ul>
<li>方法调用计数器<ul>
<li><strong>方法调用计数器用来统计方法调用的次数</strong>，在默认设置下，方法调用计数器统计的并不是方法被调用的绝对次数，而是一个相对的执行频率，即一段时间内方法被调用的次数。</li>
</ul>
</li>
<li>回边计数器<ul>
<li><strong>回边计数器用于统计一个方法中循环体代码执行的次数</strong>（准确地说，应该是回边的次数，因为并非所有的循环都是回边），在字节码中遇到控制流向后跳转的指令就称为“回边”。</li>
</ul>
</li>
</ul>
</li>
<li>在确定虚拟机运行参数的前提下，<strong>这两个计数器都有一个确定的阀值，当计数器的值超过了阀值，就会触发JIT编译</strong>。触发了 JIT 编译后，在默认设置下，执行引擎并不会同步等待编译请求完成，而是继续进入解释器按照解释方式执行字节码，直到提交的请求被编译器编译完成为止（编译工作在后台线程中进行）。当编译工作完成后，下一次调用该方法或代码时，就会使用已编译的版本。</li>
</ul>
</li>
</ul>
</li>
<li>JIT 工作流程<ul>
<li><img src="/2019/09/04/%E8%AF%AD%E8%A8%80/Java/JVM/Java-JVM-0-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/Java_JVM_JIT%E7%BC%96%E8%AF%91%E6%B5%81%E7%A8%8B.png" alt="Java_JVM_JIT编译流程"></li>
</ul>
</li>
<li>JIT 编译器在运行程序时有两种编译模式可以选择，并且其会在运行时决定使用哪一种以达到最优性能。这两种编译模式的命名源自于命令行参数（eg: <code>-client</code> 或者 <code>-server</code>）。JVM Server 模式与 client 模式启动，最主要的差别在于：<code>-server</code> 模式启动时，速度较慢，但是一旦运行起来后，性能将会有很大的提升。原因是：当虚拟机运行在 <code>-client</code> 模式的时候，使用的是一个代号为 C1 的轻量级编译器，而 <code>-server</code> 模式启动的虚拟机采用相对重量级代号为 C2 的编译器。C2 比 C1 编译器编译的相对彻底，服务起来之后，性能更高。<blockquote>
<ul>
<li>RednaxelaFX 大佬<ul>
<li>JIT 编译<ul>
<li>全称 just-in-time compilation，按照其原始的、严格的定义，是每当一部分代码准备要第一次执行的时候，将这部分代码编译，然后跳进编译好的代码里执行。这样，所有执行过的代码都必然会被编译过。早期的 JIT 编译系统对同一个块代码只会编译一次。</li>
<li>JIT 编译的单元也可以选择是方法/函数级别，或者别的，例如 trace。</li>
</ul>
</li>
<li>严格说 JIT 编译与自适应编译相比：<ul>
<li>前者的编译时机比后者早：第一次执行之前 vs 已经被执行过若干次</li>
<li>前者编译的代码比后者多：所有执行过的代码 vs 一部分代码</li>
</ul>
</li>
<li>JIT 编译与自适应编译都属于“动态编译”（dynamic compilation），或者叫“运行时编译”的范畴。特点是在程序运行的时候进行编译，而不是在程序开始运行之前就完成了编译；后者也叫做“静态编译”（static compilation）或者 AOT 编译（ahead-of-time compilation）。</li>
<li>现在“JIT 编译”这个名词已经被泛化为等价于“动态编译”，所以包含了严格的 JIT 编译和自适应编译。就这个角度说，HotSpot VM 仍然在使用“JIT 编译”；里面的 Client Compiler（C1）和 Server Compiler（C2）也常被称为“JIT 编译器“。要注意，这样的说法已经不是指严格意义上的“JIT”了。</li>
</ul>
</li>
</ul>
</blockquote>
</li>
<li>以下是具有代表性的 HotSpot 虚拟机的即时编译器在生成代码时采用的代码优化技术：<ul>
<li>公共子表达式消除（语言无关的经典优化技术之一）<ul>
<li>如果一个表达式 E 已经计算过了，并且从先前的计算到现在 E 中所有变量的值都没有发生变化，那么 E 的这次出现就成为了公共子表达式。对于这种表达式，没必要花时间再对它进行计算，只需要直接使用前面计算过的表达式结果代替 E 就可以了。</li>
<li>例子<ul>
<li><code>int d = (c*b) * 12 + a + (a+ b * c) -&gt; int d = E * 12 + a + (a+ E)</code></li>
</ul>
</li>
</ul>
</li>
<li>数组范围检查消除（语言相关的经典优化技术之一）<ul>
<li>在 Java 语言中访问数组元素的时候系统将会自动进行上下界的范围检查，超出边界会抛出异常。对于虚拟机的执行子系统来说，每次数组元素的读写都带有一次隐含的条件判定操作，对于拥有大量数组访问的程序代码，这无疑是一种性能负担。Java 在编译期根据数据流分析可以判定范围进而消除上下界检查，节省多次的条件判断操作。</li>
</ul>
</li>
<li>方法内联（最重要的优化技术之一）<ul>
<li>简单的理解为把目标方法的代码“复制”到发起调用的方法中，消除一些无用的代码。只是实际的 JVM 中的内联过程很复杂，在此不分析。</li>
</ul>
</li>
<li>逃逸分析（最前沿的优化技术之一）<ul>
<li>逃逸分析的基本行为就是分析对象动态作用域：当一个对象在方法中被定义后，它可能被外部方法所引用，例如作为调用参数传递到其他方法中，称为<strong>方法逃逸</strong>。甚至可能被外部线程访问到，譬如赋值给类变量或可以在其他线程中访问的实例变量，称为<strong>线程逃逸</strong>。</li>
<li>对象的逃逸状态<ul>
<li>全局逃逸（GlobalEscape）<ul>
<li>即一个对象的作用范围逃出了当前方法或者当前线程，有以下几种场景：<ul>
<li>对象是一个静态变量</li>
<li>对象是一个已经发生逃逸的对象</li>
<li>对象作为当前方法的返回值</li>
</ul>
</li>
</ul>
</li>
<li>参数逃逸（ArgEscape）<ul>
<li>即一个对象被作为方法参数传递或者被参数引用，但在调用过程中不会发生全局逃逸，这个状态是通过被调方法的字节码确定的。</li>
</ul>
</li>
<li>没有逃逸<ul>
<li>即方法中的对象没有发生逃逸。</li>
</ul>
</li>
</ul>
</li>
<li>如果能证明一个对象不会逃逸到方法或线程之外，也就是别的方法或线程无法通过任何途径访问到这个对象，则可以为这个变量进行一些高效的优化：<ul>
<li>栈上分配<ul>
<li>将不会逃逸的局部对象分配到栈上，那对象就会随着方法的结束而自动销毁，减少垃圾收集系统的压力。</li>
</ul>
</li>
<li>同步消除<ul>
<li>如果该变量不会发生线程逃逸，也就是无法被其他线程访问，那么对这个变量的读写就不存在竞争，可以将同步措施消除掉（同步是需要付出代价的）</li>
</ul>
</li>
<li>标量替换<ul>
<li>标量是指无法在分解的数据类型，比如原始数据类型以及 reference 类型。而聚合量就是可继续分解的，比如 Java 中的对象。标量替换如果一个对象不会被外部访问，并且对象可以被拆散的话，真正执行时可能不创建这个对象，而是直接创建它的若干个被这个方法使用到的成员变量来代替。这种方式不仅可以让对象的成员变量在栈上分配和读写，还可以为后后续进一步的优化手段创建条件。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>静态提前编译（Ahead Of Time，AOT 编译）：源代码到机器码<ul>
<li>优点是编译不占用运行时间，可以做一些较耗时的优化，并可加快程序启动。但因为 Java 语言的动态性（如反射）带来了额外的复杂性，影响了静态编译代码的质量。一般静态编译不如 JIT 编译的质量，这种方式用得比较少。</li>
<li>目前 Java 体系中主要还是采用前端编译+JIT编译的方式，如 JDK 中的 HotSpot 虚拟机。</li>
</ul>
</li>
</ul>
<h3 id="VM"><a href="#VM" class="headerlink" title="VM"></a>VM</h3><ul>
<li>HotSpot VM<ul>
<li>这个 JVM 最初由 Longview/Animorphic 实现，随着公司被 Sun/JavaSoft 收购而成为 Sun 的 JVM，并于 JDK 1.3.0 开始成为 Sun 的 Java SE 的主要 JVM。在 Sun 被 Oracle 收购后，现在 HotSpot VM 是 Oracle 的 Java SE 的主要 JVM。</li>
<li>HotSpot VM 得名于它得混合模式执行引擎：这个执行引擎包括解释器和自适应编译器（adaptive compiler）。</li>
<li>执行流程<ul>
<li>默认配置下，一开始所有 Java 方法都由解释器执行。解释器记录着每个方法得调用次数和循环次数，并以这两个数值为指标去判断一个方法的“热度”。显然，HotSpot VM 是以“方法”为单位来寻找热点代码。</li>
<li>等到一个方法足够“热”的时候，HotSpot VM 就会启动对该方法的编译。这种在所有执行过的代码里只寻找一部分来编译的做法，就叫做自适应编译（adaptive compilation）。</li>
</ul>
</li>
</ul>
</li>
<li>JRockit VM<ul>
<li>这个 JVM 使用纯编译的执行引擎，没有解释器。</li>
<li>它有多层编译：第一次执行某个方法之前会用非常低的优化级别去 JIT 编译，然后等到某个方法足够热之后再用较高的优化级别重新编译它。</li>
<li>这种系统既是严格意义上的 JIT 编译（第一次执行某个方法前编译它），又是自适应编译（找出热点再进行编译）。</li>
</ul>
</li>
<li>IBM J9</li>
</ul>
<h3 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h3><ul>
<li>工作机制：当类加载器接收到类加载的请求时，它不会自己去尝试加载这个类，而是把这个请求委派给父加载器去完成，只有当父类加载器反馈自己无法完成这个加载请求时，子加载器才会尝试自己去加载类。</li>
<li>加载流程：<ol>
<li>当类加载器接收到类加载的请求时，首先检查该类是否已经被当前类加载器加载；</li>
<li>若该类未被加载过，当前类加载器会将加载请求委托给父类加载器去完成；</li>
<li>若当前类加载器的父类加载器（或父类的父类……向上递归）为 null，会委托启动类加载器完成加载；</li>
<li>若父类加载器无法完成类的加载，当前类加载器才会去尝试加载该类。</li>
</ol>
<ul>
<li><img src="/2019/09/04/%E8%AF%AD%E8%A8%80/Java/JVM/Java-JVM-0-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/Java_%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%89%98%E6%A8%A1%E5%9E%8B_%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B.jpg" alt="Java_双亲委托模型_类加载流程"></li>
</ul>
</li>
<li>类加载器分类：<ul>
<li>启动类加载器 Bootstrap ClassLoader<ul>
<li>是所有类加载器的”老祖宗”，是由 C++ 实现的，不继承于 java.lang.ClassLoader 类。 它在虚拟机启动时会由虚拟机的一段 C++ 代码进行加载，所以它没有父类加载器，在加载完成后，它会负责去加载扩展类加载器和应用类加载器。</li>
<li>用于加载 Java 的核心类——位于 <code>&lt;JAVA_HOME&gt;\lib</code> 中，或者被 <code>-Xbootclasspath</code> 参数所指定的路径中，并且是虚拟机能够识别的类库（仅按照文件名识别,如 <code>rt.jar、tools.jar</code>，名字不符合的类库即使放在 lib 目录中也不会被加载）。</li>
</ul>
</li>
<li>拓展类加载器 Extension ClassLoader<ul>
<li>拓展类加载器继承于 java.lang.ClassLoader 类，它的父类加载器是启动类加载器，而启动类加载器在 Java 中的显示就是 null。</li>
<li>拓展类加载器负责加载 <code>&lt;JAVA_HOME&gt;\lib\ext</code> 目录中的，或者被 <code>java.ext.dirs</code> 系统变量所指定的路 径的所有类。</li>
<li>需要注意的是扩展类加载器仅支持加载被打包为 .jar 格式的字节码文件。</li>
</ul>
</li>
<li>应用类/系统类加载器 App/System ClassLoader<ul>
<li>应用类加载器继承于 java.lang.ClassLoader 类，它的父类加载器是扩展类加载器。</li>
<li>应用类加载器负责加载用户类路径 classpath 上所指定的类库。</li>
<li>如果应用程序中没有自定义的类加载器，一般情况下应用类加载器就是程序中默认的类加载器。</li>
</ul>
</li>
<li>自定义类加载器 Custom ClassLoader<ul>
<li>自定义类加载器继承于 java.lang.ClassLoader 类，它的父类加载器是应用类加载器。</li>
<li>这是自定义的类加载器，可加载指定路径的字节码文件。</li>
<li>自定义类加载器需要继承 java.lang.ClassLoader 类并重写 findClass 方法（下文有说明为什么不重写 loadClass 方法）用于实现自定义的加载类逻辑。</li>
</ul>
</li>
</ul>
</li>
<li>双亲委派模型的好处：<ul>
<li>基于双亲委派模型规定的这种带有优先级的层次性关系，虚拟机运行程序时就能够避免类的重复加载。</li>
<li>双亲委派模型能够避免核心类篡改。一般我们描述的核心类是 rt.jar、tools.jar 这些由启动类加载器加载的类，这些类库在日常开发中被广泛运用，如果被篡改，后果将不堪设想。</li>
</ul>
</li>
<li>双亲委派模型的不足：<ul>
<li>由于历史原因（ClassLoader 类在 JDK1.0 时就已经存在，而双亲委派模型是在 JDK1.2 之后才引入的），在未引入双亲委派模型时，用户自定义的类加载器需要继承 java.lang.ClassLoader 类并重写 <code>loadClass()</code> 方法，因为虚拟机在加载类时会调用 <code>ClassLoader#loadClassInternal(String)</code> 方法。而这个方法会调用自定义类加载重写的 <code>loadClass()</code> 方法。而在引入双亲委派模型后，<code>ClassLoader#loadClass</code> 方法实际就是双亲委派模型的实现，如果重写了此方法，相当于打破了双亲委派模型。为了让用户自定义的类加载器也遵从双亲委派模型， JDK 新增了 <code>findClass</code> 方法，用于实现自定义的类加载逻辑。</li>
<li>由于双亲委派模型规定的层次性关系，导致子类类加载器加载的类能访问父类类加载器加载的类，而父类类加载器加载的类无法访问子类类加载器加载的类。为了让上层类加载器加载的类能够访问下层类加载器加载的类，或者说让父类类加载器委托子类类加载器完成加载请求，JDK 引入了线程上下文类加载器，藉由它来打破双亲委派模型的屏障。<ul>
<li>线程上下文类加载器<ul>
<li>线程上下文类加载器是定义在 Thread 类中的一个 ClassLoader 类型的私有成员变量，它指向了当前线程的类加载器。这个类加载器可以通过 java.lang.Thread 类的 <code>setContextClassLoaser()</code> 方法进行设置，如果创建线程时还未设置，它将会从父线程中继承一个，如果在应用程序的全局范围内都没有设置过的话，那这个类加载器默认就是应用程序类加载器。</li>
<li>父 ClassLoader 可以使用当前线程 <code>Thread.currentThread().getContextClassLoader()</code> 所指定的 classloader 加载的类。</li>
</ul>
</li>
</ul>
</li>
<li>当用户需要程序的动态性，比如代码热替换、模块热部署等时，双亲委派模型就不再适用，类加载器会发展为更为复杂的网状结构。</li>
</ul>
</li>
<li>SPI（Service Provider Interface）<ul>
<li>它允许服务商编写具体的代码逻辑来完成该接口的功能。</li>
<li>但是 Java 提供的 SPI 接口是在核心类库中，由启动类加载器加载的，厂商实现的具体逻辑代码是在 classpath 中，是由应用类加载器加载的，而启动类加载器加载的类无法访问应用类加载器加载的类，也就是说启动类加载器无法找到 SPI 实现类，单单依靠双亲委派模型就无法实现 SPI 的功能了，所以线程上下文类加载器应运而生。</li>
</ul>
</li>
<li>相关问题<ul>
<li><strong>Class.forName 和 classloader 的区别？</strong><ul>
<li><code>Class.forName()</code> 执行初始化过程执行静态代码化。<ul>
<li>内部实际调用的方法是 <code>Class.forName(className, true, classloader);</code></li>
</ul>
</li>
<li><code>ClassLoader.loadClass</code> 不执行初始化过程。<ul>
<li>内部实际调用的方法是 <code>ClassLoader.loadClass(className, false);</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="类、对象内存相关"><a href="#类、对象内存相关" class="headerlink" title="类、对象内存相关"></a>类、对象内存相关</h3><ul>
<li>类加载<ul>
<li>加载时机<ol>
<li>遇到 new、getstatic、putstatic、invokestatic 这四条字节码指令的时候。</li>
<li>使用 java.lang.reflect 进行反射调用的时候。</li>
<li>当初始化一个类的时候，发现其父类还没有初始化，那么先去初始化它的父类。</li>
<li>当虚拟机启动的时候，需要初始化 main 函数所在的类。</li>
</ol>
</li>
<li>加载流程<ol>
<li>编译：.java 文件编译后生成 .class 字节码文件</li>
<li>加载：获取类的二进制字节流，将其静态存储结构转化为方法区的运行时数据结构</li>
<li>连接：细分三步<ol>
<li>校验：文件格式验证，元数据验证，字节码验证，符号引用验证</li>
<li>准备：在方法区中对类的 static 变量分配内存并设置类变量数据类型默认的初始值，不包括实例变量，实例变量将会在对象实例化的时候随着对象一起分配在 Java 堆中</li>
<li>解析：将常量池内的符号引用替换为直接引用的过程</li>
</ol>
</li>
<li>连接初始化：为类的静态变量赋予正确的初始值（Java 代码中被显式地赋予的值）</li>
</ol>
</li>
</ul>
</li>
<li>对象创建<ul>
<li>创建过程<ul>
<li><img src="/2019/09/04/%E8%AF%AD%E8%A8%80/Java/JVM/Java-JVM-0-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/Java_JVM_%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%BF%87%E7%A8%8B.png" alt="Java_JVM_创建对象的过程"></li>
</ul>
<ol>
<li>首先进行类加载的检查<ul>
<li>虚拟机遇到 new 指令的时候，首先去检查该指令的参数是否能够在常量池中定位到这个类的符号引用，并且检查该符号引用代表的类是否已经被加载过、解析和初始化过。若没有，必须先执行相应的类加载的过程。</li>
</ul>
</li>
<li>分配内存<ul>
<li>类加载检查通过之后，虚拟机为对象分配内存。（内存大小在类加载完后就能确定）。分配的方式有“指针碰撞”和“空闲列表”两种，若 Java 堆是规整的，采用“指针碰撞”；反之采用空闲列表。</li>
</ul>
</li>
<li>初始化零值<ul>
<li>内存分配完之后，虚拟机将分配到的内存空间初始化为零值。保证了对象的实例字段在 Java 代码中可以不赋初值就直接使用。</li>
</ul>
</li>
<li>设置对象头<ul>
<li>始化零值之后，虚拟机要对对象进行必要的设置：对象头的设置。</li>
</ul>
</li>
<li>执行 init 方法<ul>
<li>最后，虚拟机的视角来看，新的对象已经产生了。但是从 Java 程序的视角来看，init 方法还没有执行，所有字段还都是零。一般来说，执行 new 指令之后就会接着执行 init 方法，把对象按照程序员的意愿进行初始化。真正可用的对象就完全产生了。</li>
</ul>
</li>
</ol>
</li>
<li>对象初始化方法执行流程<ol>
<li>父类的静态成员赋值和静态块</li>
<li>子类的静态成员和静态块</li>
<li>父类的构造方法</li>
<li>父类的成员赋值和初始化块</li>
<li>父类的构造方法中的其它语句</li>
<li>子类的成员赋值和初始化块</li>
<li>子类的构造方法中的其它语句</li>
</ol>
</li>
<li>内存分配<ul>
<li><img src="/2019/09/04/%E8%AF%AD%E8%A8%80/Java/JVM/Java-JVM-0-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/Java_JVM_%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E6%B5%81%E7%A8%8B.png" alt="Java_JVM_创建对象内存分配流程"></li>
<li>栈上分配（JIT 性能优化之一）<ul>
<li>如果确定一个对象的作用域不会逃逸出方法之外，那可以将这个对象分配在栈上，这样，对象所占用的内存空间就可以随栈帧出栈而销毁。在一般应用中，不会逃逸的局部对象所占的比例很大，如果能使用栈上分配，那大量的对象就会随着方法的结束而自动销毁了，无须通过垃圾收集器回收，可以减小垃圾收集器的负载。</li>
<li>技术基础：<ul>
<li>逃逸分析<ul>
<li>逃逸分析的目的是判断对象的作用域是否有可能逃逸出函数体。</li>
</ul>
</li>
<li>标量替换<ul>
<li>允许将对象打散分配在栈上，比如若一个对象拥有两个字段，会将这两个字段视作局部变量进行分配。</li>
</ul>
</li>
</ul>
</li>
<li>设置方法<ul>
<li>只能在 server 模式下才能启用逃逸分析，参数 <code>-XX:DoEscapeAnalysis</code> 启用逃逸分析，参数 <code>-XX:+EliminateAllocations</code> 开启标量替换（默认打开）。Java SE 6u23 版本之后，HotSpot 中默认就开启了逃逸分析，可以通过选项 <code>-XX:+PrintEscapeAnalysis</code> 查看逃逸分析的筛选结果。</li>
</ul>
</li>
</ul>
</li>
<li>堆上分配<ul>
<li>选择那种分配方式由 Java 堆是否规整决定，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。</li>
<li>分配方式有“指针碰撞”和“空闲列表”两种<ul>
<li><img src="/2019/09/04/%E8%AF%AD%E8%A8%80/Java/JVM/Java-JVM-0-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/Java_JVM_%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E6%96%B9%E5%BC%8F.png" alt="Java_JVM_创建对象内存分配方式"></li>
<li>指针碰撞<ul>
<li><img src="/2019/09/04/%E8%AF%AD%E8%A8%80/Java/JVM/Java-JVM-0-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/Java_JVM_%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E6%96%B9%E5%BC%8F_%E6%8C%87%E9%92%88%E7%A2%B0%E6%92%9E.jpeg" alt="Java_JVM_创建对象内存分配方式_指针碰撞"></li>
</ul>
</li>
<li>空闲列表<ul>
<li><img src="/2019/09/04/%E8%AF%AD%E8%A8%80/Java/JVM/Java-JVM-0-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/Java_JVM_%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E6%96%B9%E5%BC%8F_%E7%A9%BA%E9%97%B2%E5%88%97%E8%A1%A8.jpeg" alt="Java_JVM_创建对象内存分配方式_空闲列表"></li>
</ul>
</li>
</ul>
</li>
<li>并发问题<ul>
<li>单线程下，“指针碰撞”和“空闲列表”分配内存不会有线程安全问题，实际开发过程中，创建对象是很频繁的事情，而且是多线程环境，作为虚拟机来说，必须要保证线程是安全的。</li>
<li>通常来讲，虚拟机采用两种方式来保证线程安全：<ul>
<li>CAS + 失败重试<ul>
<li>CAS 是乐观锁的一种实现方式。所谓乐观锁就是，每次不加锁而是设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性。</li>
</ul>
</li>
<li>TLAB<ul>
<li>为每一个线程预先在 Eden 区分配一块儿内存，JVM 在给线程中的对象分配内存时，首先在 TLAB 分配，当对象大于 TLAB 中的剩余内存或 TLAB 的内存已用尽时，再采用上述的 CAS 进行内存分配。</li>
<li>TLAB 的全称是 Thread Local Allocation Buffer，即线程本地分配缓存区，这是一个线程专用的内存分配区域。相当于线程的私有对象。</li>
<li>特点<ul>
<li>堆是 JVM 中所有线程共享的，因此在其上进行对象内存的分配均需要进行加锁，这也导致了 new 对象的开销是比较大的</li>
<li>Sun Hotspot JVM 为了提升对象内存分配的效率，对于所创建的线程都会分配一块独立的空间 TLAB（Thread Local Allocation Buffer），其大小由 JVM 根据运行的情况计算而得，<strong>在 TLAB 上分配对象时不需要加锁</strong>，因此 JVM 在给线程的对象分配内存时会尽量的在 TLAB 上分配，在这种情况下 JVM 中分配对象内存的性能和 C 基本是一样高效的，但如果对象过大的话则仍然是直接使用堆空间分配</li>
<li>TLAB 仅作用于新生代的 Eden Space，因此在编写 Java 程序时，通常<strong>多个小的对象比大的对象分配起来更加高效</strong>。</li>
</ul>
</li>
<li>设置方法<ul>
<li>如果设置了虚拟机参数 <code>-XX:UseTLAB</code>，在线程初始化时，同时也会申请一块指定大小的内存，只给当前线程使用，这样每个线程都单独拥有一个空间，如果需要分配内存，就在自己的空间上分配，这样就不存在竞争的情况，可以大大提升分配效率。</li>
<li>TLAB 空间的内存非常小，缺省情况下仅占有整个 Eden 空间的 1%，也可以通过选项 <code>-XX:TLABWasteTargetPercent</code> 设置 TLAB 空间所占用 Eden 空间的百分比大小。</li>
</ul>
</li>
<li>原理<ul>
<li>TLAB 的本质其实是三个指针管理的区域：start、top 和 end，每个线程都会从 Eden 分配一块空间，例如说 100KB，作为自己的 TLAB，其中 start 和 end 是占位用的，标识出 eden 里被这个 TLAB 所管理的区域，卡住 eden 里的一块空间不让其它线程来这里分配。</li>
<li>当一个 TLAB 用满（分配指针 top 撞上分配极限 end 了），就新申请一个 TLAB，而在老 TLAB 里的对象还留在原地什么都不用管——它们无法感知自己是否是曾经从 TLAB 分配出来的，而只关心自己是在 eden 里分配的。</li>
</ul>
</li>
<li>TLAB 只是让每个线程有私有的分配指针，但底下存对象的内存空间还是给所有线程访问的，只是其它线程无法在这个区域分配而已。从这一点看，它被翻译为<strong>线程私有分配区</strong>更为合理一点。</li>
<li>分配流程<ul>
<li><img src="/2019/09/04/%E8%AF%AD%E8%A8%80/Java/JVM/Java-JVM-0-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/JAVA_JVM_TLAB%E5%88%86%E9%85%8D%E6%B5%81%E7%A8%8B%E5%9B%BE.jpeg" alt="JAVA_JVM_TLAB分配流程图"></li>
</ul>
<ol>
<li>从线程当前 TLAB 分配<ul>
<li>如果启用了 TLAB（默认是启用的， 可以通过 <code>-XX:-UseTLAB</code> 关闭），则首先从线程当前 TLAB 分配内存，如果分配成功则返回，否则根据当前 TLAB 剩余空间与当前最大浪费空间限制大小进行不同的分配策略。</li>
</ul>
</li>
<li>重新申请 TLAB 分配<ul>
<li>如果当前 TLAB 剩余空间大于当前最大浪费空间限制（这个初始值为 期望大小/TLABRefillWasteFraction），直接在堆上分配。否则，重新申请一个 TLAB 分配。<ul>
<li><strong>为什么需要最大浪费空间呢？</strong><ul>
<li>当重新分配一个 TLAB 的时候，原有的 TLAB 可能还有空间剩余。原有的 TLAB 被退回堆之前，需要填充好 dummy object。由于 TLAB 仅线程内知道哪些被分配了，在 GC 扫描发生时返回 Eden 区，如果不填充的话，外部并不知道哪一部分被使用哪一部分没有，需要做额外的检查，如果填充已经确认会被回收的对象，也就是 dummy object，GC 会直接标记之后跳过这块内存，增加扫描效率。反正这块内存已经属于 TLAB，其他线程在下次扫描结束前是无法使用的。这个 dummy object 就是 int 数组。为了一定能有填充 dummy object 的空间，一般 TLAB 大小都会预留一个 dummy object 的 header 的空间，也是一个 <code>int[]</code> 的 header，所以 TLAB 的大小不能超过 int 数组的最大大小，否则无法用 dummy object 填满未使用的空间。</li>
<li>但是，填充 dummy 也造成了空间的浪费，这种浪费不能太多，所以通过最大浪费空间限制来限制这种浪费。</li>
<li>新的 TLAB 大小，取如下两个值中较小的那个：<ul>
<li>当前堆剩余给 TLAB 可分配的空间，大部分 GC 的实现其实就是对应的 Eden 区剩余大小</li>
<li>TLAB 期望大小 + 当前需要分配的空间大小</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>直接从堆上分配<ul>
<li>直接从堆上分配是最慢的分配方式。一种情况就是，如果当前 TLAB 剩余空间大于当前最大浪费空间限制，直接在堆上分配。并且，还会增加当前最大浪费空间限制，每次有这样的分配就会增加 TLABWasteIncrement 的大小，这样在一定次数的直接堆上分配之后，当前最大浪费空间限制一直增大会导致当前 TLAB 剩余空间小于当前最大浪费空间限制，从而申请新的 TLAB 进行分配。</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>对象的访问<ul>
<li>Java 程序通过栈上的 reference（引用）数据来操作堆上的具体对象。</li>
<li>主流的访问方式<ul>
<li>使用句柄<ul>
<li>如果使用句柄的话，那么 Java 堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息</li>
<li><img src="/2019/09/04/%E8%AF%AD%E8%A8%80/Java/JVM/Java-JVM-0-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/Java_JVM_%E5%AF%B9%E8%B1%A1%E8%AE%BF%E9%97%AE_%E4%BD%BF%E7%94%A8%E5%8F%A5%E6%9F%84.png" alt="Java_JVM_对象访问_使用句柄"></li>
<li>使用句柄来访问的最大好处是 reference 中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。</li>
</ul>
</li>
<li>直接指针<ul>
<li>如果使用直接指针访问，那么 Java 堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而 reference 中存储的直接就是对象的地址</li>
<li><img src="/2019/09/04/%E8%AF%AD%E8%A8%80/Java/JVM/Java-JVM-0-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/Java_JVM_%E5%AF%B9%E8%B1%A1%E8%AE%BF%E9%97%AE_%E7%9B%B4%E6%8E%A5%E6%8C%87%E9%92%88.png" alt="Java_JVM_对象访问_直接指针"></li>
<li>使用直接指针访问方式最大的好处就是速度快，它节省了一次指针定位的时间开销。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>对象在内存中分为三块区域<ul>
<li><img src="/2019/09/04/%E8%AF%AD%E8%A8%80/Java/JVM/Java-JVM-0-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/Java_JVM_%E5%AF%B9%E8%B1%A1%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E5%B8%83%E5%B1%80.png" alt="Java_JVM_对象在内存中的布局"></li>
<li>对象头<ul>
<li>Mark Word（标记字段）：默认存储对象的 HashCode，分代年龄和锁标志位信息。它会根据对象的状态复用自己的存储空间，也就是说在运行期间 Mark Word 里存储的数据会随着锁标志位的变化而变化。<ul>
<li><img src="/2019/09/04/%E8%AF%AD%E8%A8%80/Java/JVM/Java-JVM-0-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/Java_Mark_Word.jpg" alt="Java_Mark_Word"></li>
<li>64 bit</li>
</ul>
</li>
<li>Klass Point（类型指针）：对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。<ul>
<li>64 bit</li>
</ul>
</li>
</ul>
</li>
<li>实例数据<ul>
<li>这部分主要是存放类的数据信息，父类的信息。</li>
</ul>
</li>
<li>对其填充<ul>
<li>由于虚拟机要求对象起始地址必须是8字节的整数倍，填充数据不是必须存在的，仅仅是为了字节对齐。 <ul>
<li><strong>Tip：不知道大家有没有被问过一个空对象占多少个字节？就是8个字节，是因为对齐填充的关系哈，不到8个字节对其填充会帮我们自动补齐。</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="内存模型"><a href="#内存模型" class="headerlink" title="内存模型"></a>内存模型</h3><ul>
<li>内存分区<ul>
<li>方法区（Method Area）<ul>
<li>《深入理解Java虚拟机》书中对方法区（Method Area）存储内容描述如下：<ul>
<li>它用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等。</li>
</ul>
</li>
<li>方法区结构<ul>
<li>类型信息<ul>
<li>对每个加载的类型（类 class、接口 interface、枚举 enum、注解 annotation），JVM 必须在方法区中存储以下类型信息：<ol>
<li>这个类型的完整有效名称（全名=包名.类名）</li>
<li>这个类型直接父类的完整有效名（对于interface或是java.lang.Object，都没有父类）</li>
<li>这个类型的修饰符（public，abstract，final的某个子集）</li>
<li>这个类型直接接口的一个有序列表</li>
</ol>
</li>
</ul>
</li>
<li>域（Field）信息<ul>
<li>JVM必 须在方法区中保存类型的所有域的相关信息以及域的声明顺序。</li>
<li>域的相关信息包括：<ul>
<li>域名称</li>
<li>域类型</li>
<li>域修饰符（public，private，protected，static，final，volatile，transient 的某个子集）</li>
</ul>
</li>
<li>域信息特殊情况<ul>
<li>non-final 类型的类变量<ul>
<li>静态变量和类关联在一起，随着类的加载而加载，他们成为类数据在逻辑上的一部分</li>
<li>类变量被类的所有实例共享，即使没有类实例时，你也可以访问它</li>
</ul>
</li>
<li>全局常量：static final<ul>
<li>全局常量就是使用 static final 进行修饰</li>
<li>被声明为final的类变量的处理方法则不同，每个全局常量在编译的时候就会被分配了。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>方法（Method）信息<ul>
<li>JVM必须保存所有方法的以下信息，同域信息一样包括声明顺序：<ul>
<li>方法名称</li>
<li>方法的返回类型（包括 void 返回类型），void 在 Java 中对应的类为 void.class</li>
<li>方法参数的数量和类型（按顺序）</li>
<li>方法的修饰符（public，private，protected，static，final，synchronized，native，abstract 的一个子集）</li>
<li>方法的字节码（bytecodes）、操作数栈、局部变量表及大小（abstract 和 native 方法除外）</li>
<li>异常表（abstract和native 方法除外），异常表记录每个异常处理的开始位置、结束位置、代码处理在程序计数器中的偏移地址、被捕获的异常类的常量池索引</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>常量池、运行时常量池<ul>
<li>常量池、运行时常量池<ul>
<li>方法区，内部包含了运行时常量池</li>
<li>字节码文件，内部包含了常量池</li>
<li>要弄清楚方法区，需要理解清楚 ClassFile，因为加载类的信息都在方法区。</li>
<li>要弄清楚方法区的运行时常量池，需要理解清楚 ClassFile 中的常量池。</li>
</ul>
</li>
<li>常量池<ul>
<li>一个有效的字节码文件中除了包含类的版本信息、字段、方法以及接口等描述符信息外</li>
<li>还包含一项信息就是常量池表（Constant Pool Table），包括各种字面量和对类型、域和方法的符号引用</li>
<li>常量池中有啥<ul>
<li>数量值</li>
<li>字符串值</li>
<li>类引用</li>
<li>字段引用</li>
<li>方法引用</li>
</ul>
</li>
</ul>
</li>
<li>运行时常量池<ul>
<li>运行时常量池（Runtime Constant Pool）是方法区的一部分。</li>
<li>常量池表（Constant Pool Table）是 Class 字节码文件的一部分，用于存放编译期生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。</li>
<li>运行时常量池，在加载类和接口到虚拟机后，就会创建对应的运行时常量池。</li>
<li>JVM 为每个已加载的类型（类或接口）都维护一个常量池。池中的数据项像数组项一样，是通过索引访问的。</li>
<li>运行时常量池中包含多种不同的常量，包括编译期就已经明确的数值字面量，也包括到运行期解析后才能够获得的方法或者字段引用。此时不再是常量池中的符号地址了，这里换为真实地址。</li>
<li>运行时常量池，相对于 Class 文件常量池的另一重要特征是：具备动态性。</li>
<li>运行时常量池类似于传统编程语言中的符号表（symbol table），但是它所包含的数据却比符号表要更加丰富一些。</li>
<li>当创建类或接口的运行时常量池时，如果构造运行时常量池所需的内存空间超过了方法区所能提供的最大值，则 JVM 会抛 OutofMemoryError 异常。</li>
</ul>
</li>
</ul>
</li>
<li>版本区别<ul>
<li>在 JDK1.7 及之前，HotSpot VM 的实现就是将其放在永久代中，这样的好处就是可以直接使用堆中的 GC 算法来进行管理，但坏处就是经常会出现内存溢出，即 PermGen Space 异常。<ul>
<li>JDK1.6及以前<ul>
<li>有永久代（permanent generation），静态变量存储在永久代上</li>
</ul>
</li>
<li>JDK1.7<ul>
<li>有永久代，但已经逐步“去永久代”，字符串常量池，静态变量移除，保存在堆中</li>
</ul>
</li>
</ul>
</li>
<li>在 JDK1.8 中，HotSpot VM 取消了永久代，用<strong>元空间</strong>取而代之，元空间直接使用本地内存，理论上电脑有多少内存它就可以使用多少内存，所以不会再出现 PermGen Space 异常。<strong>引用类型的常量，只会在堆上（Java8）</strong></li>
<li><img src="/2019/09/04/%E8%AF%AD%E8%A8%80/Java/JVM/Java-JVM-0-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/JVM%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4_1.jpg" alt="JVM内存空间_1"></li>
<li><img src="/2019/09/04/%E8%AF%AD%E8%A8%80/Java/JVM/Java-JVM-0-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/JVM%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4_2.jpg" alt="JVM内存空间_2"></li>
<li><img src="/2019/09/04/%E8%AF%AD%E8%A8%80/Java/JVM/Java-JVM-0-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/JVM%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4_3.jpg" alt="JVM内存空间_3"></li>
</ul>
</li>
</ul>
</li>
<li>堆（Heap）<ul>
<li>几乎所有对象、数组等都是在此分配内存的，在 JVM 内存中占的比例也是极大的，也是 GC 垃圾回收的主要阵地</li>
<li>可以处于物理上不连续但逻辑上连续的空间</li>
<li>分区<ul>
<li>新生代<ul>
<li>Eden</li>
<li>From Survivor、To Survivor</li>
</ul>
</li>
<li>老年代</li>
<li>永久代【HotSpot VM 取消了永久代】</li>
</ul>
</li>
</ul>
</li>
<li>虚拟机栈（Java Stack）<ul>
<li><del>当 JVM 在执行方法时，会在此区域中创建一个栈帧来存放方法的各种信息，比如返回值，局部变量表和各种对象引用等，方法开始执行前就先创建栈帧入栈，执行完后就出栈。</del>【虚拟机栈描述的是 Java 方法执行的内存模型：每个方法被执行的时候都会同时创建一个栈帧（Stack Frame）用于存储局部变量表、操作栈、动态链接、方法出口等信息。每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。 】</li>
<li>出现栈溢出的情况<ul>
<li>如果线程请求的栈深度大于虚拟机所允许的深度，将抛出 StackOverflowError 异常； <ul>
<li>根本原因是，某个线程所需的栈内存超过了JVM的限制，而此时物理内存仍有足够的可用空间。</li>
</ul>
</li>
<li>如果虚拟机栈可以动态扩展（当前大部分的 Java 虚拟机都可动态扩展，只不过 Java 虚拟机规范中也允许固定长度的虚拟机栈），当扩展时无法申请到足够的内存时会抛出 OutOfMemoryError 异常。 <ul>
<li>根本原因是，（操作系统管理的）物理内存已没有足够的可用内存分配给JVM的栈使用。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>本地方法栈（Native Method Stack）<ul>
<li>和虚拟机栈类似，不过区别是专⻔提供给 Native 方法用的。</li>
</ul>
</li>
<li>程序计数器（Program Counter Register）<ul>
<li>占用很小的一片区域，我们知道 JVM 执行代码是一行一行执行字节码，所以需要一个计数器来记录当前执行的行数。</li>
</ul>
</li>
</ul>
</li>
<li>内存泄漏<ul>
<li>当某些对象不再被应用程序所使用，但是由于仍然被引用而导致垃圾收集器不能释放他们。</li>
<li>内存泄漏场景<ul>
<li>静态集合类</li>
<li>各种连接，如数据库连接、网络连接和 IO 连接等。</li>
<li>变量不合理的作用域。</li>
<li>内部类持有外部类<ul>
<li>如果一个外部类的实例对象的方法返回了一个内部类的实例对象，这个内部类对象被长期引用了，即使那个外部类实例对象不再被使用，但由于内部类持有外部类的实例对象，这个外部类对象将不会被垃圾回收，这也会造成内存泄露。</li>
</ul>
</li>
<li>改变哈希值<ul>
<li>当一个对象被存储进 HashSet 集合中以后，就不能修改这个对象中的那些参与计算哈希值的字段了，否则，对象修改后的哈希值与最初存储进 HashSet 集合中时的哈希值就不同了，在这种情况下，即使在 contains 方法使用该对象的当前引用作为的参数去 HashSet 集合中检索对象，也将返回找不到对象的结果，这也会导致无法从 HashSet 集合中单独删除当前对象，造成内存泄露</li>
</ul>
</li>
<li>监听器的使用，在释放对象的同时没有相应删除监听器的时候也可能导致内存泄露。</li>
</ul>
</li>
<li>内存泄露解决的原则：<ul>
<li>尽量减少使用静态变量，类的静态变量的生命周期和类同步的。  </li>
<li>声明对象引用之前，明确内存对象的有效作用域，尽量减小对象的作用域，将类的成员变量改写为方法内的局部变量；</li>
<li>减少长生命周期的对象持有短生命周期的引用；</li>
<li>使用 StringBuilder 和 StringBuffer 进行字符串连接，String 和 StringBuilder 以及 StringBuffer 等都可以代表字符串，其中 String 字符串代表的是不可变的字符串，后两者表示可变的字符串。如果使用多个 String 对象进行字符串连接运算，在运行时可能产生大量临时字符串，这些字符串会保存在内存中从而导致程序性能下降。</li>
<li>对于不需要使用的对象手动设置 null 值，不管 GC 何时会开始清理，我们都应及时的将无用的对象标记为可被清理的对象；</li>
<li>各种连接（数据库连接，网络连接，IO 连接）操作，务必显示调用 close 关闭。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h3><ul>
<li>强引用<ul>
<li>被强引用关联的对象不会被回收。</li>
<li>使用 new 一个新对象的方式来创建强引用。</li>
</ul>
</li>
<li>软引用<ul>
<li>被软引用关联的对象只有在内存不够的情况下才会被回收。</li>
<li>使用 SoftReference 类来创建软引用。</li>
</ul>
</li>
<li>弱引用<ul>
<li>被弱引用关联的对象一定会被回收，也就是说它只能存活到下一次垃圾回收发生之前。</li>
<li>使用 WeakReference 类来创建弱引用。</li>
</ul>
</li>
<li>虚引用<ul>
<li>又称为幽灵引用或者幻影引用，一个对象是否有虚引用的存在，不会对其生存时间造成影响，也无法通过虚引用得到一个对象。</li>
<li>为一个对象设置虚引用的唯一目的是能在这个对象被回收时收到一个系统通知。</li>
<li>使用 PhantomReference 来创建虚引用。</li>
</ul>
</li>
</ul>
<h3 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h3><ul>
<li>垃圾回收算法<ul>
<li>标记清除<ul>
<li>标记-清除算法将垃圾回收分为两个阶段：标记阶段和清除阶段。</li>
<li>流程<ul>
<li>在标记阶段首先通过根节点（GC Roots），标记所有从根节点开始的对象，未被标记的对象就是未被引用的垃圾对象。然后，在清除阶段，清除所有未被标记的对象。</li>
</ul>
</li>
</ul>
</li>
<li>复制算法<ul>
<li>流程<ul>
<li>从根集合节点进行扫描，标记出所有的存活对象，并将这些存活的对象复制到一块儿新的内存（图中下边的那一块儿内存）上去，之后将原来的那一块儿内存（图中上边的那一块儿内存）全部回收掉</li>
</ul>
</li>
</ul>
</li>
<li>标记整理<ul>
<li>复制算法的高效性是建立在存活对象少、垃圾对象多的前提下的。</li>
<li><strong>这种情况在新生代经常发生，但是在老年代更常⻅的情况是大部分对象都是存活对象。如果依然使用复制算法，由于存活的对象较多，复制的成本也将很高</strong>。</li>
</ul>
</li>
<li>分代收集算法<ul>
<li><strong>分代收集算法就是目前虚拟机使用的回收算法</strong>。在不同年代使用不同的算法，从而使用最合适的算法，新生代存活率低，可以使用复制算法。而老年代对象存活率搞，没有额外空间对它进行分配担保，所以只能使用标记清除或者标记整理算法。</li>
</ul>
</li>
</ul>
</li>
<li>判断一个对象是否可被回收<ul>
<li>引用计数算法<ul>
<li>为对象添加一个引用计数器，当对象增加一个引用时计数器加 1，引用失效时计数器减 1。引用计数为 0 的对象可被回收。</li>
<li>在两个对象出现循环引用的情况下，此时引用计数器永远不为 0，导致无法对它们进行回收。正是因为循环引用的存在，因此 Java 虚拟机不使用引用计数算法。</li>
</ul>
</li>
<li>可达性分析算法<ul>
<li>通过 Roots 对象作为起点进行搜索，搜索走过的路径称为“引用链”，当一个对象到 Roots 没有任何的引用链相连时时，证明此对象不可用，当然被判定为不可达的对象不一定就会成为可回收对象。<ul>
<li>GC ROOTS 可以的对象有<ul>
<li>虚拟机栈中的引用对象</li>
<li>方法区的类变量的引用</li>
<li>方法区中的常量引用</li>
<li>本地方法栈中的对象引用</li>
</ul>
</li>
</ul>
</li>
<li>被判定为不可达的对象要成为可回收对象必须至少经历两次标记过程，如果在这两次标记过程中仍然没 有逃脱成为可回收对象的可能性，则基本上就真的成为可回收对象了，能否被回收其实主要还是要看 <code>finalize()</code> 方法有没有与引用链上的对象关联，如果在 <code>finalize()</code> 方法中有关联则自救成功，改 对象不可被回收，反之如果没有关联则成功被二次标记成功，就可以称为要被回收的垃圾了。</li>
</ul>
</li>
<li>方法区的回收<ul>
<li>因为方法区主要存放永久代对象，而永久代对象的回收率比新生代低很多，所以在方法区上进行回收性价比不高。</li>
<li>主要是对常量池的回收和对类的卸载。</li>
<li>为了避免内存溢出，在大量使用反射和动态代理的场景都需要虚拟机具备类卸载功能。</li>
<li>类的卸载条件很多，需要满足以下三个条件，并且满足了条件也不一定会被卸载：<ul>
<li>该类所有的实例都已经被回收，此时堆中不存在该类的任何实例。</li>
<li>加载该类的 ClassLoader 已经被回收。</li>
<li>该类对应的 Class 对象没有在任何地方被引用，也就无法在任何地方通过反射访问该类方法。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>垃圾回收器<ul>
<li><img src="/2019/09/04/%E8%AF%AD%E8%A8%80/Java/JVM/Java-JVM-0-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/JVM_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E6%90%AD%E9%85%8D.png" alt="JVM_垃圾回收器搭配"></li>
<li>Serial<ul>
<li>复制算法，单线程，新生代</li>
<li><img src="/2019/09/04/%E8%AF%AD%E8%A8%80/Java/JVM/Java-JVM-0-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/JVM_Serial.png" alt="JVM_Serial"></li>
</ul>
</li>
<li>ParNew<ul>
<li>复制算法，多线程，新生代</li>
<li><img src="/2019/09/04/%E8%AF%AD%E8%A8%80/Java/JVM/Java-JVM-0-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/JVM_ParNew.png" alt="JVM_ParNew"></li>
</ul>
</li>
<li>Parallel Scavenge<ul>
<li>多线程，复制算法，新生代，高吞吐量</li>
</ul>
</li>
<li>Serial Old<ul>
<li>标记-整理算法，老年代</li>
<li><img src="/2019/09/04/%E8%AF%AD%E8%A8%80/Java/JVM/Java-JVM-0-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/JVM_Serial_Old.jpeg" alt="JVM_Serial_Old"></li>
</ul>
</li>
<li>Parallel Old<ul>
<li>标记-整理算法，老年代，注重吞吐量的场景下</li>
<li>JDK8 默认采用 Parallel Scavenge + Parallel Old 的组合</li>
<li><img src="/2019/09/04/%E8%AF%AD%E8%A8%80/Java/JVM/Java-JVM-0-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/JVM_Parallel_Old.jpg" alt="JVM_Parallel_Old"></li>
</ul>
</li>
<li>CMS<ul>
<li>是一种以获取最短回收停顿时间为目标的收集器</li>
<li>基于“标记-清除”算法实现</li>
<li><img src="/2019/09/04/%E8%AF%AD%E8%A8%80/Java/JVM/Java-JVM-0-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/JVM_CMS.jpg" alt="JVM_CMS"></li>
<li>运作过程：<ul>
<li>初始标记<ul>
<li>需要“stop the world”<ul>
<li>stop the world<ul>
<li>Stop-The-World 机制简称 STW，是在执行垃圾收集算法时，Java 应用程序的其他所有线程都被挂起（除了垃圾收集帮助器之外）。</li>
<li>Java 中一种全局暂停现象，全局停顿，所有 Java 代码停止，native 代码可以执行，但不能与 JVM 交互；这些现象多半是由于 gc 引起。</li>
</ul>
</li>
</ul>
</li>
<li>仅仅只是标记一下 GC Roots 能直接关联到的对象，速度很快</li>
</ul>
</li>
<li>并发标记<ul>
<li>进行 GC Roots Tracing</li>
</ul>
</li>
<li>重新标记<ul>
<li>需要“stop the world”</li>
<li>是为了修正并发标记期间因用户程序继续运作而导致标记产生表动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍⻓点，但远比并发标记的时间短</li>
</ul>
</li>
<li>并发清除</li>
</ul>
</li>
<li>优点<ul>
<li>并发收集、低停顿。</li>
</ul>
</li>
<li>缺点<ul>
<li>CMS 收集器对 CPU 资源非常敏感。在并发阶段，它虽然不会导致用户线程停顿，但是会因为占用了一部分线程而导致应用程序变慢，总吞吐量会降低。</li>
<li>CMS 收集器无法处理浮动垃圾，可能会出现“Concurrent Mode Failure（并发模式故障）”失败而导致 Full GC 产生。<ul>
<li>浮动垃圾<ul>
<li>由于 CMS 并发清理阶段用户线程还在运行着，伴随着程序运行自然就会有新的垃圾不断产生，这部分垃圾出现的标记过程之后，CMS 无法在当次收集中处理掉它们，只好留待下一次 GC 中再清理。</li>
</ul>
</li>
</ul>
</li>
<li>容易出现大量空间碎片。当空间碎片过多，将会给大对象分配带来很大的麻烦，往往会出现老年代还有很大空间剩余，但是无法找到足够大的连续空间来分配当前对象，不得不提前触发一次 Full GC。</li>
</ul>
</li>
</ul>
</li>
<li>G1<ul>
<li>从整体来看是基于“标记整理”算法实现的收集器; 从局部上来看是基于“复制”算法实现的。</li>
<li><img src="/2019/09/04/%E8%AF%AD%E8%A8%80/Java/JVM/Java-JVM-0-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/JVM_G1%E6%94%B6%E9%9B%86%E5%99%A8.png" alt="JVM_G1收集器"></li>
<li>JDK9 默认垃圾收集器 G1</li>
<li>G1 把堆划分成多个大小相等的独立区域（Region），新生代和老年代不再物理隔离。<ul>
<li>通过引入 Region 的概念，从而将原来的一整块内存空间划分成多个的小空间，使得每个小空间可以单独进行垃圾回收。这种划分方法带来了很大的灵活性，使得可预测的停顿时间模型成为可能。通过记录每个 Region 垃圾回收时间以及回收所获得的空间（这两个值是通过过去回收的经验获得），并维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的 Region。</li>
<li>每个 Region 都有一个 Remembered Set，用来记录该 Region 对象的引用对象所在的 Region。通过使用 Remembered Set，在做可达性分析的时候就可以避免全堆扫描。</li>
<li>虽然 G1 可以不需要其他收集器配合就能独立管理整个 GC 堆，但是还是保留了分代的概念。它能够采用不同的方式去处理新创建的对象和已经存活了一段时间，熬过多次 GC 的旧对象以获取更好的收集效果。</li>
</ul>
</li>
<li>对象分配策略<ul>
<li>TLAB（Thread Local Allocation Buffer）线程本地分配缓冲区</li>
<li>Eden 区中分配</li>
<li>Humongous 区分配<ul>
<li>Humongous：如果一个对象占用的空间超过了分区容量 75% 以上，G1 收集器就认为这是一个巨型对象。</li>
<li>这些巨型对象，默认直接会被分配在年老代，但是如果它是一个短期存在的巨型对象，就会对垃圾收集器造成负面影响。</li>
<li>为了解决这个问题，G1 划分了一个 Humongous 区，它用来专门存放巨型对象。</li>
<li>如果一个 H 区装不下一个巨型对象，那么 G1 会寻找连续的 H 分区来存储。为了能找到连续的H区，有时候不得不启动 Full GC。</li>
</ul>
</li>
</ul>
</li>
<li>运作步骤：<ul>
<li>初始标记</li>
<li>并发标记</li>
<li>最终标记</li>
<li>筛选回收<ul>
<li>用来统计每个 region 中的中被标记为存活的对象的数量，这个阶段如果发现完全没有活对象的 region 就会将其整体回收到可分配 region 列表中。</li>
<li>把一部分 region 里活的对象拷贝到空的 region 里面，然后回收原本的 region 空间，此阶段可以选择任意多个 region 来构成收集集合（Collection Set），选定好收集集合之后，便可以将 Collection Set 中的对象并行拷贝到新的 region 中。</li>
</ul>
</li>
</ul>
</li>
<li><img src="/2019/09/04/%E8%AF%AD%E8%A8%80/Java/JVM/Java-JVM-0-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/JVM_G1.jpeg" alt="JVM_G1"></li>
<li>特点<ul>
<li>G1 能充分利用 CPU、多核环境下的硬件优势，使用多个CPU（CPU 或者 CPU 核心）来缩短 stop-The-World 停顿时间。部分其他收集器原本需要停顿 Java 线程执行的 GC 动作，G1 收集器仍然可以通过并发的方式让 Java 程序继续执行。</li>
</ul>
</li>
<li>相关问题<ul>
<li><strong>G1 的个显著特点他能够让用户设置应用的暂停时间，为什么 G1 能做到这一点呢？</strong><ul>
<li>G1 回收的第 4 步，它是“选择一些内存块”，而不是整代内存来回收，这是 G1 跟其它 GC 非常不同的一点，其它 GC 每次回收都会回收整个 Generation 的内存（Eden, Old），而回收内存所需的时间就取决于内存的大小，以及实际垃圾的多少，所以垃圾回收时间是不可控的；而 G1 每次并不会回收整代内存，到底回收多少内存就看用户配置的暂停时间，配置的时间短就少回收点，配置的时间长就多回收点，伸缩自如。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>垃圾标记<ul>
<li>三色标记法<ul>
<li>颜色说明<ul>
<li>白色：尚未访问过。</li>
<li>黑色：本对象已访问过，而且本对象 引用到 的其他对象 也全部访问过了。</li>
<li>灰色：本对象已访问过，但是本对象 引用到 的其他对象 尚未全部访问完。全部访问后，会转换为黑色。</li>
</ul>
</li>
<li>流程<ul>
<li>停止线程标记<ul>
<li><img src="/2019/09/04/%E8%AF%AD%E8%A8%80/Java/JVM/Java-JVM-0-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/JVM_%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0%E6%B5%81%E7%A8%8B_1.webp" alt="JVM_三色标记流程_1"></li>
</ul>
<ol>
<li>初始时，所有对象都在【白色集合】中；</li>
<li>将GC Roots 直接引用到的对象挪到【灰色集合】中；</li>
<li>从灰色集合中获取对象：<ol>
<li>将本对象引用到的其他对象全部挪到【灰色集合】中；</li>
<li>将本对象挪到【黑色集合】里面。</li>
</ol>
</li>
<li>重复步骤3，直至【灰色集合】为空时结束。</li>
<li>结束后，仍在【白色集合】的对象即为GC Roots 不可达，可以进行回收。</li>
</ol>
</li>
<li>并发标记<ul>
<li>问题<ul>
<li>多标-浮动垃圾<ul>
<li><img src="/2019/09/04/%E8%AF%AD%E8%A8%80/Java/JVM/Java-JVM-0-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/JVM_%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0_%E6%B5%AE%E5%8A%A8%E5%9E%83%E5%9C%BE.webp" alt="JVM_三色标记_浮动垃圾"></li>
<li>此刻之后，对象E/F/G是“应该”被回收的。然而因为<strong>E已经变为灰色</strong>了，其仍会被<strong>当作存活对象</strong>继续遍历下去。最终的结果是：这部分对象仍会被标记为存活，即<strong>本轮GC不会回收这部分内存</strong>。</li>
<li>这部分本应该回收 但是 没有回收到的内存，被称之为“<strong>浮动垃圾</strong>”。浮动垃圾并不会影响应用程序的正确性，只是需要等到下一轮垃圾回收中才被清除。</li>
<li>另外，针对并发标记开始后的<strong>新对象</strong>，通常的做法是直接全部<strong>当成黑色</strong>，本轮不会进行清除。这部分对象期间可能会变为垃圾，这也算是浮动垃圾的一部分。</li>
</ul>
</li>
<li>漏标-读写屏障<ul>
<li><img src="/2019/09/04/%E8%AF%AD%E8%A8%80/Java/JVM/Java-JVM-0-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/JVM_%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0_%E6%BC%8F%E6%A0%87.webp" alt="JVM_三色标记_漏标"><ol>
<li>读取对象 E 的成员变量 fieldG 的引用值，即对象 G；</li>
<li>对象 E 往其成员变量 fieldG，写入 null 值。</li>
<li>对象 D 往其成员变量 fieldG，写入对象 G；</li>
</ol>
<ul>
<li>我们只要在上面这三步中的任意一步中做一些“手脚”，<strong>将对象 G 记录起来，然后作为灰色对象再进行遍历</strong>即可。比如放到一个特定的集合，等初始的 GC Roots 遍历完（并发标记），该集合的对象遍历即可（重新标记）。</li>
</ul>
</li>
<li>此时切回GC线程继续跑，因为<strong>E已经没有对G的引用了，所以不会将G放到灰色集合</strong>；尽管因为D重新引用了G，但因为<strong>D已经是黑色</strong>了，不会再重新做遍历处理。</li>
<li>最终导致的结果是：G会一直停留在白色集合中，<strong>最后被当作垃圾进行清除</strong>。这直接<strong>影响到了应用程序的正确性</strong>，是不可接受的。</li>
<li>不难分析，漏标只有<strong>同时满足</strong>以下两个条件时才会发生：<ol>
<li>灰色对象断开了白色对象的引用（直接或间接的引用）；即灰色对象原来成员变量的引用发生了变化。</li>
<li>黑色对象重新引用了该白色对象；即黑色对象成员变量增加了新的引用。</li>
</ol>
</li>
<li>解决方法<ul>
<li>写屏障（Store Barrier）<ul>
<li>写屏障 + SATB<ul>
<li>这种做法的思路是：<strong>尝试保留开始时的对象图，即原始快照（Snapshot At The Beginning，SATB）</strong>，当某个时刻的 GC Roots 确定后，当时的对象图就已经确定了。</li>
<li>比如当时 D 是引用着 G 的，那后续的标记也应该是按照这个时刻的对象图走（D 引用着 G）。如果期间发生变化，则可以记录起来，保证标记依然按照原本的视图来。</li>
<li><blockquote>
<p>SATB 破坏了条件一：【灰色对象 断开了 白色对象的引用】，从而保证了不会漏标。</p>
</blockquote>
</li>
</ul>
</li>
<li>写屏障 + 增量更新<ul>
<li>这种做法的思路是：不要求保留原始快照，而是<strong>针对新增的引用</strong>，将其记录下来等待遍历，即增量更新（Incremental Update）。</li>
<li><blockquote>
<p>增量更新破坏了条件二：【黑色对象 重新引用了 该白色对象】，从而保证了不会漏标。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
<li>读屏障（Load Barrier）<ul>
<li>当读取成员变量时，一律记录下来</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Java HotSpot VM 中，其并发标记时对漏标的处理方案如下：<ul>
<li>CMS：写屏障 + 增量更新</li>
<li>G1：写屏障 + SATB</li>
<li>ZGC：读屏障</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>GC 流程<ul>
<li><img src="/2019/09/04/%E8%AF%AD%E8%A8%80/Java/JVM/Java-JVM-0-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/JVM_GC%E6%B5%81%E7%A8%8B.png" alt="JVM_GC流程"></li>
<li>内存分配策略<ul>
<li>对象优先在 Eden 分配<ul>
<li>大多数情况下，对象在新生代 Eden 上分配，当 Eden 空间不够时，发起 Minor GC。</li>
</ul>
</li>
<li>大对象直接进入老年代<ul>
<li>大对象是指需要连续内存空间的对象，最典型的大对象是那种很长的字符串以及数组。</li>
<li>经常出现大对象会提前触发垃圾收集以获取足够的连续空间分配给大对象。</li>
<li><code>-XX:PretenureSizeThreshold</code>，大于此值的对象直接在老年代分配，避免在 Eden 和 Survivor 之间的大量内存复制。</li>
</ul>
</li>
<li>长期存活的对象进入老年代<ul>
<li>为对象定义年龄计数器，对象在 Eden 出生并经过 Minor GC 依然存活，将移动到 Survivor 中，年龄就增加 1 岁，增加到一定年龄则移动到老年代中。</li>
<li><code>-XX:MaxTenuringThreshold</code> 用来定义年龄的阈值。</li>
</ul>
</li>
<li>动态对象年龄判定<ul>
<li>虚拟机并不是永远要求对象的年龄必须达到 MaxTenuringThreshold 才能晋升老年代，如果在 Survivor 中相同年龄所有对象大小的总和大于 Survivor 空间的一半，则年龄大于或等于该年龄的对象可以直接进入老年代，无需等到 MaxTenuringThreshold 中要求的年龄。</li>
</ul>
</li>
<li>空间分配担保<ul>
<li>在发生 Minor GC 之前，虚拟机先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果条件成立的话，那么 Minor GC 可以确认是安全的。</li>
<li>如果不成立的话虚拟机会查看 HandlePromotionFailure 的值是否允许担保失败，如果允许那么就会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次 Minor GC；如果小于，或者 HandlePromotionFailure 的值不允许冒险，那么就要进行一次 Full GC。</li>
</ul>
</li>
</ul>
</li>
<li>垃圾回收分类<ul>
<li>Minor GC<ul>
<li>回收新生代，因为新生代对象存活时间很短，因此 Minor GC 会频繁执行，执行的速度一般也会比较快。</li>
<li>Minor GC 的触发条件<ul>
<li>当 Eden 空间满时，就将触发一次 Minor GC。</li>
</ul>
</li>
<li>正式 Minor GC 前的检查<ul>
<li>在正式 Minor GC 前，JVM 会先检查新生代中对象，是比老年代中剩余空间大还是小。<ul>
<li><strong>为什么要做这样的检查呢？</strong><ul>
<li>原因很简单，假如 Minor GC 之后 Survivor 区放不下剩余对象，这些对象就要进入到老年代，所以要提前检查老年代是不是够用。这样就有两种情况：<ol>
<li>老年代剩余空间大于新生代中的对象大小，那就直接 Minor GC，GC 完 survivor 不够放，老年代也绝对够放</li>
<li>老年代剩余空间小于新生代中的对象大小，这个时候就要查看是否启用了「老年代空间分配担保规则」，具体来说就是看 <code>-XX:-HandlePromotionFailure</code> 参数是否设置了（一般都会设置）<ul>
<li>老年代空间分配担保规则是这样的。如果老年代中剩余空间大小，大于历次 Minor GC 之后剩余对象的大小，那就允许进行 Minor GC。因为从概率上来说，以前的放的下，这次的也应该放的下。那就有两种情况：<ol>
<li>老年代中剩余空间大小，大于历次 Minor GC 之后剩余对象的大小，进行 Minor GC</li>
<li>老年代中剩余空间大小，小于历次 Minor GC 之后剩余对象的大小，进行 Full GC，把老年代空出来再检查</li>
</ol>
</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Minor GC 后的处境<ul>
<li>前面说了，开启<strong>老年代空间分配担保规则</strong>只能说是大概率上来说，Minor GC 剩余后的对象够放到老年代，所以当然也会有万一，Minor GC 后会有这样三种情况：<ol>
<li>Minor GC 之后的对象足够放到 Survivor 区，皆大欢喜，GC 结束</li>
<li>Minor GC 之后的对象不够放到 Survivor 区，接着进入到老年代，老年代能放下，那也可以，GC 结束</li>
<li>Minor GC 之后的对象不够放到 Survivor 区，老年代也放不下，那就只能 Full GC</li>
</ol>
</li>
</ul>
</li>
<li>实在不行只能 OOM<ul>
<li>前面都是成功 GC 的例子，还有 3 种情况，会导致 GC 失败，报 OOM：</li>
</ul>
<ol>
<li>紧接上一节 Full GC 之后，老年代任然放不下剩余对象，就只能 OOM</li>
<li>未开启老年代分配担保机制，且一次 Full GC 后，老年代任然放不下剩余对象，也只能 OOM</li>
<li>开启老年代分配担保机制，但是担保不通过，一次 Full GC 后，老年代任然放不下剩余对象，也是能 OOM</li>
</ol>
</li>
</ul>
</li>
<li>Full GC<ul>
<li>回收老年代和新生代，老年代对象其存活时间长，因此 Full GC 很少执行，执行速度会比 Minor GC 慢很多。</li>
<li>Full GC 的触发条件<ul>
<li>调用 <code>System.gc()</code><ul>
<li>只是建议虚拟机执行 Full GC，但是虚拟机不一定真正去执行。不建议使用这种方式，而是让虚拟机管理内存。</li>
</ul>
</li>
<li>老年代空间不足<ul>
<li>老年代空间不足的常见场景为大对象直接进入老年代、长期存活的对象进入老年代等。</li>
<li>为了避免以上原因引起的 Full GC，应当尽量不要创建过大的对象以及数组。除此之外，可以通过 -Xmn 虚拟机参数调大新生代的大小，让对象尽量在新生代被回收掉，不进入老年代。还可以通过 <code>-XX:MaxTenuringThreshold</code> 调大对象进入老年代的年龄，让对象在新生代多存活一段时间。</li>
</ul>
</li>
<li>空间分配担保失败<ul>
<li>使用复制算法的 Minor GC 需要老年代的内存空间作担保，如果担保失败会执行一次 Full GC。</li>
</ul>
</li>
<li>JDK 1.7 及以前的永久代空间不足<ul>
<li>在 JDK 1.7 及以前，HotSpot 虚拟机中的方法区是用永久代实现的，永久代中存放的为一些 Class 的信息、常量、静态变量等数据。</li>
<li>当系统中要加载的类、反射的类和调用的方法较多时，永久代可能会被占满，在未配置为采用 CMS GC 的情况下也会执行 Full GC。如果经过 Full GC 仍然回收不了，那么虚拟机会抛出 java.lang.OutOfMemoryError。</li>
<li>为避免以上原因引起的 Full GC，可采用的方法为增大永久代空间或转为使用 CMS GC。</li>
</ul>
</li>
<li>Concurrent Mode Failure<ul>
<li>执行 CMS GC 的过程中同时有对象要放入老年代，而此时老年代空间不足（可能是 GC 过程中浮动垃圾过多导致暂时性的空间不足），便会报 Concurrent Mode Failure 错误，并触发 Full GC。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="相关问题"><a href="#相关问题" class="headerlink" title="相关问题"></a>相关问题</h2><ul>
<li><strong>为何 Java 代码越执行越快？</strong><ul>
<li>JIT 编译优化</li>
<li>TLAB 预热</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wetts.github.io/2019/09/04/%E8%AF%AD%E8%A8%80/Java/basic_Java/Java-basic-0-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Zhang Wetts">
      <meta itemprop="description" content="Stay Hungry, Stay Foolish. <br><br><p style="font-size:8px;">[build by hexo/next/gitalk/hexo-generator-search/LaTeX]</p>">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wetts's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/09/04/%E8%AF%AD%E8%A8%80/Java/basic_Java/Java-basic-0-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/" class="post-title-link" itemprop="url">Java-basic-0-知识点汇总</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-09-04 23:46:32" itemprop="dateCreated datePublished" datetime="2019-09-04T23:46:32+08:00">2019-09-04</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h1><h2 id="Basic-Java"><a href="#Basic-Java" class="headerlink" title="Basic Java"></a>Basic Java</h2><h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h3><ul>
<li>三大特性<ul>
<li>封装<ul>
<li>指一种将抽象性函式接口的实现细节部分包装、隐藏起来的方法。</li>
</ul>
</li>
<li>继承<ul>
<li>子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为。</li>
<li>访问权限<ul>
<li>public</li>
<li>protected<ul>
<li>protected 用于修饰成员，表示在继承体系中成员对于子类可见，但是这个访问修饰符对于类没有意义。</li>
</ul>
</li>
<li>default<ul>
<li>包级可见</li>
</ul>
</li>
<li>private</li>
</ul>
</li>
<li>重写与重载<ul>
<li>重写（Override）<ul>
<li>存在于继承体系中，指子类实现了一个与父类在方法声明上完全相同的一个方法。</li>
<li>三个限制（使用 @Override 注解，可以让编译器帮忙检查是否满足上面的三个限制条件。）<ul>
<li>子类方法的访问权限必须大于等于父类方法；</li>
<li>子类方法的返回类型必须是父类方法返回类型或为其子类型。</li>
<li>子类方法抛出的异常类型必须是父类抛出异常类型或为其子类型。</li>
</ul>
</li>
<li>在调用一个方法时，先从本类中查找看是否有对应的方法，如果没有再到父类中查看，看是否从父类继承来。否则就要对参数进行转型，转成父类之后看是否有对应的方法。总的来说，方法调用的优先级为：<ul>
<li><code>this.func(this)</code></li>
<li><code>super.func(this)</code></li>
<li><code>this.func(super)</code></li>
<li><code>super.func(super)</code></li>
</ul>
</li>
</ul>
</li>
<li>重载（Overload）<ul>
<li>存在于同一个类中，指一个方法与已经存在的方法名称上相同，但是参数类型、个数、顺序至少有一个不同。</li>
<li><strong>应该注意的是，返回值不同，其它都相同不算是重载。</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>多态<ul>
<li>多态是同一个行为具有多个不同表现形式或形态的能力。</li>
</ul>
</li>
</ul>
</li>
<li>类</li>
<li>抽象类、接口<ul>
<li>接口<ul>
<li>接口的属性默认都是 static 和 final 的。</li>
<li>版本区别<ul>
<li>接口是抽象类的延伸，在 Java 8 之前，它可以看成是一个完全抽象的类，也就是说它不能有任何的方法实现。</li>
<li>从 Java 8 开始，接口也可以拥有默认的方法实现，这是因为不支持默认方法的接口的维护成本太高了。在 Java 8 之前，如果一个接口想要添加新的方法，那么要修改所有实现了该接口的类，让它们都实现新增的方法。</li>
<li>接口的成员（字段 + 方法）默认都是 public 的，并且不允许定义为 private 或者 protected。从 Java 9 开始，允许将方法定义为 private，这样就能定义某些复用的代码又不会把方法暴露出去。</li>
</ul>
</li>
</ul>
</li>
<li>抽象类（abstract class）和接口（interface）区别<ul>
<li>语法上的区别<ul>
<li>抽象类只能单继承，接口可以多实现。</li>
<li>抽象类可以有构造方法，接口中不能有构造方法。</li>
<li>抽象类中可以有成员变量，接口中没有成员变量，只能有常量（默认就是 public static final）</li>
<li>抽象类中可以包含非抽象的方法，在 Java 7 之前接口中的所有方法都是抽象的，在 Java 8 之后，接口支持非抽象方法：default 方法、静态方法等。Java 9 支持私有方法、私有静态方法。</li>
<li>抽象类中的抽象方法类型可以是任意修饰符，Java 8 之前接口中的方法只能是 public 类型，Java 9 支持 private 类型。</li>
</ul>
</li>
<li>设计思想的区别<ul>
<li>接口是自上而下的抽象过程，接口规范了某些行为，是对某一行为的抽象。我需要这个行为，我就去实现某个接口，但是具体这个行为怎么实现，完全由自己决定。</li>
<li>抽象类是自下而上的抽象过程，抽象类提供了通用实现，是对某一类事物的抽象。我们在写实现类的时候，发现某些实现类具有几乎相同的实现，因此我们将这些相同的实现抽取出来成为抽象类，然后如果有一些差异点，则可以提供抽象方法来支持自定义实现。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>枚举<ul>
<li>枚举是一个被命名的整型常数的集合，用于声明一组带标识符的常数。</li>
<li>在 JDK 1.5 之前没有枚举类型，那时候一般用接口常量来替代。而使用 Java 枚举类型 enum 可以更贴近地表示这种常量。</li>
<li>常见用法<ul>
<li>常量</li>
<li>switch</li>
<li>向枚举中添加新方法</li>
<li>覆盖枚举的方法</li>
<li>实现接口</li>
<li>使用接口组织枚举</li>
<li>枚举集合<ul>
<li>java.util.EnumSet 和 java.util.EnumMap 是两个枚举集合。EnumSet 保证集合中的元素不重复；EnumMap 中的 key 是 enum 类型，而 value 则可以是任意类型。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>注解<ul>
<li>Java 注解是附加在代码中的一些元信息，用于一些工具在编译、运行时进行解析和使用，起到说明、配置的功能。注解不会也不能影响代码的实际逻辑，仅仅起到辅助性的作用。</li>
<li>格式<ul>
<li><pre><code>public @interface 注解名称&#123;
    属性列表;
&#125;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br></pre></td><td class="code"><pre><span class="line">  - 分类</span><br><span class="line">    - 自定义注解</span><br><span class="line">    - JDK 内置注解</span><br><span class="line">      - 比如 @Override 检验方法重写，@Deprecated 标识方法过期等</span><br><span class="line">    - 第三方框架提供的注解</span><br><span class="line">      - 比如 SpringMVC 的 @Controller 等</span><br><span class="line">  - 使用位置</span><br><span class="line">    - 实际开发中，注解常常出现在类、方法、成员变量、形参位置。</span><br><span class="line">  - 作用</span><br><span class="line">    - 目的是为当前读取该注解的程序提供判断依据。比如程序只要读到加了 @Test 的方法，就知道该方法是待测试方法，又比如 @Before 注解，程序看到这个注解，就知道该方法要放在 @Test 方法之前执行。</span><br><span class="line">  - 级别</span><br><span class="line">    - 注解和类、接口、枚举是同一级别的。</span><br><span class="line">  - 元注解</span><br><span class="line">    - 所谓元注解，就是加在注解上的注解。</span><br><span class="line">    - 常用元注解</span><br><span class="line">      - @Documented</span><br><span class="line">        - 用于制作文档</span><br><span class="line">      - @Target</span><br><span class="line">        - 加在注解上，限定该注解的使用位置。不写的话，好像默认各个位置都是可以的。如果需要限定注解的使用位置，可以在自定义的注解上使用该注解。</span><br><span class="line">      - @Retention（注解的保留策略）</span><br><span class="line">        - 注解的保留策略有三种：SOURCE/CLASS/RUNTIME</span><br><span class="line">        - 注解主要被反射读取</span><br><span class="line">        - 反射只能读取内存中的字节码信息</span><br><span class="line">        - RetentionPolicy.CLASS 指的是保留到字节码文件，它在磁盘内，而不是内存中。虚拟机将字节码文件加载进内存后注解会消失</span><br><span class="line">        - 要想被反射读取，保留策略只能用RUNTIME，即运行时仍可读取</span><br><span class="line">          - 注解的读取并不只有反射一种途径。比如 @Override，它由编译器读取（你写完代码 ctrl+s 时就编译了），而编译器只是检查语法错误，此时程序尚未运行。@Override 的保留策略是 SOURCE。</span><br><span class="line">  - 属性的数据类型及特别的属性</span><br><span class="line">    - value 属性</span><br><span class="line">      - 如果注解的属性只有一个，且叫 value，那么使用该注解时，可以不用指定属性名，因为默认就是给 value 赋值。但是注解的属性如果有多个，无论是否叫value，都必须写明属性的对应关系。</span><br><span class="line">    - 数组属性</span><br><span class="line">      - </span><br><span class="line">- 反射</span><br><span class="line">  - 每个类都有一个**Class**对象，包含了与类有关的信息。当编译一个新类时，会产生一个同名的 .class 文件，该文件内容保存着 Class 对象。</span><br><span class="line">  - 类加载相当于 Class 对象的加载，类在第一次使用时才动态加载到 JVM 中。也可以使用 `Class.forName(&quot;com.mysql.jdbc.Driver&quot;)` 这种方式来控制类的加载，该方法会返回一个 Class 对象。</span><br><span class="line">  - 反射可以提供运行时的类信息，并且这个类可以在运行时才加载进来，甚至在编译时期该类的 .class 不存在也可以加载进来。</span><br><span class="line">  - 反射的三种方式</span><br><span class="line">    - 通过 new 对象实现反射：`obj.getClass()`</span><br><span class="line">    - 通过路径实现：`Class.forName()`</span><br><span class="line">    - 通过类名实现：`Clazz.class`</span><br><span class="line">  - Class 和 java.lang.reflect 一起对反射提供了支持，java.lang.reflect 类库主要包含了以下三个类：</span><br><span class="line">    - **Field**  ：可以使用 `get()` 和 `set()` 方法读取和修改 Field 对象关联的字段；</span><br><span class="line">    - **Method**  ：可以使用 `invoke()` 方法调用与 Method 对象关联的方法；</span><br><span class="line">    - **Constructor**  ：可以用 Constructor 的 `newInstance()` 创建新的对象。</span><br><span class="line">  - 整体流程</span><br><span class="line">    - 准备阶段：编译期装载所有的类，将每个类的元信息保存至 Class 类对象中，每一个类对应一个 Class 对象</span><br><span class="line">    - 获取 Class 对象：调用 `x.class/x.getClass()/Class.forName()` 获取 x 的 Class 对象 clz</span><br><span class="line">    - 进行实际反射操作：通过 clz 对象获取 Field/Method/Constructor 对象进行进一步操作</span><br><span class="line">  - 优点</span><br><span class="line">    - **可扩展性**：应用程序可以利用全限定名创建可扩展对象的实例，来使用来自外部的用户自定义类。</span><br><span class="line">    - **类浏览器和可视化开发环境**：一个类浏览器需要可以枚举类的成员。可视化开发环境（如 IDE）可以从利用反射中可用的类型信息中受益，以帮助程序员编写正确的代码。</span><br><span class="line">    - **调试器和测试工具**：调试器需要能够检查一个类里的私有成员。测试工具可以利用反射来自动地调用类里定义的可被发现的 API 定义，以确保一组测试中有较高的代码覆盖率。</span><br><span class="line">  - 缺点</span><br><span class="line">    - **性能开销**：反射涉及了动态类型的解析，所以 JVM 无法对这些代码进行优化。因此，反射操作的效率要比那些非反射操作低得多。我们应该避免在经常被执行的代码或对性能要求很高的程序中使用反射。</span><br><span class="line">    - **安全限制**：使用反射技术要求程序必须在一个没有安全限制的环境中运行。如果一个程序必须在有安全限制的环境中运行，如 Applet，那么这就是个问题了。</span><br><span class="line">    - **内部暴露**：由于反射允许代码执行一些在正常情况下不被允许的操作（比如访问私有的属性和方法），所以使用反射可能会导致意料之外的副作用，这可能导致代码功能失调并破坏可移植性。反射代码破坏了抽象性，因此当平台发生改变的时候，代码的行为就有可能也随着变化。</span><br><span class="line">- 范型</span><br><span class="line">  - 泛型的本质是为了参数化类型（在不创建新的类型的情况下，通过泛型指定的不同类型来控制形参具体限制的类型）。也就是说在泛型使用过程中，操作的数据类型被指定为一个参数，这种参数类型可以用在类、接口和方法中，分别被称为泛型类、泛型接口、泛型方法。</span><br><span class="line">  - 限定通配符和非限定通配符</span><br><span class="line">    - 限定通配符</span><br><span class="line">      - `&lt;? extends T&gt;`</span><br><span class="line">        - 确保类型必须是T的子类来设定类型的上界</span><br><span class="line">      - `&lt;? super T&gt;`</span><br><span class="line">        - 确保类型必须是T的父类来设定类型的下界</span><br><span class="line">    - 非限定通配符</span><br><span class="line">      - `&lt;?&gt;`</span><br><span class="line">        - 用任意类型来替代</span><br><span class="line">  - 实现原理</span><br><span class="line">    - 泛型是通过类型擦除来实现的，编译器在编译时擦除了所有类型相关的信息，所以在运行时不存在任何类型相关的信息。例如`List&lt;String&gt;`在运行时仅用一个 List 来表示。这样做的目的，是确保能和 Java5 之前的版本开发二进制类库进行兼容。你无法在运行时访问到类型参数，因为编译器已经把泛型类型转换成了原始类型。</span><br><span class="line"></span><br><span class="line">### 关键字</span><br><span class="line">- 保留关键字</span><br><span class="line">  - const</span><br><span class="line">    - 常量，常数：用于修改字段或局部变量的声明。</span><br><span class="line">  - goto</span><br><span class="line">    - 转到：指定跳转到标签，找到标签后，程序将处理从下一行开始的命令</span><br><span class="line">- 访问修饰符的关键字</span><br><span class="line">  - public （公有的）：可跨包</span><br><span class="line">  - protected（受保护的）：当前包内可用</span><br><span class="line">  - private（私有的）：当前类可用</span><br><span class="line">- 定义类、接口、抽象类和实现接口、继承类的关键字、实例化对象</span><br><span class="line">  - class（类）：`public class A()&#123;&#125;` 花括号里是已实现的方法体，类名需要与文件名相同</span><br><span class="line">  - interface（接口）：`public interface B()&#123;&#125;` 花括号里有方法体，但没有实现，方法体句子后面是英文分号 ; 结尾</span><br><span class="line">  - abstract（声明抽象）：`public abstract class C()&#123;&#125;` 介于类与接口中间，可以有，也可以没有已经实现的方法体</span><br><span class="line">  - implemenst（实现）：用于类或接口，实现接口 `public class A interface B()&#123;&#125;`</span><br><span class="line">  - extends（继承）：用于类继承类 `public class A extends D()&#123;&#125;`</span><br><span class="line">  - new（创建新对象）：`A a=new A();` A 表示一个类</span><br><span class="line">- 包的关键字</span><br><span class="line">  - import（引入包的关键字）：当使用某个包的一些类时，仅需要类名</span><br><span class="line">  - package（定义包的关键字）：将所有相关的类放在一个包类以便查找修改等</span><br><span class="line">- 数据类型的关键字</span><br><span class="line">  - byte（字节型）：8bit</span><br><span class="line">  - char（字节型）：16bit</span><br><span class="line">  - boolean（布尔型）：--</span><br><span class="line">  - short（短整型）：16bit</span><br><span class="line">  - int（整型）：32bit</span><br><span class="line">  - float（浮点型）：32bit</span><br><span class="line">  - long（长整型）：64bit</span><br><span class="line">  - double（双精度）：64bit</span><br><span class="line">  - void（无返回）：`public void A()&#123;&#125;` 其他需要反回的经常与 return 连用</span><br><span class="line">  - null（空值）</span><br><span class="line">  - true（真）</span><br><span class="line">  - false（假）</span><br><span class="line">- 条件循环（流程控制）</span><br><span class="line">  - if（如果）：if（条件语句｛执行代码｝如果条件语句成立，就开始执行｛｝里面的内容</span><br><span class="line">  - else（否则，或者）：常与 if 连用，用法相同：`if(...)&#123;...&#125;else&#123;...&#125;`</span><br><span class="line">  - while（当什么时候）：while（条件语句）｛执行代码｝</span><br><span class="line">  - for（满足三个条件时）：`for(初始化循环变量；判断条件；循环变量值)&#123;&#125;`</span><br><span class="line">  - switch（选择结构）：`switch(表达式)&#123;case 常量表达式1: 语句1；...case 常量表达式2; 语句2; default:语句；&#125;` default 就是如果没有匹配的 case 就执行它，default 并不是必须的。case 后的语句可以不用大括号。</span><br><span class="line">  - case（匹配switch的表达式里的结果）：同上</span><br><span class="line">  - default（默认）：default 就是如果没有匹配的 case 就执行它，default 并不是必须的</span><br><span class="line">  - do（运行）：通常与 while 连用</span><br><span class="line">  - break（跳出循环）：直接跳出循环，执行循环体后的代码</span><br><span class="line">  - continue（继续）：中断本次循环，并开始下一轮循环</span><br><span class="line">  - return（返回）：return 一个返回值类型</span><br><span class="line">  - instanceof（实例）：一个二元操作符，和 ==、&gt;、&lt;是 同一类的。测试它左边的对象是否是它右边的类的实例，返回 boolean 类型的数据</span><br><span class="line">- 修饰方法、类、属性和变量</span><br><span class="line">  - static（静态的）</span><br><span class="line">    - 静态变量</span><br><span class="line">      - 对应 *实例变量*</span><br><span class="line">    - 静态方法</span><br><span class="line">      - 方法中不能有 this 和 super 关键字，因为这两个关键字与具体对象关联。</span><br><span class="line">    - 静态语句块</span><br><span class="line">    - 静态内部类</span><br><span class="line">      - 非静态内部类依赖于外部类的实例，也就是说需要先创建外部类实例，才能用这个实例去创建非静态内部类。而静态内部类不需要。</span><br><span class="line">      - 静态内部类不能访问外部类的非静态的变量和方法。</span><br><span class="line">    - 静态导包</span><br><span class="line">      - 在使用静态变量和方法时不用再指明 ClassName，从而简化代码，但可读性大大降低。</span><br><span class="line">    - 初始化顺序</span><br><span class="line">      - 静态变量和静态语句块优先于实例变量和普通语句块，静态变量和静态语句块的初始化顺序取决于它们在代码中的顺序。</span><br><span class="line">  - final（最终的不可被改变）</span><br><span class="line">    - 数据</span><br><span class="line">      - 对于基本类型，final 使数值不变；</span><br><span class="line">      - 对于引用类型，final 使引用不变，也就不能引用其它对象，但是被引用的对象本身是可以修改的。</span><br><span class="line">    - 方法</span><br><span class="line">      - 不能被子类重写。</span><br><span class="line">        - private 方法隐式地被指定为 final，如果在子类中定义的方法和基类中的一个 private 方法签名相同，此时子类的方法不是重写基类方法，而是在子类中定义了一个新的方法。</span><br><span class="line">    - 类</span><br><span class="line">      - 不允许被继承。</span><br><span class="line">  - super（调用父类的方法）：常见 `public void paint(Graphics g)&#123;super.paint(g);...&#125;`</span><br><span class="line">  - this（当前类的父类的对象）：调用当前类中的方法（表示调用这个方法的对象）`this.addActionListener(al);` 等等</span><br><span class="line">  - native（本地）</span><br><span class="line">  - strictfp（严格，精准）</span><br><span class="line">  - synchronized（线程，同步）：一个时间内只能有一个线程得到执行。另一个线程必须等待当前线程执行完这个代码块以后才能执行该代码块</span><br><span class="line">  - transient（短暂）</span><br><span class="line">  - volatile（易失）</span><br><span class="line">    - 可⻅性</span><br><span class="line">      - volatile 可⻅性是由指令原子性保证的，在 jmm 中定义了 8 类原子性指令，比如 write、store、read、load。而 volatile 就要求 write-store、load-read 成为一个原子性操作，这样子可以确保在读取的时候都是从主内存读入，写入的时候会同步到主内存中。</span><br><span class="line">        - JVM 线程工作时的原子性指令有：</span><br><span class="line">          - lock</span><br><span class="line">            - 将主内存中的变量锁定，为一个线程所独占。</span><br><span class="line">          - unclock</span><br><span class="line">            - 将 lock 加的锁定解除，此时其它的线程可以有机会访问此变量。</span><br><span class="line">          - read</span><br><span class="line">            - 将主内存中的变量值读到工作内存当中。</span><br><span class="line">          - load</span><br><span class="line">            - 将 read 读取的值保存到工作内存中的变量副本中。</span><br><span class="line">          - use</span><br><span class="line">            - 将值传递给线程的代码执行引擎。</span><br><span class="line">          - assign</span><br><span class="line">            - 将执行引擎处理返回的值重新赋值给变量副本。</span><br><span class="line">          - store</span><br><span class="line">            - 将变量副本的值存储到主内存中。</span><br><span class="line">          - write</span><br><span class="line">            - 将 store 存储的值写入到主内存的共享变量当中。</span><br><span class="line">      - MESI协议：在早期的 CPU 中，是通过在总线加 LOCK #锁的方式实现的，但这种方式开销太大，所以 Intel 开发了缓存一致性协议，也就是 MESI 协议，该解决缓存一致性的思路是：当 CPU 写数据时，如果发现操作的变量是共享变量，即在其他 CPU 中也存在该变量的副本，那么他会发出信号通知其他 CPU 将该变量的缓存行设置为无效状态。当其他 CPU 使用这个变量时，首先会去嗅探是否有对该变量更改的信号，当发现这个变量的缓存行已经无效时，会从新从内存中读取这个变量。</span><br><span class="line">      - volatile 内部实现机制就是 MESI 协议，应该是先判断该变量的缓存行状态是否失效，如果失效，才会重新从内存中读取该变量的值，而不是每次都从内存中读取。</span><br><span class="line">    - 有序性（防止指令重排序）</span><br><span class="line">      - **如何保证线程间可⻅和避免指令重排？**</span><br><span class="line">        - 是由内存屏障来保证的，由两个内存屏障：</span><br><span class="line">          - 一个是编译器屏障：阻止编译器重排，保证编译程序时在优化屏障之前的指令不会在优化屏障之后执行。</span><br><span class="line">          - 第二个是 cpu 屏障：sfence 保证写入，lfence 保证读取，lock 类似于锁的方式。java 多执行了一个 `load addl $0x0, (%esp)` 操作，这个操作相当于一个 lock 指令，就是增加一个完全的内存屏障指令。</span><br><span class="line">    - 保障变量单次读，写操作的原子性，但不能保证 i++ 这种操作的原子性，因为本质是读、写两次操作</span><br><span class="line">- 错误处理</span><br><span class="line">  - catch（处理异常）</span><br><span class="line">  - try（捕获异常）</span><br><span class="line">  - finally（有没有异常都执行）</span><br><span class="line">  - throw（抛出一个异常对象）</span><br><span class="line">  - throws（声明一个异常可能被抛出）</span><br><span class="line">- 其他</span><br><span class="line">  - enum（枚举）</span><br><span class="line">  - assert（断言）</span><br><span class="line"></span><br><span class="line">### Java 基本类型</span><br><span class="line">- boolean</span><br><span class="line">  - 在 Java 虚拟机中没有任何供 boolean 值专用的字节码指令，Java 语言表达式所操作的 boolean 值，在编译之后都使用 Java 虚拟机中的 int 数据类型来代替，而 boolean 数组将会被编码成 Java 虚拟机的 byte 数组，每个元素 boolean 元素占 8 位。**具体还取决于虚拟机的实现**。</span><br><span class="line">  - **那虚拟机为什么要用 int 来代替 boolean 呢？为什么不用 byte 或 short，这样不是更节省内存空间吗。**</span><br><span class="line">    - 经过查阅资料发现，使用 int 的原因是，对于当下 32 位的处理器（CPU）来说，一次处理数据是 32 位（这里不是指的是 32/64 位系统，而是指 CPU 硬件层面），32 位 CPU 使用 4 个字节是最为节省的，哪怕你是 1 个 bit 他也是占用 4 个字节。因为 CPU 寻址系统只能 32 位 32 位地寻址，具有高效存取的特点。</span><br><span class="line">- byte</span><br><span class="line">  - 8 位带符号二进制数的取值范围是 `[-128, 127]`</span><br><span class="line">  - 计算时候将他们提升为 int 类型，再进行计算</span><br><span class="line">- short</span><br><span class="line">  - 16 位</span><br><span class="line">- int</span><br><span class="line">  - 32 位</span><br><span class="line">- long</span><br><span class="line">  - 64 位</span><br><span class="line">- float</span><br><span class="line">  - 32 位</span><br><span class="line">- double</span><br><span class="line">  - 64 位</span><br><span class="line">- **自动类型转换规则**</span><br><span class="line">  - 基本就是先转换为高位数据类型，再参加运算，结果也是最高位的数据类型；</span><br><span class="line">    1. 如操作数之一为 double，则另一个操作数先被转化为 double，再参与算术运算。 </span><br><span class="line">    2. 如两操作数均不为 double，当操作数之一为 float，则另一操作数先被转换为 float，再参与运算。 </span><br><span class="line">    3. 如两操作数均不为 double 或 float，当操作数之一为 long，、则另一操作数先被转换为 long，再参与算术运算。 </span><br><span class="line">    4. 如两操作数均不为 double、float 或 long，则两操作数先被转换为 int，再参与运算。</span><br><span class="line">  - byte short char 运算会转换为 int；</span><br><span class="line">    - **当运算符为自动递增运算符（++）或自动递减运算符（--）时，如果操作数为 byte，short 或 char 类型不发生改变。**</span><br><span class="line">  - **如采用 ++、--、+=、*= 等缩略形式的运算符，系统会自动强制将运算结果转换为目标变量的类型。**</span><br><span class="line">- 基本类型对应的缓冲池如下【在使用这些基本类型对应的包装类型时，如果该数值范围在缓冲池范围内，就可以直接使用缓冲池中的对象。】：</span><br><span class="line">  - boolean values true and false</span><br><span class="line">  - all byte values</span><br><span class="line">  - short values between -128 and 127</span><br><span class="line">  - int values between -128 and 127</span><br><span class="line">  - char in the range \u0000 to \u007F</span><br><span class="line"></span><br><span class="line">### 语法</span><br><span class="line">- switch</span><br><span class="line">  - 从 Java 7 开始，可以在 switch 条件判断语句中使用 String 对象。</span><br><span class="line">  - switch 不支持 long、float、double，是因为 switch 的设计初衷是对那些只有少数几个值的类型进行等值判断，如果值过于复杂，那么还是用 if 比较合适。</span><br><span class="line"></span><br><span class="line">### 内置对象</span><br><span class="line">#### Object</span><br><span class="line">- Object 通用方法</span><br><span class="line">  - `public native int hashCode()`</span><br><span class="line">  - `public boolean equals(Object obj)`</span><br><span class="line">  - `protected native Object clone() throws CloneNotSupportedException`</span><br><span class="line">    - `clone()` 方法并不是 Cloneable 接口的方法，而是 Object 的一个 protected 方法。Cloneable 接口只是规定，如果一个类没有实现 Cloneable 接口又调用了 c`lone()` 方法，就会抛出 CloneNotSupportedException。</span><br><span class="line">  - `public String toString()`</span><br><span class="line">  - `public final native Class&lt;?&gt; getClass()`</span><br><span class="line">  - `protected void finalize() throws Throwable &#123;&#125;`</span><br><span class="line">    - 子类可以覆盖该方法以实现资源清理工作，GC 在回收对象之前调用该方法。</span><br><span class="line">    - 与C++中的析构函数不是对应的。C++ 中的析构函数调用的时机是确定的（对象离开作用域或 delete 掉），但 Java 中的 finalize 的调用具有不确定性</span><br><span class="line">    - 不建议用 finalize 方法完成“非内存资源”的清理工作，但建议用于：</span><br><span class="line">      - 清理本地对象（通过JNI创建的对象）；</span><br><span class="line">      - 作为确保某些非内存资源（如 Socket、文件等）释放的一个补充：在finalize方法中显式调用其他资源释放方法。</span><br><span class="line">    - finalize 的问题</span><br><span class="line">      - 一些与 finalize 相关的方法，由于一些致命的缺陷，已经被废弃了，如 `System.runFinalizersOnExit()` 方法、`Runtime.runFinalizersOnExit()` 方法</span><br><span class="line">      - `System.gc()` 与 `System.runFinalization()` 方法增加了 finalize 方法执行的机会，但不可盲目依赖它们</span><br><span class="line">      - Java 语言规范并不保证 finalize 方法会被及时地执行、而且根本不会保证它们会被执行</span><br><span class="line">      - finalize 方法可能会带来性能问题。因为 JVM 通常在单独的低优先级线程中完成 finalize 的执行</span><br><span class="line">      - 对象再生问题：finalize 方法中，可将待回收对象赋值给 GC Roots 可达的对象引用，从而达到对象再生的目的</span><br><span class="line">      - finalize 方法至多由 GC 执行一次（用户当然可以手动调用对象的 finalize 方法，但并不影响 GC 对 finalize 的行为）</span><br><span class="line">    - finalize 的执行过程（生命周期）</span><br><span class="line">      - 当对象变成（GC Roots）不可达时，GC 会判断该对象是否覆盖了 finalize 方法，若未覆盖，则直接将其回收。否则，若对象未执行过 finalize 方法，将其放入 F-Queue 队列，由一低优先级线程执行该队列中对象的 finalize 方法。执行 finalize 方法完毕后，GC 会再次判断该对象是否可达，若不可达，则进行回收，否则，对象“复活”。</span><br><span class="line">    - 一般用途</span><br><span class="line">      - 对象复活</span><br><span class="line">      - 覆盖 finalize 方法以确保资源释放</span><br><span class="line">        - 作为一个补充操作，以防用户忘记“关闭”资源，JDK 中 FileInputStream、FileOutputStream、Connection 类均用了此“技术”</span><br><span class="line">    - 版本</span><br><span class="line">      - 在 Java 9 中该方法已经被标记为废弃，并添加新的 java.lang.ref.Cleaner，提供了更灵活和有效的方法来释放资源</span><br><span class="line">  - `public final native void notify()`</span><br><span class="line">  - `public final native void notifyAll()`</span><br><span class="line">  - `public final native void wait(long timeout) throws InterruptedException`</span><br><span class="line">  - `public final void wait(long timeout, int nanos) throws InterruptedException`</span><br><span class="line">  - `public final void wait() throws InterruptedException`</span><br><span class="line"></span><br><span class="line">#### String、StringBuilder、StringBuffer</span><br><span class="line">- StringBuilder</span><br><span class="line">  - 线程不安全</span><br><span class="line">- StringBuffer</span><br><span class="line">  - 线程安全</span><br><span class="line">- String</span><br><span class="line">  - String 类是 final 类，也即意味着 String 类不能被继承，并且它的成员方法都默认为 final 方法。</span><br><span class="line">  - String 类包含三个成员变量：char value[]，int offset，int count,他们分别用来：存储真正的字符数组、存储数组的第一个位置索引、存储字符串中包含的字符个数。</span><br><span class="line">    - 在 Java 9 之后，String 类的实现改用 byte 数组存储字符串，同时使用 `coder` 来标识使用了哪种编码。</span><br><span class="line">  - 字符串拼接</span><br><span class="line">    - 在字符串拼接的场景下，Java 编译器会自动进行优化，新建一个 StringBuilder 对象，然后调用 append 方法进行字符串的拼接。而在最后，调用了 StringBuilder 的 toString 方法，生成了一个新的字符串对象，而不是引用的常量池中的常量。</span><br><span class="line">  - 方法：</span><br><span class="line">    - `substring()`</span><br><span class="line">      - JDK 6：会创建一个新的 String 对象，但是这个 String 的数组然指向堆中的同一个字符数组。这两个对象中只有 count 和 offset 的值是不同的。</span><br><span class="line">        - **存在的问题**：如果有一个很长的字符串，但是你只需要使用很短的一段，于是你使用 substring 进行切割，但是由于你实际上引用了整个字符串，这个很长的字符串无法被回收。往小了说，造成了存储空间的浪费，往大了说，可能造成内存泄漏。</span><br><span class="line">      - JDK 7：会在堆中创建一个新的数组</span><br><span class="line">  - 相关问题</span><br><span class="line">    - **为什么 String 在 Java 是不可更改的？**</span><br><span class="line">      - 字符串常量池的需要</span><br><span class="line">        - 当一个 string 被创建如果这个 string 已经在内存里面存在了，那个存在的 string 的引用被返回，而不是创建个新的对象和返回它的引用。</span><br><span class="line">      - 缓存哈希值</span><br><span class="line">        - 在 Java 中，string 的哈希值经常被用。举个例子，在 HashMap 中。保持不变，可以保证总是返回相同的哈希值。所以它可以被缓存而不用担心被改变。这意味这不需要在使用的时候每次都计算哈希值。这将更高效。</span><br><span class="line">      - 使其他类的使用更加容易</span><br><span class="line">      - 安全</span><br><span class="line">        - String 在很多 Java 的类中，网络连接中，打开的文件中经常被作为参数使用。如果 String 是可以改变的，一个连接或者文件将有可能被改变，这将导致严肃的安全威胁。这个方法认为它正连接到一个机器，但是实际上不是。易变的 strings 将在反射或者作为参数将导致安全问题。</span><br><span class="line">      - 不变对象是自然线程安全</span><br><span class="line">        - 因为不可变对象是不可以改变的，它能够被多个线程自由的共享。这消除了同步。</span><br><span class="line"></span><br><span class="line">#### 容器</span><br><span class="line">容器主要包括 Collection 和 Map 两种，Collection 存储着对象的集合，而 Map 存储着键值对（两个对象）的映射表。</span><br><span class="line"></span><br><span class="line">##### Collection</span><br><span class="line">- Set</span><br><span class="line">  - TreeSet</span><br><span class="line">    - 基于红黑树实现，支持有序性操作，例如根据一个范围查找元素的操作。但是查找效率不如 HashSet，HashSet 查找的时间复杂度为 $O(1)$，TreeSet 则为 $O(logN)$。</span><br><span class="line">  - HashSet</span><br><span class="line">    - 基于哈希表实现，支持快速查找，但不支持有序性操作。并且失去了元素的插入顺序信息，也就是说使用 Iterator 遍历 HashSet 得到的结果是不确定的。</span><br><span class="line">  - LinkedHashSet</span><br><span class="line">    - 具有 HashSet 的查找效率，并且内部使用双向链表维护元素的插入顺序。</span><br><span class="line">  - CopyOnWriteArraySet</span><br><span class="line">- List</span><br><span class="line">  - ArrayList</span><br><span class="line">    - 用数组实现的存储</span><br><span class="line">    - 线程不安全。可以用 Collections.synchronizedList 把一个普通 ArrayList 包装成一个线程安全版本的数组容器。</span><br><span class="line">    - 特点</span><br><span class="line">      - 查询效率高，增删效率低</span><br><span class="line">    - 扩容机制</span><br><span class="line">      - 插入数据时，会调用 `ensureCapacityInternal` 方法。</span><br><span class="line">      - 扩容后的大小为</span><br><span class="line">        - 原来的 1.5 倍</span><br><span class="line">    - 版本区别</span><br><span class="line">      - JDK 1.7 以前会调用 `this(10)` 才是真正的容量为 10</span><br><span class="line">      - 1.7 及本身以后是默认走了空数组，只有第一次 add 的时候容量会变成 10</span><br><span class="line">  - LinkedList</span><br><span class="line">    - 基于双向链表</span><br><span class="line">    - 使用了尾插法的方式，内部维护了链表的⻓度，以及头节点和尾节点，所以获取⻓度不需要遍历</span><br><span class="line">    - 特点</span><br><span class="line">      - 适合一些插入、删除频繁的情况。</span><br><span class="line">  - Vector</span><br><span class="line">    - 线程安全。就是把所有的方法统统加上 synchronized 了。</span><br><span class="line">  - PriorityQueue</span><br><span class="line">    - 基于堆结构实现，可以用它来实现优先队列。</span><br><span class="line">  - CopyOnWriteArrayList</span><br><span class="line">    - CopyOnWriteArrayList，运用了一种“写时复制”的思想。通俗的理解就是当我们需要修改（增/删/改）列表中的元素时，不直接进行修改，而是先将列表 Copy，然后在新的副本上进行修改，修改完成之后，再将引用从原列表指向新列表。</span><br><span class="line">    - 适用于“读多写少”</span><br><span class="line">    - 核心方法</span><br><span class="line">      - 查询【get 方法】</span><br><span class="line">        - get 方法并没有加锁，直接返回了内部数组对应索引位置的值</span><br><span class="line">      - 添加【add 方法】</span><br><span class="line">        - add 方法首先会进行加锁，保证只有一个线程能进行修改；然后会创建一个新数组（大小为 n+1），并将原数组的值复制到新数组，新元素插入到新数组的最后；最后，将字段 array 指向新数组。</span><br><span class="line">      - 删除【remove 方法】</span><br><span class="line">        - 删除方法和插入一样，都需要先加锁（所有涉及修改元素的方法都需要先加锁，写-写不能并发），然后构建新数组，复制旧数组元素至新数组，最后将 array 指向新数组。</span><br><span class="line">      - 迭代</span><br><span class="line">        - CopyOnWriteArrayList 对元素进行迭代时，仅仅返回一个当前内部数组的快照，也就是说，如果此时有其它线程正在修改元素，并不会在迭代中反映出来，因为修改都是在新数组中进行的。</span><br><span class="line">    - 存在的一些问题</span><br><span class="line">      - 内存的使用</span><br><span class="line">        - 由于 CopyOnWriteArrayList 使用了“写时复制”，所以在进行写操作的时候，内存里会同时存在两个 array 数组，如果数组内存占用的太大，那么可能会造成频繁 GC,所以 CopyOnWriteArrayList 并不适合大数据量的场景。</span><br><span class="line">      - 数据一致性</span><br><span class="line">        - CopyOnWriteArrayList 只能保证数据的最终一致性，不能保证数据的实时一致性——读操作读到的数据只是一份快照。所以如果希望写入的数据可以立刻被读到，那 CopyOnWriteArrayList 并不适合。</span><br><span class="line">- 阻塞队列</span><br><span class="line">  - 都是线程安全的</span><br><span class="line">  - ArrayBlockingQueue</span><br><span class="line">    - 一个由数组结构组成的有界阻塞队列</span><br><span class="line">    - 内部用 ReentrantLock 实现线程安全</span><br><span class="line">    - 方法</span><br><span class="line">      - 入队方法</span><br><span class="line">        - `add(E e)`</span><br><span class="line">          - 调用 offer 方法，数组满了就抛出异常</span><br><span class="line">        - `offer(E e)`</span><br><span class="line">          - 如果数组满了就返回 false</span><br><span class="line">        - `put(E e)`</span><br><span class="line">          - 如果数组满了，用 Lock 的 Condition 实现等待，然后出队列的时候进行唤醒，无返回值</span><br><span class="line">        - `offer(E e, long timeout, TimeUnit unit)`</span><br><span class="line">          - 如果数组满了，用 Lock 的 Condition 实现等待（有最大等待时常）</span><br><span class="line">      - 出队方法</span><br><span class="line">        - `remove()`</span><br><span class="line">          - 调用 poll 方法，没有返回元素则抛出异常</span><br><span class="line">        - `poll()`</span><br><span class="line">          - 没有返回元素则返回 null</span><br><span class="line">        - `take()`</span><br><span class="line">          - 没有返回元素，则用 Lock 的 Condition 实现等待，然后有元素的时候唤醒返回</span><br><span class="line">        - `poll(long timeout, TimeUnit unit)`</span><br><span class="line">          - 没有返回元素，用 Lock 的 Condition 实现等待（有最大等待时常）</span><br><span class="line">  - LinkedBlockingQueue</span><br><span class="line">    - 一个由链表结构组成的有界阻塞队列。 </span><br><span class="line">  - PriorityBlockingQueue</span><br><span class="line">    - 一个支持优先级排序的无界阻塞队列。 </span><br><span class="line">  - DealyQueue</span><br><span class="line">    - 一个使用优先级队列实现的无界阻塞队列。 </span><br><span class="line">  - SynchronousQueue</span><br><span class="line">    - 一个不存储元素的阻塞队列。 </span><br><span class="line">  - LinkedTransferQueue</span><br><span class="line">    - 一个由链表结构组成的无界阻塞队列。 </span><br><span class="line">  - LinkedBlockingDeque</span><br><span class="line">    - 一个由链表结构组成的双向阻塞队列。</span><br><span class="line"></span><br><span class="line">##### Map</span><br><span class="line">- ![Java_Map对比](Java-basic-0-知识点汇总/Java_Map对比.jpg)</span><br><span class="line">- HashMap</span><br><span class="line">  - 线程不安全。可以使用 `Collections.synchronizedMap(Map)` 创建线程安全的 map 集合。</span><br><span class="line">    - **Collections.synchronizedMap 是怎么实现线程安全的？**</span><br><span class="line">      - 在 SynchronizedMap 内部维护了一个普通对象 Map，还有排斥锁 mutex。</span><br><span class="line">      - 在调用这个方法的时候就需要传入一个 Map，有两个构造器，如果传入了 mutex 参数，则将对象排斥锁赋值为传入的对象。如果没有，则将对象排斥锁赋值为 this。</span><br><span class="line">      - 创建出 SynchronizedMap 之后，再操作 map 的时候，就会对方法上锁。</span><br><span class="line">  - 由数组和链表组合构成。</span><br><span class="line">  - 初始容量 16。</span><br><span class="line">  - 负载因子默认 0.75。</span><br><span class="line">    - 根据泊松分布，在负载因子默认为 0.75 的时候，单个 hash 槽内元素个数为 8 的概率小于百万分之一，所以将 7 作为一个分水岭，**等于 7 的时候不转换，大于等于 8 的时候才进行转换为红黑树，小于等于 6 的时候就化为链表**。</span><br><span class="line">  - HashMap 的键值则都可以为 null。</span><br><span class="line">  - hash 方法</span><br><span class="line">    - 扰动函数</span><br><span class="line">      - 混合原始哈希码的高位和低位，以此来加大低位的随机性。</span><br><span class="line">      - Java 7</span><br><span class="line">        - ```</span><br><span class="line">          static int hash(int h) &#123;</span><br><span class="line">              h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12);</span><br><span class="line">              return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4);</span><br><span class="line">          &#125;</span><br></pre></td></tr></table></figure>
- Java 8 中，做一次 16 位右位移异或混合
  - ```
    //Java 8中的散列值优化函数
    static final int hash(Object key) &#123;
      int h;
      int h;
      return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);    //key.hashCode()为哈希算法，返回初始哈希值
    &#125;
</code></pre>
</li>
</ul>
</li>
<li>操作<ul>
<li>扩容机制<ul>
<li>当现有容量大于总容量 * 负载因子时，HashMap 扩容规则为当前容量翻倍。</li>
<li>扩容流程<ul>
<li><img src="/2019/09/04/%E8%AF%AD%E8%A8%80/Java/basic_Java/Java-basic-0-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/Java_HashMap_resize%E6%B5%81%E7%A8%8B.jpg" alt="Java_HashMap_resize流程"></li>
</ul>
</li>
</ul>
</li>
<li>迭代器<ul>
<li>HashMap 中的 Iterator 迭代器是 fail-fast 的。<ul>
<li>快速失败（fail—fast）是 Java 集合中的一种机制，在用迭代器遍历一个集合对象时，如果遍历过程中对集合对象的内容进行了修改（增加、删除、修改），则会抛出 Concurrent Modification Exception。<ul>
<li>原理：<ul>
<li>迭代器在遍历时直接访问集合中的内容，并且在遍历过程中使用一个 modCount 变量。</li>
<li>集合在被遍历期间如果内容发生变化，就会改变 modCount 的值。</li>
<li>每当迭代器使用 <code>hashNext()</code>/<code>next()</code> 遍历下一个元素之前，都会检测 modCount 变量是否为 expectedmodCount 值，是的话就返回遍历；否则抛出异常，终止遍历。</li>
<li>这里异常的抛出条件是检测到 modCount!=expectedmodCount 这个条件。如果集合发生变化时修改 modCount 值刚好又设置为了 expectedmodCount 值，则异常不会抛出。</li>
</ul>
</li>
<li>java.util 包下的集合类都是快速失败的，不能在多线程下发生并发修改（迭代过程中被修改）算是一种安全机制吧。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>插入数据时：<ul>
<li>Java8 之前是头插法。采用 <strong>数组+链表</strong> 的数据结构。</li>
<li>Java8 之后，都是所用尾部插入了。采用 <strong>Node 数组+链表+红黑树</strong> 的数据结构。</li>
<li>插入流程<ul>
<li><img src="/2019/09/04/%E8%AF%AD%E8%A8%80/Java/basic_Java/Java-basic-0-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/Java_HashMap_%E6%8F%92%E5%85%A5%E6%B5%81%E7%A8%8B.jpg" alt="Java_HashMap_插入流程"></li>
</ul>
</li>
<li>相关问题<ul>
<li><strong>为什么要改插入方式？</strong><ul>
<li>多线程 resize 的时候，可能会产生环形链表，则插入会死循环</li>
<li>使用头插会改变链表的上的顺序，但是如果使用尾插，在扩容时会保持链表元素原本的顺序，就不会出现链表成环的问题了</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>相关问题<ul>
<li><strong>为什么是非线程安全的？</strong><ul>
<li>多线程 put（不考虑 resize）<ul>
<li>如果 hash 冲突，后一个线程覆盖前一个线程的 key-value，如在一系列线程中出现 hash 冲突的键值对个数为 N，则最多可能丢失 N-1 个键值对，即只有一个线程的键值对最终被加入到 table 内的链表或红黑树中</li>
</ul>
</li>
<li>多线程 resize<ul>
<li>可能会产生环形链表，则插入会死循环</li>
</ul>
</li>
<li>多线程 remove<ul>
<li>可能没删掉</li>
</ul>
</li>
</ul>
</li>
<li><strong>为什么容量要是 2 的幂？</strong><ul>
<li>为了位运算的方便，位与运算比算数计算的效率高了很多</li>
<li>当数组长度为 $2^n$ 时，$2^n − 1$ 的所有位都是 1，如 8-1=7 即 111，那么进行低位 &amp; 运算时，值总与原来的 hash 值相同，降低了碰撞的概率</li>
<li><blockquote>
<p>当 table 数组的大小为 2 的幂次时，通过 <code>key.hash &amp; table.length-1</code> 这种方式计算出的索引 i，当 table 扩容后（2 倍），新的索引要么在原来的位置 i，要么是 i+n。</p>
</blockquote>
<ul>
<li><img src="/2019/09/04/%E8%AF%AD%E8%A8%80/Java/basic_Java/Java-basic-0-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/Java_HashMap_rehash.png" alt="Java_HashMap_rehash"></li>
</ul>
</li>
</ul>
</li>
<li><strong>为什么重写 equals 方法的时候需要重写 hashCode 方法？</strong><ul>
<li>这两个方法都是用来比较两个对象是否相等的</li>
<li>未重写 equals 方法，我们是继承了 object 的 equals 方法，那里的 equals 是比较两个对象的内存地址</li>
<li>get 的时候，他就是根据 key 去 hash 然后计算出 index。所以如果我们对 equals 方法进行了重写，建议一定要对 hashCode 方法重写，以保证相同的对象返回相同的 hash 值，不同的对象返回不同的 hash 值。</li>
</ul>
</li>
<li><strong>JDK1.8 发生了哪些变化？</strong><ol>
<li>由数组+链表改为数组+链表+红黑树，当链表的长度超过8时，链表变为红黑树。<ul>
<li><strong>为什么要这么改？</strong><ul>
<li>我们知道链表的查找效率为 $O(n)$，而红黑树的查找效率为 $O(logn)$，查找效率变高了。</li>
</ul>
</li>
<li><strong>为什么不直接用红黑树？</strong><ul>
<li>因为红黑树的查找效率虽然变高了，但是插入效率变低了，如果从一开始就用红黑树并不合适。从概率学的角度选了一个合适的临界值为 8</li>
</ul>
</li>
</ul>
</li>
<li>优化了 hash 算法（变成位运算）</li>
<li>计算元素在新数组中位置的算法发生了变化，新算法通过新增位判断 <code>oldTable[i]</code> 应该放在 <code>newTable[i]</code> 还是 <code>newTable[i+oldTable.length]</code></li>
<li>头插法改为尾插法，扩容时链表没有发生倒置（避免形成死循环）</li>
</ol>
</li>
<li><strong>为什么不使用 AVL 树而使用红黑树？</strong><ul>
<li>红黑树和 AVL 树都是最常用的平衡二叉搜索树，它们的查找、删除、修改都是 $O(lgn)$</li>
<li>AVL 树和红黑树有几点比较和区别：<ul>
<li>AVL 树是更加严格的平衡，因此可以提供更快的查找速度，一般读取查找密集型任务，适用 AVL 树。</li>
<li>红黑树更适合于插入修改密集型任务。</li>
<li>通常，AVL 树的旋转比红黑树的旋转更加难以平衡和调试。</li>
</ul>
</li>
<li>总结：<ul>
<li>AVL 以及红黑树是高度平衡的树数据结构。它们非常相似，真正的区别在于在任何添加/删除操作时完成的旋转操作次数。</li>
<li>两种实现都缩放为a $O(lgN)$，其中 N 是叶子的数量，但实际上 AVL 树在查找密集型任务上更快：利用更好的平衡，树遍历平均更短。另一方面，插入和删除方面，AVL 树速度较慢：需要更高的旋转次数才能在修改时正确地重新平衡数据结构。</li>
<li>在 AVL 树中，从根到任何叶子的最短路径和最长路径之间的差异最多为 1。在红黑树中，差异可以是 2 倍。</li>
<li>两个都给 $O(logn)$ 查找，但平衡 AVL 树可能需要 $O(logn)$ 旋转，而红黑树将需要最多两次旋转使其达到平衡（尽管可能需要检查 $O(logn)$ 节点以确定旋转的位置）。旋转本身是 $O(1)$ 操作，因为你只是移动指针。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>HashTable<ul>
<li>线程安全。直接在方法上锁，并发度很低，最多同时允许一个线程访问。<ul>
<li>读写枷锁</li>
<li><strong>为什么效率低？</strong><ul>
<li>对数据操作的时候都会上锁，所以效率比较低下。</li>
</ul>
</li>
</ul>
</li>
<li>扩容机制<ul>
<li>当现有容量大于总容量 * 负载因子时，Hashtable 扩容规则为当前容量翻倍 + 1。</li>
</ul>
</li>
<li>Hashtable 是不允许键或值为 null 的。<ul>
<li><strong>为什么 Hashtable 是不允许 KEY 和 VALUE 为 null, 而 HashMap 则可以呢？</strong><ul>
<li>因为 Hashtable 在我们 put 空值的时候会直接抛空指针异常，但是 HashMap 却做了特殊处理（key 为 null 直接放在 <code>table[0]</code> 处）。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>ConcurrentHashMap<ul>
<li>线程安全<ul>
<li>读不加锁，写不一定加锁</li>
</ul>
</li>
<li>基本结构<ul>
<li>结点定义<ul>
<li>Node 结点<ul>
<li>是其它类型节点的父类</li>
</ul>
</li>
<li>TreeNode 结点<ul>
<li>TreeNode 就是红黑树的结点，TreeNode 不会直接链接到 <code>table[i]</code>（桶）上面，而是由 TreeBin 链接，TreeBin 会指向红黑树的根结点。</li>
</ul>
</li>
<li>TreeBin 结点<ul>
<li>TreeBin 相当于 TreeNode 的代理结点。TreeBin 会直接链接到 <code>table[i]</code>（桶）上面，该结点提供了一系列红黑树相关的操作，以及加锁、解锁操作。</li>
</ul>
</li>
<li>ForwardingNode 结点<ul>
<li>ForwardingNode 结点仅仅在扩容时才会使用。</li>
<li>当最后一个线程完成迁移任务后，会遍历所有桶，看看是否都是 ForwardingNode，如果是，那么说明整个扩容/数据迁移的过程就完成了。</li>
</ul>
</li>
<li>ReservationNode 结点<ul>
<li>保留结点</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>操作<ul>
<li>插入数据时：<ul>
<li>Java8 之前，是由 Segment 数组、HashEntry 组成，和 HashMap 一样，仍然是数组加链表。采用了分段锁技术，其中 Segment 继承于 ReentrantLock。不会像 HashTable 那样不管是 put 还是 get 操作都需要做同步处理，理论上 ConcurrentHashMap 支持 CurrencyLevel（Segment 数组数量）的线程并发。每当一个线程占用锁访问一个 Segment 时，不会影响到其他的 Segment。</li>
<li>Java8 之后，Node 数组+链表+红黑树，采用了 CAS + synchronized 来保证并发安全性。操作 hash值 相同的链表，头结点用 synchronized 上锁保证线程安全。<ul>
<li>步骤：<ol>
<li>根据 key 计算出 hashcode。</li>
<li>判断是否需要进行初始化。</li>
<li>即为当前 key 定位出的 Node，如果为空表示当前位置可以写入数据，利用 CAS 尝试写入，失败则自旋保证成功。<ul>
<li>当 <code>table[i]</code> 的结点类型为 Node（链表结点）时，就会将新结点以“尾插法”的形式插入链表的尾部。</li>
<li>当 <code>table[i]</code> 的结点类型为 TreeBin（红黑树代理结点）时，就会将新结点通过红黑树的插入方式插入。</li>
</ul>
</li>
<li>如果当前位置的 hashcode == MOVED == -1 ,则需要进行扩容。</li>
<li>如果都不满足，则利用 synchronized 锁写入数据。</li>
<li>如果数量大于 TREEIFY_THRESHOLD 则要转换为红黑树。</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li>查询数据<ul>
<li>当槽 <code>table[i]</code> 被普通 Node 结点占用，说明是链表链接的形式，直接从链表头开始查找</li>
<li>当槽 <code>table[i]</code> 被 TreeBin 结点占用时，说明链接的是一棵红黑树。由于红黑树的插入、删除会涉及整个结构的调整，所以通常存在读写并发操作的时候，是需要加锁的</li>
</ul>
</li>
<li>扩容<ul>
<li>Hash 表的扩容，一般都包含两个步骤：<ul>
<li>table 数组的扩容<ul>
<li>table 数组的扩容，一般就是新建一个 2 倍大小的槽数组，这个过程通过由一个单线程完成，且不允许出现并发。</li>
</ul>
</li>
<li>数据迁移<ul>
<li>把旧 table 中的各个槽中的结点重新分配到新 table 中。</li>
</ul>
</li>
</ul>
</li>
<li>transfer 方法，这个方法可以被多个线程同时调用，也是“数据迁移”的核心操作方法</li>
<li>transfer 方法主要包含 4 个分支，即对 4 种不同情况进行处理<ul>
<li>桶 <code>table[i]</code> 为空<ul>
<li>当旧 table 的桶 <code>table[i] == null</code>，说明原来这个桶就没有数据，那就直接尝试放置一个 ForwardingNode，表示这个桶已经处理完成。</li>
</ul>
</li>
<li>桶 <code>table[i]</code> 已迁移完成</li>
<li>桶 <code>table[i]</code> 未迁移完成<ul>
<li>如果旧桶的数据未迁移完成，就要进行迁移，这里根据桶中结点的类型分为：链表迁移、红黑树迁移<ul>
<li>链表迁移<ol>
<li>链表迁移的过程如下，首先会遍历一遍原链表，找到最后一个相邻的 runBit 不同的结点。<ul>
<li>runbit 是根据 key.hash 和旧 table 长度 n 进行与运算得到的值，由于 table 的长度为 2 的幂次，所以 runbit 只可能为 0 或最高位为 1</li>
</ul>
</li>
<li>然后，会进行第二次链表遍历，按照第一次遍历找到的结点为界，将原链表分成 2 个子链表，再链接到新 table 的槽中。可以看到，新 table 的索引要么是 i，要么是 i+n</li>
</ol>
</li>
<li>红黑树迁移<ul>
<li>红黑树的迁移按照链表遍历的方式进行，当链表结点超过/小于阈值时，涉及红黑树&lt;-&gt;链表的相互转换</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>当前是最后一个迁移任务或出现扩容冲突</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>安全失败：<ul>
<li>java.util.concurrent 包下的容器都是安全失败，可以在多线程下并发使用，并发修改。</li>
<li>采用安全失败机制的集合容器，在遍历时不是直接在集合内容上访问的，而是先复制原有集合内容，在拷贝的集合上进行遍历。</li>
</ul>
</li>
<li>迭代器：<ul>
<li>是弱一致性迭代器。ConcurrentHashMap 的迭代器创建后，就会按照哈希表结构遍历每个元素，但在遍历过程中，内部元素可能会发生变化，如果变化发生在已遍历过的部分，迭代器就不会反映出来，而如果变化发生在未遍历过的部分，迭代器就会发现并反映出来，这就是弱一致性。</li>
<li>ConcurrentHashMap 中每个结点指向下一个结点的 next 是不可变的（final）。concurrentHashMap 的删除操作是通过将被删除的元素重新复制一遍实现的。也就是说，如果 A 删掉了第 7 个元素，此时 B 已经遍历到了第 3 个元素，那么 B 还是可以遍历到被删除的第 7 个元素（Java1.8 之前）。</li>
</ul>
</li>
</ul>
</li>
<li>TreeMap<ul>
<li>TreeMap 是会自动进行排序的，也就是一个有序 Map（使用了红黑树来实现）</li>
</ul>
</li>
<li>LinkedHashMap<ul>
<li>有序的 HashMap，和 TreeMap 是不一样的概念，是用了 HashMap+双向链 的方式来构造的</li>
<li>线程不安全</li>
<li>顺序<ul>
<li>插入顺序（默认实现）<ul>
<li>插入的是什么顺序，读出来的就是什么顺序</li>
</ul>
</li>
<li>访问顺序<ul>
<li>每次 get 的时候都会把链表的节点移除掉，放到链表的最后面。这样子就是一个 LRU 的一种实现方式。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="I-O"><a href="#I-O" class="headerlink" title="I/O"></a>I/O</h3><ul>
<li>基本概念<ul>
<li>同步、异步<ul>
<li>同步：同步就是发起一个调用后，被调用者未处理完请求之前，调用不返回。</li>
<li>异步：异步就是发起一个调用后，立刻得到被调用者的回应表示已接收到请求，但是被调用者并没有返回结果，此时我们可以处理其他的请求，被调用者通常依靠事件，回调等机制来通知调用者其返回结果。</li>
<li>同步和异步的区别最大在于异步的话调用者不需要等待处理结果，被调用者会通过回调等机制来通知调用者其返回结果。</li>
</ul>
</li>
<li>阻塞、非阻塞<ul>
<li>阻塞：阻塞就是发起一个请求，调用者一直等待请求结果返回，也就是当前线程会被挂起，无法从事其他任务，只有当条件就绪才能继续。</li>
<li>非阻塞：非阻塞就是发起一个请求，调用者不用一直等着结果返回，可以先去干其他事情。</li>
</ul>
</li>
<li>相关问题<ul>
<li><strong>同步阻塞、同步非阻塞和异步非阻塞又代表什么意思呢？</strong><ul>
<li>举个生活中简单的例子，你妈妈让你烧水，小时候你比较笨啊，在哪里傻等着水开（<strong>同步阻塞</strong>）。等你稍微再长大一点，你知道每次烧水的空隙可以去干点其他事，然后只需要时不时来看看水开了没有（<strong>同步非阻塞</strong>）。后来，你们家用上了水开了会发出声音的壶，这样你就只需要听到响声后就知道水开了，在这期间你可以随便干自己的事情，你需要去倒水了（<strong>异步非阻塞</strong>）。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>I/O 方式<ul>
<li>BIO（Blocking I/O）<ul>
<li>传统 BIO<ul>
<li>同步阻塞 I/O 模式，数据的读取写入必须阻塞在一个线程内等待其完成。</li>
<li><img src="/2019/09/04/%E8%AF%AD%E8%A8%80/Java/basic_Java/Java-basic-0-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/Java_BIO%E9%80%9A%E4%BF%A1%E6%A8%A1%E5%9E%8B%E5%9B%BE.png" alt="Java_BIO通信模型图"></li>
<li>采用 BIO 通信模型 的服务端，通常由一个独立的 Acceptor 线程负责监听客户端的连接。我们一般通过在 <code>while(true)</code> 循环中服务端会调用 <code>accept()</code> 方法等待接收客户端的连接的方式监听请求，请求一旦接收到一个连接请求，就可以建立通信套接字在这个通信套接字上进行读写操作，此时不能再接收其他客户端连接请求，只能等待同当前连接的客户端的操作执行完成，不过可以通过多线程来支持多个客户端的连接。可以通过线程池机制改善，线程池还可以让线程的创建和回收成本相对较低。</li>
</ul>
</li>
<li>伪异步 IO<ul>
<li>为了解决同步阻塞 I/O 面临的一个链路需要一个线程处理的问题，后来有人对它的线程模型进行了优化。</li>
<li>后端通过一个线程池来处理多个客户端的请求接入，形成客户端个数 M : 线程池最大线程数 N 的比例关系，其中 M 可以远远大于 N。通过线程池可以灵活地调配线程资源，设置线程的最大值，防止由于海量并发接入导致线程耗尽。</li>
<li><img src="/2019/09/04/%E8%AF%AD%E8%A8%80/Java/basic_Java/Java-basic-0-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/Java_%E4%BC%AA%E5%BC%82%E6%AD%A5IO%E6%A8%A1%E5%9E%8B%E5%9B%BE.png" alt="Java_伪异步IO模型图"></li>
</ul>
</li>
<li>总结<ul>
<li>在活动连接数不是特别高（小于单机 1000）的情况下，这种模型是比较不错的，可以让每一个连接专注于自己的 I/O 并且编程模型简单，也不用过多考虑系统的过载、限流等问题。线程池本身就是一个天然的漏斗，可以缓冲一些系统处理不了的连接或请求。但是，当面对十万甚至百万级连接的时候，传统的 BIO 模型是无能为力的。因此，我们需要一种更高效的 I/O 处理模型来应对更高的并发量。</li>
</ul>
</li>
</ul>
</li>
<li>NIO<ul>
<li>NIO 是一种同步非阻塞的 I/O 模型，在 Java 1.4 中引入了 NIO 框架，对应 java.nio 包，提供了 Channel、Selector、Buffer 等抽象。它支持面向缓冲的，基于通道的 I/O 操作方法。</li>
<li>JDK 的 NIO 底层由 epoll 实现。</li>
<li>NIO 提供了与传统 BIO 模型中的 Socket 和 ServerSocket 相对应的 SocketChannel 和 ServerSocketChannel 两种不同的套接字通道实现，两种通道都支持阻塞和非阻塞两种模式。阻塞模式使用就像传统中的支持一样，比较简单，但是性能和可靠性都不好；非阻塞模式正好与之相反。对于低负载、低并发的应用程序，可以使用同步阻塞 I/O 来提升开发速率和更好的维护性；对于高负载、高并发的（网络）应用，应使用 NIO 的非阻塞模式来开发。</li>
<li>核心组件<ul>
<li>Buffer<ul>
<li>在 NIO 厍中，所有数据都是用缓冲区处理的。在读取数据时，它是直接读到缓冲区中的；在写入数据时，写入到缓冲区中。任何时候访问NIO中的数据，都是通过缓冲区进行操作。</li>
<li>最常用的缓冲区是 ByteBuffer，一个 ByteBuffer 提供了一组功能用于操作 byte 数组。除了 ByteBuffer，还有其他的一些缓冲区，事实上，每一种 Java 基本类型（除了 Boolean 类型）都对应有一种缓冲区。</li>
</ul>
</li>
<li>Channel<ul>
<li>NIO 通过 Channel（通道）进行读写。</li>
<li>通道是双向的，可读也可写，而流的读写是单向的。无论读写，通道只能和 Buffer 交互。因为 Buffer，通道可以异步地读写。</li>
</ul>
</li>
<li>Selectors<ul>
<li>选择器用于使用单个线程处理多个通道。</li>
<li><img src="/2019/09/04/%E8%AF%AD%E8%A8%80/Java/basic_Java/Java-basic-0-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/Java_NIO_Selectors.png" alt="Java_NIO_Selectors"></li>
</ul>
</li>
</ul>
</li>
<li>NIO 读数据和写数据方式<ul>
<li>从通道进行数据读取：创建一个缓冲区，然后请求通道读取数据。</li>
<li>从通道进行数据写入：创建一个缓冲区，填充数据，并要求通道写入数据。</li>
</ul>
</li>
</ul>
</li>
<li>AIO（Asynchronous I/O）<ul>
<li>AIO 也就是 NIO 2。在 Java 7 中引入了 NIO 的改进版 NIO 2，它是异步非阻塞的 IO 模型。异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。</li>
<li>AIO 是异步 IO 的缩写，虽然 NIO 在网络操作中，提供了非阻塞的方法，但是 NIO 的 IO 行为还是同步的。对于 NIO 来说，我们的业务线程是在 IO 操作准备好时，得到通知，接着就由这个线程自行进行 IO 操作，IO 操作本身是同步的。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><ul>
<li>并发编程 3 大重要特征<ul>
<li>原子性<ul>
<li>一个操作或者多个操作，要么全部执行成功，要么全部执行失败。满足原子性的操作，中途不可被中断。</li>
</ul>
</li>
<li>可见性<ul>
<li>多个线程共同访问共享变量时，某个线程修改了此变量，其他线程能立即看到修改后的值。</li>
</ul>
</li>
<li>有序性<ul>
<li>程序执行的顺序按照代码的先后顺序执行。（由于 JMM 模型中允许编译器和处理器为了效率，进行指令重排序的优化。指令重排序在单线程内表现为串行语义，在多线程中会表现为无序。那么多线程并发编程中，就要考虑如何在多线程环境下可以允许部分指令重排，又要保证有序性）</li>
</ul>
</li>
</ul>
</li>
<li>锁<ul>
<li>概念<ul>
<li>公平锁和非公平锁<ul>
<li>公平锁<ul>
<li>多个线程按照申请锁的顺序去获得锁，线程会直接进入队列去排队，永远都是队列的第一位才能得到锁。</li>
<li>优点：所有的线程都能得到资源，不会饿死在队列中</li>
<li>缺点：吞吐量会下降很多，队列里面除了第一个线程，其他的线程都会阻塞，cpu唤醒阻塞线程的开销会很大。</li>
</ul>
</li>
<li>非公平锁<ul>
<li>多个线程去获取锁的时候，会直接去尝试获取，获取不到，再去进入等待队列，如果能获取到，就直接获取到锁。</li>
<li>优点：可以减少 CPU 唤醒线程的开销，整体的吞吐效率会高点，CPU 也不必取唤醒所有线程，会减少唤起线程的数量。</li>
<li>缺点：你们可能也发现了，这样可能导致队列中间的线程一直获取不到锁或者长时间获取不到锁，导致饿死。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>synchronized<ul>
<li>synchronized 是一种独占式的重量级锁，在运行到同步方法或者同步代码块的时候，让程序的运行级别由用户态切换到内核态，把所有的线程挂起，通过操作系统的指令，去调度线程。这样会频繁出现程序运行状态的切换，线程的挂起和唤醒，会消耗系统资源，为了提高效率，引入了偏向锁、轻量级锁、尽量让多线程访问公共资源的时候，不进行程序运行状态的切换。</li>
<li>非公平锁</li>
<li>特性<ul>
<li>可重入性<ul>
<li>synchronized 锁对象的时候有个计数器，他会记录下线程获取锁的次数，在执行完对应的代码块之后，计数器就会 -1，直到计数器清零，就释放锁了。<ul>
<li><strong>那可重入有什么好处呢？</strong><ul>
<li>可以避免一些死锁的情况，也可以让我们更好封装我们的代码。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>不可中断性<ul>
<li>不可中断就是指，一个线程获取锁之后，另外一个线程处于阻塞或者等待状态，前一个不释放，后一个也一直会阻塞或者等待，不可以被中断。</li>
</ul>
</li>
</ul>
</li>
<li>对象监视器（Monitor）<ul>
<li>在 HotSpot JVM 实现中，锁有个专门的名字：对象监视器。</li>
<li>任何一个对象都有一个 Monitor 与之关联，当且一个 Monitor 被持有后，它将处于锁定状态。</li>
<li>监视器锁（Monitor）本质是依赖于底层的操作系统的 Mutex Lock（互斥锁）来实现的。每个对象都对应于一个可称为“互斥锁”的标记，这个标记用来保证在任一时刻，只能有一个线程访问该对象。</li>
<li>synchronized 在 JVM 里的实现都是基于进入和退出 Monitor 对象来实现方法同步和代码块同步，虽然具体实现细节不一样，但是都可以通过成对的 MonitorEnter 和 MonitorExit 指令来实现。<ul>
<li>MonitorEnter 指令：插入在同步代码块的开始位置，当代码执行到该指令时，将会尝试获取该对象 Monitor 的所有权，即尝试获得该对象的锁；</li>
<li>MonitorExit 指令：插入在方法结束处和异常处，JVM 保证每个 MonitorEnter 必须有对应的 MonitorExit；</li>
</ul>
</li>
<li>Monitor 对象存在于每个 Java 对象的对象头 Mark Word 中（存储的指针的指向）</li>
<li>当多个线程同时请求某个对象监视器时，对象监视器会设置几种状态用来区分请求的线程：<ul>
<li>Contention List：所有请求锁的线程将被首先放置到该竞争队列<ul>
<li>ContentionList 并不是一个真正的 Queue，而只是一个虚拟队列，原因在于 ContentionList 是由 Node 及其 next 指针逻辑构成，并不存在一个 Queue 的数据结构。</li>
<li>ContentionList 是一个 <del>后进先出（LIFO）</del> <strong>【注：按上下文来看应该是先进先出（FIFO）】</strong>的队列，每次新加入 Node 时都会在队头进行，通过 CAS 改变第一个节点的的指针为新增节点，同时设置新增节点的 next 指向后续节点，而取得操作则发生在队尾。显然，该结构其实是个 Lock-Free 的队列。</li>
<li>因为只有 Owner 线程才能从队尾取元素，也即线程出列操作无争用，当然也就避免了 CAS 的 ABA 问题。</li>
<li><img src="/2019/09/04/%E8%AF%AD%E8%A8%80/Java/basic_Java/Java-basic-0-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/Java_ContentionList.jpg" alt="Java_ContentionList"></li>
</ul>
</li>
<li>Entry List：Contention List 中那些有资格成为候选人的线程被移到 Entry List<ul>
<li>EntryList 与 ContentionList 逻辑上同属等待队列，ContentionList 会被线程并发访问，为了降低对 ContentionList 队尾的争用，而建立 EntryList。</li>
<li>Owner 线程在 unlock 时会从 ContentionList 中迁移线程到 EntryList，并会指定 EntryList 中的某个线程（一般为 Head）为 Ready（OnDeck）线程。Owner 线程并不是把锁传递给 OnDeck 线程，只是把竞争锁的权利交给 OnDeck，OnDeck 线程需要重新竞争锁。这样做虽然牺牲了一定的公平性，但极大的提高了整体吞吐量，在 Hotspot 中把 OnDeck 的选择行为称之为“竞争切换”。</li>
<li>OnDeck 线程获得锁后即变为 owner 线程，无法获得锁则会依然留在 EntryList 中，考虑到公平性，在 EntryList 中的位置不发生变化（依然在队头）。如果 Owner 线程被 wait 方法阻塞，则转移到 WaitSet 队列；如果在某个时刻被 <code>notify/notifyAll</code> 唤醒，则再次转移到 EntryList。</li>
</ul>
</li>
<li>Wait Set：那些调用 wait 方法被阻塞的线程被放置到 Wait Set</li>
<li>OnDeck：任何时刻最多只能有一个线程正在竞争锁，该线程称为 OnDeck</li>
<li>Owner：获得锁的线程称为 Owner</li>
<li>!Owner：释放锁的线程</li>
</ul>
</li>
<li>状态转换<ul>
<li><img src="/2019/09/04/%E8%AF%AD%E8%A8%80/Java/basic_Java/Java-basic-0-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/Java_%E5%AF%B9%E8%B1%A1%E7%9B%91%E8%A7%86%E5%99%A8_%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2%E5%85%B3%E7%B3%BB.jpg" alt="Java_对象监视器_状态转换关系"></li>
</ul>
</li>
</ul>
</li>
<li>原理<ul>
<li>对象头，他会关联到一个 monitor 对象。</li>
<li>当我们进入一个人方法的时候，执行 monitorenter，就会获取当前对象的一个所有权，这个时候 monitor 进入数为 1，当前的这个线程就是这个 monitor 的 owner。</li>
<li>如果你已经是这个 monitor 的 owner 了，你再次进入，就会把进入数 +1。<ul>
<li>如果线程调用 wait 方法，将释放锁，当前线程置为 null，计数器 -1，同时进入 waitSet 等待被唤醒，调用 notify 或者 notifyAll 之后又会进入 entryList 竞争锁。</li>
</ul>
</li>
<li>同理，当他执行完 monitorexit，对应的进入数就 -1，直到为 0，才可以被其他线程持有。</li>
<li><img src="/2019/09/04/%E8%AF%AD%E8%A8%80/Java/basic_Java/Java-basic-0-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/Java_synchronized_%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.jpg" alt="Java_synchronized_执行流程"></li>
</ul>
</li>
<li>自旋锁<ul>
<li>出现自旋锁的原因<ul>
<li>那些处于 ContetionList、EntryList、WaitSet 中的线程均处于阻塞状态，阻塞操作由操作系统完成（在 Linxu 下通过 pthread_mutex_lock 函数）。线程被阻塞后便进入内核（Linux）调度状态，这个会导致系统在用户态与内核态之间来回切换，严重影响锁的性能。</li>
</ul>
</li>
<li>原理<ul>
<li>当发生争用时，若 Owner 线程能在很短的时间内释放锁，则那些正在争用线程可以稍微等一等（自旋），在 Owner 线程释放锁后，争用线程可能会立即得到锁，从而避免了系统阻塞。但 Owner 运行的时间可能会超出了临界值，争用线程自旋一段时间后还是无法获得锁，这时争用线程则会停止自旋进入阻塞状态（后退）。基本思路就是自旋，不成功再阻塞，尽量降低阻塞的可能性，这对那些执行时间很短的代码块来说有非常重要的性能提高。自旋锁有个更贴切的名字：自旋-指数后退锁，也即复合锁。很显然，自旋在多处理器上才有意义。</li>
</ul>
</li>
<li>相关问题<ul>
<li><strong>线程自旋时做些啥？</strong><ul>
<li>其实啥都不做，可以执行几次 for 循环，可以执行几条空的汇编指令，目的是占着 CPU 不放，等待获取锁的机会。所以说，自旋是把双刃剑，如果旋的时间过长会影响整体性能，时间过短又达不到延迟阻塞的目的。显然，自旋的周期选择显得非常重要，但这与操作系统、硬件体系、系统的负载等诸多场景相关，很难选择，如果选择不当，不但性能得不到提高，可能还会下降，因此大家普遍认为自旋锁不具有扩展性。</li>
</ul>
</li>
<li><strong>synchronized 实现何时使用了自旋锁？</strong><ul>
<li>在线程进入 ContentionList 时，也即第一步操作前。线程在进入等待队列时首先进行自旋尝试获得锁，如果不成功再进入等待队列。这对那些已经在等待队列中的线程来说，稍微显得不公平。还有一个不公平的地方是自旋线程可能会抢占了  Ready 线程的锁。自旋锁由每个监视对象维护，每个监视对象一个。</li>
</ul>
</li>
</ul>
</li>
<li>适应性自旋锁<ul>
<li>JDK 1.6 引入了更加聪明的自旋锁，即自适应自旋锁。所谓自适应就意味着自旋的次数不再是固定的，它是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。</li>
<li><strong>如何进行适应性自旋呢？</strong><ul>
<li>线程如果自旋成功了，那么下次自旋的次数会更加多，因为虚拟机认为既然上次成功了，那么此次自旋也很有可能会再次成功，那么它就会允许自旋等待持续的次数更多。反之，如果对于某个锁，很少有自旋能够成功，那么在以后要或者这个锁的时候自旋的次数会减少甚至省略掉自旋过程，以免浪费处理器资源。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>锁消除<ul>
<li>锁消除是指虚拟机即时编译器在运行时，对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除。锁消除的主要判定依据来源于逃逸分析的数据支持，如果判断在一段代码中，堆上的所有数据都不会逃逸出去从而被其他线程访问到，那就可以把它们当做栈上数据对待，认为它们是线程私有的，同步加锁自然就无须进行。</li>
<li>例子<ul>
<li>变量是否逃逸，对于虚拟机来说需要使用数据流分析来确定，但是程序员自己所该是很清楚的，怎么会在明知道不存在数据争用的情况下要求同步呢？答案是有许多同步措施并不是程序员自己加入的，同步的代码在 Java 程序中的普遍程度也许超过了大部分读者的想象。我们来看看下面代码中的例子，这段非常简单的代码仅仅是输出 3 个字符串相加的结果，无论是源码字面上还是程序语义上都没有同步。</li>
<li><img src="/2019/09/04/%E8%AF%AD%E8%A8%80/Java/basic_Java/Java-basic-0-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/Java_synchronized_%E9%94%81%E6%B6%88%E9%99%A4_1.jpg" alt="Java_synchronized_锁消除_1"></li>
<li>我们也知道，由于 String 是一个不可变的类，对字符串的连接操作总是通过生成新的 String 对象来进行的，因此 Javac 编译器会对 String 连接做自动优化。在 JDK 1.5 之前，会转化为 StringBuffer 对象的连续 <code>append()</code> 操作，在 JDK 1.5及以后的版本中，会转化为 StringBuilder 对象的连续 <code>append()</code> 操作，上述代码可能会变成下面的样子。</li>
<li><img src="/2019/09/04/%E8%AF%AD%E8%A8%80/Java/basic_Java/Java-basic-0-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/Java_synchronized_%E9%94%81%E6%B6%88%E9%99%A4_2.jpg" alt="Java_synchronized_锁消除_2"></li>
<li>每个 <code>StringBuffer.append()</code> 方法中都有一个同步块，锁就是 sb 对象。虚拟机观察变量 sb，很快就会发现它的动态作用域被限制在 <code>concatString()</code> 方法内部。也就是说，sb 的所有引用永远不会 “逃逸” 到 <code>concatString()</code> 方法之外，其他线程无法访问到它，因此，虽然这里有锁，但是可以被安全地消除掉，在即时编译之后，这段代码就会忽略掉所有的同步而直接执行了。</li>
</ul>
</li>
</ul>
</li>
<li>锁粗化<ul>
<li>原则上，我们在编写代码的时候，总是推荐将同步块的作用范围限制得尽量小，只在共享数据的实际作用域中才进行同步，这样是为了使得需要同步的操作数量尽可能变小，如果存在锁竞争，那等待锁的线程也能尽快拿到锁。</li>
<li>大部分情况下，上面的原则都是正确的，但是如果一系列的连续操作都对同一个对象反复加锁和解锁，甚至加锁操作是出现在循环体中的，那即使没有线程竞争，频繁地进行互斥同步操作也会导致不必要的性能损耗。</li>
<li>例子<ul>
<li><img src="/2019/09/04/%E8%AF%AD%E8%A8%80/Java/basic_Java/Java-basic-0-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/Java_synchronized_%E9%94%81%E7%B2%97%E5%8C%96.png" alt="Java_synchronized_锁粗化"></li>
<li>上述代码中连续的 <code>append()</code> 方法就属于这类情况。如果虚拟机探测到有这样一串零碎的操作都对同一个对象加锁，将会把加锁同步的范围扩展（粗化）到整个操作序列的外部，以上述代码为例，就是扩展到 <code>append()</code> 操作外部，也就是把 while 循环加锁，这样只需要加锁一次就可以了。</li>
</ul>
</li>
</ul>
</li>
<li>锁升级<ul>
<li>从 JDK1.6 版本之后，synchronized 本身也在不断优化锁的机制，有些情况下他并不会是一个很重量级的锁了。优化机制包括自适应锁、自旋锁、锁消除、锁粗化、轻量级锁和偏向锁。</li>
<li>无锁——&gt;偏向锁——&gt;轻量级锁——&gt;重量级锁，膨胀方向不可逆。<ul>
<li>偏向锁<ul>
<li>对象头是由 Mark Word 和 Klass pointer 组成，锁争夺也就是对象头指向的 Monitor 对象的争夺，一旦有线程持有了这个对象，标志位修改为 1，就进入偏向模式，同时会把这个线程的 ID 记录在对象的 Mark Word 中。</li>
<li>这个过程是采用了 CAS 乐观锁操作的，每次同一线程进入，虚拟机就不进行任何同步的操作了，对标志位 +1 就好了，不同线程过来，CAS 会失败，也就意味着获取锁失败。</li>
<li>偏向锁在 1.6 之后是默认开启的，1.5 中是关闭的，需要手动开启参数是 <code>xx:-UseBiasedLocking=false</code>。</li>
<li><img src="/2019/09/04/%E8%AF%AD%E8%A8%80/Java/basic_Java/Java-basic-0-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/Java_synchronized%E5%8E%9F%E7%90%86_%E5%81%8F%E5%90%91%E9%94%81.jpg" alt="Java_synchronized原理_偏向锁"></li>
</ul>
</li>
<li>轻量级锁<ul>
<li>如果这个对象是无锁的，JVM 就会在当前线程的栈帧中建立一个叫锁记录（Lock Record）的空间，用来存储锁对象的 Mark Word 拷贝，然后把 Lock Record 中的 owner 指向当前对象。</li>
<li>JVM 接下来会利用 CAS 尝试把对象原本的 Mark Word 更新为 Lock Record 的指针，成功就说明加锁成功，改变锁标志位，执行相关同步操作。</li>
<li>如果失败了，就会判断当前对象的 Mark Word 是否指向了当前线程的栈帧，是则表示当前的线程已经持有了这个对象的锁，否则说明被其他线程持有了，继续锁升级，修改锁的状态，之后等待的线程也阻塞。</li>
<li><img src="/2019/09/04/%E8%AF%AD%E8%A8%80/Java/basic_Java/Java-basic-0-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/Java_synchronized%E5%8E%9F%E7%90%86_%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81.jpg" alt="Java_synchronized原理_轻量级锁"></li>
<li>轻量级锁认为竞争存在，但是竞争的程度很轻，一般两个线程对于同一个锁的操作都会错开，或者说稍微等待一下（自旋），另一个线程就会释放锁。 但是当自旋超过一定的次数，或者一个线程在持有锁，一个在自旋，又有第三个来访时，轻量级锁膨胀为重量级锁，重量级锁使除了拥有锁的线程以外的线程都阻塞，防止 CPU 空转。</li>
</ul>
</li>
<li>重量级锁<ul>
<li>就是让争抢锁的线程从用户态转换成内核态。让 CPU 借助操作系统进行线程协调。</li>
</ul>
</li>
</ul>
</li>
<li>流程<ol>
<li>检查 MarkWord 里面是不是放的自己的 ThreadId，如果是，表示当前线程是处于“偏向锁”。跳过轻量级锁直接执行同步体。</li>
<li>如果 MarkWord 不是自己的 ThreadId，锁升级，这时候，用 CAS 来执行切换，新的线程根据 MarkWord 里面现有的 ThreadId，通知之前线程暂停，之前线程将 Markword 的内容置为空。</li>
<li>两个线程都把对象的 HashCode 复制到自己新建的用于存储锁的记录空间，接着开始通过 CAS 操作，把共享对象的 MarKWord 的内容修改为自己新建的记录空间的地址的方式竞争 MarkWord.</li>
<li>第三步中成功执行 CAS 的获得资源，失败的则进入自旋.</li>
<li>自旋的线程在自旋过程中，成功获得资源（即之前获的资源的线程执行完成并释放了共享资源），则整个状态依然处于轻量级锁的状态，如果自旋失败</li>
<li>进入重量级锁的状态，这个时候，自旋的线程进行阻塞，等待之前线程执行完成并唤醒自己.</li>
</ol>
</li>
<li><img src="/2019/09/04/%E8%AF%AD%E8%A8%80/Java/basic_Java/Java-basic-0-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/Java_synchronized%E5%8E%9F%E7%90%86.png" alt="Java_synchronized原理"></li>
<li><img src="/2019/09/04/%E8%AF%AD%E8%A8%80/Java/basic_Java/Java-basic-0-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/Java_synchronized%E5%8E%9F%E7%90%86_%E9%94%81%E5%8D%87%E7%BA%A7.jpeg" alt="Java_synchronized原理_锁升级"></li>
<li><img src="/2019/09/04/%E8%AF%AD%E8%A8%80/Java/basic_Java/Java-basic-0-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/Java_synchronized%E5%8E%9F%E7%90%86_%E9%94%81%E5%8D%87%E7%BA%A7%E7%AE%80%E7%95%A5%E7%89%88.jpeg" alt="Java_synchronized原理_锁升级简略版">   </li>
</ul>
</li>
<li>同步代码块和同步方法<ul>
<li>同步方法就是在方法前加关键字 synchronized；同步代码块则是在方法内部使用 synchronized</li>
<li>加锁对象相同的话，同步方法锁的范围大于等于同步方法块。一般加锁范围越大，性能越差</li>
<li>同步方法如果是 static 方法，等同于同步方法块加锁在该 Class 对象上</li>
</ul>
</li>
<li>相关命令<ul>
<li>wait</li>
<li>notify</li>
</ul>
</li>
</ul>
</li>
<li>ReentrantLock<ul>
<li>基于 AQS 而形成了一个“可重入锁”<ul>
<li>AQS：AbstractQueuedSynchronizer 的缩写<ul>
<li><img src="/2019/09/04/%E8%AF%AD%E8%A8%80/Java/basic_Java/Java-basic-0-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/Java_AQS%E6%B5%81%E7%A8%8B%E5%9B%BE.jpg" alt="Java_AQS流程图"></li>
<li>AQS 是 JUC（java.util.concurrent）的核心，而 CLH 锁又是 AQS 的基础<ul>
<li>CLH 锁<ul>
<li>原理<ul>
<li>首先有一个尾节点指针，通过这个尾结点指针来构建等待线程的逻辑队列，因此能确保线程线程先到先服务的公平性，因此尾指针可以说是构建逻辑队列的桥梁；此外这个尾节点指针是原子引用类型，避免了多线程并发操作的线程安全性问题；</li>
<li>通过等待锁的每个线程在自己的某个变量上自旋等待，这个变量将由前一个线程写入。由于某个线程获取锁操作时总是通过尾节点指针获取到前一线程写入的变量，而尾节点指针又是原子引用类型，因此确保了这个变量获取出来总是线程安全的。</li>
<li><img src="/2019/09/04/%E8%AF%AD%E8%A8%80/Java/basic_Java/Java-basic-0-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/Java_CLH%E9%94%81.jpg" alt="Java_CLH锁"></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>可重入：同一个线程对于已经获得到的锁，可以多次继续申请到该锁的使用权</li>
</ul>
</li>
<li>ReentrantLock 实现了 Lock 接口，操作其成员变量 sync（AQS 的子类），来完成锁的相关功能。<ul>
<li>sync 有 2 种形态：NonfairSync 和 FairSync。<ul>
<li>FairSync<ul>
<li>在 tryAquire 方法中，当判断到锁状态字段 <code>state == 0</code> 时，不会立马将当前线程设置为该锁的占用线程，而是去判断是在此线程之前是否有其他线程在等待这个锁（执行 <code>hasQueuedPredecessors()</code> 方法），如果是的话，则该线程会加入到等待队列中，进行排队（FIFO，先进先出的排队形式）。</li>
<li><img src="/2019/09/04/%E8%AF%AD%E8%A8%80/Java/basic_Java/Java-basic-0-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/Java_ReetrantLock_FairSync.jpg" alt="Java_ReetrantLock_FairSync"></li>
</ul>
</li>
<li>NoFairSync<ul>
<li>在 tryAquire 方法中，没有判断是否有在此之前的排队线程，而是直接进行获锁操作，因此多个线程之间同时争用一把锁的时候，谁先获取到就变得随机了，很有可能线程 A 比线程 B 更早等待这把锁，但是B却获取到了锁，A 继续等待。</li>
<li><img src="/2019/09/04/%E8%AF%AD%E8%A8%80/Java/basic_Java/Java-basic-0-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/Java_RettrantLock_NoFairSync.jpg" alt="Java_RettrantLock_NoFairSync"></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Node<ul>
<li>Node 结点是对每一个访问同步代码的线程的封装</li>
<li>其包含了需要同步的线程本身以及线程的状态，如是否被阻塞，是否等待唤醒，是否已经被取消等。每个 Node 结点内部关联其前继结点 prev 和后继结点 next，这样可以方便线程释放锁后快速唤醒下一个在等待的线程。</li>
<li>结构<ul>
<li>waitStatus<ul>
<li>表示当前被封装成 Node 结点的等待状态<ul>
<li>CANCELLED<ul>
<li>值为 1，在同步队列中等待的线程等待超时或被中断，需要从同步队列中取消该 Node 的结点，其结点的 waitStatus 为 CANCELLED，即结束状态，进入该状态后的结点将不会再变化。</li>
</ul>
</li>
<li>SIGNAL<ul>
<li>值为 -1，被标识为该等待唤醒状态的后继结点，当其前继结点的线程释放了同步锁或被取消，将会通知该后继结点的线程执行。说白了，就是处于唤醒状态，只要前继结点释放锁，就会通知标识为 SIGNAL 状态的后继结点的线程执行。</li>
</ul>
</li>
<li>CONDITION<ul>
<li>值为 -2，与 Condition 相关，该标识的结点处于等待队列中，结点的线程等待在 Condition 上，当其他线程调用了 Condition 的 <code>signal()</code> 方法后，CONDITION 状态的结点将从等待队列转移到同步队列中，等待获取同步锁。</li>
</ul>
</li>
<li>PROPAGATE<ul>
<li>值为 -3，与共享模式相关，在共享模式中，该状态标识结点的线程处于可运行状态。</li>
</ul>
</li>
<li>0 状态<ul>
<li>值为0，代表初始化状态。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Condition<ul>
<li>Condition 的具体实现类是 AQS 的内部类 ConditionObject。</li>
<li>每个 Condition 都对应着一个等待队列，也就是说如果一个锁上创建了多个 Condition 对象，那么也就存在多个等待队列。等待队列是一个 FIFO 的队列，在队列中每一个节点都包含了一个线程的引用，而该线程就是 Condition 对象上等待的线程。当一个线程调用了 <code>await()</code> 相关的方法，那么该线程将会释放锁，并构建一个 Node 节点封装当前线程的相关信息加入到等待队列中进行等待，直到被唤醒、中断、超时才从队列中移出。</li>
<li>Condition 结构<ul>
<li><img src="/2019/09/04/%E8%AF%AD%E8%A8%80/Java/basic_Java/Java-basic-0-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/Java_ReentrantLock_Condition%E7%BB%93%E6%9E%84.png" alt="Java_ReentrantLock_Condition结构"></li>
<li>等待队列中结点的状态只有两种即 CANCELLED 和 CONDITION</li>
</ul>
</li>
</ul>
</li>
<li>相关问题<ul>
<li><strong>线程是什么时候排队的？</strong><ul>
<li>在获锁的时候，无法成功获取到该锁，然后进行排队等待。</li>
</ul>
</li>
<li><strong>线程是如何排队的？</strong><ul>
<li><img src="/2019/09/04/%E8%AF%AD%E8%A8%80/Java/basic_Java/Java-basic-0-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/Java_ReentrantLock_%E5%8A%A0%E9%94%81.png" alt="Java_ReentrantLock_加锁"></li>
<li>想要知道如何排队，那也就是去理解 <code>addWaiter(Node.EXCLUSIVE)</code> 这个方法具体是如何实现的。</li>
<li>流程<ol>
<li>初始状态（也就是锁未被任何线程占用的时候）线程 A 申请锁。此时，成功获取到锁，无排队线程。</li>
<li>线程 B 申请该锁，且上一个线程未释放。<ul>
<li><img src="/2019/09/04/%E8%AF%AD%E8%A8%80/Java/basic_Java/Java-basic-0-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/Java_ReetrantLock_%E6%8E%92%E9%98%9F_1.jpg" alt="Java_ReetrantLock_排队_1"></li>
<li>这里需要关注的是 Head 节点，这个节点是一个空的 Node 节点，不存储任何线程相关的信息</li>
</ul>
</li>
<li>线程 C 申请该锁，且占有该锁的线程未释放<ul>
<li><img src="/2019/09/04/%E8%AF%AD%E8%A8%80/Java/basic_Java/Java-basic-0-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/Java_ReetrantLock_%E6%8E%92%E9%98%9F_2.jpg" alt="Java_ReetrantLock_排队_2"></li>
</ul>
</li>
<li>线程 D 申请该锁，且占有该锁的线程未释放<ul>
<li><img src="/2019/09/04/%E8%AF%AD%E8%A8%80/Java/basic_Java/Java-basic-0-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/Java_ReetrantLock_%E6%8E%92%E9%98%9F_3.jpg" alt="Java_ReetrantLock_排队_3"></li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
<li><strong>等待中的线程如何感知到锁空闲并获得锁？</strong><ul>
<li><code>acquireQueued(addWaiter(Node.EXCLUSIVE), arg)</code> 中的 <code>addWaiter(Node.EXCLUSIVE)</code> 方法是对获锁失败的线程放入到队列中排队等待，而该方法的外层方法 <code>acquireQueued()</code> 就是对已经排队中的线程进行“获锁”操作。</li>
<li>就是一个线程获取锁失败了，被放到了线程等待队列中，而 acquireQueued 方法就是把放入队列中的这个线程不断进行“获锁”，直到它“成功获锁”或者“不再需要锁（如被中断）”。</li>
<li><img src="/2019/09/04/%E8%AF%AD%E8%A8%80/Java/basic_Java/Java-basic-0-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/Java_ReetrantLock_%E8%8E%B7%E9%94%81%E6%B5%81%E7%A8%8B.jpg" alt="Java_ReetrantLock_获锁流程"><ul>
<li>不管公平还是非公平模式下，ReentrantLock 对于排队中的线程都能保证，<em>排在前面的一定比排在后面的线程优先获得锁</em>。但是，非公平模式<em>不保证队列中的第一个线程一定就比新来的（未加入到队列）的线程优先获锁</em>。因为队列中的第一个线程尝试获得锁时，可能刚好来了一个线程也要获取锁，而这个刚来的线程都还未加入到等待队列，此时两个线程同时随机竞争，很有可能，队列中的第一个线程竞争失败（而该线程等待的时间其实比这个刚来的线程等待时间要久）。</li>
<li><strong>什么时候线程需要被阻塞呢？</strong><ul>
<li><img src="/2019/09/04/%E8%AF%AD%E8%A8%80/Java/basic_Java/Java-basic-0-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/Java_ReetrantLock_AQS%E5%88%A4%E6%96%AD%E7%BA%BF%E7%A8%8B%E6%98%AF%E5%90%A6%E5%BA%94%E8%AF%A5%E8%A2%AB%E9%98%BB%E5%A1%9E.jpg" alt="Java_ReetrantLock_AQS判断线程是否应该被阻塞"></li>
<li>while 循环中必须要这个 node 符合“它就是该队列中最早的 Node 并且获锁成功”才会跳出 while 循环体，如果不是，则会继续执行到“判断这个线程是否应该被阻塞”，此时。原本状态不是 SIGNAL 的线程，因为在上一次“判断这个线程是否应该被阻塞”这个方法时被设置成了 SIGNAL，那么第二次执行这个判断时，就会被成功阻塞。也就不会出现“空跑”的情况。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><strong>那什么时候唤醒这些阻塞的线程呢？</strong><ul>
<li><img src="/2019/09/04/%E8%AF%AD%E8%A8%80/Java/basic_Java/Java-basic-0-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/Java_ReentrantLock_%E8%A7%A3%E9%94%81.png" alt="Java_ReentrantLock_解锁"></li>
<li><code>unparkSuccessor(h)</code> 方法就是“唤醒操作”，主要流程如代码所示<ol>
<li>尝试释放当前线程持有的锁</li>
<li>如果成功释放，那么去唤醒头结点的后继节点（因为头节点 head 是不保存线程信息的节点，仅仅是因为数据结构设计上的需要，在数据结构上，这种做法往往叫做“空头节点链表”。对应的就有“非空头结点链表”）</li>
</ol>
</li>
</ul>
</li>
<li><strong>synchronized、ReentrantLock 的区别</strong><ul>
<li><img src="/2019/09/04/%E8%AF%AD%E8%A8%80/Java/basic_Java/Java-basic-0-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/Java_ReentrantLock%E4%B8%8Esynchronized%E7%9A%84%E5%8C%BA%E5%88%AB.png" alt="Java_ReentrantLock与synchronized的区别"></li>
</ul>
</li>
<li><strong>非公平锁比公平锁高效的原因？</strong><ul>
<li>因为线程切换的开销。如果一个线程在 running 期间直接抢占到锁资源，就不需要进行【恢复现场】操作，也就可以更快地执行业务代码。相反地，如果是一个就绪态的线程想要获得锁资源，首先需要恢复现场，之后争抢锁（可能成功也可能失败），此时就已经浪费了大量的 CPU，只有在获取锁成功后才能继续执行业务代码。</li>
<li>非公平锁减少了线程挂起的几率，后来的线程有一定几率逃离被挂起的开销。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>ReentrantReadWriteLock<ul>
<li>表示两个锁，一个是读操作相关的锁，称为共享锁；一个是写相关的锁，称为排他锁</li>
<li>入锁条件：<ul>
<li>线程进入读锁的前提条件：<ul>
<li>没有其他线程的写锁</li>
<li>没有写请求或者有写请求，但调用线程和持有锁的线程是同一个。</li>
</ul>
</li>
<li>线程进入写锁的前提条件：<ul>
<li>没有其他线程的读锁</li>
<li>没有其他线程的写锁</li>
</ul>
</li>
</ul>
</li>
<li>三个重要的特性：<ul>
<li>公平选择性：支持非公平（默认）和公平的锁获取方式，吞吐量还是非公平优于公平。</li>
<li>重进入：读锁和写锁都支持线程重进入。</li>
<li>锁降级：遵循获取写锁、获取读锁再释放写锁的次序，写锁能够降级成为读锁。</li>
</ul>
</li>
<li>结构<ul>
<li><img src="/2019/09/04/%E8%AF%AD%E8%A8%80/Java/basic_Java/Java-basic-0-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/Java_Lock%E7%BB%A7%E6%89%BF%E7%BB%93%E6%9E%84.png" alt="Java_Lock继承结构"></li>
</ul>
</li>
<li>原理<ul>
<li>同步状态在重入锁的实现中是表示被同一个线程重复获取的次数，即一个整形变量来维护，但是之前的那个表示仅仅表示是否锁定，而不用区分是读锁还是写锁。而读写锁需要在同步状态（一个整形变量）上维护多个读线程和一个写线程的状态。</li>
<li>读写锁对于同步状态的实现是在一个整形变量上通过“按位切割使用”：将变量切割成两部分，高 16 位表示读，低 16 位表示写。<ul>
<li><img src="/2019/09/04/%E8%AF%AD%E8%A8%80/Java/basic_Java/Java-basic-0-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/Java_%E8%AF%BB%E5%86%99%E9%94%81%E5%90%8C%E6%AD%A5%E7%8A%B6%E6%80%81.png" alt="Java_读写锁同步状态"></li>
</ul>
</li>
</ul>
</li>
<li>读锁<ul>
<li>加锁过程<ul>
<li><img src="/2019/09/04/%E8%AF%AD%E8%A8%80/Java/basic_Java/Java-basic-0-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/Java_%E8%AF%BB%E9%94%81%E7%AB%9E%E4%BA%89%E8%BF%87%E7%A8%8B.png" alt="Java_读锁竞争过程"></li>
<li>读锁的获取条件要满足：<ol>
<li><strong>当前的写锁未被占有（AQS state 变量低 16 位为 0）或者当前线程是写锁占有的线程</strong></li>
<li><strong><code>readerShouldBlock()</code> 方法返回 false</strong></li>
<li><strong>当前读锁占有量小于最大值<code>(2^16 -1)</code></strong></li>
<li><strong>成功通过 CAS 操作将读锁占有量 +1（AQS 的 state 高 16 位同步加 1）</strong></li>
</ol>
</li>
</ul>
</li>
<li>释放过程<ul>
<li><img src="/2019/09/04/%E8%AF%AD%E8%A8%80/Java/basic_Java/Java-basic-0-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/Java_%E8%AF%BB%E9%94%81%E9%87%8A%E6%94%BE%E8%BF%87%E7%A8%8B.png" alt="Java_读锁释放过程"></li>
</ul>
</li>
</ul>
</li>
<li>写锁<ul>
<li>加锁过程<ul>
<li><img src="/2019/09/04/%E8%AF%AD%E8%A8%80/Java/basic_Java/Java-basic-0-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/Java_%E5%86%99%E9%94%81%E7%AB%9E%E4%BA%89%E8%BF%87%E7%A8%8B.png" alt="Java_写锁竞争过程"></li>
<li>写锁获取的条件需要满足：<ol>
<li><strong>读锁未被占用（AQS state 高 16 位为 0） ，写锁未被占用（state 低 16 位为 0）或者占用写锁的线程是当前线程</strong></li>
<li><strong><code>writerShouldBlock()</code>方法返回 false，即不阻塞写线程</strong></li>
<li><strong>当前写锁占有量小于最大值（2^16 -1），否则抛出Error(“Maximum lock count exceeded”)</strong></li>
<li><strong>通过 CAS 竞争将写锁状态 +1（将 state 低 16 位同步 +1）</strong></li>
</ol>
</li>
</ul>
</li>
<li>释放过程<ul>
<li><img src="/2019/09/04/%E8%AF%AD%E8%A8%80/Java/basic_Java/Java-basic-0-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/Java_%E5%86%99%E9%94%81%E9%87%8A%E6%94%BE%E8%BF%87%E7%A8%8B.png" alt="Java_写锁释放过程"></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>StampedLock<ul>
<li>StampedLock 类，在 JDK1.8 时引入，是对读写锁 ReentrantReadWriteLock 的增强，该类提供了一些功能，优化了读锁、写锁的访问，同时使读写锁之间可以互相转换，更细粒度控制并发。</li>
<li>StampedLock 是不可重入锁。</li>
<li>主要特点<ul>
<li>所有获取锁的方法，都返回一个邮戳（Stamp），Stamp 为 0 表示获取失败，其余都表示成功；</li>
<li>所有释放锁的方法，都需要一个邮戳（Stamp），这个 Stamp 必须是和成功获取锁时得到的 Stamp 一致；</li>
<li>StampedLock 是不可重入的；（如果一个线程已经持有了写锁，再去获取写锁的话就会造成死锁）</li>
<li>StampedLock 支持读锁和写锁的相互转换<ul>
<li>在 RRW 中，当线程获取到写锁后，可以降级为读锁，但是读锁是不能直接升级为写锁的。</li>
<li>StampedLock 提供了读锁和写锁相互转换的功能，使得该类支持更多的应用场景。</li>
</ul>
</li>
<li>无论写锁还是读锁，都不支持 Conditon 等待</li>
<li>StampedLock 相比 ReentrantReadWriteLock，对多核 CPU 进行了优化。当 CPU 核数超过 1 时，会有一些自旋操作</li>
</ul>
</li>
<li>StampedLock 有三种访问模式：<ul>
<li>Reading（读模式）：功能和 ReentrantReadWriteLock 的读锁类似</li>
<li>Writing（写模式）：功能和 ReentrantReadWriteLock 的写锁类似</li>
<li>Optimistic reading（乐观读模式）：这是一种优化的读模式<ul>
<li>读的时候不加读锁，读出来发现数据被修改了，再升级为“悲观读”；即读错了再严格读一次，避免写线程被饿死。乐观读不能保证读取到的数据是最新的，所以将数据读取到局部变量的时候需要通过 <code>lock.validate(stamp)</code> 校验是否被写线程修改过，若是修改过则需要上悲观读锁，再重新读取数据到局部变量。<ul>
<li>stamp 类似 version</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>原理<ul>
<li>StampedLock 虽然不像其它锁一样定义了内部类来实现 AQS 框架，但是 StampedLock 的基本实现思路还是利用 CLH 队列进行线程的管理，通过同步状态值来表示锁的状态和类型。</li>
<li><img src="/2019/09/04/%E8%AF%AD%E8%A8%80/Java/basic_Java/Java-basic-0-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/Java_StampedLock_CLH%E9%98%9F%E5%88%97.jpg" alt="Java_StampedLock_CLH队列"></li>
</ul>
</li>
<li>相关问题<ul>
<li><strong>为什么有了 ReentrantReadWriteLock，还要引入 StampedLock？</strong><ul>
<li>ReentrantReadWriteLock 使得多个读线程同时持有读锁（只要写锁未被占用），而写锁是独占的。</li>
<li>但是，读写锁如果使用不当，很容易产生“饥饿”问题。<ul>
<li>例如<ul>
<li>比如在读线程非常多，写线程很少的情况下，很容易导致写线程“饥饿”，虽然使用“公平”策略可以一定程度上缓解这个问题，但是“公平”策略是以牺牲系统吞吐量为代价的。<ul>
<li>线程饥饿<ul>
<li>大量读多写少的场景，读线程连续抢占导致等待的写线程无法执行。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>LockSupport<ul>
<li>底层实现原理<ul>
<li>在 Linux 系统下，是用的 Posix 线程库 pthread 中的 mutex（互斥量），condition（条件变量）来实现的。</li>
<li>mutex 和 condition 保护了一个 _counter 的变量，当 park 时，这个变量被设置为 0，当 unpark 时，这个变量被设置为 1。</li>
</ul>
</li>
<li>LockSupport可以在任何场合使线程阻塞，同时也可以指定要唤醒的线程<ul>
<li>使用 wait、notify 来实现等待唤醒功能至少有两个缺点：<ol>
<li>在调用这两个方法前必须先获得锁对象，这限制了其使用场合：只能在同步代码块中。</li>
<li>当对象的等待队列中有多个线程时，notify 只能随机选择一个线程唤醒，无法唤醒指定的线程。</li>
</ol>
</li>
</ul>
</li>
<li>常用方法<ul>
<li><code>LockSupport.park()</code><ul>
<li>用来阻塞当前线程</li>
<li>当调用 <code>park()</code> 方法时，会将 _counter 置为 0，同时判断设置前值，等于 1 说明前面被 unpark 过，则直接退出，否则将使该线程阻塞。</li>
</ul>
</li>
<li><code>LockSupport.park(Object blocker)</code><ul>
<li>指定线程阻塞的对象 blocker，该对象主要用来排查问题</li>
</ul>
</li>
<li><code>LockSupport.unpark(Thread thread)</code><ul>
<li>用来唤醒线程，因为需要线程作参数，所以可以指定线程进行唤醒</li>
<li>当调用 <code>unpark()</code> 方法时，会将 _counter 置为 1，同时判断设置前值，小于 1 会进行线程唤醒，否则直接退出。</li>
</ul>
</li>
</ul>
</li>
<li>相关问题<ul>
<li><strong>为什么可以先唤醒线程后阻塞线程？</strong><ul>
<li>因为 unpark 获得了一个凭证,之后调用 park 因为有凭证消费，故不会阻塞。</li>
</ul>
</li>
<li><strong>为什么唤醒两次后阻塞两次会阻塞线程？</strong><ul>
<li>因为凭证的数量最多为 1，连续调用两次 unpark 和调用一次 unpark 效果一样，只会增加一个凭证；而调用两次 park 却需要消费两个凭证。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>ThreadLocal<ul>
<li>ThreadLocal 的作用<ul>
<li>作用主要是做数据隔离，填充的数据只属于当前线程，变量的数据对别的线程而言是相对隔离的，在多线程环境下，如何防止自己的变量被其它线程篡改。<ul>
<li><strong>隔离有什么用，会用在什么场景么？</strong><ul>
<li>Spring 实现事务隔离级别<ul>
<li>Spring 采用 Threadlocal 的方式，来保证单个线程中的数据库操作使用的是同一个数据库连接，同时，采用这种方式可以使业务层使用事务时不需要感知并管理 connection 对象，通过传播级别，巧妙地管理多个事务配置之间的切换，挂起和恢复。</li>
<li>Spring 框架里面就是用的 ThreadLocal 来实现这种隔离，主要是在T ransactionSynchronizationManager 这个类里面</li>
<li>Spring 的事务主要是 ThreadLocal 和 AOP 去做实现的</li>
</ul>
</li>
<li>很多场景的 cookie，session 等数据隔离都是通过 ThreadLocal 去做实现的。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>常用于以下这个场景<ul>
<li>多线程环境下存在对非线程安全对象的并发访问，而且该对象不需要在线程间共享，但是我们不想加锁，这时候可以使用 ThreadLocal 来使得每个线程都持有一个该对象的副本。</li>
</ul>
</li>
<li>原理<ul>
<li>每个 Thread 线程内部都有一个静态的 ThreadLocalMap。Map 里面存储线程本地对象 ThreadLocal（key）和线程的变量副本（value）。</li>
<li>Thread 内部的 Map 是由 ThreadLocal 维护，ThreadLocal 负责向 map 获取和设置线程的变量值。</li>
<li>一个 Thread 可以有多个 ThreadLocal。</li>
<li><img src="/2019/09/04/%E8%AF%AD%E8%A8%80/Java/basic_Java/Java-basic-0-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/Java_%E5%A4%9A%E7%BA%BF%E7%A8%8B_ThreadLocal%E7%BB%93%E6%9E%84.jpg" alt="Java_多线程_ThreadLocal结构"></li>
<li><img src="/2019/09/04/%E8%AF%AD%E8%A8%80/Java/basic_Java/Java-basic-0-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/Java_ThreadLocal_ThreadLocalMap%E7%BB%93%E6%9E%84.jpg" alt="Java_ThreadLocal_ThreadLocalMap结构"><ul>
<li>Entry 是继承 WeakReference（弱引用）的，只用了数组没有用链表。<ul>
<li><strong>为什么需要数组呢？没有了链表怎么解决 Hash 冲突呢？</strong><ul>
<li>用数组是因为，我们开发过程中可以一个线程可以有多个 ThreadLocal 来存放不同类型的对象的，但是他们都将放到你当前线程的 ThreadLocalMap 里，所以肯定要数组来存。</li>
<li>ThreadLocalMap 在存储的时候会给每一个 ThreadLocal 对象一个 threadLocalHashCode，在插入过程中，根据 ThreadLocal 对象的 hash 值，定位到 table 中的位置 i，<code>int i = key.threadLocalHashCode &amp; (len-1)</code>。<ul>
<li>然后会判断一下：如果当前位置是空的，就初始化一个 Entry 对象放在位置 i 上；</li>
<li>如果位置 i 不为空，如果这个 Entry 对象的 key 正好是即将设置的 key，那么就刷新 Entry 中的 value；</li>
<li>如果位置 i 的不为空，而且 key 不等于 entry，那就找下一个空位置，直到为空为止。</li>
</ul>
</li>
<li><img src="/2019/09/04/%E8%AF%AD%E8%A8%80/Java/basic_Java/Java-basic-0-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/Java_ThreadLocal_%E6%96%B0%E5%A2%9E%E6%95%B0%E6%8D%AE.jpg" alt="Java_ThreadLocal_新增数据"></li>
<li>在 get 的时候，也会根据 ThreadLocal 对象的 hash 值，定位到 table 中的位置，然后判断该位置 Entry 对象中的 key 是否和 get 的 key 一致，如果不一致，就判断下一个位置，set 和 get 如果冲突严重的话，效率还是很低的。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>ThreadLocal 的问题<ul>
<li>内存泄露<ul>
<li>ThreadLocal 在保存的时候会把自己当做 Key 存在 ThreadLocalMap 中，正常情况应该是 key 和 value 都应该被外界强引用才对，但是现在 key 被设计成 WeakReference 弱引用了。</li>
<li>这就导致了一个问题，ThreadLocal 在没有外部强引用时，发生 GC 时会被回收，如果创建 ThreadLocal 的线程一直持续运行，那么这个 Entry 对象中的 value 就有可能一直得不到回收，发生内存泄露。</li>
<li>就比如线程池里面的线程，线程都是复用的，那么之前的线程实例处理完之后，出于复用的目的线程依然存活，所以，ThreadLocal 设定的 value 值被持有，导致内存泄露。</li>
<li>按照道理一个线程使用完，ThreadLocalMap 是应该要被清空的，但是现在线程被复用了。<ul>
<li><strong>那怎么解决？</strong><ul>
<li>在代码的最后使用 remove 就好了，我们只要记得在使用的最后用 remove 把值清空就好了。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>相关问题<ul>
<li><strong>如果我想共享线程的 ThreadLocal 数据怎么办？</strong><ul>
<li>使用 InheritableThreadLocal 可以实现多个线程访问 ThreadLocal 的值，我们在主线程中创建一个 InheritableThreadLocal 的实例，然后在子线程中得到这个 InheritableThreadLocal 实例设置的值。</li>
<li><strong>怎么传递的呀？</strong><ul>
<li><img src="/2019/09/04/%E8%AF%AD%E8%A8%80/Java/basic_Java/Java-basic-0-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/Java_ThreadLocal_InheritableThreadLocal.jpg" alt="Java_ThreadLocal_InheritableThreadLocal"></li>
<li>```<br>public class Thread implements Runnable {<br>  ……<br>  if (inheritThreadLocals &amp;&amp; parent.inheritableThreadLocals != null)<pre><code>  this.inheritableThreadLocals=ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);
</code></pre>
  ……<br>}<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br></pre></td><td class="code"><pre><span class="line">        - 如果线程的 inheritThreadLocals 变量不为空，比如我们上面的例子，而且父线程的 inheritThreadLocals 也存在，那么我就把父线程的 inheritThreadLocals 给当前线程的 inheritThreadLocals。</span><br><span class="line">    - **那为什么 ThreadLocalMap 的 key 要设计成弱引用？**</span><br><span class="line">      - key 不设置成弱引用的话就会造成和 entry 中 value 一样内存泄漏的场景。</span><br><span class="line">- 多线程相关使用类</span><br><span class="line">  - 原子操作相关类</span><br><span class="line">    - AtomicReference</span><br><span class="line">      - AtomicReference 是作用是对”对象”进行原子操作。提供了一种读和写都是原子性的对象引用变量。</span><br><span class="line">    - FieldUpdater</span><br><span class="line">      - 子类有：AtomicIntegerFieldUpdater、AtomicLongFieldUpdater、AtomicReferenceFieldUpdater</span><br><span class="line">      - AtomicXXXFieldUpdater，就是可以以一种线程安全的方式操作非线程安全对象的某些字段</span><br><span class="line">      - 可以在不修改用户代码（调用方）的情况下，就能实现并发安全性</span><br><span class="line">        - ![Java_AtomicIntegerFieldUpdater_例子](Java-basic-0-知识点汇总/Java_AtomicIntegerFieldUpdater_例子.png)</span><br><span class="line">      - AtomicReferenceFieldUpdater 的使用必须满足以下条件</span><br><span class="line">        - AtomicReferenceFieldUpdater 只能修改对于它可见的字段，也就是说对于目标类的某个字段 field，如果修饰符是 private，但是 AtomicReferenceFieldUpdater 所在的使用类不能看到 field，那就会报错；</span><br><span class="line">        - 目标类的操作字段，必须用 volatile 修饰；</span><br><span class="line">        - 目标类的操作字段，不能是 static 的；</span><br><span class="line">        - AtomicReferenceFieldUpdater 只适用于引用类型的字段；</span><br><span class="line">      - 原理</span><br><span class="line">        - 利用 Unsafe 进行 CAS 更新</span><br><span class="line">    - LongAdder</span><br><span class="line">      - JDK1.8 时，java.util.concurrent.atomic 包中提供了一个新的原子类：LongAdder。</span><br><span class="line">      - 根据 Oracle 官方文档的介绍，LongAdder 在高并发的场景下会比它的前辈（AtomicLong）具有更好的性能，代价是消耗更多的内存空间</span><br><span class="line">      - 原理</span><br><span class="line">        - 内部是一个 Base + 一个 Cell 数组</span><br><span class="line">          - base 变量：非竞争状态条件下，直接累加到该变量上</span><br><span class="line">          - Cell数组：竞争条件下（高并发下），累加各个线程自己的槽 `Cell[i]` 中</span><br><span class="line">        - add 方法</span><br><span class="line">          - ![Java_LongAdder_add方法原理](Java-basic-0-知识点汇总/Java_LongAdder_add方法原理.png)</span><br><span class="line">        - sum 方法</span><br><span class="line">          - $\text &#123; value &#125;=\text &#123; base &#125;+\sum_&#123;i=0&#125;^&#123;n&#125; \operatorname&#123;Cell&#125;[i]$</span><br><span class="line">      - 相关类</span><br><span class="line">        - LongAccumulator</span><br><span class="line">          - LongAccumulator 是 LongAdder 的增强版。LongAdder 只能针对数值的进行加减运算，而 LongAccumulator 提供了自定义的函数操作。</span><br><span class="line">        - DoubleAdder</span><br><span class="line">        - DoubleAccumulator</span><br><span class="line">      - 相关问题</span><br><span class="line">        - **为什么要引入 LongAdder？**</span><br><span class="line">          - AtomicLong 是利用了底层的 CAS 操作来提供并发性的，比如 addAndGet 方法：</span><br><span class="line">            - ![Java_AtomicLong_addAndGet](Java-basic-0-知识点汇总/Java_AtomicLong_addAndGet.png)</span><br><span class="line">          - 上述方法调用了 Unsafe 类的 getAndAddLong 方法，该方法内部是个 native 方法，它的逻辑是采用自旋的方式不断更新目标值，直到更新成功。</span><br><span class="line">          - 在并发量较低的环境下，线程冲突的概率比较小，自旋的次数不会很多。但是，高并发环境下，N 个线程同时进行自旋操作，会出现大量失败并不断自旋的情况，此时 AtomicLong 的自旋会成为瓶颈。</span><br><span class="line">          - 这就是 LongAdder 引入的初衷-d解决高并发环境下 AtomicLong 的自旋瓶颈问题。</span><br><span class="line">        - **LongAdder 快在哪里？**</span><br><span class="line">          - AtomicLong 中有个内部变量 value 保存着实际的 long 值，所有的操作都是针对该变量进行。也就是说，高并发环境下，value 变量其实是一个热点，也就是 N 个线程竞争一个热点。</span><br><span class="line">          - LongAdder 的基本思路就是分散热点，将 value 值拆分到一个数组中，不同线程会命中到数组的不同槽中，各个线程只对自己槽中的那个值进行 CAS 操作，这样热点就被分散了，冲突的概率就小很多。如果要获取真正的 long 值，只要将各个槽中的变量值累加返回。</span><br><span class="line">  - 其他</span><br><span class="line">    - Semaphore</span><br><span class="line">      - Semaphore，又名信号量，这个类的作用有点类似于“许可证”。有时，我们因为一些原因需要控制同时访问共享资源的最大线程数量，比如出于系统性能的考虑需要限流，或者共享资源是稀缺资源，我们需要有一种办法能够协调各个线程，以保证合理的使用公共资源。</span><br><span class="line">      - Semaphore 维护了一个许可集，其实就是一定数量的“许可证”。</span><br><span class="line">        - 当有线程想要访问共享资源时，需要先获取（acquire）的许可；如果许可不够了，线程需要一直等待，直到许可可用。当线程使用完共享资源后，可以归还（release）许可，以供其它需要的线程使用。</span><br><span class="line">      - Semaphore 其实就是实现了AQS共享功能的同步器</span><br><span class="line">      - 注意：Semaphore 不是锁，只能限制同时访问资源的线程数，至于对数据一致性的控制，Semaphore 是不关心的。当前，如果是只有一个许可的 Semaphore，可以当作锁使用。</span><br><span class="line">    - CyclicBarrier</span><br><span class="line">      - CyclicBarrier 是一个辅助同步器类，在 JDK1.5 时随着 J.U.C 一起引入。</span><br><span class="line">      - CyclicBarrier 可以认为是一个栅栏。让线程到达栅栏时被阻塞（调用await方法），直到到达栅栏的线程数满足指定数量要求时，栅栏才会打开放行。</span><br><span class="line">      - ![Java_CyclicBarrier](Java-basic-0-知识点汇总/Java_CyclicBarrier.png)</span><br><span class="line">      - CyclicBarrier 是可以循环复用的</span><br><span class="line">    - CountDownLatch</span><br><span class="line">      - CountDownLatch 是一个辅助同步器类，用来作计数使用，它的作用有点类似于生活中的倒数计数器，先设定一个计数初始值，当计数降到0时，将会触发一些事件，如火箭的倒数计时。</span><br><span class="line">      - 用法</span><br><span class="line">        - 初始计数值在构造 CountDownLatch 对象时传入，每调用一次 `countDown()` 方法，计数值就会减 1。</span><br><span class="line">        - 线程可以调用 CountDownLatch 的 await 方法进入阻塞，当计数值降到 0 时，所有之前调用 await 阻塞的线程都会释放。</span><br><span class="line">      - 注意：CountDownLatch 的初始计数值一旦降到 0，无法重置。如果需要重置，可以考虑使用 CyclicBarrier。</span><br><span class="line">    - Exchanger</span><br><span class="line">      - Exchanger-交换器，是 JDK1.5 时引入的一个同步器，从字面上就可以看出，这个类的主要作用是交换数据。</span><br><span class="line">      - Exchanger 有点类似于 CyclicBarrier。Exchanger 可以看成是一个双向栅栏。</span><br><span class="line">        - ![Java_Exchanger](Java-basic-0-知识点汇总/Java_Exchanger.png)</span><br><span class="line">        - Thread1 线程到达栅栏后，会首先观察有没其它线程已经到达栅栏，如果没有就会等待，如果已经有其它线程（Thread2）已经到达了，就会以成对的方式交换各自携带的信息，因此 Exchanger 非常适合用于两个线程之间的数据交换。</span><br><span class="line">    - Phaser</span><br><span class="line">      - Phaser 是 JDK1.7 开始引入的一个同步工具类，适用于一些需要分阶段的任务的处理。它的功能与 CyclicBarrier 和 CountDownLatch 有些类似，类似于一个多阶段的栅栏，并且功能更强大</span><br><span class="line">    - Fork/Join 框架</span><br><span class="line">      - Fork/Join 框架是在 java7 之后提供的一种基于分治策略的多线程框架。与分支策略思想一样，即一个大问题可以被拆分为若干个小问题，而且小问题之间互不干扰，并且解法与原问题形式相同，最终将子问题的解合并可以得到原问题的解。</span><br><span class="line">      - 执行流程</span><br><span class="line">        - ![Java_ForkJoin_执行流程](Java-basic-0-知识点汇总/Java_ForkJoin_执行流程.png)</span><br><span class="line">      - 相关类</span><br><span class="line">        - RecursiveTask</span><br><span class="line">        - ForkJoinPool</span><br><span class="line">- 线程</span><br><span class="line">  - 线程的五种状态</span><br><span class="line">    - ![Java_线程_线程状态转换图](Java-basic-0-知识点汇总/Java_线程_线程状态转换图.jpg)</span><br><span class="line">    - NEW</span><br><span class="line">      - 新创建了一个线程对象。</span><br><span class="line">    - RUNNABLE</span><br><span class="line">      - 线程对象创建后，其他线程（比如 main 线程）调用了该对象的 `start()` 方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获取 cpu 的使用权。</span><br><span class="line">    - RUNNING</span><br><span class="line">      - 可运行状态（runnable）的线程获得了 cpu 时间片（timeslice），执行程序代码。</span><br><span class="line">    - BLOCKED</span><br><span class="line">      - 阻塞状态是指线程因为某种原因放弃了 cpu 使用权，也即让出了 cpu timeslice，暂时停止运行。直到线程进入可运行（runnable）状态，才有机会再次获得 cpu timeslice 转到运行（running）状态。阻塞的情况分三种：</span><br><span class="line">        - 等待阻塞：运行（running）的线程执行 `o.wait()` 方法，JVM 会把该线程放入等待队列（waitting queue）中。</span><br><span class="line">          - 等待队列</span><br><span class="line">            - 调用 obj 的 `wait()`，`notify()`方法前，必须获得 obj 锁，也就是必须写在 `synchronized(obj)` 代码段内。</span><br><span class="line">            - ![Java_线程_锁池](Java-basic-0-知识点汇总/Java_线程_锁池.jpg)</span><br><span class="line">            - 锁池状态</span><br><span class="line">              - 当前线程想调用对象 A 的同步方法时，发现对象 A 的锁被别的线程占有，此时当前线程进入锁池状态。简言之，锁池里面放的都是想争夺对象锁的线程。</span><br><span class="line">              - 当一个线程 1 被另外一个线程 2 唤醒时，1 线程进入锁池状态，去争夺对象锁。</span><br><span class="line">              - 锁池是在同步的环境下才有的概念，一个对象对应一个锁池。</span><br><span class="line">        - 同步阻塞：运行（running）的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则 JVM 会把该线程放入锁池（lock pool）中。</span><br><span class="line">        - 其他阻塞：运行（running）的线程执行 `Thread.sleep(long ms)` 或 `t.join()` 方法，或者发出了 I/O 请求时，JVM 会把该线程置为阻塞状态。当 `sleep()` 状态超时、`join()` 等待线程终止或者超时、或者 I/O 处理完毕时，线程重新转入可运行（runnable）状态。</span><br><span class="line">    - DEAD</span><br><span class="line">      - 线程 `run()`、`main()` 方法执行结束，或者因异常退出了 `run()` 方法，则该线程结束生命周期。死亡的线程不可再次复生。</span><br><span class="line">  - 几种会导致线程状态改变的方法</span><br><span class="line">    - api</span><br><span class="line">      - `Thread.sleep(long millis)`，一定是当前线程调用此方法，当前线程进入阻塞，但不释放对象锁，millis 后线程自动苏醒进入可运行状态。</span><br><span class="line">        - 作用：给其它线程执行机会的最佳方式。</span><br><span class="line">      - `Thread.yield()`，一定是当前线程调用此方法，当前线程放弃获取的 cpu 时间片，由运行状态变会可运行状态，让 OS 再次选择线程。</span><br><span class="line">        - 作用：让相同优先级的线程轮流执行，但并不保证一定会轮流执行。实际中无法保证 `yield()` 达到让步目的，因为让步的线程还有可能被线程调度程序再次选中。`Thread.yield()` 不会导致阻塞。</span><br><span class="line">      - `t.join()/t.join(long millis)`，当前线程里调用其它线程 1 的 join 方法，当前线程阻塞，但不释放对象锁，直到线程 1 执行完毕或者 millis 时间到，当前线程进入可运行状态。</span><br><span class="line">      - `obj.wait()`，当前线程调用对象的 `wait()` 方法，当前线程释放对象锁，进入等待队列。依靠 `notify()/notifyAll()` 唤醒或者 `wait(long timeout)` timeout 时间到自动唤醒。</span><br><span class="line">      - `obj.notify()`，唤醒在此对象监视器上等待的单个线程，选择是任意性的。`notifyAll()` 唤醒在此对象监视器上等待的所有线程。</span><br><span class="line">    - 应用</span><br><span class="line">      - `Thread.yield()` 和 `Thread.sleep(0)`</span><br><span class="line">        - `Thread.yield()` 和 `Thread.sleep(0)` 语义实现取决于具体的 JVM，某些 JVM 可能什么都不做，而大多数虚拟机会让线程放弃剩余的 cpu 时间片，重新变为 runnable 状态，并放到同优先级线程队列的末尾等待 cpu 资源。 但是当我们调用 `Thread.yield()` 的那一刻，并不意味着当前线程立马释放 cpu 资源，这是因为获得时间片的线程从 runable 切换到 running 仍需要一定的准备时间，这段时间当前线程仍可能运行一小段时间。</span><br><span class="line">  - Thread 的常用方法</span><br><span class="line">    - `interrupt()`</span><br><span class="line">      - 其作用是中断此线程（此线程不一定是当前线程，而是指调用该方法的 Thread 实例所代表的线程），但实际上只是给线程设置一个中断标志，线程仍会继续运行。</span><br><span class="line">    - `interrupted()`</span><br><span class="line">      - 作用是测试当前线程是否被中断（检查中断标志），返回一个 boolean 并清除中断状态，第二次再调用时中断状态已经被清除，将返回一个 false。</span><br><span class="line">    - `isInterrupted()`</span><br><span class="line">      - 作用是只测试此线程是否被中断 ，不清除中断状态。</span><br><span class="line">    - `join()`</span><br><span class="line">  - 线程安全问题</span><br><span class="line">    - 运行结果错误</span><br><span class="line">    - 发布和初始化导致线程安全问题</span><br><span class="line">      - 我们创建对象并进行发布和初始化供其他类或对象使用是常见的操作，但如果我们操作的时间或地点不对，就可能导致线程安全问题。</span><br><span class="line">    - 活跃性问题</span><br><span class="line">      - 活跃性问题就是程序始终得不到运行的最终结果，相比于前面两种线程安全问题带来的数据错误或报错，活跃性问题带来的后果可能更严重，比如发生死锁会导致程序完全卡死，无法向下运行。</span><br><span class="line">      - 最典型的有三种</span><br><span class="line">        - 死锁</span><br><span class="line">          - 死锁是一种状态，当两个（或多个）线程（或进程）相互持有对方所需要的资源，却又都不主动释放自己手中所持有的资源，导致大家都获取不到自己想要的资源，所有相关的线程（或进程）都无法继续往下执行，在未改变这种状态之前都不能向前推进，我们就把这种状态称为死锁状态，认为它们发生了死锁。</span><br><span class="line">        - 活锁</span><br><span class="line">          - 举一个例子，假设有一个消息队列，队列里放着各种各样需要被处理的消息，而某个消息由于自身被写错了导致不能被正确处理，执行时会报错，可是队列的重试机制会重新把它放在队列头进行优先重试处理，但这个消息本身无论被执行多少次，都无法被正确处理，每次报错后又会被放到队列头进行重试，周而复始，最终导致线程一直处于忙碌状态，但程序始终得不到结果，便发生了活锁问题。</span><br><span class="line">        - 饥饿</span><br><span class="line">          - 饥饿是指线程需要某些资源时始终得不到，尤其是 CPU 资源，就会导致线程一直不能运行而产生的问题。</span><br><span class="line">- 线程池</span><br><span class="line">  - 核心的参数概念</span><br><span class="line">    - 最大线程数 maximumPoolSize</span><br><span class="line">      - 该参数表示的是线程池中允许存在的最大线程数量。当任务队列满了以后，再有新的任务进入到线程池时，会判断再新建一个线程是否会超过 maximumPoolSize，如果会超过，则不创建线程，而是执行拒绝策略。如果不会超过 maximumPoolSize，则会创建新的线程来执行任务。</span><br><span class="line">    - 核心线程数 corePoolSize</span><br><span class="line">      - 该参数表示的是线程池的核心线程数。当任务提交到线程池时，如果线程池的线程数量还没有达到 corePoolSize，那么就会新创建的一个线程来执行任务，如果达到了，就将任务添加到任务队列中。</span><br><span class="line">    - 活跃时间 keepAliveTime</span><br><span class="line">      - 当线程池中的线程数量大于 corePoolSize 时，那么大于 corePoolSize 这部分的线程，如果没有任务去处理，那么就表示它们是空闲的，这个时候是不允许它们一直存在的，而是允许它们最多空闲一段时间，这段时间就是 keepAliveTime，时间的单位就是 TimeUnit。</span><br><span class="line">    - unit</span><br><span class="line">      - 空闲线程允许存活时间的单位，TimeUnit 是一个枚举值，它可以是纳秒、微妙、毫秒、秒、分、小时、天。</span><br><span class="line">    - 阻塞队列 workQueue</span><br><span class="line">      - 任务队列，用来存放任务。该队列的类型是阻塞队列，常用的阻塞队列有 ArrayBlockingQueue、LinkedBlockingQueue、SynchronousQueue、PriorityBlockingQueue 等。</span><br><span class="line">        - ArrayBlockingQueue</span><br><span class="line">          - 是一个基于数组实现的阻塞队列，元素按照先进先出（FIFO）的顺序入队、出队。因为底层实现是数组，数组在初始化时必须指定大小，因此 ArrayBlockingQueue 是有界队列。 </span><br><span class="line">        - LinkedBlockingQueue</span><br><span class="line">          - 是一个基于链表实现的阻塞队列，元素按照先进先出（FIFO）的顺序入队、出队。因为顶层是链表，链表是基于节点之间的指针指向来维持前后关系的，如果不指链表的大小，它默认的大小是 Integer.MAX_VALUE。这个数值太大了，因此通常称 LinkedBlockingQueue 是一个无界队列。当然如果在初始化的时候，就指定链表大小，那么它就是有界队列了。</span><br><span class="line">        - SynchronousQueue</span><br><span class="line">          - 是一个不存储元素的阻塞队列。每个插入操作必须得等到另一个线程调用了移除操作后，该线程才会返回，否则将一直阻塞。吞吐量通常要高于 LinkedBlockingQueue。</span><br><span class="line">        - PriorityBlockingQueue</span><br><span class="line">          - 是一个将元素按照优先级排序的阻塞的阻塞队列，元素的优先级越高，将会越先出队列。这是一个无界队列。</span><br><span class="line">    - threadFactory</span><br><span class="line">      - 线程池工厂，用来创建线程。通常在实际项目中，为了便于后期排查问题，在创建线程时需要为线程赋予一定的名称，通过线程池工厂，可以方便的为每一个创建的线程设置具有业务含义的名称。</span><br><span class="line">    - 拒绝策略 RejectedExecutionHandler</span><br><span class="line">      - AbortPolicy：直接丢弃任务，抛出异常，这是默认策略</span><br><span class="line">      - CallerRunsPolicy：只用调用者所在的线程来处理任务</span><br><span class="line">      - DiscardOldestPolicy：丢弃等待队列中最旧的任务，并执行当前任务</span><br><span class="line">      - DiscardPolicy：直接丢弃任务，也不抛出异常</span><br><span class="line">  - 分类</span><br><span class="line">    - FixedThreadPool</span><br><span class="line">      - 特点：固定池子中线程的个数。使用静态方法 `newFixedThreadPool()` 创建线程池的时候指定线程池个数。</span><br><span class="line">    - CachedThreadPool（弹性缓存线程池）</span><br><span class="line">      - 特点：用 `newCachedThreadPool()` 方法创建该线程池对象，创建之初里面一个线程都没有，当 execute 方法或 submit 方法向线程池提交任务时，会自动新建线程；如果线程池中有空余线程，则不会新建；这种线程池一般最多情况可以容纳几万个线程，里面的线程空余 60s 会被回收。</span><br><span class="line">    - SingleThreadPool（单线程线程池）</span><br><span class="line">      - 池中只有一个线程，如果扔 5 个任务进来，那么有 4 个任务将排队；作用是保证任务的顺序执行。</span><br><span class="line">    - ScheduledThreadpool（定时器线程池）</span><br><span class="line">      - 在给定延迟后运行命令或者定期地执行。</span><br><span class="line">    - WorkStealingPool</span><br><span class="line">      -  在 Java 8 中，引入了一种新型的线程池，作为 `newWorkStealingPool()` 来补充现有的线程池。WorkStealingPool 线程池，来维持相应的并行级别，它会通过工作窃取的方式，使得多核的 CPU 不会闲置，总会有活着的线程让 CPU 去运行。</span><br><span class="line">      -  它基于工作窃取算法，其中任务可以生成其他较小的任务，这些任务将添加到并行处理线程的队列中。如果一个线程完成了工作并且无事可做，则可以从另一线程的队列中“窃取”工作。</span><br><span class="line">      -  底层用的 ForkJoinPool 来实现的。</span><br><span class="line">    - ForkJoinPool</span><br><span class="line">      - 在 Java7 中引入。主要用来使用分治法（Divide-and-Conquer Algorithm）来解决问题。ForkJoinPool 的优势在于，可以充分利用多 cpu，多核 cpu 的优势，把一个任务拆分成多个“小任务”分发到不同的 cpu 核心上执行，执行完后再把结果收集到一起返回。</span><br><span class="line">  - 线程池的五种状态</span><br><span class="line">    - ![Java_线程池_状态转换](Java-basic-0-知识点汇总/Java_线程池_状态转换.jpg)</span><br><span class="line">    - RUNNING</span><br><span class="line">      - 状态说明：线程池处在 RUNNING 状态时，能够接收新任务，以及对已添加的任务进行处理。</span><br><span class="line">      - 状态切换：线程池的初始化状态是 RUNNING。换句话说，线程池被一旦被创建，就处于 RUNNING 状态，并且线程池中的任务数为 0！</span><br><span class="line">    - SHUTDOWN</span><br><span class="line">      - 状态说明：线程池处在 SHUTDOWN 状态时，不接收新任务，但能处理已添加的任务。</span><br><span class="line">      - 状态切换：调用线程池的 `shutdown()` 接口时，线程池由 RUNNING -&gt; SHUTDOWN。</span><br><span class="line">    - STOP</span><br><span class="line">      - 状态说明：线程池处在 STOP 状态时，不接收新任务，不处理已添加的任务，并且会中断正在处理的任务。</span><br><span class="line">      - 状态切换：调用线程池的 `shutdownNow()` 接口时，线程池由（RUNNING or SHUTDOWN） -&gt; STOP。</span><br><span class="line">    - TIDYING</span><br><span class="line">      - 状态说明：当所有的任务已终止，ctl 记录的”任务数量”为 0，线程池会变为 TIDYING 状态。当线程池变为 TIDYING 状态时，会执行钩子函数 `terminated()`。`terminated()` 在 ThreadPoolExecutor 类中是空的，若用户想在线程池变为 TIDYING 时，进行相应的处理；可以通过重载 `terminated()` 函数来实现。</span><br><span class="line">      - 状态切换：当线程池在 SHUTDOWN 状态下，阻塞队列为空并且线程池中执行的任务也为空时，就会由 SHUTDOWN -&gt; TIDYING。当线程池在 STOP 状态下，线程池中执行的任务为空时，就会由 STOP -&gt; TIDYING。</span><br><span class="line">    - TERMINATED</span><br><span class="line">      - 状态说明：线程池彻底终止，就变成 TERMINATED 状态。</span><br><span class="line">      - 状态切换：线程池处在 TIDYING 状态时，执行完 `terminated()` 之后，就会由 TIDYING -&gt; TERMINATED。</span><br><span class="line">  - 提交一个新任务到线程池时，具体的执行流程</span><br><span class="line">    1. 当我们提交任务，线程池会根据 corePoolSize 大小创建若干任务数量线程执行任务</span><br><span class="line">    2. 当任务的数量超过 corePoolSize 数量，后续的任务将会进入阻塞队列阻塞排队</span><br><span class="line">    3. 当阻塞队列也满了之后，那么将会继续创建 `(maximumPoolSize-corePoolSize)` 个数量的线程来执行任务，如果任务处理完成，`maximumPoolSize-corePoolSize` 额外创建的线程等待 keepAliveTime 之后被自动销毁</span><br><span class="line">       - **如果使用无界队列**</span><br><span class="line">         - 使用了无界队列，会直接导致最大线程数的配置失效。服务端高并发下使用无界的阻塞队列会发生 OOM，把机器打爆。LinkedBlockingQueue 默认的最大任务数量是 Integer.MAX_VALUE，非常大，近乎于可以理解为无限吧。</span><br><span class="line">    4. 如果达到 maximumPoolSize，阻塞队列还是满的状态，那么将根据不同的拒绝策略对应处理</span><br><span class="line">    - ![Java_线程池_提交任务](Java-basic-0-知识点汇总/Java_线程池_提交任务.jpg)</span><br><span class="line">  - 原理</span><br><span class="line">    - 在线程池中，使用了一个原子类 AtomicInteger 的变量来表示线程池状态和线程数量，该变量在内存中会占用 4 个字节，也就是 32bit，其中高 3 位用来表示线程池的状态，低 29 位用来表示线程的数量。</span><br><span class="line">      - 线程池的状态一共有 5 种状态，用 3bit 最多可以表示 8 种状态</span><br><span class="line">      - ![Java_线程池_AtomicInteger](Java-basic-0-知识点汇总/Java_线程池_AtomicInteger.jpg)</span><br><span class="line">  - 线程池参数设计</span><br><span class="line">    - CPU 密集型任务</span><br><span class="line">      - 这种任务消耗的主要是 CPU 资源，可以将线程数设置为 N（CPU 核心数）+1，比 CPU 核心数多出来的一个线程是为了防止线程偶发的缺页中断，或者其它原因导致的任务暂停而带来的影响。</span><br><span class="line">      - 一旦任务暂停，CPU 就会处于空闲状态，而在这种情况下多出来的一个线程就可以充分利用 CPU 的空闲时间。</span><br><span class="line">    - I/O 密集型任务</span><br><span class="line">      - 这种任务应用起来，系统会用大部分的时间来处理 I/O 交互，而线程在处理 I/O 的时间段内不会占用 CPU 来处理，这时就可以将 CPU 交出给其它线程使用。因此在 I/O 密集型任务的应用中，我们可以多配置一些线程，具体的计算方法是 2N。</span><br><span class="line">        - **IO 是否会一直占用CPU？**</span><br><span class="line">          - IO 所需要的 CPU 资源非常少。大部分工作是分派给 DMA（Direct Memory Access）完成的。</span><br><span class="line">          - 流程</span><br><span class="line">            - CPU 计算文件地址 ——&gt; 委派 DMA 读取文件 ——&gt; DMA 接管总线 ——&gt; CPU 的 A 进程阻塞，挂起——&gt; CPU 切换到 B 进程 ——&gt; DMA 读完文件后通知 CPU（一个中断异常）——&gt; CPU 切换回 A 进程操作文件</span><br><span class="line">  - 相关问题</span><br><span class="line">    - **为什么是先判断任务队列有没有满，再判断线程数有没有超过最大线程数？而不是先判断最大线程数，再判断任务队列是否已满？**</span><br><span class="line">      - 案和具体的源码实现有关。因为当需要创建线程的时候，都会调用 `addWorker()` 方法，在 `addWorker()` 的后半部分的逻辑中，会调用 `mainLock.lock()` 方法来获取全局锁，而获取锁就会造成一定的资源争抢。如果先判断最大线程数，再判断任务队列是否已满，这样就会造成线程池原理的 4 个步骤中，第 1 步判断核心线程数时要获取全局锁，第 2 步判断最大线程数时，又要获取全局锁，这样相比于先判断任务队列是否已满，再判断最大线程数，就可能会多出一次获取全局锁的过程。因此在设计线程池，为了尽可能的避免因为获取全局锁而造成资源的争抢，所以会先判断任务队列是否已满，再判断最大线程数。</span><br><span class="line">    - **LinkedBlockingQueue 的吞吐量比 ArrayBlockingQueue 的吞吐量要高。前者是基于链表实现的，后者是基于数组实现的，正常情况下，不应该是数组的性能要高于链表吗？**</span><br><span class="line">      - 因为 LinkedBlockingQueue 的读和写操作使用了两个锁，takeLock 和 putLock，读写操作不会造成资源的争抢。而 ArrayBlockingQueue 的读和写使用的是同一把锁，读写操作存在锁的竞争。因此 LinkedBlockingQueue 的吞吐量高于 ArrayBlockingQueue。</span><br><span class="line">    - **为什么要使用线程池？**</span><br><span class="line">      - 降低资源消耗。通过重复利用已创建的线程，降低线程创建和销毁造成的消耗。</span><br><span class="line">      - 提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。</span><br><span class="line">      - 增加线程的可管理型。线程是稀缺资源，使用线程池可以进行统一分配，调优和监控。</span><br><span class="line">    - **线程池为什么能维持线程不释放，随时运行各种任务？**</span><br><span class="line">      - 线程池就是用一堆包装住 Thread 的 Wroker 类的集合，在里面有条件的进行着死循环，从而可以不断接受任务来进行。</span><br><span class="line"></span><br><span class="line">### 异常</span><br><span class="line">- 基类为 Throwable</span><br><span class="line">  - 子类 Error（错误）</span><br><span class="line">    - 所有的编译时期的错误以及系统错误都是通过 Error 抛出的。这些错误表示故障发生于虚拟机自身、或者发生在虚拟机试图执行应用时，如 Java 虚拟机运行错误（Virtual MachineError）、类定义错误（NoClassDefFoundError）等。这些错误是不可查的，因为它们在应用程序的控制和处理能力之外，而且绝大多数是程序运行时不允许出现的状况。对于设计合理的应用程序来说，即使确实发生了错误，本质上也不应该试图去处理它所引起的异常状况。在 Java 中，错误通过 Error 的子类描述。</span><br><span class="line">    - 常见的 Error</span><br><span class="line">      - OutOfMemoryError</span><br><span class="line">        - 如果虚拟机在扩展栈时无法申请到足够的内存空间，则抛出 OutOfMemoryError异常。</span><br><span class="line">        - 具体情况</span><br><span class="line">          - OutOfMemoryError: PermGen space</span><br><span class="line">            - 在 JDK1.8 之前，方法区放在堆的永久带区（PermGen），方法区内存溢出则报此异常</span><br><span class="line">          - OutOfMemoryError: Metaspace</span><br><span class="line">            - JDK1.8 及以后的版本使用 Metaspace 来代替永久代，Metaspace 是方法区在 HotSpot 中的实现，它与持久代最大区别在于，Metaspace 并不在虚拟机内存中而是使用本地内存。</span><br><span class="line">      - StackOverflowError</span><br><span class="line">        - 如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出 StackOverflowError异常。</span><br><span class="line">  - 子类 Exception（异常）</span><br><span class="line">    - RuntimeException</span><br><span class="line">      - 常见的 RuntimeException</span><br><span class="line">        - NullPointerException</span><br><span class="line">        - ClassNotFoundException</span><br><span class="line">        - NumberFormatException</span><br><span class="line">        - IndexOutOfBoundsException</span><br><span class="line">        - IllegalArgumentException</span><br><span class="line">        - ClassCastException</span><br><span class="line">    - 非 RuntimeException</span><br><span class="line">      - 是 checked exception，需要在代码中处理</span><br><span class="line">- 捕获异常</span><br><span class="line">  - finally</span><br><span class="line">    - try 关键字最后可以定义 finally 代码块。 finally 块中定义的代码，总是在 try 和任何 catch 块之后、方法完成之前运行。</span><br><span class="line">    - 正常情况下，不管是否抛出或捕获异常 finally 块都会执行。</span><br><span class="line">    - 使用场景</span><br><span class="line">      - 执行关闭连接、关闭文件和释放线程的的操作。</span><br><span class="line">    - 相关问题</span><br><span class="line">      - **啥时候 finally 不会被执行？**</span><br><span class="line">        - 调用 System.exit 函数</span><br><span class="line">          - ```</span><br><span class="line">            try &#123;</span><br><span class="line">                System.out.println(&quot;Inside try&quot;);</span><br><span class="line">                System.exit(1);</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                System.out.println(&quot;Inside finally&quot;);</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure></li>
<li>调用 halt 函数<ul>
<li>```<br>try {<pre><code>System.out.println(&quot;Inside try&quot;);
Runtime.getRuntime().halt(1);
</code></pre>
} finally {<pre><code>System.out.println(&quot;Inside finally&quot;);
</code></pre>
}<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">    - 守护线程</span><br><span class="line">      - 如果守护线程刚开始执行到 finally 代码块，此时没有任何其他非守护线程，那么虚拟机将退出，此时 JVM 不会等待守护线程的 finally 代码块执行完成。</span><br><span class="line">    - try 代码块中无限循环</span><br><span class="line">- 常见陷阱</span><br><span class="line">  - 忽视异常</span><br><span class="line">    - finally 代码块包含返回语句，没有处理未捕获的异常。</span><br><span class="line">    - ```</span><br><span class="line">      try &#123;</span><br><span class="line">          System.out.println(&quot;Inside try&quot;);</span><br><span class="line">          throw new RuntimeException();</span><br><span class="line">      &#125; finally &#123;</span><br><span class="line">          System.out.println(&quot;Inside finally&quot;);</span><br><span class="line">          return &quot;from finally&quot;;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>此时，try 代码块中的 RuntimeException 会被忽略，函数返回 “from finally”字符串。</li>
</ul>
</li>
<li>覆盖其他返回语句<ul>
<li>如果 finally 代码块中存在返回语句，则 try 和 catch 代码块如果存在返回语句就会被忽略。</li>
</ul>
</li>
<li>改变 throw 或 return 行为<ul>
<li>如果再 finally 代码块中扔出异常，则 try 和 catch 中的异常扔出或者返回语句都将被忽略。</li>
<li>```<br>try {<pre><code>System.out.println(&quot;Inside try&quot;);
return &quot;from try&quot;;
</code></pre>
} finally {<pre><code>throw new RuntimeException();
</code></pre>
}<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">    - 这段代码永远都不会有返回值，总是会抛出 RuntimeException。</span><br><span class="line">- 执行顺序</span><br><span class="line">  - ```</span><br><span class="line">    try &#123;</span><br><span class="line">        return expression;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        do some work;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<ol>
<li>执行：expression，计算该表达式，结果保存在操作数栈顶；</li>
<li>执行：操作数栈顶值（expression 的结果）复制到局部变量区作为返回值；</li>
<li>执行：finally 语句块中的代码；</li>
<li>执行：将第 2 步复制到局部变量区的返回值又复制回操作数栈顶；</li>
<li>执行：return 指令，返回操作数栈顶的值；</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="JNI、JNA"><a href="#JNI、JNA" class="headerlink" title="JNI、JNA"></a>JNI、JNA</h3><ul>
<li>JNI（Java Native Interface）<ul>
<li>它允许 Java 代码和其他语言（尤其 C/C++）写的代码进行交互，只要遵守调用约定即可。</li>
<li>调用过程<ul>
<li><img src="/2019/09/04/%E8%AF%AD%E8%A8%80/Java/basic_Java/Java-basic-0-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/Java_JNI%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B.png" alt="Java_JNI调用过程"></li>
</ul>
</li>
<li>缺点<ul>
<li>调用步骤非常的多，很麻烦，使用 JNI 调用 .dll/.so 共享库都能体会到这个痛苦的过程。如果已有一个编译好的 .dll/.so 文件，如果使用 JNI 技术调用，我们首先需要使用 C 语言另外写一个 .dll/.so 共享库，使用 SUN 规定的数据结构替代 C 语言的数据结构，调用已有的 dll/so 中公布的函数。然后再在 Java 中载入这个库 dll/so，最后编写 Java native 函数作为链接库中函数的代理。经过这些繁琐的步骤才能在 Java 中调用本地代码。因此，很少有 Java 程序员愿意编写调用 dll/.so 库中原生函数的 java 程序。</li>
</ul>
</li>
</ul>
</li>
<li>JNA（Java Native Access）<ul>
<li>是一个开源的 Java 框架，是 SUN 公司主导开发的，建立在经典的 JNI 的基础之上的一个框架。</li>
<li>JNA 大大简化了调用本地方法的过程，使用很方便，基本上不需要脱离 Java 环境就可以完成。</li>
<li>调用过程<ul>
<li><img src="/2019/09/04/%E8%AF%AD%E8%A8%80/Java/basic_Java/Java-basic-0-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/Java_JNA%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B.png" alt="Java_JNA调用过程"></li>
</ul>
</li>
</ul>
</li>
<li>相关问题<ul>
<li><strong>JNA 能完全替代 JNI 吗？</strong><ul>
<li>JNA 是不能完全替代 JNI 的，因为有些需求还是必须求助于 JNI。</li>
<li>使用 JNI 技术，不仅可以实现 Java 访问 C 函数，也可以实现 C 语言调用 Java 代码。</li>
<li>而 JNA 只能实现 Java 访问 C 函数，作为一个 Java 框架，自然不能实现 C 语言调用 Java 代码。此时，你还是需要使用 JNI 技术。</li>
<li>JNI 是 JNA 的基础，是 Java 和 C 互操作的技术基础。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="Java-与-C-的区别"><a href="#Java-与-C-的区别" class="headerlink" title="Java 与 C++ 的区别"></a>Java 与 C++ 的区别</h2><ul>
<li>Java 是纯粹的面向对象语言，所有的对象都继承自 java.lang.Object，C++ 为了兼容 C 即支持面向对象也支持面向过程。</li>
<li>Java 通过虚拟机从而实现跨平台特性，但是 C++ 依赖于特定的平台。</li>
<li>Java 没有指针，它的引用可以理解为安全指针，而 C++ 具有和 C 一样的指针。</li>
<li>Java 支持自动垃圾回收，而 C++ 需要手动回收。</li>
<li>Java 不支持多重继承，只能通过实现多个接口来达到相同目的，而 C++ 支持多重继承。</li>
<li>Java 不支持操作符重载，虽然可以对两个 String 对象执行加法运算，但是这是语言内置支持的操作，不属于操作符重载，而 C++ 可以。</li>
<li>Java 的 goto 是保留字，但是不可用，C++ 可以使用 goto。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wetts.github.io/2019/09/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%81%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95-0-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Zhang Wetts">
      <meta itemprop="description" content="Stay Hungry, Stay Foolish. <br><br><p style="font-size:8px;">[build by hexo/next/gitalk/hexo-generator-search/LaTeX]</p>">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wetts's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/09/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%81%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95-0-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/" class="post-title-link" itemprop="url">算法-0-知识点汇总.md</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-09-04 23:24:59" itemprop="dateCreated datePublished" datetime="2019-09-04T23:24:59+08:00">2019-09-04</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><h2 id="五大常用算法"><a href="#五大常用算法" class="headerlink" title="五大常用算法"></a>五大常用算法</h2><h3 id="分治算法"><a href="#分治算法" class="headerlink" title="分治算法"></a>分治算法</h3><ul>
<li>基本概念：把一个复杂的问题分成两个或更多的相同或相似的子问题，再把子问题分成更小的子问题……直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。</li>
<li>运用：排序算法（快速排序，归并排序）、傅立叶变换（快速傅立叶变换）、二分搜索、大整数乘法、Strassen 矩阵乘法、棋盘覆盖、线性时间选择、最接近点对问题、循环赛日程表、汉诺塔……</li>
<li>分治法所能解决的问题一般具有以下几个特征：</li>
</ul>
<blockquote>
<ol>
<li>该问题的规模缩小到一定的程度就可以容易地解决</li>
<li>该问题可以分解为若干个规模较小的相同问题，即该问题具有最优子结构性质。</li>
<li>利用该问题分解出的子问题的解可以合并为该问题的解；</li>
<li>该问题所分解出的各个子问题是相互独立的，即子问题之间不包含公共的子子问题。  </li>
</ol>
<p><em><strong>说明：第一条特征是绝大多数问题都可以满足的，因为问题的计算复杂性一般是随着问题规模的增加而增加；<br>第二条特征是应用分治法的前提它也是大多数问题可以满足的，此特征反映了递归思想的应用；<br>第三条特征是关键，能否利用分治法完全取决于问题是否具有第三条特征，如果具备了第一条和第二条特征，而不具备第三条特征，则可以考虑用贪心法或动态规划法。<br>第四条特征涉及到分治法的效率，如果各子问题是不独立的则分治法要做许多不必要的工作，重复地解公共的子问题，此时虽然可用分治法，但一般用动态规划法较好。</strong></em></p>
</blockquote>
<ul>
<li>分治法在每一层递归上都有三个步骤：</li>
</ul>
<blockquote>
<ol>
<li>分解：将原问题分解为若干个规模较小，相互独立，与原问题形式相同的子问题；</li>
<li>解决：若子问题规模较小而容易被解决则直接解，否则递归地解各个子问题</li>
<li>合并：将各个子问题的解合并为原问题的解。</li>
</ol>
</blockquote>
<h3 id="动态归纳"><a href="#动态归纳" class="headerlink" title="动态归纳"></a>动态归纳</h3><ul>
<li>基本概念：每次决策依赖于当前状态，又随即引起状态的转移。一个决策序列就是在变化的状态中产生出来的，所以，这种多阶段最优化决策解决问题的过程就称为动态规划。</li>
<li>与分治法之间的区别：适合于用动态规划法求解的问题，经分解后得到的子问题往往不是互相独立的（即下一个子阶段的求解是建立在上一个子阶段的解的基础上，进行进一步的求解）。</li>
<li>能采用动态规划求解的问题的一般要具有 3 个性质：</li>
</ul>
<blockquote>
<ol>
<li>最优化原理：如果问题的最优解所包含的子问题的解也是最优的，就称该问题具有最优子结构，即满足最优化原理。</li>
<li>无后效性：即某阶段状态一旦确定，就不受这个状态以后决策的影响。也就是说，某状态以后的过程不会影响以前的状态，只与当前状态有关。</li>
<li>有重叠子问题：即子问题之间是不独立的，一个子问题在下一阶段决策中可能被多次使用到。（该性质并不是动态规划适用的必要条件，但是如果没有这条性质，动态规划算法同其他算法相比就不具备优势）</li>
</ol>
</blockquote>
<ul>
<li>动态规划的设计都有着一定的模式，一般要经历以下几个步骤：</li>
</ul>
<blockquote>
<ol>
<li>划分阶段：按照问题的时间或空间特征，把问题分为若干个阶段。在划分阶段时，注意划分后的阶段一定要是有序的或者是可排序的，否则问题就无法求解。</li>
<li>确定状态和状态变量：将问题发展到各个阶段时所处于的各种客观情况用不同的状态表示出来。当然，状态的选择要满足无后效性。</li>
<li>确定决策并写出状态转移方程：因为决策和状态转移有着天然的联系，状态转移就是根据上一阶段的状态和决策来导出本阶段的状态。所以如果确定了决策，状态转移方程也就可写出。但事实上常常是反过来做，根据相邻两个阶段的状态之间的关系来确定决策方法和状态转移方程。</li>
<li>寻找边界条件：给出的状态转移方程是一个递推式，需要一个递推的终止条件或边界条件。</li>
</ol>
</blockquote>
<h3 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h3><ul>
<li>基本概念：在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，他所做出的仅是在某种意义上的局部最优解。</li>
<li>运用：Prim算法、Kruskal算法（都是求最小生成树的）</li>
<li>基本思路：将问题分解为若干个小问题，逐渐求得各个子问题的局部最优解，最后合并为原来问题的解</li>
<li>贪婪算法可解决的问题通常大部分都有如下的特性：</li>
</ul>
<blockquote>
<ol>
<li>随着算法的进行，将积累起其它两个集合：一个包含已经被考虑过并被选出的候选对象，另一个包含已经被考虑过但被丢弃的候选对象。</li>
<li>有一个函数来检查一个候选对象的集合是否提供了问题的解答。该函数不考虑此时的解决方法是否最优。</li>
<li>还有一个函数检查是否一个候选对象的集合是可行的，也即是否可能往该集合上添加更多的候选对象以获得一个解。和上一个函数一样，此时不考虑解决方法的最优性。</li>
<li>选择函数可以指出哪一个剩余的候选对象最有希望构成问题的解。</li>
<li>最后，目标函数给出解的值。</li>
<li>为了解决问题，需要寻找一个构成解的候选对象集合，它可以优化目标函数，贪婪算法一步一步的进行。起初，算法选出的候选对象的集合为空。接下来的每一步中，根据选择函数，算法从剩余候选对象中选出最有希望构成解的对象。如果集合中加上该对象后不可行，那么该对象就被丢弃并不再考虑；否则就加到集合里。每一次都扩充集合，并检查该集合是否构成解。如果贪婪算法正确工作，那么找到的第一个解通常是最优的。</li>
</ol>
</blockquote>
<ul>
<li>贪心算法的实现框架</li>
</ul>
<blockquote>
<p>从问题的某一初始解出发；<br>while （能朝给定总目标前进一步）<br>{<br>利用可行的决策，求出可行解的一个解元素；<br>}<br>由所有解元素组合成问题的一个可行解；</p>
</blockquote>
<h3 id="回溯算法"><a href="#回溯算法" class="headerlink" title="回溯算法"></a>回溯算法</h3><ul>
<li>基本概念：回溯算法实际上一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就“回溯”返回，尝试别的路径。</li>
</ul>
<h3 id="分支限界"><a href="#分支限界" class="headerlink" title="分支限界"></a>分支限界</h3><ul>
<li>基本概念：类似于回溯法，也是一种在问题的解空间树T上搜索问题解的算法。</li>
<li>与回溯算法的区别：分支限界法与回溯法的求解目标不同。回溯法的求解目标是找出T中满足约束条件的所有解，而分支限界法的求解目标则是找出满足约束条件的一个解，或是在满足约束条件的解中找出使某一目标函数值达到极大或极小的解，即在某种意义下的最优解。</li>
</ul>
<h2 id="加密算法"><a href="#加密算法" class="headerlink" title="加密算法"></a>加密算法</h2><ul>
<li>加密和解密<ul>
<li>加密<ul>
<li>数据加密的基本过程，就是对原来为明文的文件或数据按某种算法进行处理，使其成为不可读的一段代码，通常称为“密文”。通过这样的途径，来达到保护数据不被 非法人窃取、阅读的目的。</li>
</ul>
</li>
<li>解密<ul>
<li>加密的逆过程为解密，即将该编码信息转化为其原来数据的过程。</li>
</ul>
</li>
</ul>
</li>
<li>加密方式<ul>
<li>对称加密算法<ul>
<li>的加密与解密<strong>密钥相同</strong>，又称为共享密钥加密算法。</li>
<li>流程<ul>
<li>数据加密过程：在对称加密算法中，数据发送方将明文（原始数据）和加密密钥一起经过特殊加密处理，生成复杂的加密密文进行发送。</li>
<li>数据解密过程：数据接收方收到密文后，若想读取原数据，则需要使用加密使用的密钥及相同算法的 逆算法对加密的密文进行解密，才能使其恢复成可读明文。</li>
</ul>
</li>
<li>常见算法<ul>
<li>DES 算法<ul>
<li>DES 加密算法是一种<strong>分组密码</strong>，以 64 位为分组对数据加密，它的密钥长度是 56 位，加密解密用同一算法。</li>
<li>DES 加密算法是对密钥进行保密，而公开算法，包括加密和解密算法。这样，只有掌握了和发送方相同密钥的人才能解读由 DES 加密算法加密的密文数据。因此，破译 DES 加密算法实际上就是搜索密钥的编码。对于 56 位长度的密钥来说，如果用穷举法来进行搜索的话，其运算次数为 $2^56$ 次。</li>
</ul>
</li>
<li>3DES 算法<ul>
<li>是基于 DES 的对称算法，对一块数据用<strong>三个不同的密钥</strong>进行三次加密，强度更高。</li>
</ul>
</li>
<li>AES 算法<ul>
<li>AES 加密算法是密码学中的高级加密标准，该加密算法采用<strong>对称分组密码体制</strong>，密钥长度的最少支持为 128 位、 192 位、256 位，分组长度 128 位，算法应易于各种硬件和软件实现。这种加密算法是美国联邦政府采用的区块加密标准。</li>
<li>AES 本身就是为了取代 DES 的，AES 具有更好的安全性、效率和灵活性。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>非对称加密算法<ul>
<li>的加密密钥与解密<strong>密钥不同</strong>，又称为公开密钥加密算法。</li>
<li>需要两个密钥，一个称为公开密钥（public key），即公钥，另一个称为私有密钥（private key），即私钥。</li>
<li>流程<ul>
<li>如果使用公钥对数据进行加密，只有用对应的私钥才能进行解密。</li>
<li>如果使用私钥对数据进行加密，只有用对应的公钥才能进行解密。</li>
</ul>
</li>
<li>常见算法<ul>
<li>RSA 算法<ul>
<li>RSA 加密算法是目前最有影响力的公钥加密算法，并且被普遍认为是目前最优秀的公钥方案之一。RSA 是第一个能同时用于加密和数字签名的算法，它能够抵抗到目前为止已知的所有密码攻击，已被 ISO 推荐为公钥数据加密标准。</li>
<li>RSA 加密算法基于一个十分简单的数论事实：将两个大素数相乘十分容易，但想要对其乘积进行因式分解却极其困难，因此可以将乘积公开作为加密密钥。</li>
<li>原理<ul>
<li>例子<ul>
<li>假如原文是 123</li>
<li>$123*13=1599$，我取后 3 位即 599 作为密文，然后取 13 作为加密密钥，关键来了，如果要对 599 进行解密，按照以往的思路，是不是要做除法？但是你的密文是 599，你并不知道 1599 这个完整的信息，所以不能直接做除法，那怎么办呢？</li>
<li>$599*77=46123$，然后我取 46123 的后 3 位，其中 77 是解密密钥</li>
<li>那么上面的这个加密和解密用的都是乘法，加密解密不是互逆的运算，这就是非对称。</li>
<li>那么这个 13 和 77 为什么是这两个数字呢？其实 $13*77=1001$，任何三位正整数 abc 乘以 1001 结果都是 abcabc, 所以才能保证原文的正确还原</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>ECC 算法<ul>
<li>ECC 也是一种非对称加密算法，主要优势是在某些情况下，它比其他的方法使用更小的密钥，比如 RSA 加密算法，提供相当的或更高等级的安全级别。不过一个缺点是加密和解密操作的实现比其他机制时间长（相比 RSA 算法，该算法对 CPU 消耗严重）。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>不需要密钥的散列算法<ul>
<li>常见算法<ul>
<li>MD5 算法<ul>
<li>MD5 用的是哈希函数，它的典型应用是对一段信息产生信息摘要，以防止被篡改。严格来说，MD5 不是一种加密算法而是摘要算法。无论是多长的输入，MD5 都会输出长度为 128bits 的一个串（通常用 16 进制表示为 32 个字符）。</li>
</ul>
</li>
<li>SHA1 算法<ul>
<li>SHA1 是和 MD5 一样流行的消息摘要算法，然而 SHA1 比 MD5 的 安全性更强。对于长度小于 $2^64$ 位的消息，SHA1 会产生一个 160 位的消息摘要。基于 MD5、SHA1 的信息摘要特性以及不可逆（一般而言），可以被应用在检查文件完整性以及数字签名等场景。</li>
</ul>
</li>
<li>HMAC 算法<ul>
<li>HMAC 是密钥相关的哈希运算消息认证码（Hash-based Message Authentication Code），HMAC 运算利用哈希算法（MD5、SHA1 等），以一个密钥和一个消息为输入，生成一个消息摘要作为输出。</li>
<li>HMAC 发送方 和 接收方都有的 key 进行计算，而没有这把 key 的第三方，则是无法计算出正确的散列值的，这样就可以防止数据被篡改。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>混合加密<ul>
<li>由于以上加密算法都有各自的缺点（RSA 加密速度慢、AES 密钥存储问题、MD5 加密不可逆），因此实际应用时常将几种加密算法混合使用。</li>
<li>常见算法<ul>
<li>RSA + AES<ul>
<li>采用 RSA 加密 AES 的密钥，采用 AES 对数据进行加密，这样集成了两种加密算法的优点，既保证了数据加密的速度，又实现了安全方便的密钥管理。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>其他<ul>
<li>Base64<ul>
<li>Base64 编码之所以称为 Base64，是因为其使用 64 个字符来对任意数据进行编码，同理有 Base32、Base16 编码。</li>
<li>标准 Base64 编码使用的 64 个字符为：<ul>
<li><img src="/2019/09/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%81%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95-0-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/Base64_%E5%9F%BA%E7%A1%80%E5%AD%97%E7%AC%A6.jpg" alt="Base64_基础字符"></li>
<li>这 64 个字符是各种字符编码（比如 ASCII 编码）所使用字符的子集，基本，并且可打印。唯一有点特殊的是最后两个字符，因对最后两个字符的选择不同，Base64 编码又有很多变种，比如 Base64 URL 编码。</li>
</ul>
</li>
<li>原理<ul>
<li>Base64 编码本质上是一种将二进制数据转成文本数据的方案。对于非二进制数据，是先将其转换成二进制形式，然后每连续 6 比特（$2^6=64$）计算其十进制值，根据该值在上面的索引表中找到对应的字符，最终得到一个文本字符串。</li>
</ul>
</li>
<li>Base64 编码是每 3 个原始字符编码成 4 个字符，如果原始字符串长度不能被 3 整除，那怎么办？使用 0 值来补充原始字符串。<ul>
<li><img src="/2019/09/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%81%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95-0-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/Base64_%E7%BC%96%E7%A0%81%E4%BE%8B%E5%AD%90.jpg" alt="Base64_编码例子"><ul>
<li>最后 2 个零值只是为了 Base64 编码而补充的，在原始字符中并没有对应的字符，那么 Base64 编码结果中的最后两个字符 AA 实际不带有效信息，所以需要特殊处理，以免解码错误。</li>
</ul>
</li>
<li>标准 Base64 编码通常用 = 字符来替换最后的 A，即编码结果为 SGVsbG8hIQ==。因为 = 字符并不在 Base64 编码索引表中，其意义在于结束符号，在 Base64 解码时遇到 = 时即可知道一个 Base64 编码字符串结束。</li>
<li>解码是对编码的逆向操作，但注意一点：对于最后的两个 = 字符，转换成两个 A 字符，再转成对应的两个 6 比特二进制0值，接着转成原始字符之前，需要将最后的两个 6 比特二进制 0 值丢弃，因为它们实际上不携带有效信息。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h2><ul>
<li>分类<ul>
<li>根据排序的空间来分<ul>
<li>In-place sort（内部排序）<ul>
<li>在排序过程中，所有需要排序的数都在内存，并在内存中调整它们的存储顺序，称为内排序</li>
<li>当需要对大量数据进行排序时，In-place sort 就显示出优点，因为只需要占用常数的内存</li>
<li>排序方式<ul>
<li>插入排序、选择排序、冒泡排序、堆排序、快速排序</li>
</ul>
</li>
</ul>
</li>
<li>Out-place sort（外部排序）<ul>
<li>在排序过程中，只有部分数被调入内存，并借助内存调整数在外存中的存放顺序排序方法称为外排序</li>
<li>排序方式<ul>
<li>归并排序、计数排序、基数排序、桶排序</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>根据排序的稳定性来分<ul>
<li>stable sort（稳定排序）<ul>
<li>有相等的数经过某种排序方法后，仍能保持它们在排序之前的相对次序，我们就说这种排序方法是稳定的</li>
<li>排序方式<ul>
<li>插入排序、冒泡排序、归并排序、计数排序、基数排序、桶排序</li>
</ul>
</li>
</ul>
</li>
<li>unstable sort（非稳定排序）</li>
<li>排序方式<ul>
<li>选择排序、快速排序、堆排序</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>排序算法<ul>
<li><img src="/2019/09/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%81%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95-0-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%AF%94%E8%BE%83.jpeg" alt="排序算法比较"></li>
<li>插入排序<ul>
<li>基本思路：每步将一个待排序的纪录，按其关键码值的大小插入前面已经排序的文件中适当位置上，直到全部插入完为止。<ul>
<li><img src="/2019/09/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%81%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95-0-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F.gif" alt="插入排序"></li>
</ul>
</li>
<li>时间复杂度：<ul>
<li>最优复杂度：当输入数组就是排好序的时候，复杂度为 $O(n)$，而快速排序在这种情况下会产生 $O(n^2)$ 的复杂度。</li>
<li>最差复杂度：当输入数组为倒序时，复杂度为 $O(n^2)$。</li>
</ul>
</li>
<li>插入排序包括：<ul>
<li>直接插入排序<ul>
<li>基本思路：把待排序的纪录按其关键码值的大小逐个插入到一个已经排好序的有序序列中，直到所有的纪录插入完为止，得到一个新的有序序列</li>
<li>稳定性：稳定排序</li>
</ul>
</li>
<li>二分插入排序（又称折半插入排序）<ul>
<li>将直接插入排序中寻找 A[i] 的插入位置的方法改为采用折半比较，即可得到折半插入排序算法。</li>
<li>稳定性：稳定排序</li>
<li>算法过程<ol>
<li>计算 0 ~ i-1 的中间点，用 i 索引处的元素与中间值进行比较，如果 i 索引处的元素大，说明要插入的这个元素应该在中间值和刚加入i索引之间，反之，就是在刚开始的位置到中间值的位置，这样很简单的完成了折半；</li>
<li>在相应的半个范围里面找插入的位置时，不断的用（1）步骤缩小范围，不停的折半，范围依次缩小为 1/2 1/4 1/8 …….快速的确定出第 i 个元素要插在什么地方；</li>
<li>确定位置之后，将整个序列后移，并将元素插入到相应位置。</li>
</ol>
</li>
</ul>
</li>
<li>链表插入排序</li>
</ul>
</li>
</ul>
</li>
<li>希尔排序（又称缩小增量排序）。<ul>
<li>希尔排序法又称缩小增量法。是插入排序的一种变种。</li>
<li>稳定性：不稳定</li>
<li>基本思路：把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至 1 时，整个文件恰被分成一组，算法便终止。<ul>
<li><img src="/2019/09/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%81%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95-0-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F.jpg" alt="希尔排序"></li>
</ul>
</li>
<li>时间复杂度：希尔排序的时间复杂度与增量序列的选取有关。例如希尔增量时间复杂度为 $O(n^2)$，而 Hibbard 增量的希尔排序的时间复杂度为 $O(n^{\frac{3}{2}})$，希尔排序时间复杂度的下界是 $O(n*log2n)$。</li>
<li>希尔排序没有快速排序算法快 $O(n(logn))$，因此中等大小规模表现良好，对规模非常大的数据排序不是最优选择。</li>
<li>本质上讲，希尔排序算法是直接插入排序算法的一种改进，减少了其复制的次数，速度要快很多。原因是，当n值很大时数据项每一趟排序需要的个数很少，但数据项的距离很长。当n值减小时每一趟需要和动的数据增多，此时已经接近于它们排序后的最终位置。正是这两种情况的结合才使希尔排序效率比插入排序高很多。</li>
</ul>
</li>
<li>冒泡排序<ul>
<li>基于交换排序的一种算法。</li>
<li>稳定性：稳定</li>
<li>时间复杂度：<ul>
<li>最坏运行时间：$O(n^2)$；</li>
<li>最佳运行时间：$O(n^2)$（当然，也可以进行改进使得最佳运行时间为 $O(n)$）</li>
</ul>
</li>
<li>基本思路：通过两两交换，像水中的泡泡一样，小的先冒出来，大的后冒出来。<ul>
<li><img src="/2019/09/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%81%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95-0-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F.gif" alt="冒泡排序"></li>
</ul>
</li>
</ul>
</li>
<li>选择排序<ul>
<li>稳定性：不稳定</li>
<li>时间复杂度：<ul>
<li>最好情况时间：$O(n^2)$。</li>
<li>最坏情况时间：$O(n^2)$。</li>
</ul>
</li>
<li>基本思路：每一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完。<ul>
<li><img src="/2019/09/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%81%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95-0-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F.gif" alt="选择排序"></li>
</ul>
</li>
</ul>
</li>
<li>归并排序<ul>
<li>时间复杂度：<ul>
<li>最坏情况运行时间：$O(nlogn)$。</li>
<li>最佳运行时间：$O(nlogn)$。</li>
</ul>
</li>
<li>速度仅次于快速排序</li>
<li>稳定性：稳定</li>
<li>基本思路：运用分治法思想解决排序问题<ul>
<li><img src="/2019/09/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%81%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95-0-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F.gif" alt="归并排序"></li>
</ul>
</li>
<li>算法过程<ol>
<li>申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列</li>
<li>设定两个指针，最初位置分别为两个已经排序序列的起始位置</li>
<li>比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置</li>
<li>重复步骤 3 直到某一指针超出序列尾</li>
<li>将另一序列剩下的所有元素直接复制到合并序列尾</li>
</ol>
</li>
</ul>
</li>
<li>快速排序<ul>
<li>被誉为“20世纪十大经典算法之一”。</li>
<li>时间复杂度：<ul>
<li>最坏运行时间：当输入数组已排序时，时间为 $O(n^2)$，当然可以通过随机化来改进（shuffle array 或者 randomized select pivot），使得期望运行时间为 $O(nlogn)$。</li>
<li>最佳运行时间：$O(nlogn)$。</li>
</ul>
</li>
<li>稳定性：不稳定</li>
<li>基本思路：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。<ul>
<li><img src="/2019/09/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%81%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95-0-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F.gif" alt="快速排序"></li>
</ul>
</li>
</ul>
</li>
<li>堆排序<ul>
<li>时间复杂度：<ul>
<li>最优时间：$O(nlogn)$。</li>
<li>最差时间：$O(nlogn)$。</li>
</ul>
</li>
<li>稳定性：不稳定</li>
<li>基本思路：堆排序利用了大根堆（或小根堆）堆顶记录的关键字最大（或最小）这一特征，使得在当前无序区中选取最大（或最小）关键字的记录变得简单。<ul>
<li><img src="/2019/09/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%81%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95-0-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/%E5%A0%86%E6%8E%92%E5%BA%8F.gif" alt="堆排序"></li>
</ul>
</li>
<li>堆实质上是满足如下性质的完全二叉树：树中任一非叶子结点的关键字均不大于（或不小于）其左右孩子（若存在）结点的关键字。</li>
<li>大根堆和小根堆：根结点（亦称为堆顶）的关键字是堆里所有结点关键字中最小者的堆称为小根堆，又称最小堆。根结点（亦称为堆顶）的关键字是堆里所有结点关键字中最大者，称为大根堆，又称最大堆。</li>
</ul>
</li>
<li>计数排序<ul>
<li>是一个非基于比较的排序算法</li>
<li>时间复杂度：<ul>
<li>最坏情况运行时间：$O(n+k)$。</li>
<li>最好情况运行时间：$O(n+k)$。当 $k=O(n)$ 时，计数排序时间为 $O(n)$</li>
</ul>
</li>
<li>稳定性：稳定</li>
<li>基本思路：对于给定的输入序列中的每一个元素 x，确定该序列中值小于 x 的元素的个数。一旦有了这个信息，就可以将x直接存放到最终的输出序列的正确位置上。<ul>
<li><img src="/2019/09/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%81%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95-0-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F.gif" alt="计数排序"></li>
</ul>
</li>
<li>它的优势在于在对一定范围内的整数排序时，它的复杂度为 $Ο(n+k)$（其中k是整数的范围），快于任何比较排序算法。</li>
</ul>
</li>
<li>基数排序<ul>
<li>时间复杂度：<ul>
<li>最坏情况运行时间：$O((n+k)d)$。</li>
<li>最好情况运行时间：$O((n+k)d)$。</li>
</ul>
</li>
<li>稳定性：稳定</li>
<li>基本思路：将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列。<ul>
<li><img src="/2019/09/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%81%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95-0-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F.gif" alt="基数排序"></li>
</ul>
</li>
</ul>
</li>
<li>桶排序<ul>
<li>时间复杂度：<ul>
<li>最坏情况运行时间：当分布不均匀时，全部元素都分到一个桶中，则 $O(n^2)$，当然也可以将插入排序换成堆排序、快速排序等，这样最坏情况就是 $O(nlgn)$。</li>
<li>最好情况运行时间：$O(n)$</li>
</ul>
</li>
<li>稳定性：稳定</li>
<li>基本思路：工作的原理是将阵列分到有限数量的桶子里。每个桶子再个别排序（有可能再使用别的排序算法或是以递回方式继续使用桶排序进行排序）。<ul>
<li><img src="/2019/09/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%81%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95-0-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/%E6%A1%B6%E6%8E%92%E5%BA%8F.jpg" alt="桶排序"></li>
</ul>
</li>
<li>桶排序是鸽巢排序的一种归纳结果。</li>
<li>桶排序非常快，但是同时也非常耗空间，基本上是最耗空间的一种排序算法</li>
</ul>
</li>
<li>鸽巢排序<ul>
<li>时间复杂度：<ul>
<li>最坏时间复杂度：$O(N+n)$。</li>
<li>最好时间复杂度：$O(N+n)$。</li>
</ul>
</li>
<li>基本思路：假设我们要排序的数组为 init_array，设其中最大元素为 Max。额外分配一个长度为 Max 的 int 类型数组 temp[Max]，数组中元素初始都为 0，算法开始循环地将 temp 中下标为 init_array[i] 处的元素置一个常数 a（假设为 1）；然后从 0 开始扫描数组 init_array，遇到 temp 中值为这个常数 a 的元素时，将其依次存入数组 init_array 中，此时 init_array 中存储的就是已排序的元素。</li>
<li>算法过程：<ol>
<li>对于给定的一组要排序的数组，需要初始化一个空的辅助数组（“鸟巢”）,把初始数组中的每个值作为一个 key（“阁子”）。</li>
<li>遍历初始数组，根据每个值放入辅助数组对应的“阁子”。  </li>
<li>顺序遍历辅助数组，把辅助数组“阁子”中不为空的数放回初始数组中。  </li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><ul>
<li>动态规划<ul>
<li>维特比算法<ul>
<li>维特比算法是一种动态规划算法用于寻找最有可能产生观测事件序列的-维特比路径-隐含状态序列，特别是在马尔可夫信息源上下文和隐马尔可夫模型中。</li>
<li><img src="/2019/09/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%81%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95-0-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/%E7%BB%B4%E7%89%B9%E6%AF%94%E7%AE%97%E6%B3%95.jpg" alt="维特比算法"></li>
<li><img src="/2019/09/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%81%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95-0-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/%E7%BB%B4%E7%89%B9%E6%AF%94%E7%AE%97%E6%B3%952.jpg" alt="维特比算法2"></li>
<li>步骤<ul>
<li>找到每一层每一个点的最短路径再算下一层</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><ul>
<li>深度优先（DFS）</li>
<li>广度优先（BFS）<ul>
<li><img src="/2019/09/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%81%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95-0-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/BFS(%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2).gif" alt="BFS(广度优先搜索)"></li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wetts.github.io/2019/09/01/%E5%B7%A5%E7%A8%8B/%E6%A8%A1%E5%9E%8B%E3%80%81%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84-0-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Zhang Wetts">
      <meta itemprop="description" content="Stay Hungry, Stay Foolish. <br><br><p style="font-size:8px;">[build by hexo/next/gitalk/hexo-generator-search/LaTeX]</p>">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wetts's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/09/01/%E5%B7%A5%E7%A8%8B/%E6%A8%A1%E5%9E%8B%E3%80%81%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84-0-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/" class="post-title-link" itemprop="url">系统架构-0-知识点汇总.md</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-09-01 15:15:42" itemprop="dateCreated datePublished" datetime="2019-09-01T15:15:42+08:00">2019-09-01</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/" itemprop="url" rel="index"><span itemprop="name">系统架构</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul>
<li>康威定律<ul>
<li>第一定律<ul>
<li>Communication dictates the design.<ul>
<li>组织沟通方式会通过系统设计表达出来</li>
</ul>
</li>
<li>对于复杂的，需要协作完成的系统开发，沟通是必须要持续提升的问题。</li>
<li>每个团队由5-10人组成（<code>沟通成本 = n(n-1)/2</code>），在团队内部进行频繁的、细粒度的沟通。对于团队外部，定义好接口，契约，只进行粗粒度的沟通。这样可以降低沟通成本，同时也符合高内聚，低耦合原则（代码和人员管理有些时候真是相通的）。</li>
</ul>
</li>
<li>第二定律<ul>
<li>There is never enough time to do something right, but there is always enough time to do it over.<ul>
<li>时间再多一件事情也不可能做的完美，但总有时间做完一件事情</li>
</ul>
</li>
<li>这就是我们在用 kanban 管理迭代时几乎都有一列是 BAU（Business As Usual），其中会包括一些日常修复的 Bug Story。敏捷开发中将迭代引入，做到持续交付，快速验证，迅速反馈，持续改进。</li>
</ul>
</li>
<li>第三定律<ul>
<li>There is a homomorphism from the linear graph of a system to the linear graph of its design organization.<ul>
<li>线型系统和线型组织架构间有潜在的异质同态特性</li>
</ul>
</li>
<li>大白话就是，你想要架构成为什么样，就将团队分成怎样的结构。比如前后端分离的团队，架构就是基于前后端分离。在基于微服务设计的团队里，一个很好的理念是自管理。团队内部对于自己所负责的模块高度负责，进行端对端的开发以及运维。</li>
</ul>
</li>
<li>第四定律<ul>
<li>The structures of large systems tend to disintegrate during development, qualitatively more so than with small systems.<ul>
<li>大的系统组织总是比小系统更倾向于分解</li>
</ul>
</li>
<li>合久必分，分久必合，团队以及架构都是在不断优化的。一个团队随着人员的增加，沟通以及管理成本一定会增加。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="项目架构"><a href="#项目架构" class="headerlink" title="项目架构"></a>项目架构</h2><ul>
<li>单机架构<ul>
<li>特征是整个开发围绕着数据库进行设计和开发。</li>
<li>存在的问题<ul>
<li>系统复杂：内部多个模块紧耦合，关联依赖复杂，牵一发而动全身。</li>
<li>运维困难：变更或升级的影响分析困难，任何一个小修改都可能导致单体应用整体运行出现故障。</li>
<li>无法扩展：无法拆分部署，出现性能瓶颈后往往只能够增加服务器或增加集群节点，但是 DB 问题难解决</li>
</ul>
</li>
<li>三层式的集中式架构<ul>
<li>采用面向对象的设计方法，业务逻辑分业务层、逻辑层、数据访问层，这种架构很容易某一层或者几层变得臃肿，扩展性较差， 另外摩尔定律失效， 单台机器性能有限。</li>
</ul>
</li>
</ul>
</li>
<li>SOA<ul>
<li><img src="/2019/09/01/%E5%B7%A5%E7%A8%8B/%E6%A8%A1%E5%9E%8B%E3%80%81%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84-0-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/SOA%E4%B8%8E%E5%BE%AE%E6%9C%8D%E5%8A%A1.jpg" alt="SOA与微服务"></li>
<li>提出 MicroService 概念的 Martin Fowler 说过，“我们应该把 SOA 看作微服务的超集”，也就是说微服务是 SOA 的子集。</li>
<li>SOA 的探索大概始于 2000 年（概念产生可能更早一些），大家知道当初 ERP、CRM、OA 之类的信息系统都是一套套部署起来的，不同系统往往由不同的供应商分别开发的，技术差别也很大，各个系统孤零零的，企业于是有了应用集成和数据集成的需求，SOA 就出来了，各个系统对外提供粗粒度的服务供外部系统访问，所有的服务都集中在一个 ESB 上，曾经 SOA 和 SOA 治理是信息化领域的热门话题，然而这种集成方式开发代价大、通信效率低，且有单点故障的风险， 实际上在企业中并没有得到大规模应用。</li>
<li>ESB<ul>
<li>ESB 就是一根管道，用来连接各个服务节点。ESB的存在是为了集成基于不同协议的不同服务，ESB 做了消息的转化、解释以及路由的工作，以此来让不同的服务互联互通。</li>
<li>从名称就能知道，它的概念借鉴了计算机组成原理中的通信模型——总线，所有需要和外部系统通信的系统，统统接入 ESB，岂不是完美地兼容了现有的互相隔离的异构系统，可以利用现有的系统构建一个全新的松耦合的异构的分布式系统。</li>
</ul>
</li>
<li>相关问题<ul>
<li><strong>SOA、ESB、微服务的区别和关系</strong><ul>
<li>SOA 是一种理念，它的主要特性–面向服务的分布式计算，服务间松散耦合，支持服务的封装，服务注册和自动发现，以服务契约方式定义服务交互方式。但是，SOA 并没有定义出具体的实现方式，目前有两套 SOA 理念的实现方式：中心化和去中心化，这两套架构并没有优劣之分，还是要针对企业的根本诉求。</li>
<li>SOA 中心化的实现方式就是 ESB，ESB 的根本诉求是为了解决异构系统之间的连通性，通过协议转换、消息解析、消息路由把服务提供者的数据传送到服务消费者。所以，ESB 是中心化的，很重，有一定的逻辑，但它的确可以解决一些公用逻辑的问题。</li>
<li>SOA 去中心化的实现方式的根本诉求是扩展性，实现方式就是微服务。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>微服务<ul>
<li>实现应用之间的解耦，解决单体应用扩展性的问题。</li>
<li>微服务存在的问题<ul>
<li>业务或者微服务的边界界定</li>
</ul>
</li>
<li>业务划分方式<ul>
<li>领域驱动建模（DDD）<ul>
<li>DDD 不是一种架构，而是一种架构方法论，目的就是将复杂问题领域简单化，帮助我们设计出清晰的领域和边界，可以很好的实现技术架构的演进。</li>
<li>战略设计、战术设计<ul>
<li>战略设计<ul>
<li>在某个领域，核心围绕上下文的设计</li>
<li>主要关注上下文的划分、上下文映射的设计、通用语言的定义</li>
<li>问题空间、解决空间</li>
</ul>
</li>
<li>战术设计<ul>
<li>核心关注上下文中的实体建模，定义值对象、实体等，更偏向开发细节</li>
<li>战术设计的术语<ul>
<li>实体<ul>
<li>实体是指描述了领域中唯一的且可持续变化的抽象模型，通常建模时，名词用于给概念命名，形容词用于描述这些概念，而动词则表示可以完成的操作</li>
</ul>
</li>
<li>值对象<ul>
<li>描述了领域中的一件东西，将不同的相关属性组合成了一个概念整体，当度量和描述改变时，可以用另外一个值对象予以替换，属性判等、固定不变</li>
</ul>
</li>
<li>服务<ul>
<li>标识的是在领域对象之外的操作与行为，接受用户的请求和执行某些操作</li>
</ul>
</li>
<li>聚合<ul>
<li>实体和值对象会形成聚合，每个聚合一般是在一个事物中操作，一般都有持久化操作。聚合中，根实体的生命周期决定了聚合整体的生命周期</li>
</ul>
</li>
<li>工厂（Facotry）和仓库（Repository）</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>领域服务、应用服务、实体行为<ul>
<li>职能、原则<ul>
<li>应用服务<ul>
<li>编排领域服务</li>
<li>暴露系统的全部功能</li>
<li>安全验证、持久化处理</li>
<li>轻量级、不处理业务逻辑</li>
<li>跨模块协调</li>
<li>DTO 转换、AOP、邮件短信、消息通知</li>
</ul>
</li>
<li>实体行为<ul>
<li>体现实体业务行为</li>
<li>根实体：公开接口行为、保证不变条件</li>
<li>负责协调实体和值对象按照完成业务逻辑</li>
</ul>
</li>
<li>领域服务<ul>
<li>组织业务逻辑（流程、策略、规则、完整性约束等）</li>
<li>协调方案、非必要性</li>
<li>协调领域对象的行为、无状态</li>
<li>某个动作不适合放在聚合对象上时</li>
<li>过度使用领域服务将导致贫血模型</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>特点<ul>
<li>领域模型是对具有某个边界的领域的一个抽象，反映了领域内用户业务需求的本质；领域模型是有边界的，只反应了我们在领域内所关注的部分；</li>
<li>领域模型只反映业务，和任何技术实现无关；领域模型不仅能反映领域中的一些实体概念，如货物，书本，应聘记录，地址，等；还能反映领域中的一些过程概念，如资金转账，等；</li>
<li>领域模型确保了我们的软件的业务逻辑都在一个模型中，都在一个地方；这样对提高软件的可维护性，业务可理解性以及可重用性方面都有很好的帮助；</li>
<li>领域模型能够帮助开发人员相对平滑地将领域知识转化为软件构造；</li>
<li>领域模型贯穿软件分析、设计，以及开发的整个过程；领域专家、设计人员、开发人员通过领域模型进行交流，彼此共享知识与信息；因为大家面向的都是同一个模型，所以可以防止需求走样，可以让软件设计开发人员做出来的软件真正满足需求；</li>
<li>要建立正确的领域模型并不简单，需要领域专家、设计、开发人员积极沟通共同努力，然后才能使大家对领域的认识不断深入，从而不断细化和完善领域模型；</li>
<li>为了让领域模型看的见，我们需要用一些方法来表示它；图是表达领域模型最常用的方式，但不是唯一的表达方式，代码或文字描述也能表达领域模型；</li>
<li>领域模型是整个软件的核心，是软件中最有价值和最具竞争力的部分；设计足够精良且符合业务需求的领域模型能够更快速的响应需求变化；</li>
</ul>
</li>
<li>可以通过三步来确定领域模型和微服务边界<ul>
<li><img src="/2019/09/01/%E5%B7%A5%E7%A8%8B/%E6%A8%A1%E5%9E%8B%E3%80%81%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84-0-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/DDD.jpg" alt="DDD"></li>
</ul>
<ol>
<li>在事件风暴中梳理业务过程中的用户操作、事件以及外部依赖关系等，根据这些要素梳理出领域实体等领域对象。</li>
<li>根据领域实体之间的业务关联性，将业务紧密相关的实体进行组合形成聚合，同时确定聚合中的聚合根、值对象和实体。在这个图里，聚合之间的边界是第一层边界，它们在同一个微服务实例中运行，这个边界是逻辑边界，所以用虚线表示。</li>
<li>根据业务及语义边界等因素，将一个或者多个聚合划定在一个限界上下文内，形成领域模型。在这个图里，限界上下文之间的边界是第二层边界，这一层边界可能就是未来微服务的边界，不同限界上下文内的领域逻辑被隔离在不同的微服务实例中运行，物理上相互隔离，所以是物理边界，边界之间用实线来表示。</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>IaaS<ul>
<li>基础设施即服务（IaaS：Infrastructure as a Service）</li>
<li>把计算基础（服务器、网络技术、存储和数据中心空间）作为一项服务提供给客户。它也包括提供操作系统和虚拟化技术、来管理资源。消费者通过 Internet 可以从完善的计算机基础设施获得服务。</li>
<li>优点：相对其他几种服务，它的自由度、灵活度非常的高。客户可以自行安装自己喜欢的操作系统、方便自己的数据集、需要的软件等。所以，一切东西可以自行部署。我的理解是有点像学生时代去机房上网。</li>
<li>缺点：它的维护成本比较高。使用它会导致 CPU、内存等等计算资源浪费。相关的人力资源和时间资源也会被浪费。相当于把资源分割成一个一个个性化的虚拟的电脑，它们之间互相独立。“土地”就只有这么多，分完了就没有了。而对于用户来说，必须要自行下载操作系统等等繁琐的操作。对于云端和用户来说，各种资源其实都浪费了。</li>
</ul>
</li>
<li>Paas<ul>
<li>平台即服务（PaaS：Platform as a Service）</li>
<li>PaaS 实际上是指将软件研发的平台作为一种服务，供应商提供超过基础设施的服务，一个作为软件开发和运行环境的整套解决方案，即以 SaaS 的模式提交给用户。因此，PaaS 也是 SaaS 模式的一种应用。但是，PaaS 的出现可以加快 SaaS 的发展，尤其是加快 SaaS 应用的开发速度。</li>
<li>优点：减少的搭建各种平台的损耗，为云端和用户节省了资源。</li>
<li>缺点：相对 IaaS 来说，PaaS 的自由度和灵活度比较低，不太适合专业性比较高的 IT 技术从业人员。相当于范围被限定，在特定的范围做一些事情。我的理解有点像 QQ 远程控制自己的电脑处理事情。</li>
</ul>
</li>
<li>Saas<ul>
<li>软件即服务（SaaS：Software as a Service）</li>
<li>是一种交付模式，其中应用作为一项服务托管，通过 Internet 提供给用户；帮助客户更好地管理它们的 IT 项目和服务、确保它们 IT 应用的质量和性能，监控它们的在线业务。</li>
<li>优点：方便快捷，资源利用可以非常优化。用户使用直接管理这些软件产生的数据就可以了。而使用的时候是模块化的，选择需要功能使用就行。多用户可以并行运行。</li>
<li>缺点：软件多而且杂乱、安装复杂、使用复杂、运维复杂。用户如果不是批量采购的话购买价格昂贵。<h2 id="大数据"><a href="#大数据" class="headerlink" title="大数据"></a>大数据</h2></li>
</ul>
</li>
<li>大数据的特征（4V 特征）<ul>
<li>规模性（Volume）<ul>
<li>随着信息化技术的高速发展，数据开始爆发性增长。大数据中的数据不再以几个 GB 或几个 TB 为单位来衡量，而是以 PB（1千个T）、EB（1百万个T）或 ZB（10亿个T）为计量单位。</li>
</ul>
</li>
<li>高速性（Velocity）<ul>
<li>这是大数据区分于传统数据挖掘最显著的特征。大数据与海量数据的重要区别在两方面：一方面，大数据的数据规模更大；另一方面，大数据对处理数据的响应速度有更严格的要求。实时分析而非批量分析，数据输入、处理与丢弃立刻见效，几乎无延迟。数据的增长速度和处理速度是大数据高速性的重要体现。</li>
</ul>
</li>
<li>多样性（Variety）<ul>
<li>多样性主要体现在数据来源多、数据类型多和数据之间关联性强这三个方面。</li>
</ul>
</li>
<li>价值性（Value）<ul>
<li>尽管企业拥有大量数据，但是发挥价值的仅是其中非常小的部分。大数据背后潜藏的价值巨大。由于大数据中有价值的数据所占比例很小，而大数据真正的价值体现在从大量不相关的各种类型的数据中。挖掘出对未来趋势与模式预测分析有价值的数据，并通过机器学习方法、人工智能方法或数据挖掘方法深度分析，并运用于农业、金融、医疗等各个领域，以期创造更大的价值。</li>
</ul>
</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wetts.github.io/2019/09/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C%E4%B8%8E%E9%80%9A%E4%BF%A1/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-0-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Zhang Wetts">
      <meta itemprop="description" content="Stay Hungry, Stay Foolish. <br><br><p style="font-size:8px;">[build by hexo/next/gitalk/hexo-generator-search/LaTeX]</p>">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wetts's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/09/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C%E4%B8%8E%E9%80%9A%E4%BF%A1/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-0-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/" class="post-title-link" itemprop="url">计算机网络-0-知识点汇总.md</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-09-01 15:15:42" itemprop="dateCreated datePublished" datetime="2019-09-01T15:15:42+08:00">2019-09-01</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">计算机网络</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="分层"><a href="#分层" class="headerlink" title="分层"></a>分层</h2><ul>
<li><img src="/2019/09/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C%E4%B8%8E%E9%80%9A%E4%BF%A1/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-0-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/net_1.jpg" alt="net_1"></li>
<li><img src="/2019/09/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C%E4%B8%8E%E9%80%9A%E4%BF%A1/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-0-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/net_2.gif" alt="net_2"></li>
<li><img src="/2019/09/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C%E4%B8%8E%E9%80%9A%E4%BF%A1/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-0-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%88%86%E5%B1%82.JPG" alt="网络协议分层"></li>
<li>应用层<ul>
<li>应用层<ul>
<li>DNS 域名解析协议<ul>
<li>域名解析协议是能够来将域名和 IP 地址相互映射，使人更方便地访问互联网的协议。</li>
</ul>
</li>
<li>FTP 文件传输协议<ul>
<li>FTP 协议是基于 TCP 的传输，FTP 采用双 TCP 连接方式，提供一种在服务器和客户机之间上传和下载文件的有效方式，支持授权与认证机制，提供目录列表功能。</li>
</ul>
</li>
<li>SMTP 简单邮件传输协议<ul>
<li>SMTP 简单邮件传输协议是一种提供可靠且有效的电子邮件传输的协议，它控制两个相互通信的 SMTP 进程交换信息。有以下三个阶段，连接建立、邮件传送、连接释放。</li>
</ul>
</li>
<li>HTTP 超文本传输协议<ul>
<li>HTTP 超文本传输协议是用于从万维网服务器传输超文本到本地浏览器的传送协议，它一个无状态的请求/响应协议，是因特网上应用最为广泛的一种网络传输协议，所有的 WWW 文件都必须遵守这个标准，HTTP 超文本传输协议基于 TCP/IP 通信协议来传递数据。</li>
</ul>
</li>
</ul>
</li>
<li>表示层</li>
<li>会话层</li>
</ul>
</li>
<li>传输层<ul>
<li>传输层协议为不同主机上运行的应用进程提供逻辑通信</li>
<li>传输层则负责将数据可靠地传送到相应的端口（<strong>端到端</strong>），传输层提供了主机应用程序进程之间的端到端的服务。传输层利用网络层提供的服务，并通过传输层地址提供给高层用户传输数据的通信端口，使高层用户看到的只是在两个传输实体间的一条端到端的、可由用户控制和设定的、可靠的数据通路。</li>
</ul>
</li>
<li>网络层<ul>
<li>网络层协议为不同主机提供逻辑通信。</li>
<li>网络层只是根据网络地址将源结点发出的数据包传送到目的结点（<strong>点到点</strong>），其主要任务是：通过路由选择算法，为报文或分组通过通信子网选择最适当的路径。该层控制数据链路层与传输层之间的信息转发，建立、维持和终止网络的连接。具体地说，数据链路层的数据在这一层被转换为数据包，然后通过路径选择、分段组合、顺序、进/出路由等控制，将信息从一个网络设备传送到另一个网络设备。</li>
<li>路由器的主要功能<ul>
<li>路由选择、分组转发，掌握原理</li>
</ul>
</li>
<li>动态路由算法<ul>
<li>距离向量路由算法、链路状态路由算法</li>
</ul>
</li>
<li>IP 地址<ul>
<li>IP 地址是 IP 协议提供的一种统一的地址格式，它为互联网上的每一个网络和每一台主机分配一个逻辑地址，以此来屏蔽物理地址的差异</li>
</ul>
</li>
<li>MAC 地址<ul>
<li>MAC 是地址物理地址，用来定义网络设备的位置，在 OSI 模型中，第三层网络层负责 IP 地址，第二层数据链路层则负责 MAC 地址。</li>
</ul>
</li>
</ul>
</li>
<li>网络接口层<ul>
<li>数据链路层<ul>
<li>可靠传输机制<ul>
<li>序列号、校验和、确认应答机制、超时重传、连接管理（三次握手四次挥手）、流量控制、拥塞控制</li>
</ul>
</li>
</ul>
</li>
<li>物理层<ul>
<li>物理层的几种复用<ul>
<li>频分复用、时分复用、波分复用、码分复用</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul>
<li>路由器和交换机  <ul>
<li>路由器<ul>
<li>DHCP<ul>
<li>DHCP 是动态主机设置协议的简称</li>
<li>主要有两个用途<ul>
<li>用于内部网或网络服务供应商自动分配IP地址；</li>
<li>给用户用于内部网管理员作为对所有计算机作中央管理的手段。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>区别<ul>
<li>工作层次不同<ul>
<li>交换机主要工作在数据链路层（第二层）</li>
<li>路由器工作在网络层（第三层）</li>
</ul>
</li>
<li>转发依据不同<ul>
<li>交换机转发所依据的对象时：MAC 地址。（物理地址）</li>
<li>路由转发所依据的对象是：IP 地址。（网络地址）</li>
</ul>
</li>
<li>主要功能不同<ul>
<li>交换机主要用于组建局域网。</li>
<li>路由主要功能是将由交换机组好的局域网相互连接起来，或者接入Interne。</li>
<li>交换机能做的，路由都能做。</li>
<li>交换机不能分割广播域，路由可以。</li>
<li>路由还可以提供防火墙的功能。</li>
<li>路由配置比交换机复杂。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="网络层协议"><a href="#网络层协议" class="headerlink" title="网络层协议"></a>网络层协议</h2><h3 id="ICMP"><a href="#ICMP" class="headerlink" title="ICMP"></a>ICMP</h3><ul>
<li>ICMP（Internet Control Message Protocol）Internet 控制报文协议。它是 TCP/IP 协议簇的一个子协议，用于在 IP 主机、路由器之间传递控制消息。控制消息是指网络通不通、主机是否可达、路由是否可用等网络本身的消息。这些控制消息虽然并不传输用户数据，但是对于用户数据的传递起着重要的作用。</li>
<li>ICMP 使用 IP 的基本支持，就像它是一个更高级别的协议，但是，ICMP 实际上是 IP 的一个组成部分，必须由每个 IP 模块实现。</li>
<li><strong>PING 命令是利用 ICMP 协议</strong></li>
</ul>
<h3 id="SSL-TSL"><a href="#SSL-TSL" class="headerlink" title="SSL/TSL"></a>SSL/TSL</h3><ul>
<li>SSL<ul>
<li>SSL（Secure Socket Layer 安全套接层）以及其继承者 TSL（Transport Layer Security 传输层安全）是为了网络通信安全，提供安全及数据完整性的一种安全协议。TLS 与 SSL 在传输层对网络连接进行加密。</li>
<li>SSL 协议位于 TCP/IP 协议与各种应用层协议之间，为数据通讯提供安全支持。</li>
<li>SSL 协议可分为两层：<ul>
<li>SSL 记录协议（SSL Record Protocol）<ul>
<li>它建立在可靠的传输协议（如 TCP）之上，为高层协议提供数据封装、压缩、加密等基本功能的支持。</li>
</ul>
</li>
<li>SSL 握手协议（SSL Handshake Protocol）<ul>
<li>它建立在 SSL 记录协议之上，用于在实际的数据传输开始前，通讯双方进行身份认证、协商加密算法、交换加密密钥等。</li>
</ul>
</li>
</ul>
</li>
<li><img src="/2019/09/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C%E4%B8%8E%E9%80%9A%E4%BF%A1/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-0-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/SSL_%E5%BA%94%E7%94%A8.jpg" alt="SSL_应用"></li>
</ul>
</li>
<li>TSL<ul>
<li>TLS（Transport Layer Security）传输层安全是 IETF 在 SSL3.0 基础上设计的协议，实际上相当于 SSL 的后续版本。</li>
<li>结构<ul>
<li><img src="/2019/09/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C%E4%B8%8E%E9%80%9A%E4%BF%A1/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-0-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/TSL_%E7%BB%93%E6%9E%84.jpg" alt="TSL_结构"></li>
<li>TLS主要分为两层<ul>
<li>底层的是 TLS 记录协议，主要负责使用对称密码对消息进行加密。</li>
<li>上层的是 TLS 握手协议，主要分为握手协议，密码规格变更协议和应用数据协议 4 个部分。<ul>
<li>握手协议负责在客户端和服务器端商定密码算法和共享密钥，包括证书认证，是 4 个协议中最最复杂的部分。</li>
<li>密码规格变更协议负责向通信对象传达变更密码方式的信号</li>
<li>警告协议负责在发生错误的时候将错误传达给对方</li>
<li>应用数据协议负责将 TLS 承载的应用数据传达给通信对象的协议。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="传输层协议"><a href="#传输层协议" class="headerlink" title="传输层协议"></a>传输层协议</h2><h3 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h3><ul>
<li>报文<ul>
<li>报文头部<ul>
<li><img src="/2019/09/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C%E4%B8%8E%E9%80%9A%E4%BF%A1/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-0-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/TCP%E6%8A%A5%E6%96%87%E5%A4%B4%E9%83%A8.jpeg" alt="TCP报文头部"></li>
</ul>
</li>
</ul>
</li>
<li>流程<ul>
<li><img src="/2019/09/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C%E4%B8%8E%E9%80%9A%E4%BF%A1/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-0-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/TCP.gif" alt="TCP"></li>
<li>在 TCP 中，有个 FLAGS 字段，这个字段有以下几个标识<ul>
<li>SYN<ul>
<li>表示建立连接</li>
</ul>
</li>
<li>FIN<ul>
<li>表示关闭连接</li>
</ul>
</li>
<li>ACK<ul>
<li>表示响应</li>
<li>ACK 是可能与 SYN，FIN 等同时使用的</li>
</ul>
</li>
<li>PSH<ul>
<li>表示有 DATA 数据传输</li>
</ul>
</li>
<li>RST<ul>
<li>表示连接重置</li>
</ul>
</li>
<li>URG</li>
</ul>
</li>
<li>TCP 状态表<ul>
<li><img src="/2019/09/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C%E4%B8%8E%E9%80%9A%E4%BF%A1/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-0-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/TCP%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2%E5%9B%BE.JPG" alt="TCP状态转换图"></li>
<li>CLOSED<ul>
<li>关闭状态，没有连接活动或正在进行</li>
</ul>
</li>
<li>LISTEN<ul>
<li>监听状态，服务器正在等待连接进入</li>
</ul>
</li>
<li>SYN RCVD<ul>
<li>收到一个连接请求，尚未确认</li>
</ul>
</li>
<li>SYN SENT<ul>
<li>已经发出连接请求，等待确认</li>
</ul>
</li>
<li>ESTABLISHED<ul>
<li>连接建立，正常数据传输状态</li>
</ul>
</li>
<li>FIN WAIT 1<ul>
<li>（主动关闭）已经发送关闭请求，等待确认</li>
</ul>
</li>
<li>FIN WAIT 2<ul>
<li>（主动关闭）收到对方关闭确认，等待对方关闭请求</li>
</ul>
</li>
<li>TIME WAIT<ul>
<li>完成双向关闭，等待所有分组死掉</li>
</ul>
</li>
<li>CLOSING<ul>
<li>双方同时尝试关闭，等待对方确认</li>
</ul>
</li>
<li>CLOSE WAIT<ul>
<li>（被动关闭）收到对方关闭请求，已经确认</li>
</ul>
</li>
<li>LAST ACK<ul>
<li>（被动关闭）等待最后一个关闭确认，并等待所有分组死掉</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>由<code>客户端端口+服务端端口+客户端IP+服务端IP+传输协议</code>组成的五元组可以明确的标识一条连接</li>
<li>使用 TCP 的协议：FTP（文件传输协议）、Telnet（远程登录协议）、SMTP（简单邮件传输协议）、POP3（和 SMTP 相对，用于接收邮件）、HTTP 协议等。</li>
<li>安全性<ul>
<li>初始化序列号 ISN（Initial Sequence Number）<ul>
<li>三次握手过程是建立 TCP 连接的第一步，所以这里的序列号叫初始序列号 ISN。在后续通信中的序列号都是基于 ISN 计算出来的。所以 ISN 是后续通信的基础，如果在后续的报文中检查序列号不匹配，这个报文将被认为是非法报文，做丢弃处理。</li>
<li>ISN 生成基本规则<ol>
<li>递增，直到超过最大值，再从较小的值开始。ISN 如果不是递增的，就可能因为网络延迟导致 ISN 重复，引起后续通信错乱，连接失败。</li>
<li>随机，ISN 必须是不可预测的随机数，如果 ISN 可以预测，将会引起很多安全问题。</li>
</ol>
</li>
<li><img src="/2019/09/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C%E4%B8%8E%E9%80%9A%E4%BF%A1/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-0-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/TCP_ISN.png" alt="TCP_ISN"></li>
</ul>
</li>
</ul>
</li>
<li>拆包、封包<ul>
<li>TCP 是个”流”协议，所谓流，就是没有界限的一串数据。大家可以想想河里的流水，是连成一片的，其间是没有分界线的。但一般通讯程序开发是需要定义一个个相互独立的数据包的，比如用于登陆的数据包，用于注销的数据包。</li>
<li>由于 TCP “流”的特性以及网络状况，在进行数据传输时会出现以下几种情况<ol>
<li>先接收到 data1，然后接收到 data2</li>
<li>先接收到 data1 的部分数据,然后接收到 data2 余下的部分以及 data2 的全部</li>
<li>先接收到了 data1 的全部数据和 data2 的部分数据，然后接收到了 data2 的余下的数据</li>
<li>一次性接收到了 data1 和 data2 的全部数据</li>
</ol>
<ul>
<li>2、3、4 的情况就是大家经常说的”粘包”，就需要我们把接收到的数据进行拆包，拆成一个个独立的数据包。为了拆包就必须在发送端进行封包。<ul>
<li>封包<ul>
<li>封包就是给一段数据加上包头,这样一来数据包就分为包头和包体两部分内容了。</li>
<li>包头其实上是个大小固定的结构体，其中有个结构体成员变量表示包体的长度，这是个很重要的变量，其他的结构体成员可根据需要自己定义。根据包头长度固定以及包头中含有包体长度的变量就能正确的拆分出一个完整的数据包。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>保活机制（keepAlive）<ul>
<li>保活机制是由一个保活计时器实现的。当计时器被激发，连接端将发送一个保活探测报文，另一端接收报文的同时会发送一个 ACK 作为响应。</li>
<li>相关配置<ul>
<li>保活时间：默认 7200 秒（2 小时）</li>
<li>保活时间间隔：默认 75 秒</li>
<li>保活探测数：默认 9 次</li>
</ul>
</li>
<li>过程描述<ul>
<li>连接中启动保活功能的一端，在保活时间内连接处于非活动状态，则向对方发送一个保活探测报文，如果收到响应，则重置保活计时器，如果没有收到响应报文，则经过一个保活时间间隔后再次向对方发送一个保活探测报文，如果还没有收到响应报文，则继续，直到发送次数到达保活探测数，此时，对方主机将确认为不可到达，连接被中断。</li>
</ul>
</li>
<li>TCP 保活功能工作过程中，开启该功能的一端会发现对方处于以下四种状态之一：<ul>
<li>对方主机仍在工作，并且可以到达。此时请求端将保活计时器重置。如果在计时器超时之前应用程序通过该连接传输数据，计时器再次被设定为保活时间值。</li>
<li>对方主机已经崩溃，包括已经关闭或者正在重新启动。这时对方的 TCP 将不会响应。请求端不会接收到响应报文，并在经过保活时间间隔指定的时间后超时。超时前，请求端会持续发送探测报文，一共发送保活探测数指定次数的探测报文，如果请求端没有收到任何探测报文的响应，那么它将认为对方主机已经关闭，连接也将被断开。</li>
<li>客户主机崩溃并且已重启。在这种情况下，请求端会收到一个对其保活探测报文的响应，但这个响应是一个重置报文段 RST，请求端将会断开连接。</li>
<li>对方主机仍在工作，但是由于某些原因不能到达请求端（例如网络无法传输，而且可能使用 ICMP 通知也可能不通知对方这一事实）。这种情况与状态 2 相同，因为 TCP 不能区分状态 2 与状态 4，结果是都没有收到探测报文的响应。</li>
</ul>
</li>
<li>弊端<ul>
<li>在出现短暂的网络错误的时候，保活机制会使一个好的连接断开；</li>
<li>保活机制会占用不必要的带宽；</li>
</ul>
</li>
<li>保活功能在默认情况下是关闭的。没有经过应用层的请求，Linux 系统不会提供保活功能。</li>
<li>相关问题<ul>
<li><strong>TCP 连接时，一方如何知道另一方【异常断开连接】?</strong><ul>
<li>TCP 不是轮询的协议，否则 TCP 将占用大量网络带宽。可以说 TCP 属于事件触发的协议，对等方的异常断链只能在应用层通过 <code>send()</code> 函数来判断，所以业界通常的做法是定时 send HEARTBEAD。TCP 还有个套接字 Option，设置后每隔 2 小时如果没有数据交互的话协议会自动检测。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>确保可靠性的方式：<ul>
<li>校验和<ul>
<li>计算方式<ul>
<li>在数据传输的过程中，将发送的数据段都当做一个 16 位的整数。将这些整数加起来。并且前面的进位不能丢弃，补在后面，最后取反，得到校验和。</li>
</ul>
</li>
<li>发送方：在发送数据之前计算检验和，并进行校验和的填充。</li>
<li>接收方：收到数据后，对数据以同样的方式进行计算，求出校验和，与发送方的进行比对。</li>
<li><img src="/2019/09/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C%E4%B8%8E%E9%80%9A%E4%BF%A1/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-0-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/TCP%E6%A0%A1%E9%AA%8C%E5%92%8C.png" alt="TCP校验和"></li>
<li>如果接收方比对校验和与发送方不一致，那么数据一定传输有误。但是如果接收方比对校验和与发送方一致，<strong>数据不一定传输成功</strong>。</li>
</ul>
</li>
<li>序列号、确认应答<ul>
<li>序列号<ul>
<li>TCP 传输时将每个字节的数据都进行了编号，这就是序列号。</li>
</ul>
</li>
<li>确认应答<ul>
<li>TCP 传输的过程中，每次接收方收到数据后，都会对传输方进行确认应答。也就是发送 ACK 报文。这个 ACK 报文当中带有对应的确认序列号，告诉发送方，接收到了哪些数据，下一次的数据从哪里发。</li>
</ul>
</li>
<li><img src="/2019/09/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C%E4%B8%8E%E9%80%9A%E4%BF%A1/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-0-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/TCP%E7%A1%AE%E8%AE%A4%E5%BA%94%E7%AD%94%E4%B8%8E%E5%BA%8F%E5%88%97%E5%8F%B7.png" alt="TCP确认应答与序列号"></li>
<li>序列号的作用不仅仅是应答的作用，有了序列号能够将接收到的数据根据序列号排序，并且去掉重复序列号的数据。这也是TCP传输可靠性的保证之一。</li>
</ul>
</li>
<li>超时重传<ul>
<li>发送方没有介绍到响应的ACK报文原因可能有两点：<ul>
<li>数据在传输过程中由于网络原因等直接全体丢包，接收方根本没有接收到。</li>
<li>接收方接收到了响应的数据，但是发送的ACK报文响应却由于网络原因丢包了。</li>
</ul>
</li>
<li>重传机制就是发送方在发送完数据后等待一个时间，时间到达没有接收到 ACK 报文，那么对刚才发送的数据进行重新发送。如果是刚才第一个原因，接收方收到二次重发的数据后，便进行 ACK 应答。如果是第二个原因，接收方发现接收的数据已存在（判断存在的根据就是序列号，所以上面说序列号还有去除重复数据的作用），那么直接丢弃，仍旧发送ACK应答。<ul>
<li>最大超时时间（也就是等待的时间）是动态计算的<ul>
<li>在 Linux 中（BSD Unix 和 Windows 下也是这样）超时以 500ms 为一个单位进行控制，每次判定超时重发的超时时间都是 500ms 的整数倍。重发一次后，仍未响应，那么等待 <code>2*500ms</code> 的时间后，再次重传。等待 <code>4*500ms</code> 的时间继续重传。以一个指数的形式增长。累计到一定的重传次数，TCP 就认为网络或者对端出现异常，强制关闭连接。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>连接管理<ul>
<li>握手、挥手<ul>
<li>三次握手<ul>
<li>过程描述<ul>
<li>第一次握手：客户端给服务端发一个 SYN 报文，并指明客户端的初始化序列号 ISN(c)。此时客户端处于 SYN_SEND 状态。<ul>
<li>首部的同步位 SYN=1，初始序号 seq=x，SYN=1 的报文段不能携带数据，但要消耗掉一个序号。</li>
</ul>
</li>
<li>第二次握手：服务器收到客户端的 SYN 报文之后，会以自己的 SYN 报文作为应答，并且也是指定了自己的初始化序列号 ISN(s)。同时会把客户端的 ISN + 1 作为 ACK 的值，表示自己已经收到了客户端的 SYN，此时服务器处于 SYN_REVD 的状态。<ul>
<li>在确认报文段中 SYN=1，ACK=1，确认号 ack=x+1，初始序号 seq=y。</li>
<li>SYN-ACK 重传次数<ul>
<li>服务器发送完SYN-ACK包，如果未收到客户确认包，服务器进行首次重传，等待一段时间仍未收到客户确认包，进行第二次重传。如果重传次数超过系统规定的最大重传次数，系统将该连接信息从半连接队列中删除。</li>
<li>注意，每次重传等待的时间不一定相同，一般会是指数增长，例如间隔时间为 1s，2s，4s，8s…</li>
</ul>
</li>
</ul>
</li>
<li>第三次握手：客户端收到 SYN 报文之后，会发送一个 ACK 报文，当然，也是一样把服务器的 ISN + 1 作为 ACK 的值，表示已经收到了服务端的 SYN 报文，此时客户端处于 ESTABLISHED 状态。服务器收到 ACK 报文之后，也处于 ESTABLISHED 状态，此时，双方已建立起了连接。<ul>
<li>确认报文段 ACK=1，确认号 ack=y+1，序号 seq=x+1（初始为 seq=x，第二个报文段所以要 +1），ACK 报文段可以携带数据，不携带数据则不消耗序号。</li>
</ul>
</li>
<li>发送第一个 SYN 的一端将执行主动打开（active open），接收这个 SYN 并发回下一个 SYN 的另一端执行被动打开（passive open）。</li>
<li><img src="/2019/09/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C%E4%B8%8E%E9%80%9A%E4%BF%A1/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-0-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/TCP_%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.jpg" alt="TCP_三次握手"></li>
</ul>
</li>
</ul>
</li>
<li>四次挥手<ul>
<li>过程描述<ul>
<li>第一次挥手：客户端发送一个 FIN 报文，报文中会指定一个序列号。此时客户端处于 FIN_WAIT1 状态。<ul>
<li>即发出连接释放报文段（FIN=1，序号seq=u），并停止再发送数据，主动关闭 TCP 连接，进入 FIN_WAIT1（终止等待 1）状态，等待服务端的确认。</li>
</ul>
</li>
<li>第二次挥手：服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序列号值 +1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 CLOSE_WAIT 状态。<ul>
<li>即服务端收到连接释放报文段后即发出确认报文段（ACK=1，确认号 ack=u+1，序号 seq=v），服务端进入 CLOSE_WAIT（关闭等待）状态，此时的 TCP 处于半关闭状态，客户端到服务端的连接释放。客户端收到服务端的确认后，进入 FIN_WAIT2（终止等待2）状态，等待服务端发出的连接释放报文段。</li>
</ul>
</li>
<li>第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号。此时服务端处于 LAST_ACK 的状态。<ul>
<li>即服务端没有要向客户端发出的数据，服务端发出连接释放报文段（FIN=1，ACK=1，序号seq=w，确认号 ack=u+1），服务端进入 LAST_ACK（最后确认）状态，等待客户端的确认。</li>
</ul>
</li>
<li>第四次挥手：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 +1 作为自己 ACK 报文的序列号值，此时客户端处于 TIME_WAIT 状态。需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态，服务端收到 ACK 报文之后，就处于关闭连接了，处于 CLOSED 状态。<ul>
<li>即客户端收到服务端的连接释放报文段后，对此发出确认报文段（ACK=1，seq=u+1，ack=w+1），客户端进入 TIME_WAIT（时间等待）状态。此时 TCP 未释放掉，需要经过时间等待计时器设置的时间 2MSL 后，客户端才进入 CLOSED 状态。</li>
</ul>
</li>
<li>收到一个 FIN 只意味着在这一方向上没有数据流动。客户端执行主动关闭并进入 TIME_WAIT 是正常的，服务端通常执行被动关闭，不会进入 TIME_WAIT 状态。</li>
<li><img src="/2019/09/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C%E4%B8%8E%E9%80%9A%E4%BF%A1/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-0-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/TCP_%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.jpg" alt="TCP_四次挥手"></li>
</ul>
</li>
</ul>
</li>
<li>相关问题<ul>
<li><strong>为什么要三次握手？</strong><ul>
<li>防止失效的连接请求报文段被服务端接收，从而产生错误。<ul>
<li>失效的连接请求：若客户端向服务端发送的连接请求丢失，客户端等待应答超时后就会再次发送连接请求，此时，上一个连接请求就是『失效的』。</li>
</ul>
</li>
<li>若建立连接只需两次握手，客户端并没有太大的变化，仍然需要获得服务端的应答后才进入 ESTABLISHED 状态，而服务端在收到连接请求后就进入 ESTABLISHED 状态。此时如果网络拥塞，客户端发送的连接请求迟迟到不了服务端，客户端便超时重发请求，如果服务端正确接收并确认应答，双方便开始通信，通信结束后释放连接。此时，如果那个失效的连接请求抵达了服务端，由于只有两次握手，服务端收到请求就会进入 ESTABLISHED 状态，等待发送数据或主动发送数据。但此时的客户端早已进入 CLOSED 状态，服务端将会一直等待下去，这样浪费服务端连接资源。</li>
</ul>
</li>
<li><strong>什么是半连接队列？</strong><ul>
<li>服务器第一次收到客户端的 SYN 之后，就会处于 SYN_RCVD 状态，此时双方还没有完全建立其连接，服务器会把此种状态下请求连接放在一个队列里，我们把这种队列称之为半连接队列。</li>
<li>当然还有一个全连接队列，就是已经完成三次握手，建立起连接的就会放在全连接队列中。如果队列满了就有可能会出现丢包现象。</li>
</ul>
</li>
<li><strong>为什么要四次挥手？</strong><ul>
<li>试想一下，假如现在你是客户端你想断开跟 Server 的所有连接该怎么做？第一步，你自己先停止向 Server 端发送数据，并等待 Server 的回复。但事情还没有完，虽然你自身不往 Server 发送数据了，但是因为你们之前已经建立好平等的连接了，所以此时他也有主动权向你发送数据；故 Server 端还得终止主动向你发送数据，并等待你的确认。其实，说白了就是保证双方的一个合约的完整执行！</li>
</ul>
</li>
<li><strong>为什么 TIME_WAIT 状态需要经过 2MSL（最大报文段生存时间）才能返回到 CLOSE 状态？</strong><ul>
<li>为了保证 Server 能收到 Client 的确认应答。</li>
<li>若 Client 发完确认应答后直接进入 CLOSED 状态，那么如果该应答丢失，Server 等待超时后就会重新发送连接释放请求，但此时 Client 已经关闭了，不会作出任何响应，因此 Server 永远无法正常关闭。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>流量控制与拥塞控制<ul>
<li>流量控制<ul>
<li>接收端在接收到数据后，对其进行处理。如果发送端的发送速度太快，导致接收端的结束缓冲区很快的填充满了。此时如果发送端仍旧发送数据，那么接下来发送的数据都会丢包，继而导致丢包的一系列连锁反应，超时重传呀什么的。而 TCP 根据接收端对数据的处理能力，决定发送端的发送速度，这个机制就是流量控制。</li>
<li>在 TCP 协议的报头信息当中，有一个 16 位字段的窗口大小。在介绍这个窗口大小时我们知道，窗口大小的内容实际上是接收端接收数据缓冲区的剩余大小。这个数字越大，证明接收端接收缓冲区的剩余空间越大，网络的吞吐量越大。接收端会在确认应答发送 ACK 报文时，将自己的即时窗口大小填入，并跟随 ACK 报文一起发送过去。而发送方根据 ACK 报文里的窗口大小的值的改变进而改变自己的发送速度。如果接收到窗口大小的值为 0，那么发送方将停止发送数据。并定期的向接收端发送窗口探测数据段，让接收端把窗口大小告诉发送端。</li>
<li><img src="/2019/09/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C%E4%B8%8E%E9%80%9A%E4%BF%A1/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-0-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/TCP%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6.png" alt="TCP流量控制"></li>
<li>16 位的窗口大小最大能表示 65535 个字节（64K），但是 TCP 的窗口大小最大并不是 64K。在 TCP 首部中 40 个字节的选项中还包含了一个窗口扩大因子 M，实际的窗口大小就是 16 为窗口字段的值左移 M 位。每移一位，扩大一倍。</li>
</ul>
</li>
<li>拥塞控制<ul>
<li>TCP 传输的过程中，发送端开始发送数据的时候，如果刚开始就发送大量的数据，那么就可能造成一些问题。网络可能在开始的时候就很拥堵，如果给网络中在扔出大量数据，那么这个拥堵就会加剧。拥堵的加剧就会产生大量的丢包，就对大量的超时重传，严重影响传输。</li>
<li>TCP 引入了慢启动的机制，在开始发送数据时，先发送少量的数据探路。探清当前的网络状态如何，再决定多大的速度进行传输。这时候就引入一个叫做拥塞窗口的概念。发送刚开始定义拥塞窗口为 1，每次收到 ACK 应答，拥塞窗口加 1。在发送数据之前，首先将拥塞窗口与接收端反馈的窗口大小比对，取较小的值作为实际发送的窗口。</li>
<li>拥塞窗口的增长是指数级别的。慢启动的机制只是说明在开始的时候发送的少，发送的慢，但是增长的速度是非常快的。为了控制拥塞窗口的增长，不能使拥塞窗口单纯的加倍，设置一个拥塞窗口的阈值，当拥塞窗口大小超过阈值时，不能再按照指数来增长，而是线性的增长。在慢启动开始的时候，慢启动的阈值等于窗口的最大值，一旦造成网络拥塞，发生超时重传时，慢启动的阈值会为原来的一半（这里的原来指的是发生网络拥塞时拥塞窗口的大小），同时拥塞窗口重置为 1。</li>
<li><img src="/2019/09/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C%E4%B8%8E%E9%80%9A%E4%BF%A1/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-0-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/TCP%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6.png" alt="TCP拥塞控制"></li>
<li>操作步骤<ul>
<li>慢开始：最开始发送方的拥塞窗口为 1，由小到大逐渐增大发送窗口和拥塞窗口。每经过一个传输轮次，拥塞窗口 cwnd 加倍。当 cwnd 超过慢开始门限，则使用拥塞避免算法，避免 cwnd 增长过大。</li>
<li>拥塞避免：每经过一个往返时间 RTT，cwnd 就增长1。另外在慢开始和拥塞避免的过程中，一旦发现网络拥塞，就把慢开始门限设为当前值的一半，并且重新设置 cwnd 为 1，重新慢启动。（乘法减小，加法增大）</li>
<li>快重传：接收方每次收到一个失序的报文段后就立即发出重复确认，发送方只要连续收到三个重复确认就立即重传（尽早重传未被确认的报文段）。</li>
<li>快恢复：当发送方连续收到了三个重复确认，就乘法减半（慢开始门限减半），将当前的拥塞窗口设置为慢开始门限，并且采用拥塞避免算法（连续收到了三个重复请求，说明当前网络可能没有拥塞）。</li>
<li>采用慢开始和拥塞避免算法的时候<ul>
<li>一旦 cwnd &gt; 慢开始门限，就采用拥塞避免算法，减慢增长速度</li>
<li>一旦出现丢包的情况，就重新进行慢开始，减慢增长速度</li>
</ul>
</li>
<li>采用快恢复和快重传算法的时候<ul>
<li>一旦 cwnd &gt; 慢开始门限，就采用拥塞避免算法，减慢增长速度</li>
<li>一旦发送方连续收到了三个重复确认，就采用拥塞避免算法，减慢增长速度</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>发送端实际可用的窗口：接收端通知窗口（流量控制中的发送窗口）和拥塞窗口中的较小者。</li>
</ul>
</li>
</ul>
</li>
<li>相关问题<ul>
<li><strong>滑动窗口的作用</strong>：<ul>
<li>流量控制<ul>
<li>接收端窗口大小，代表接收端缓冲区还有多少大小，从而控制发送端发送大小，达到流量控制的目的。</li>
</ul>
</li>
<li>拥塞控制<ul>
<li>拥塞控制也就是考虑当前的网络环境，动态调整窗口大小，没有发生拥塞情况，则窗口增大，拥塞了窗口减小，如此往复，最终应该接近与接收端的窗口大小。</li>
</ul>
</li>
<li>提高传输效率<ul>
<li>在确认应答机制中，对每一个发送的数据段，都要给一个 ACK 确认应答，收到 ACK 后再发送下一个数据段。这样做有一个比较大的缺点，就是性能较差。而有了滑动窗口，通信双方就不用发送一个报文后，收到此报文的确认后再发送下一个报文，而是可以连续发送多个报文，只要别超过窗口大小限制。<ul>
<li>粘包<ul>
<li>发送端为了将多个发往接收端的包，更加高效的的发给接收端，于是采用了优化算法（Nagle算法），将多次间隔较小、数据量较小的数据，合并成一个数据量大的数据块，然后进行封包。</li>
<li>产生原因<ul>
<li>发送方原因</li>
<li>接收方原因<ul>
<li>TCP 接收到数据包时，并不会马上交到应用层进行处理，或者说应用层并不会立即处理。实际上，TCP 将接收到的数据包保存在接收缓存里，然后应用程序主动从缓存读取收到的分组。这样一来，如果 TCP 接收数据包到缓存的速度大于应用程序从缓存中读取数据包的速度，多个包就会被缓存，应用程序就有可能读取到多个首尾相接粘到一起的包。</li>
</ul>
</li>
</ul>
</li>
<li>TCP 本来就是基于字节流而不是消息包的协议，按长度解析包就行。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h3><ul>
<li>UDP 是无连接的，即发送数据之前不需要建立连接，减少了开销和发送数据之前的时延。UDP 使用尽最大努力交付，即不保证可靠交付，主机不需要维持复杂的连接状态表。UDP 面向报文，发送方的 UDP 对应用程序交下来的报文，在添加首部后就向下交付 IP 层。UDP 对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。</li>
<li>Quic<ul>
<li>Quic 全称 quick udp internet connection，“快速 UDP 互联网连接”，（和英文 quick 谐音，简称“快”）是由 Google 提出的使用 udp 进行多路并发传输的协议。</li>
<li>Quic 相比现在广泛应用的 http2+tcp+tls 协议有如下优势：<ul>
<li>减少了 TCP 三次握手及 TLS 握手时间；</li>
<li>改进的拥塞控制；</li>
<li>避免队头阻塞的多路复用；</li>
<li>连接迁移；</li>
<li>前向冗余纠错。</li>
</ul>
</li>
<li><img src="/2019/09/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C%E4%B8%8E%E9%80%9A%E4%BF%A1/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-0-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/UDP_QUIC_%E7%BD%91%E7%BB%9C%E5%B1%82%E5%AF%B9%E6%AF%94%E5%9B%BE.png" alt="UDP_QUIC_网络层对比图"></li>
<li><img src="/2019/09/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C%E4%B8%8E%E9%80%9A%E4%BF%A1/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-0-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/UDP_QUIC_%E9%80%9A%E8%AE%AF%E6%97%B6%E9%97%B4%E5%AF%B9%E6%AF%94%E5%9B%BE.png" alt="UDP_QUIC_通讯时间对比图"></li>
<li>需要 QUIC 的原因<ul>
<li>问题描述<ul>
<li>协议历史悠久导致中间设备僵化；</li>
<li>依赖于操作系统的实现导致协议本身僵化；</li>
<li>建立连接的握手延迟大；</li>
<li>队头阻塞。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="应用层协议"><a href="#应用层协议" class="headerlink" title="应用层协议"></a>应用层协议</h2><h3 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h3><ul>
<li>HTTP（HyperText Transfer Protocol）: 超文本传输协议。是互联网上应用最广泛的一种网络协议。所有 www 文件都必须遵守的一个标准，是以 ASCII 码传输，建立在 TCP/IP 协议之上的应用层规范。简单点说就是一种固定的通讯规则。</li>
<li>HTTP 状态码<ul>
<li><table>
<thead>
<tr>
<th align="center"></th>
<th align="center">已定义范围</th>
<th align="center">分类</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1XX</td>
<td align="center">100-101</td>
<td align="center">信息提示</td>
</tr>
<tr>
<td align="center">2XX</td>
<td align="center">200-206</td>
<td align="center">成功</td>
</tr>
<tr>
<td align="center">3XX</td>
<td align="center">300-305</td>
<td align="center">重定向</td>
</tr>
<tr>
<td align="center">4XX</td>
<td align="center">400-415</td>
<td align="center">客户端错误</td>
</tr>
<tr>
<td align="center">5XX</td>
<td align="center">500-505</td>
<td align="center">服务器错误</td>
</tr>
</tbody></table>
</li>
<li>常见状态码：<ul>
<li>200 OK。服务器成功处理了请求（这个是我们见到最多的）</li>
<li>301/302 Moved Permanently（重定向）。请求的 URL 已移走。Response 中应该包含一个 Location URL, 说明资源现在所处的位置</li>
<li>400 Bad Request（坏请求）。告诉客户端，它发送了一个错误的请求。</li>
<li>404 Not Found。未找到资源</li>
<li>500 Internal Server Error（内部服务器错误）。服务器遇到一个错误，使其无法为请求提供服务</li>
</ul>
</li>
</ul>
</li>
<li>生命周期<ul>
<li>HTTP 的生命周期通过 Request 来界定，也就是一个 Request 一个 Response，那么在 HTTP1.0 中，这次 HTTP 请求就结束了。</li>
<li>在 HTTP1.1 中进行了改进，使得有一个 keep-alive，也就是说，在一个 HTTP 连接中，可以发送多个 Request，接收多个 Response。</li>
</ul>
</li>
<li>特点<ul>
<li>被动性：只能由客户端发起请求</li>
</ul>
</li>
<li>请求方式<ul>
<li>分类<ul>
<li>POST<ul>
<li>浏览器先发送 header，服务器响应 100 continue，浏览器再发送 data，服务器响应 200 ok（返回数据）</li>
</ul>
</li>
<li>GET<ul>
<li>请求过程<ul>
<li>浏览器会把 http header 和 data 一并发送出去，服务器响应 200（返回数据）</li>
</ul>
</li>
</ul>
</li>
<li>PUT</li>
<li>DELETE</li>
</ul>
</li>
<li>GET 和 POST 的区别<ul>
<li>get 参数通过 url 传递，post 放在 request body 中。</li>
<li>get 请求在 url 中传递的参数是有长度限制的，而 post 没有。</li>
<li>get 比 post 更不安全，因为参数直接暴露在 url 中，所以不能用来传递敏感信息。</li>
<li>get 请求只能进行 url 编码，而 post 支持多种编码方式。</li>
<li>get 请求会浏览器主动 cache。</li>
<li>get 请求参数会被完整保留在浏览历史记录里，而 post 中的参数不会被保留。</li>
<li>GET 和 POST 本质上就是 TCP 链接，并无差别。但是由于 HTTP 的规定和浏览器/服务器的限制，导致他们在应用过程中体现出一些不同。</li>
<li>GET 产生一个 TCP 数据包；POST 产生两个 TCP 数据包。</li>
</ul>
</li>
</ul>
</li>
<li>发展历史<ul>
<li><img src="/2019/09/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C%E4%B8%8E%E9%80%9A%E4%BF%A1/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-0-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/HTTP%E5%8F%91%E5%B1%95%E5%8F%B2.png" alt="HTTP发展史"></li>
<li>HTTP/0.9 版本<ul>
<li>这是最早定稿的HTTP版本，这个版本中它的内容非常地简单。<ul>
<li>首先它只有一个命令 GET。对应到现在的 GET 请求和 POST 请求，这些叫做 HTTP 的命令或者方法。</li>
<li>它没有 HEADER 等描述数据的信息。因为这个时候的请求非常简单，它需要达到的目的也非常简单，没有那么多数据格式。</li>
<li>服务器发送完内容之后，就关闭 TCP 连接。这里需要注意一点，这里的 TCP 连接和 http 请求是不一样的。http 请求和 TCP 连接不是一个概念。一个 http 请求通过 TCP 连接发送，而一个 TCP 连接里面可以发送很多个 http 请求（HTTP/0.9 不能这么做，但是 HTTP/1.1 可以这么做，而且在 HTTP/2 这方面会更大程度地优化，来提高 HTTP 协议传输的效率以及服务器的性能），所以一个 TCP 连接对应的是多个 http 请求，一个 http 请求肯定是在某一个 TCP 连接里面进行发送的。</li>
</ul>
</li>
</ul>
</li>
<li>HTTP/1.0 版本<ul>
<li>这个版本和 HTTP/1.1 差不多，在 HTTP/0.9 版本基础上进行了改进。<ul>
<li>增加了很多命令。比如：POST、PUT、HEADER 这些命令。</li>
<li>增加了 status code 和 header 相关的内容。<ul>
<li>status code 是用来描述服务器端处理某一个请求之后的状态的；</li>
<li>header 主要包含：请求和发送数据的描述以及对这部分数据进行操作的方法。</li>
</ul>
</li>
<li>增加了多字符集支持、多部分发送、权限、缓存等相关的内容。这些内容有利于更好地使用 http 请求去实现 WEB 服务。</li>
</ul>
</li>
</ul>
</li>
<li>HTTP/1.1 版本<ul>
<li>这个版本是在 HTTP/1.0 的基础上增加了一些功能来优化网络连接的过程。<ul>
<li>在这个版本支持了持久连接。在 HTTP/1.0 版本里面，一个 http 请求要发送就要先在客户端和服务器端之间创建一个 TCP 连接，创建完这个 TCP 连接之后，等服务器端返回完数据之后，这个 TCP 连接就关闭了。</li>
<li>增加了 pipeline。可以在同一个 TCP 连接里面发送多个 http 请求，就是上面说的那样。但是在 HTTP/1.1 里面，虽然是可以在同一个 TCP 连接里面发送多个 http 请求，但是服务器端对于进来的请求，是要按照顺序进行数据返回的。<ul>
<li>因此，如果前一个请求等待时间非常长，而后一个请求处理得比较快。这个时候后一个请求不能先发送，而是要等第一个请求数据全部发送完成之后，才能进行发送，即是串行的。等待的这部分时间就体现出了与并行传输性能之间的差距 <strong>【这个在HTTP/2里面得到了优化。】</strong>。</li>
</ul>
</li>
<li>增加了 HTTP 的头 host 和其他一些命令。其中比较重要的就是 host，有了 host 之后就可以在同一台服务器（物理服务器）上同时跑多个 web 服务。比如说一个 Node.js 的 web 服务，一个 Java 的 web 服务。</li>
</ul>
</li>
</ul>
</li>
<li>HTTP/2 版本<ul>
<li>所有数据都是以二进制进行传输的。在 HTTP/1.1 里面大部分的数据传输是通过字符串，所以数据的分片方式是不太一样的。在 HTTP/2 里面所有的数据都是以帧进行传输的。</li>
<li>多路复用。同一个连接里面发送多个请求时，服务器端不再需要按照顺序来返回处理后的数据了。而是可以在返回第一个请求里面数据的时候，同时返回第二个请求里面的数据。这样的并行传输能够更大限度地提高 web 应用的传输效率。</li>
<li>新增头信息压缩以及推送等功能，提高了传输效率。HTTP/2 其实主要就是改善了 HTTP/1.1 里面造成性能低下的一些问题。<ul>
<li>头信息的压缩<ul>
<li>在 HTTP/1.1 里面每一次发送请求和返回请求，很多 http 头都是必须要进行完整的发送和返回的，但是这一部分头信息里面有很多的内容比如说：Headers 字段、Content-Type、accept 等字段是以字符串的形式保存的。</li>
<li>所以占用较大的带宽量。所以 HTTP/2 里面对头信息进行了压缩，可以有效地减少带宽使用</li>
</ul>
</li>
<li>推送的功能<ul>
<li>指的是 HTTP/2 之前，只能由客户端发送数据，服务器端返回数据。客户端是主动方，服务器端永远是被动方。在 HTTP/2 里面有了”推送”的概念，也就是说服务器端可以主动向客户端发起一些数据传输。</li>
<li>例子<ul>
<li>一个 web 页面加载时会要求一些 html、css、js 等文件，css 和 js文件是以链接的形式在 html 文本里面显示的，只有通过浏览器解析了 html 里面的内容之后，才能根据链接里面包含的 URL 地址去请求对应的 css 和 js 文件。</li>
<li>在 HTTP/2 之前，这个传输过程会包含顺序问题，需要先请求到 html 的文件，通过浏览器运行解析这个 html 文件之后，才能去发送 css 的请求和 js 的请求。</li>
<li>HTTP/2 中有了推送功能之后，在请求 html 的同时，服务器端可以主动把 html 里面所引用到的 css 和 js 文件推送到客户端，这样 html、css 和 js 的发送就是并行的而不是串行的，整体的传输效率和性能就提高了不少。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>HTTP/3<ul>
<li>之前协议的问题<ul>
<li>虽然 HTTP/2 解决了很多之前旧版本的问题，但是它还是存在一个巨大的问题，虽然这个问题并不是它本身造成的，而是底层支撑的 TCP 协议的问题。<ul>
<li>因为 HTTP/2 使用了多路复用，一般来说同一域名下只需要使用一个 TCP 连接。当这个连接中出现了丢包的情况，那就会导致 HTTP/2 的表现情况反倒不如 HTTP/1 了。</li>
<li>因为在出现丢包的情况下，整个 TCP 都要开始等待重传，也就导致了后面的所有数据都被阻塞了。但是对于 HTTP/1 来说，可以开启多个 TCP 连接，出现这种情况反到只会影响其中一个连接，剩余的 TCP 连接还可以正常传输数据。</li>
<li>那么可能就会有人考虑到去修改 TCP 协议，其实这已经是一件不可能完成的任务了。因为 TCP 存在的时间实在太长，已经充斥在各种设备中，并且这个协议是由操作系统实现的，更新起来不大现实。</li>
<li>基于这个原因，Google 就更起炉灶搞了一个基于 UDP 协议的 QUIC 协议，并且使用在了 HTTP/3 上，当然 HTTP/3 之前名为 HTTP-over-QUIC，从这个名字中我们也可以发现，HTTP/3 最大的改造就是使用了 QUIC。</li>
</ul>
</li>
</ul>
</li>
<li>HTTP3 核心新功能<ul>
<li>QUIC<ul>
<li>QUIC 是基于 UDP 实现的，UDP 协议虽然效率很高，但是并不是那么的可靠。QUIC 虽然基于 UDP，但是在原本的基础上新增了很多功能，比如多路复用、0-RTT、使用 TLS1.3 加密、流量控制、有序交付、重传等等功能。<ul>
<li>多路复用<ul>
<li>虽然 HTTP/2 支持了多路复用，但是 TCP 协议终究是没有这个功能的。QUIC 原生就实现了这个功能，并且传输的单个数据流可以保证有序交付且不会影响其他的数据流，这样的技术就解决了之前 TCP 存在的问题。</li>
<li>并且 QUIC 在移动端的表现也会比 TCP 好。因为 TCP 是基于 IP 和端口去识别连接的，这种方式在多变的移动端网络环境下是很脆弱的。但是 QUIC 是通过 ID 的方式去识别一个连接，不管你网络环境如何变化，只要 ID 不变，就能迅速重连上。</li>
</ul>
</li>
<li>0-RTT<ul>
<li>通过使用类似 TCP 快速打开的技术，缓存当前会话的上下文，在下次恢复会话的时候，只需要将之前的缓存传递给服务端验证通过就可以进行传输了。</li>
</ul>
</li>
<li>纠错机制<ul>
<li>假如说这次我要发送三个包，那么协议会算出这三个包的异或值并单独发出一个校验包，也就是总共发出了四个包。</li>
<li>当出现其中的非校验包丢包的情况时，可以通过另外三个包计算出丢失的数据包的内容。</li>
<li>当然这种技术只能使用在丢失一个包的情况下，如果出现丢失多个包就不能使用纠错机制了，只能使用重传的方式了。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h3><ul>
<li>特点<ul>
<li>建立在 TCP 协议之上，服务器端的实现比较容易。</li>
<li>与 HTTP 协议有着良好的兼容性。默认端口也是 80 和 443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器。</li>
<li>数据格式比较轻量，性能开销小，通信高效。</li>
<li>可以发送文本，也可以发送二进制数据。</li>
<li>没有同源限制，客户端可以与任意服务器通信。</li>
<li>协议标识符是 ws（如果加密，则为 wss），服务器网址就是 URL。</li>
</ul>
</li>
<li>对比技术<ul>
<li>ajax 轮询<ul>
<li>让浏览器隔个几秒就发送一次请求，询问服务器是否有新信息。</li>
</ul>
</li>
<li>long poll<ul>
<li>原理跟 ajax轮询 差不多，都是采用轮询的方式，不过采取的是阻塞模型（一直打电话，没收到就不挂电话），也就是说，客户端发起连接后，如果没消息，就一直不返回 Response 给客户端。直到有消息才返回，返回完之后，客户端再次建立连接，周而复始。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="请求过程"><a href="#请求过程" class="headerlink" title="请求过程"></a>请求过程</h4><ul>
<li>网页请求过程<ol>
<li>对网址进行 DNS 域名解析，得到对应的 IP 地址<ul>
<li>DNS 域名解析采用的是递归查询的方式，过程是，先去找 DNS 缓存-&gt;缓存找不到就去找根域名服务器-&gt;根域名又会去找下一级，这样递归查找之后，找到了，给我们的 web 浏览器</li>
</ul>
</li>
<li>根据这个 IP，找到对应的服务器，发起 TCP 的三次握手</li>
<li>建立 TCP 连接后发起 HTTP 请求</li>
<li>服务器响应 HTTP 请求，浏览器得到 HTML 代码</li>
<li>关闭TCP连接<ul>
<li>一般情况下，一旦 Web 服务器向浏览器发送了请求的数据，它就要关闭 TCP 连接，但是如果浏览器或者服务器在其头信息加入了这行代码：<code>Connection:keep-alive</code>。TCP 连接在发送后将仍然保持打开状态，于是，浏览器可以继续通过相同的连接发送请求。保持连接节省了为每个请求建立新连接所需的时间，还节约了网络带宽。</li>
</ul>
</li>
<li>浏览器解析 HTML 代码，并请求 HTML 代码中的资源（如 js、css、图片等）（先得到 HTML 代码，才能去找这些资源）</li>
<li>浏览器对页面进行渲染呈现给用户</li>
</ol>
</li>
</ul>
<h3 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h3><ul>
<li><img src="/2019/09/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C%E4%B8%8E%E9%80%9A%E4%BF%A1/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-0-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/DNS%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90.png" alt="DNS域名解析"></li>
</ul>
<h2 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h2><h3 id="网络编程模型"><a href="#网络编程模型" class="headerlink" title="网络编程模型"></a>网络编程模型</h3><ul>
<li>Acceptor-Connector 模式<ul>
<li>这种模式是面向连接的 TCP/IP 协议。</li>
<li>模式思想<ul>
<li>此模式只负责连接的建立，不管有多少连接上来，这个模式都能应对。</li>
<li>至于连接建立之后如何通信，那是通信处理器的事情，与此模式不再有任何关系。</li>
<li>资源的管理总是通过调用函数的返回值来做约定的处理。不用类型如果有特殊的资源管理需求，均可以覆盖父类的方法。</li>
</ul>
</li>
</ul>
</li>
<li>Asynchronous Completion Token 模式<ul>
<li>ACT 就是应对应用程序异步调用服务操作，并处理相应的服务完成事件。</li>
<li>例子<ul>
<li>比如，通常应用程序会有调用第三方服务的需求，一般是业务线程请求都到，需要第三方资源的时候，去同步的发起第三方请求，而为了提升应用性能，需要异步的方式发起请求，但异步请求的话，等数据到达之后，此时的我方应用程序的语境以及上下文信息已经发生了变化，你没办法去处理。</li>
<li>ACT 解决的就是这个问题，采用了一个 token 的方式记录异步发送前的信息，发送给接受方，接受方回复的时候再带上这个 token，此时就能恢复业务的调用场景。</li>
</ul>
</li>
</ul>
</li>
<li>Proactor 模式<ul>
<li>Proactor 模型运用于异步 I/O 操作。</li>
</ul>
</li>
<li>Reactor 模式<ul>
<li>Reactor 模型用于同步 I/O。Reactor 模式是一种典型的事件驱动的编程模型。</li>
<li>Reactor 模型中定义的三种角色：<ul>
<li>Reactor<ul>
<li>负责监听和分配事件，将 I/O 事件分派给对应的 Handler。新的事件包含连接建立就绪、读就绪、写就绪等。</li>
</ul>
</li>
<li>Acceptor<ul>
<li>处理客户端新连接，并分派请求到处理器链中。</li>
</ul>
</li>
<li>Handler<ul>
<li>将自身与事件绑定，执行非阻塞读/写任务，完成 channel 的读入，完成处理业务逻辑后，负责将结果写出 channel。可用资源池来管理。</li>
</ul>
</li>
</ul>
</li>
<li>流程<ul>
<li>Reactor 处理请求的流程：<ul>
<li>读取操作：<ol>
<li>应用程序注册读就绪事件和相关联的事件处理器</li>
<li>事件分离器等待事件的发生</li>
<li>当发生读就绪事件的时候，事件分离器调用第一步注册的事件处理器</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wetts.github.io/2019/09/01/%E5%B7%A5%E7%A8%8B/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F-0-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Zhang Wetts">
      <meta itemprop="description" content="Stay Hungry, Stay Foolish. <br><br><p style="font-size:8px;">[build by hexo/next/gitalk/hexo-generator-search/LaTeX]</p>">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wetts's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/09/01/%E5%B7%A5%E7%A8%8B/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F-0-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/" class="post-title-link" itemprop="url">分布式-0-知识点汇总.md</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-09-01 12:10:14" itemprop="dateCreated datePublished" datetime="2019-09-01T12:10:14+08:00">2019-09-01</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/" itemprop="url" rel="index"><span itemprop="name">分布式</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h1><h2 id="基础理论"><a href="#基础理论" class="headerlink" title="基础理论"></a>基础理论</h2><ul>
<li>ACID<ul>
<li>原子性（Atomicity）<ul>
<li>原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。</li>
</ul>
</li>
<li>一致性（Consistency）<ul>
<li>一致性是指事务执行前后，数据处于一种合法的状态，这种状态是语义上的而不是语法上的。<ul>
<li><strong>那什么是合法的数据状态呢？</strong><ul>
<li>这个状态是满足预定的约束就叫做合法的状态，再通俗一点，这状态是由你自己来定义的。满足这个状态，数据就是一致的，不满足这个状态，数据就是不一致的！</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>隔离性（Isolation）<ul>
<li>事务的隔离性是多个用户并发访问数据库时，数据库为每一个用户开启的事务，不能被其他事务的操作数据所干扰，多个并发事务之间要相互隔离。</li>
</ul>
</li>
<li>持久性（Durability）<ul>
<li>持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来即使数据库发生故障也不应该对其有任何影响</li>
</ul>
</li>
</ul>
</li>
<li>CAP<ul>
<li>CAP 原则又称 CAP 定理，指的是在一个分布式系统中，Consistency（一致性）、Availability（可用性）、Partition tolerance（分区容错性），三者不可得兼。<ul>
<li>一致性（C）：在分布式系统中的所有数据备份，在同一时刻是否同样的值。（等同于所有节点访问同一份最新的数据副本）</li>
<li>可用性（A）：在集群中一部分节点故障后，集群整体是否还能响应客户端的读写请求。（对数据更新具备高可用性）</li>
<li>分区容忍性（P）：以实际效果而言，分区相当于对通信的时限要求。系统如果不能在时限内达成数据一致性，就意味着发生了分区的情况，必须就当前操作在 C 和 A 之间做出选择。</li>
</ul>
</li>
<li>“三选二”定律<ul>
<li>CAP 要解释成，当 P 发生的时候，A 和 C 只能而选一。</li>
<li>例子<ul>
<li>A 服务器 B 服务器同步数据，现在 A、B 之间网络断掉了，那么现在发来 A 一个写入请求，但是 B 却没有相关的请求，显然，如果 A 不写，保持一致性，那么我们就失去了 A 的服务，但是如果 A 写了，跟 B 的数据就不一致了，我们自然就丧失了一致性。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>BASE 理论<ul>
<li>BASE 是 Basically Available（基本可用）、Soft state（软状态）和 Eventually consistent（最终一致性）三个短语的简写，BASE 是对 CAP 中一致性和可用性权衡的结果，其来源于对大规模互联网系统分布式实践的结论，是基于 CAP 定理逐步演化而来的，其核心思想是即使无法做到强一致性（Strong consistency），但每个应用都可以根据自身的业务特点，采用适当的方式来使系统达到最终一致性（Eventual consistency）。<ul>
<li>基本可用<ul>
<li>基本可用是指分布式系统在出现不可预知故障的时候，允许损失部分可用性。</li>
<li>但请注意，这绝不等价于系统不可用，以下两个就是“基本可用”的典型例子。<ul>
<li>响应时间上的损失：正常情况下，一个在线搜索引擎需要 0.5 秒内返回给用户相应的查询结果，但由于出现异常（比如系统部分机房发生断电或断网故障），查询结果的响应时间增加到了 1~2 秒。</li>
<li>功能上的损失：正常情况下，在一个电子商务网站上进行购物，消费者几乎能够顺利地完成每一笔订单，但是在一些节日大促购物高峰的时候，由于消费者的购物行为激增，为了保护购物系统的稳定性，部分消费者可能会被引导到一个降级页面。</li>
</ul>
</li>
</ul>
</li>
<li>软状态<ul>
<li>弱状态也称为软状态，和硬状态相对，是指允许系统中的数据存在中间状态，并认为该中间状态的存在不会影响系统的整体可用性，即允许系统在不同节点的数据副本之间进行数据听不的过程存在延时。</li>
</ul>
</li>
<li>最终一致性<ul>
<li>最终一致性强调的是系统中所有的数据副本，在经过一段时间的同步后，最终能够达到一个一致的状态。因此，最终一致性的本质是需要系统保证最终数据能够达到一致，而不需要实时保证系统数据的强一致性。</li>
<li>在实际工程实践中，最终一致性分为 5 种：<ul>
<li>因果一致性（Causal consistency）<ul>
<li>如果节点 A 在更新完某个数据后通知了节点 B，那么节点 B 之后对该数据的访问和修改都是基于 A 更新后的值。于此同时，和节点 A 无因果关系的节点 C 的数据访问则没有这样的限制。</li>
</ul>
</li>
<li>读己之所写（Read your writes）<ul>
<li>节点 A 更新一个数据后，它自身总是能访问到自身更新过的最新值，而不会看到旧值。其实也算一种因果一致性。</li>
</ul>
</li>
<li>会话一致性（Session consistency）<ul>
<li>会话一致性将对系统数据的访问过程框定在了一个会话当中：系统能保证在同一个有效的会话中实现“读己之所写”的一致性，也就是说，执行更新操作之后，客户端能够在同一个会话中始终读取到该数据项的最新值。</li>
</ul>
</li>
<li>单调读一致性（Monotonic read consistency）<ul>
<li>如果一个节点从系统中读取出一个数据项的某个值后，那么系统对于该节点后续的任何数据访问都不应该返回更旧的值。</li>
</ul>
</li>
<li>单调写一致性（Monotonic write consistency）<ul>
<li>一个系统要能够保证来自同一个节点的写操作被顺序的执行。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="分布式相关问题及算法"><a href="#分布式相关问题及算法" class="headerlink" title="分布式相关问题及算法"></a>分布式相关问题及算法</h2><ul>
<li>问题<ul>
<li>拜占庭将军问题<ul>
<li>拜占庭将军问题是 Leslie Lamport（2013 年的图灵讲得住）用来为描述分布式系统一致性问题（Distributed Consensus）在论文中抽象出来一个著名的例子。</li>
<li>例子<ul>
<li>拜占庭帝国想要进攻一个强大的敌人，为此派出了 10 支军队去包围这个敌人。这个敌人虽不比拜占庭帝国，但也足以抵御 5 支常规拜占庭军队的同时袭击。这10支军队在分开的包围状态下同时攻击。他们任一支军队单独进攻都毫无胜算，除非有至少 6 支军队（一半以上）同时袭击才能攻下敌国。他们分散在敌国的四周，依靠通信兵骑马相互通信来协商进攻意向及进攻时间。困扰这些将军的问题是，他们不确定他们中是否有叛徒，叛徒可能擅自变更进攻意向或者进攻时间。在这种状态下，拜占庭将军们才能保证有多于6支军队在同一时间一起发起进攻，从而赢取战斗？</li>
<li><blockquote>
<p>拜占庭将军问题中并不去考虑通信兵是否会被截获或无法传达信息等问题，即消息传递的信道绝无问题。Lamport 已经证明了在消息可能丢失的不可靠信道上试图通过消息传递的方式达到一致性是不可能的。所以，在研究拜占庭将军问题的时候，已经假定了信道是没有问题的。</p>
</blockquote>
</li>
<li>问题分析<ul>
<li>先看在没有叛徒情况下，假如一个将军 A 提一个进攻提议（如：明日下午 1 点进攻，你愿意加入吗？）由通信兵通信分别告诉其他的将军，如果幸运中的幸运，他收到了其他6位将军以上的同意，发起进攻。如果不幸，其他的将军也在此时发出不同的进攻提议（如：明日下午 2 点、3 点进攻，你愿意加入吗？），由于时间上的差异，不同的将军收到（并认可）的进攻提议可能是不一样的，这是可能出现 A 提议有 3 个支持者，B 提议有 4 个支持者，C 提议有 2 个支持者等等。</li>
<li>再加一点复杂性，在有叛徒情况下，一个叛徒会向不同的将军发出不同的进攻提议（通知 A 明日下午 1 点进攻， 通知B明日下午 2 点进攻等等），一个叛徒也会可能同意多个进攻提议（即同意下午 1 点进攻又同意下午 2 点进攻）。<ul>
<li>叛徒发送前后不一致的进攻提议，被称为“拜占庭错误”，而能够处理拜占庭错误的这种容错性称为「Byzantine fault tolerance」，简称为 BFT。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>算法<ul>
<li>一致性算法<ul>
<li>一致性就是数据保持一致，在分布式系统中，可以理解为多个节点中数据的值是一致的。</li>
<li>具体算法<ul>
<li>强一致性<ul>
<li>说明：保证系统改变提交以后立即改变集群的状态。</li>
<li>模型：<ul>
<li>Paxos<ul>
<li>概念介绍<ul>
<li>Proposal<ul>
<li>提案，即分布式系统的修改请求，可以表示为<code>[提案编号N，提案内容value]</code></li>
</ul>
</li>
<li>Client<ul>
<li>用户，类似社会民众，负责提出建议</li>
</ul>
</li>
<li>Proposer<ul>
<li>议员，类似基层人大代表，负责帮 Client 上交提案</li>
</ul>
</li>
<li>Acceptor<ul>
<li>投票者，类似全国人大代表，负责为提案投票，不同意比自己以前接收过的提案编号要小的提案，其他提案都同意，例如 A 以前给 N 号提案表决过，那么再收到小于等于 N 号的提案时就直接拒绝了</li>
</ul>
</li>
<li>Learner<ul>
<li>提案接受者，类似记录被通过提案的记录员，负责记录提案</li>
</ul>
</li>
</ul>
</li>
<li>Basic Paxos 算法<ul>
<li>步骤<ol>
<li>Proposer 准备一个 N 号提案</li>
<li>Proposer 询问 Acceptor 中的多数派是否接收过 N 号的提案，如果都没有进入下一步，否则本提案不被考虑</li>
<li>Acceptor 开始表决，Acceptor 无条件同意从未接收过的 N 号提案，达到多数派同意后，进入下一步</li>
<li>Learner 记录提案</li>
</ol>
<ul>
<li><img src="/2019/09/01/%E5%B7%A5%E7%A8%8B/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F-0-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/BasicPaxos%E7%AE%97%E6%B3%95.jpg" alt="BasicPaxos算法"></li>
</ul>
</li>
<li>节点故障<ul>
<li>若 Proposer 故障，没关系，再从集群中选出 Proposer 即可</li>
<li>若 Acceptor 故障，表决时能达到多数派也没问题</li>
</ul>
</li>
<li>潜在问题<ul>
<li>活锁<ul>
<li>假设系统有多个 Proposer，他们不断向 Acceptor 发出提案，还没等到上一个提案达到多数派下一个提案又来了，就会导致 Acceptor 放弃当前提案转向处理下一个提案，于是所有提案都别想通过了。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Multi Paxos 算法<ul>
<li>根据 Basic Paxos 的改进：整个系统只有一个 Proposer，称之为 Leader。</li>
<li>步骤<ol>
<li>若集群中没有 Leader，则在集群中选出一个节点并声明它为第 M 任 Leader。</li>
<li>集群的 Acceptor 只表决最新的 Leader 发出的最新的提案</li>
<li>其他步骤和 Basic Paxos 相同</li>
</ol>
<ul>
<li><img src="/2019/09/01/%E5%B7%A5%E7%A8%8B/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F-0-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/MultiPaxos%E7%AE%97%E6%B3%95.jpg" alt="MultiPaxos算法"></li>
</ul>
</li>
<li>算法优化<ul>
<li>Multi Paxos 角色过多，对于计算机集群而言，可以将 Proposer、Acceptor 和 Learner 三者身份集中在一个节点上，此时只需要从集群中选出 Proposer，其他节点都是 Acceptor 和 Learner，这就是接下来要讨论的 Raft 算法。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Raft（muti-paxos）<ul>
<li>说明：Paxos 算法不容易实现，Raft 算法是对 Paxos 算法的简化和改进</li>
<li>概念介绍<ul>
<li>Leader<ul>
<li>总统节点，负责发出提案</li>
</ul>
</li>
<li>Follower<ul>
<li>追随者节点，负责同意 Leader 发出的提案</li>
</ul>
</li>
<li>Candidate<ul>
<li>候选人，负责争夺 Leader</li>
</ul>
</li>
<li><img src="/2019/09/01/%E5%B7%A5%E7%A8%8B/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F-0-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/Raft_%E6%A6%82%E5%BF%B5%E4%BB%8B%E7%BB%8D.jpg" alt="Raft_概念介绍"></li>
</ul>
</li>
<li>步骤：Raft 算法将一致性问题分解为两个的子问题，Leader 选举和状态复制<ul>
<li>Leader 选举<ul>
<li>时间被分为很多连续的随机长度的 term，term 有唯一的 id。每个 term 一开始就进行选主</li>
<li>流程<ol>
<li>每个 Follower 都持有一个定时器<ul>
<li><img src="/2019/09/01/%E5%B7%A5%E7%A8%8B/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F-0-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/Raft_Leader%E9%80%89%E4%B8%BE_1.jpg" alt="Raft_Leader选举_1"></li>
</ul>
</li>
<li>当定时器时间到了而集群中仍然没有 Leader，<strong>【批注：将自己维护的 current_term_id 加 1】</strong>Follower 将声明自己是 Candidate 并参与 Leader 选举，同时将消息发给其他节点来争取他们的投票 <strong>【批注：发送 RequestVoteRPC 消息（带上 current_term_id）】</strong>，若其他节点长时间没有响应 Candidate 将重新发送选举信息<ul>
<li><img src="/2019/09/01/%E5%B7%A5%E7%A8%8B/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F-0-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/Raft_Leader%E9%80%89%E4%B8%BE_2.jpg" alt="Raft_Leader选举_2"></li>
</ul>
</li>
<li>集群中其他节点将给 Candidate 投票<ul>
<li><img src="/2019/09/01/%E5%B7%A5%E7%A8%8B/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F-0-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/Raft_Leader%E9%80%89%E4%B8%BE_3.jpg" alt="Raft_Leader选举_3"></li>
</ul>
</li>
<li>获得多数派支持的 Candidate 将成为第 M 任 Leader（M 任是最新的任期）<ul>
<li><img src="/2019/09/01/%E5%B7%A5%E7%A8%8B/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F-0-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/Raft_Leader%E9%80%89%E4%B8%BE_4.jpg" alt="Raft_Leader选举_4"></li>
</ul>
</li>
<li>在任期内的 Leader 会不断发送心跳给其他节点证明自己还活着，其他节点受到心跳以后就清空自己的计时器并回复 Leader 的心跳。这个机制保证其他节点不会在 Leader 任期内参加 Leader 选举。<ul>
<li><img src="/2019/09/01/%E5%B7%A5%E7%A8%8B/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F-0-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/Raft_Leader%E9%80%89%E4%B8%BE_5.jpg" alt="Raft_Leader选举_5"></li>
</ul>
</li>
<li>当 Leader 节点出现故障而导致 Leader 失联，没有接收到心跳的 Follower 节点将准备成为 Candidate 进入下一轮 Leader 选举<ul>
<li><img src="/2019/09/01/%E5%B7%A5%E7%A8%8B/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F-0-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/Raft_Leader%E9%80%89%E4%B8%BE_6.jpg" alt="Raft_Leader选举_6"></li>
</ul>
</li>
<li>若出现两个 Candidate 同时选举并获得了相同的票数，那么这两个 Candidate 将随机推迟一段时间后再向其他节点发出投票请求，这保证了再次发送投票请求以后不冲突<ul>
<li><img src="/2019/09/01/%E5%B7%A5%E7%A8%8B/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F-0-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/Raft_Leader%E9%80%89%E4%B8%BE_7.jpg" alt="Raft_Leader选举_7"></li>
</ul>
</li>
</ol>
</li>
<li>过程会有三种结果<ul>
<li>自己被选成了主<ul>
<li>当收到了 majority 的投票后，状态切成 Leader，并且定期给其它的所有 server 发心跳消息（不带 log 的 AppendEntriesRPC）以告诉对方自己是 current_term_id 所标识的 term 的 leader。每个 term 最多只有一个 leader，term id 作为 logical clock，在每个 RPC 消息中都会带上，用于检测过期的消息。当一个 server 收到的 RPC 消息中的 rpc_term_id 比本地的 current_term_id 更大时，就更新 current_term_id 为 rpc_term_id，并且如果当前 state 为 leader 或者 candidate 时，将自己的状态切成 follower。如果 rpc_term_id 比本地的 current_term_id 更小，则拒绝这个 RPC 消息。</li>
</ul>
</li>
<li>别人成为了主<ul>
<li>当 Candidator 在等待投票的过程中，收到了大于或者等于本地的 current_term_id 的声明对方是 leader 的 AppendEntriesRPC 时，则将自己的 state 切成 follower，并且更新本地的 current_term_id。</li>
</ul>
</li>
<li>没有选出主<ul>
<li>当投票被瓜分，没有任何一个 candidate 收到了 majority 的 vote 时，没有 leader 被选出。这种情况下，每个 candidate 等待的投票的过程就超时了，接着 candidates 都会将本地的 current_term_id 再加 1，发起 RequestVoteRPC 进行新一轮的 leader election。</li>
</ul>
</li>
</ul>
</li>
<li>投票策略<ul>
<li>每个节点只会给每个 term 投一票，具体的是否同意和后续的 Safety 有关。<ul>
<li>Safety<ul>
<li><strong>哪些 follower 有资格成为 leader?</strong><ul>
<li><blockquote>
<p>Raft 保证被选为新 leader 的节点拥有所有已提交的 log entry，这与 ViewStamped Replication 不同，后者不需要这个保证，而是通过其他机制从 follower 拉取自己没有的提交的日志记录</p>
</blockquote>
</li>
<li>这个保证是在 RequestVoteRPC 阶段做的，candidate 在发送 RequestVoteRPC 时，会带上自己的最后一条日志记录的 term_id 和 index，其他节点收到消息时，如果发现自己的日志比 RPC 请求中携带的更新，拒绝投票。日志比较的原则是，如果本地的最后一条 log entry 的 term id 更大，则更新，如果 term id 一样大，则日志更多的更大（index 更大）。</li>
</ul>
</li>
<li><strong>哪些日志记录被认为是 commited?</strong><ul>
<li>leader 正在 replicate 当前 term（即 term 2）的日志记录给其它 Follower，一旦 leader 确认了这条 log entry 被 majority 写盘了，这条 log entry 就被认为是 committed。</li>
<li>leader 正在 replicate 更早的 term 的 log entry 给其它 follower。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>当投票被瓜分后，所有的 candidate 同时超时，然后有可能进入新一轮的票数被瓜分，为了避免这个问题，Raft 采用一种很简单的方法：每个 Candidate 的 election timeout 从 150ms-300ms 之间随机取，那么第一个超时的 Candidate 就可以发起新一轮的 leader election，带着最大的 term_id 给其它所有 server 发送 RequestVoteRPC 消息，从而自己成为 leader，然后给他们发送心跳消息以告诉他们自己是主。</li>
</ul>
</li>
</ul>
</li>
<li>状态复制<ol>
<li>Leader 负责接收来自 Client 的提案请求（红色提案表示未确认）<ul>
<li><img src="/2019/09/01/%E5%B7%A5%E7%A8%8B/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F-0-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/Raft_%E7%8A%B6%E6%80%81%E5%A4%8D%E5%88%B6_1.jpg" alt="Raft_状态复制_1"></li>
</ul>
</li>
<li>提案内容将包含在 Leader 发出的下一个心跳中<ul>
<li><img src="/2019/09/01/%E5%B7%A5%E7%A8%8B/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F-0-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/Raft_%E7%8A%B6%E6%80%81%E5%A4%8D%E5%88%B6_2.jpg" alt="Raft_状态复制_2"></li>
</ul>
</li>
<li>Follower 接收到心跳以后回复 Leader 的心跳<ul>
<li><img src="/2019/09/01/%E5%B7%A5%E7%A8%8B/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F-0-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/Raft_%E7%8A%B6%E6%80%81%E5%A4%8D%E5%88%B6_3.jpg" alt="Raft_状态复制_3"></li>
</ul>
</li>
<li>Leader 接收到多数派 Follower 的回复以后<strong>确认提案</strong>并写入自己的存储空间中并<strong>回复 Client</strong><ul>
<li><img src="/2019/09/01/%E5%B7%A5%E7%A8%8B/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F-0-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/Raft_%E7%8A%B6%E6%80%81%E5%A4%8D%E5%88%B6_4.jpg" alt="Raft_状态复制_4"></li>
</ul>
</li>
<li>Leader <strong>通知 Follower 节点确认提案</strong>并写入自己的存储空间，随后所有的节点都拥有相同的数据<ul>
<li><img src="/2019/09/01/%E5%B7%A5%E7%A8%8B/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F-0-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/Raft_%E7%8A%B6%E6%80%81%E5%A4%8D%E5%88%B6_5.jpg" alt="Raft_状态复制_5"></li>
</ul>
</li>
<li>若集群中出现网络异常，导致集群被分割，将出现多个 Leader<ul>
<li><img src="/2019/09/01/%E5%B7%A5%E7%A8%8B/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F-0-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/Raft_%E7%8A%B6%E6%80%81%E5%A4%8D%E5%88%B6_6.jpg" alt="Raft_状态复制_6"></li>
</ul>
</li>
<li>被分割出的非多数派集群将无法达到共识，即<strong>脑裂</strong>，如图中的 A、B 节点将无法确认提案<ul>
<li><img src="/2019/09/01/%E5%B7%A5%E7%A8%8B/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F-0-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/Raft_%E7%8A%B6%E6%80%81%E5%A4%8D%E5%88%B6_7.jpg" alt="Raft_状态复制_7"></li>
<li><img src="/2019/09/01/%E5%B7%A5%E7%A8%8B/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F-0-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/Raft_%E7%8A%B6%E6%80%81%E5%A4%8D%E5%88%B6_8.jpg" alt="Raft_状态复制_8"></li>
</ul>
</li>
<li>当集群再次连通时，将只听从最新任期 Leader 的指挥，旧 Leader 将退化为 Follower，如图中 B 节点的 Leader（任期 1）需要听从 D 节点的 Leader（任期 2）的指挥，此时集群重新达到一致性状态<ul>
<li><img src="/2019/09/01/%E5%B7%A5%E7%A8%8B/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F-0-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/Raft_%E7%8A%B6%E6%80%81%E5%A4%8D%E5%88%B6_9.jpg" alt="Raft_状态复制_9"></li>
<li><img src="/2019/09/01/%E5%B7%A5%E7%A8%8B/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F-0-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/Raft_%E7%8A%B6%E6%80%81%E5%A4%8D%E5%88%B6_10.jpg" alt="Raft_状态复制_10"></li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li>ZAB（muti-paxos）<ul>
<li>说明：ZAB 也是对 Multi Paxos 算法的改进，大部分和 Raft 相同</li>
<li>和 Raft 算法的主要区别：<ul>
<li>对于 Leader 的任期，Raft 叫做 term，而 ZAB 叫做 epoch</li>
<li>在状态复制的过程中，Raft 的心跳从 Leader 向 Follower 发送，而 ZAB 则相反。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>弱一致性<ul>
<li>说明：也叫最终一致性，系统不保证改变提交以后立即改变集群的状态，但是随着时间的推移最终状态是一致的。</li>
<li>模型：<ul>
<li>DNS 系统</li>
<li>Gossip 协议<ul>
<li>说明：Gossip 算法每个节点都是对等的，即没有角色之分。Gossip 算法中的每个节点都会将数据改动告诉其他节点（类似传八卦）。有话说得好：”最多通过六个人你就能认识全世界任何一个陌生人”，因此数据改动的消息很快就会传遍整个集群。</li>
<li>步骤：<ol>
<li>集群启动，如下图所示（这里设置集群有20个节点）<ul>
<li><img src="/2019/09/01/%E5%B7%A5%E7%A8%8B/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F-0-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/Gossip%E7%AE%97%E6%B3%95_%E6%AD%A5%E9%AA%A4_1.jpg" alt="Gossip算法_步骤_1"></li>
</ul>
</li>
<li>某节点收到数据改动，并将改动传播给其他 4 个节点，传播路径表示为较粗的 4 条线<ul>
<li><img src="/2019/09/01/%E5%B7%A5%E7%A8%8B/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F-0-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/Gossip%E7%AE%97%E6%B3%95_%E6%AD%A5%E9%AA%A4_2.jpg" alt="Gossip算法_步骤_2"></li>
<li><img src="/2019/09/01/%E5%B7%A5%E7%A8%8B/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F-0-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/Gossip%E7%AE%97%E6%B3%95_%E6%AD%A5%E9%AA%A4_3.jpg" alt="Gossip算法_步骤_3"></li>
</ul>
</li>
<li>收到数据改动的节点重复上面的过程直到所有的节点都被感染</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>应用举例<ul>
<li>Google 的 Chubby 分布式锁服务，采用了 Paxos 算法</li>
<li>etcd 分布式键值数据库，采用了 Raft 算法</li>
<li>ZooKeeper 分布式应用协调服务，Chubby 的开源实现，采用 ZAB 算法</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="分布式-ID"><a href="#分布式-ID" class="headerlink" title="分布式 ID"></a>分布式 ID</h2><ul>
<li>雪花算法<ul>
<li>组成部分（64bit）<ol>
<li>第一位 占用 1bit，其值始终是 0，没有实际作用。</li>
<li>时间戳 占用 41bit，精确到毫秒，总共可以容纳约 69 年的时间。</li>
<li>工作机器 id 占用 10bit，其中高位 5bit 是数据中心 ID，低位 5bit 是工作节点 ID，做多可以容纳 1024 个节点。</li>
<li>序列号占用 12bit，每个节点每毫秒 0 开始不断累加，最多可以累加到 4095，一共可以产生 4096 个 ID。</li>
</ol>
</li>
<li>可能出现的问题<ul>
<li>时钟回拨<ul>
<li>如果时间回拨时间较短，比如配置 5ms 以内，那么可以直接等待一定的时间，让机器的时间追上来。</li>
<li>如果时间的回拨时间较长，我们不能接受这么长的阻塞等待，那么又有两个策略:<ol>
<li>直接拒绝，抛出异常，打日志，通知 RD 时钟回滚。</li>
<li>利用扩展位，上面我们讨论过不同业务场景位数可能用不到那么多，那么我们可以把扩展位数利用起来了，比如当这个时间回拨比较长的时候，我们可以不需要等待，直接在扩展位加 1、2 位的扩展位允许我们有 3 次大的时钟回拨，一般来说就够了，如果其超过三次我们还是选择抛出异常，打日志。</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h2><ul>
<li>基于 MySQL 的分布式锁</li>
<li>基于 Redis 的分布式锁</li>
<li>基于 Zookeeper 的分布式锁</li>
</ul>
<h2 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h2><ul>
<li>2PC<ul>
<li>2PC（Two-phase commit protocol），中文叫二阶段提交。 二阶段提交是一种强一致性设计，2PC 引入一个事务协调者的角色来协调管理各参与者（也可称之为各本地资源）的提交和回滚，二阶段分别指的是准备（投票）和提交两个阶段。</li>
<li>具体流程<ol>
<li>准备阶段协调者会给各参与者发送准备命令，你可以把准备命令理解成除了提交事务之外啥事都做完了。</li>
<li>同步等待所有资源的响应之后就进入第二阶段即提交阶段（注意提交阶段不一定是提交事务，也可能是回滚事务）。<ol>
<li>假如在第一阶段所有参与者都返回准备成功，那么协调者则向所有参与者发送提交事务命令，然后等待所有事务都提交成功之后，返回事务执行成功。<ul>
<li><img src="/2019/09/01/%E5%B7%A5%E7%A8%8B/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F-0-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1_2PC_%E6%88%90%E5%8A%9F.jpg" alt="分布式事务_2PC_成功"></li>
</ul>
</li>
<li>假如在第一阶段有一个参与者返回失败，那么协调者就会向所有参与者发送回滚事务的请求，即分布式事务执行失败。<ul>
<li><img src="/2019/09/01/%E5%B7%A5%E7%A8%8B/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F-0-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1_2PC_%E5%A4%B1%E8%B4%A5.jpg" alt="分布式事务_2PC_失败"></li>
</ul>
</li>
</ol>
</li>
<li>如果第二阶段提交失败<ol>
<li>第一种是第二阶段执行的是回滚事务操作，那么答案是不断重试，直到所有参与者都回滚了，不然那些在第一阶段准备成功的参与者会一直阻塞着。</li>
<li>第二种是第二阶段执行的是提交事务操作，那么答案也是不断重试，因为有可能一些参与者的事务已经提交成功了，这个时候只有一条路，就是头铁往前冲，不断的重试，直到提交成功，到最后真的不行只能人工介入处理。</li>
</ol>
</li>
</ol>
</li>
<li>首先 2PC 是一个同步阻塞协议，<ul>
<li>第一阶段协调者会等待所有参与者响应才会进行下一步操作，当然第一阶段的协调者有超时机制，假设因为网络原因没有收到某参与者的响应或某参与者挂了，那么超时后就会判断事务失败，向所有参与者发送回滚命令。</li>
<li>在第二阶段协调者的没法超时，因为按照我们上面分析只能不断重试！</li>
</ul>
</li>
<li>协调者故障分析<ul>
<li>协调者是一个单点，存在单点故障问题。<ul>
<li>假设协调者在发送准备命令之前挂了，还行等于事务还没开始。</li>
<li>假设协调者在发送准备命令之后挂了，这就不太行了，有些参与者等于都执行了处于事务资源锁定的状态。不仅事务执行不下去，还会因为锁定了一些公共资源而阻塞系统其它操作。</li>
<li>假设协调者在发送回滚事务命令之前挂了，那么事务也是执行不下去，且在第一阶段那些准备成功参与者都阻塞着。</li>
<li>假设协调者在发送回滚事务命令之后挂了，这个还行，至少命令发出去了，很大的概率都会回滚成功，资源都会释放。但是如果出现网络分区问题，某些参与者将因为收不到命令而阻塞着。</li>
<li>假设协调者在发送提交事务命令之前挂了，这下是所有资源都阻塞着。</li>
<li>假设协调者在发送提交事务命令之后挂了，这个还行，也是至少命令发出去了，很大概率都会提交成功，然后释放资源，但是如果出现网络分区问题某些参与者将因为收不到命令而阻塞着。</li>
</ul>
</li>
<li>协调者故障，通过选举得到新协调者<ul>
<li>如果处于第一阶段，其实影响不大都回滚好了，在第一阶段事务肯定还没提交。</li>
<li>如果处于第二阶段，假设参与者都没挂，此时新协调者可以向所有参与者确认它们自身情况来推断下一步的操作。</li>
<li>假设有个别参与者挂了！比如协调者发送了回滚命令，此时第一个参与者收到了并执行，然后协调者和第一个参与者都挂了。<ul>
<li>此时其他参与者都没收到请求，然后新协调者来了，它询问其他参与者都说OK，但它不知道挂了的那个参与者到底O不OK，所以它傻了。</li>
<li>问题其实就出在每个参与者自身的状态只有自己和协调者知道，因此新协调者无法通过在场的参与者的状态推断出挂了的参与者是什么情况。</li>
</ul>
</li>
<li>虽然协议上没说，不过在实现的时候我们可以灵活的让协调者将自己发过的请求在哪个地方记一下，也就是日志记录</li>
<li>但是就算协调者知道自己该发提交请求，那么在参与者也一起挂了的情况下没用，因为你不知道参与者在挂之前有没有提交事务。<ul>
<li>如果参与者在挂之前事务提交成功，新协调者确定存活着的参与者都没问题，那肯定得向其他参与者发送提交事务命令才能保证数据一致。</li>
<li>如果参与者在挂之前事务还未提交成功，参与者恢复了之后数据是回滚的，此时协调者必须是向其他参与者发送回滚事务命令才能保持事务的一致。</li>
</ul>
</li>
<li>所以说极端情况下还是无法避免数据不一致问题。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>3PC<ul>
<li>3PC 的出现是为了解决 2PC 的一些问题，相比于 2PC 它在参与者中也引入了超时机制，并且新增了一个阶段使得参与者可以利用这一个阶段统一各自的状态。</li>
<li>3PC 包含了三个阶段，分别是准备阶段、预提交阶段和提交阶段，对应的英文就是：CanCommit、PreCommit 和 DoCommit。<ul>
<li>看起来是把 2PC 的提交阶段变成了预提交阶段和提交阶段，但是 3PC 的准备阶段协调者只是询问参与者的自身状况。</li>
<li><img src="/2019/09/01/%E5%B7%A5%E7%A8%8B/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F-0-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1_3PC_%E6%B5%81%E7%A8%8B%E5%9B%BE.jpg" alt="分布式事务_3PC_流程图"></li>
<li>不管哪一个阶段有参与者返回失败都会宣布事务失败，这和 2PC 是一样的（当然到最后的提交阶段和 2PC 一样只要是提交请求就只能不断重试）。</li>
</ul>
</li>
<li>3PC 的阶段相对 2PC 的变更有什么影响<ul>
<li>首先准备阶段的变更成不会直接执行事务，而是会先去询问此时的参与者是否有条件接这个事务，因此不会一来就干活直接锁资源，使得在某些资源不可用的情况下所有参与者都阻塞着。</li>
<li>而预提交阶段的引入起到了一个统一状态的作用，它像一道栅栏，表明在预提交阶段前所有参与者其实还未都回应，在预处理阶段表明所有参与者都已经回应了。<ul>
<li>假如你是一位参与者，你知道自己进入了预提交状态那你就可以推断出来其他参与者也都进入了预提交状态。</li>
</ul>
</li>
<li>但是多引入一个阶段也多一个交互，因此性能会差一些，而且绝大部分的情况下资源应该都是可用的，这样等于每次明知可用执行还得询问一次。</li>
</ul>
</li>
<li>超时机制<ul>
<li>如果是等待提交命令超时，那么参与者就会提交事务了，因为都到了这一阶段了大概率是提交的，如果是等待预提交命令超时，那该干啥就干啥了，反正本来啥也没干。</li>
<li>数据不一致<ul>
<li>比如在等待提交命令时候超时了，参与者默认执行的是提交事务操作，但是有可能执行的是回滚操作，这样一来数据就不一致了。</li>
</ul>
</li>
</ul>
</li>
<li>2PC 和 3PC 都不能保证数据100%一致，因此一般都需要有定时扫描补偿机制。</li>
</ul>
</li>
<li>TCC<ul>
<li>2PC 和 3PC 都是数据库层面的，而 TCC 是业务层面的分布式事务，分布式事务不仅仅包括数据库的操作，还包括发送短信等，这时候 TCC 就派上用场了！</li>
<li>TCC 指的是Try - Confirm - Cancel。<ul>
<li>Try 指的是预留，即资源的预留和锁定，注意是预留。</li>
<li>Confirm 指的是确认操作，这一步其实就是真正的执行了。</li>
<li>Cancel 指的是撤销操作，可以理解为把预留阶段的动作撤销了。</li>
</ul>
</li>
<li>TCC 模型还有个事务管理者的角色，用来记录 TCC 全局事务状态并提交或者回滚事务。</li>
<li>流程<ul>
<li><img src="/2019/09/01/%E5%B7%A5%E7%A8%8B/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F-0-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1_TCC_%E6%B5%81%E7%A8%8B%E5%9B%BE.jpg" alt="分布式事务_TCC_流程图"></li>
</ul>
</li>
<li>特点<ul>
<li>TCC 对业务的侵入较大和业务紧耦合，需要根据特定的场景和业务逻辑来设计相应的操作。</li>
<li>撤销和确认操作的执行可能需要重试，因此还需要保证操作的幂等。</li>
</ul>
</li>
</ul>
</li>
<li>本地消息表<ul>
<li>例子<ul>
<li><img src="/2019/09/01/%E5%B7%A5%E7%A8%8B/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F-0-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1_%E6%9C%AC%E5%9C%B0%E6%B6%88%E6%81%AF%E8%A1%A8.jpg" alt="分布式事务_本地消息表"></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="分布式调度"><a href="#分布式调度" class="headerlink" title="分布式调度"></a>分布式调度</h2><ul>
<li>发展史<ul>
<li><img src="/2019/09/01/%E5%B7%A5%E7%A8%8B/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F-0-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/%E5%88%86%E5%B8%83%E5%BC%8F%E8%B0%83%E5%BA%A6_%E5%8F%91%E5%B1%95%E5%8F%B2.jpg" alt="分布式调度_发展史"></li>
</ul>
<ol>
<li>第一阶段<ul>
<li>单线程调度，在 Java1.5 之前，基于线程的等待（sleep 或 wait）机制定时执行，需要开发者实现调度逻辑，单个线程（Thread）处理单个任务有些浪费，但是一个线程（Timer）处理多个任务容易因为某个任务繁忙导致其他任务阻塞。</li>
</ul>
</li>
<li>第二阶段<ul>
<li>线程池调度，在 Java1.5 开始提供 ScheduledExecutorService 调度线程池，调度线程池支持固定的延时和固定间隔模式，对于需要在某天或者某月的时间点执行就不大方便，需要计算时间间隔，转换成启动延时和固定间隔，处理起来比较麻烦。</li>
</ul>
</li>
<li>第三阶段<ul>
<li>Spring 任务调度，Spring 简化了任务调度，通过 @Scheduled 注解支持将某个 Bean 的方法定时执行，除了支持固定延时和固定间隔模式外，还支持 cron 表达式，使得定时任务的开发变得极其简单。</li>
</ul>
</li>
<li>第四阶段<ul>
<li>Quartz 任务调度，在任务服务集群部署下，Quartz 通过数据库锁，实现任务的调度并发控制，避免同一个任务同时执行的情况。Quartz 通过 Scheduler 提供了任务调度 API，开发可以基于此开发自己的任务调度管理平台。</li>
</ul>
</li>
<li>第五阶段<ul>
<li>分布式任务平台，提供一个统一的平台，无需再去做和调度相关的开发，业务系统只需要实现具体的任务逻辑，自动注册到任务调度平台，在上面进行相关的配置就完成了定时任务的开发。</li>
</ul>
</li>
</ol>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wetts.github.io/2019/09/01/%E5%B7%A5%E7%A8%8B/%E6%8E%A5%E5%8F%A3/%E6%8E%A5%E5%8F%A3-0-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Zhang Wetts">
      <meta itemprop="description" content="Stay Hungry, Stay Foolish. <br><br><p style="font-size:8px;">[build by hexo/next/gitalk/hexo-generator-search/LaTeX]</p>">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wetts's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/09/01/%E5%B7%A5%E7%A8%8B/%E6%8E%A5%E5%8F%A3/%E6%8E%A5%E5%8F%A3-0-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/" class="post-title-link" itemprop="url">接口-0-知识点汇总.md</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-09-01 12:10:14" itemprop="dateCreated datePublished" datetime="2019-09-01T12:10:14+08:00">2019-09-01</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%8E%A5%E5%8F%A3/" itemprop="url" rel="index"><span itemprop="name">接口</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="接口设计"><a href="#接口设计" class="headerlink" title="接口设计"></a>接口设计</h2><ul>
<li><p>遇到的问题</p>
<ul>
<li><p><strong>高并发下如何保证接口的幂等性？</strong></p>
<ul>
<li>幂等性定义<ul>
<li>幂等性就是同一个操作执行多次，产生的效果一样。如 http 的 get 请求、数据库的 select 请求就是幂等的。</li>
<li>如提交订单、扣款等接口都要保证幂等性，不然会造成重复创建订单、重复扣款</li>
</ul>
</li>
<li>解决方法<ul>
<li>前端保证幂等性的方法<ul>
<li>按钮只能点击一次<ul>
<li>用户点击按钮后将按钮置灰，或者显示 loading 状态</li>
</ul>
</li>
<li>RPG 模式<ul>
<li>即 Post-Redirect-Get，当客户提交表单后，去执行一个客户端的重定向，转到提交成功页面。避免用户按 F5 刷新导致的重复提交，也能消除按浏览器后退键导致的重复提交问题。</li>
</ul>
</li>
</ul>
</li>
<li>后端保证幂等性的方法<ul>
<li>使用唯一索引<ul>
<li>对业务唯一的字段加上唯一索引，这样当数据重复时，插入数据库会抛异常</li>
<li><img src="/2019/09/01/%E5%B7%A5%E7%A8%8B/%E6%8E%A5%E5%8F%A3/%E6%8E%A5%E5%8F%A3-0-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/%E6%8E%A5%E5%8F%A3%E5%B9%82%E7%AD%89%E6%80%A7_%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95.jpg" alt="接口幂等性_唯一索引"></li>
</ul>
</li>
<li>状态机幂等<ul>
<li>如果业务上需要修改订单状态，例如订单状态有待支付，支付中，支付成功，支付失败。设计时最好只支持状态的单向改变。这样在更新的时候就可以加上条件，多次调用也只会执行一次。例如想把订单状态更新为支持成功，则之前的状态必须为支付中。</li>
<li><img src="/2019/09/01/%E5%B7%A5%E7%A8%8B/%E6%8E%A5%E5%8F%A3/%E6%8E%A5%E5%8F%A3-0-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/%E6%8E%A5%E5%8F%A3%E5%B9%82%E7%AD%89%E6%80%A7_%E7%8A%B6%E6%80%81%E6%9C%BA.jpg" alt="接口幂等性_状态机"></li>
</ul>
</li>
<li>悲观锁<ul>
<li><img src="/2019/09/01/%E5%B7%A5%E7%A8%8B/%E6%8E%A5%E5%8F%A3/%E6%8E%A5%E5%8F%A3-0-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/%E6%8E%A5%E5%8F%A3%E5%B9%82%E7%AD%89%E6%80%A7_%E6%82%B2%E8%A7%82%E9%94%81.jpg" alt="接口幂等性_悲观锁"></li>
</ul>
</li>
<li>乐观锁<ul>
<li>步骤<ol>
<li>查询数据获得版本号</li>
<li>通过版本号去更新，版本号匹配则更新，版本号不匹配则不更新</li>
</ol>
</li>
<li><img src="/2019/09/01/%E5%B7%A5%E7%A8%8B/%E6%8E%A5%E5%8F%A3/%E6%8E%A5%E5%8F%A3-0-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/%E6%8E%A5%E5%8F%A3%E5%B9%82%E7%AD%89%E6%80%A7_%E4%B9%90%E8%A7%82%E9%94%81.jpg" alt="接口幂等性_乐观锁"></li>
</ul>
</li>
<li>防重表<ul>
<li>增加一个防重表，业务唯一的 id 作为唯一索引，如订单号，当想针对订单做一系列操作时，可以向防重表中插入一条记录，插入成功，执行后续操作，插入失败，则不执行后续操作。本质上可以看成是基于 MySQL 实现的分布式锁。根据业务场景决定执行成功后，是否删除防重表中对应的数据。</li>
<li><img src="/2019/09/01/%E5%B7%A5%E7%A8%8B/%E6%8E%A5%E5%8F%A3/%E6%8E%A5%E5%8F%A3-0-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/%E6%8E%A5%E5%8F%A3%E5%B9%82%E7%AD%89%E6%80%A7_%E9%98%B2%E9%87%8D%E8%A1%A8.jpg" alt="接口幂等性_防重表"></li>
</ul>
</li>
<li>select+insert<ul>
<li>先查询一下有没有符合要求的数据，如果没有再执行插入。没有并发的系统中可以保证幂等性，高并发下不要用这种方法，也会造成数据的重复插入。我一般做消息幂等的时候就是先 select，有数据直接返回，没有数据加分布式锁进行 insert 操作。</li>
</ul>
</li>
<li>分布式锁<ul>
<li>执行方法时，先根据业务唯一的 id 获取分布式锁，获取成功，则执行，失败则不执行。分布式锁可以基于 Redis、zookeeper、MySQL 来实现。</li>
<li><img src="/2019/09/01/%E5%B7%A5%E7%A8%8B/%E6%8E%A5%E5%8F%A3/%E6%8E%A5%E5%8F%A3-0-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/%E6%8E%A5%E5%8F%A3%E5%B9%82%E7%AD%89%E6%80%A7_%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81.jpg" alt="接口幂等性_分布式锁"></li>
</ul>
</li>
<li>全局唯一号<ul>
<li>通过 source（来源）+ seq（序列号）来判断请求是否重复，重复则直接返回请求重复提交，否则执行。如当多个三方系统调用服务的时候，就可以采用这种方式。</li>
</ul>
</li>
<li>获取 token<ul>
<li>该方案跟之前的所有方案都有点不一样，需要两次请求才能完成一次业务操作。</li>
<li>步骤<ol>
<li>第一次请求获取 token<ul>
<li><img src="/2019/09/01/%E5%B7%A5%E7%A8%8B/%E6%8E%A5%E5%8F%A3/%E6%8E%A5%E5%8F%A3-0-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/%E6%8E%A5%E5%8F%A3%E5%B9%82%E7%AD%89%E6%80%A7_%E8%8E%B7%E5%8F%96token_1.jpg" alt="接口幂等性_获取token_1"></li>
</ul>
</li>
<li>第二次请求带着这个 token，完成业务操作。<ul>
<li><img src="/2019/09/01/%E5%B7%A5%E7%A8%8B/%E6%8E%A5%E5%8F%A3/%E6%8E%A5%E5%8F%A3-0-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/%E6%8E%A5%E5%8F%A3%E5%B9%82%E7%AD%89%E6%80%A7_%E8%8E%B7%E5%8F%96token_2.jpg" alt="接口幂等性_获取token_2"></li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>多版本共存</p>
<ul>
<li><p>解决方案</p>
<ul>
<li><p>Header 版本控制</p>
<ul>
<li><p>此方法需要客户端将指示资源版本的自定义 Header 添加到请求中，如果省略了此 Header，按默认值（一般是最新版）处理。</p>
</li>
<li><p>```</p>
<h1 id="Request"><a href="#Request" class="headerlink" title="Request"></a>Request</h1><p>GET <a target="_blank" rel="noopener" href="http://adventure-works.com/customers/3">http://adventure-works.com/customers/3</a><br>Custom-Header: api-version=1</p>
<h1 id="Response"><a href="#Response" class="headerlink" title="Response"></a>Response</h1><p>HTTP/1.1 200 OK<br>Content-Type: application/json; charset=utf-8</p>
<p>{“id”:3,”name”:”Contoso LLC”,”address”:”1 Microsoft Way Redmond WA 98053”}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  - 优点：纯粹的版本控制机制，符合 RESTful API「每个资源使用唯一的URI定位」的原则</span><br><span class="line">  - 缺点：不直观，无法支持表单直接调用（众所周知 HTML 表单是不能添加自定义 Header 的），缓存不友好（不能认为同一 URI/查询字符串指向的是相同数据，因此难以缓存）</span><br><span class="line">- 媒体类型版本控制</span><br><span class="line">  - 通常，Accept 标头的用途是由客户端指定响应的正文是 XML、JSON或其他格式。但是，可以定义包括以下信息的自定义媒体类型：该信息使客户端应用程序可以指示它所需的资源版本。</span><br><span class="line">  - ```</span><br><span class="line">    # Request</span><br><span class="line">    GET http://adventure-works.com/customers/3 HTTP/1.1</span><br><span class="line">    Accept: application/vnd.adventure-works.v1+json</span><br></pre></td></tr></table></figure></li>
<li><p>服务端负责处理 Accept 标头并尽可能采用该值（可以在 Accept 标头中指定多种格式，在这种情况下，服务端在其中选择最适合的格式用于响应正文）。返回结果中的 Content-Type 标头确认响应正文中的数据格式：</p>
</li>
<li><p>```</p>
<h1 id="Response-1"><a href="#Response-1" class="headerlink" title="Response"></a>Response</h1><p>Content-Type: application/vnd.company.myapp-v3+xml</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- URI 版本控制</span><br><span class="line">  - ```</span><br><span class="line">    # Request</span><br><span class="line">    GET http://adventure-works.com/v2/customers/3</span><br></pre></td></tr></table></figure></li>
<li><p>优点：直观，缓存友好，支持表单直接调用</p>
</li>
<li><p>缺点：不符合「每个资源使用唯一的URI定位」的原则</p>
</li>
</ul>
</li>
<li><p>查询字符串版本控制</p>
<ul>
<li><pre><code># Request
GET http://adventure-works.com/customers/3?version=2
</code></pre>
</li>
<li>优点：直观，缓存友好，支持表单直接调用，符合「每个资源使用唯一的URI定位」的原则</li>
<li>缺点：某些较旧的 Web 浏览器和代理不会缓存在 URI 中包含字符串的请求的响应，这会对性能产生影响</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>如何保证 API 接口数据安全？</strong></p>
<ol>
<li>登陆验证</li>
<li>权限验证</li>
<li>HTTPS</li>
<li>接口签名<ul>
<li>签名流程<ul>
<li><img src="/2019/09/01/%E5%B7%A5%E7%A8%8B/%E6%8E%A5%E5%8F%A3/%E6%8E%A5%E5%8F%A3-0-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/%E6%8E%A5%E5%8F%A3%E5%AE%89%E5%85%A8%E6%80%A7_%E7%AD%BE%E5%90%8D%E6%B5%81%E7%A8%8B.png" alt="接口安全性_签名流程"></li>
</ul>
</li>
<li>签名规则<ul>
<li>线下分配 appid 和 appsecret，针对不同的调用方分配不同的 appid 和 appsecret<ul>
<li>appSecret 的作用主要是区分不同客户端 app。并且利用获取到的 appSecret 参与到 sign 签名，保证了客户端的请求签名是由我们后台控制的，我们可以为不同的客户端颁发不同的 appSecret。</li>
</ul>
</li>
<li>加入 timestamp（时间戳），5 分钟内数据有效</li>
<li>加入临时流水号 nonce（防止重复提交），至少为 10 位。针对查询接口，流水号只用于日志落地，便于后期日志核查。针对办理类接口需校验流水号在有效期内的唯一性，以避免重复请求。</li>
<li>加入签名字段 signature，所有数据的签名信息。</li>
</ul>
</li>
<li>客户端签名生成<ul>
<li>所有动态参数 = 请求头部分 + 请求 URL 地址 + 请求 Request 参数 + 请求 Body<ul>
<li>上面的动态参数以 key-value 的格式存储，并以 key 值正序排序，进行拼接</li>
</ul>
</li>
<li>最后拼接的字符串再拼接 appSecret</li>
<li>拼接成一个字符串，然后做md5不可逆加密<ul>
<li><code>signature = DigestUtils.md5DigestAsHex(sortParamsMap + appSecret)</code></li>
</ul>
</li>
</ul>
</li>
<li>服务端签名验证<ul>
<li>验证流程<ol>
<li>验证必须的头部参数</li>
<li>获取头部参数，request 参数，Url 请求路径，请求体 Body，把这些值放入 SortMap 中进行排序</li>
<li>对 SortMap 里面的值进行拼接</li>
<li>对拼接的值进行加密，生成 sign</li>
<li>把生成的 sign 和前端传入的 sign 进行比较，如果不相同就返回错误</li>
</ol>
</li>
<li>附加功能<ul>
<li>可以通过对请求的 timestamp 进行时间验证，如果大于 10 分钟表示此链接已经超时，防止别人来到这个链接去请求。</li>
<li>利用 nonce 参数，防止重复提交</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
</ul>
<h2 id="限流"><a href="#限流" class="headerlink" title="限流"></a>限流</h2><ul>
<li>计数器（固定窗口）算法<ul>
<li>计数器算法是使用计数器在周期内累加访问次数，当达到设定的限流值时，触发限流策略。下一个周期开始时，进行清零，重新计数。</li>
<li><img src="/2019/09/01/%E5%B7%A5%E7%A8%8B/%E6%8E%A5%E5%8F%A3/%E6%8E%A5%E5%8F%A3-0-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95_%E8%AE%A1%E6%95%B0%E5%99%A8%EF%BC%88%E5%9B%BA%E5%AE%9A%E7%AA%97%E5%8F%A3%EF%BC%89%E7%AE%97%E6%B3%95_1.png" alt="限流算法_计数器（固定窗口）算法_1"></li>
<li>这个算法通常用于QPS限流和统计总访问量，对于秒级以上的时间周期来说，会存在一个非常严重的问题，那就是临界问题。<ul>
<li>假设 1min 内服务器的负载能力为 100，因此一个周期的访问量限制在 100，然而在第一个周期的最后 5 秒和下一个周期的开始 5 秒时间段内，分别涌入 100 的访问量，虽然没有超过每个周期的限制量，但是整体上 10 秒内已达到 200 的访问量，已远远超过服务器的负载能力，由此可见，计数器算法方式限流对于周期比较长的限流，存在很大的弊端。</li>
<li><img src="/2019/09/01/%E5%B7%A5%E7%A8%8B/%E6%8E%A5%E5%8F%A3/%E6%8E%A5%E5%8F%A3-0-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95_%E8%AE%A1%E6%95%B0%E5%99%A8%EF%BC%88%E5%9B%BA%E5%AE%9A%E7%AA%97%E5%8F%A3%EF%BC%89%E7%AE%97%E6%B3%95_2.png" alt="限流算法_计数器（固定窗口）算法_2"></li>
</ul>
</li>
</ul>
</li>
<li>滑动窗口算法<ul>
<li>滑动窗口算法是将时间周期分为 N 个小周期，分别记录每个小周期内访问次数，并且根据时间滑动删除过期的小周期。<ul>
<li>假设时间周期为 1min，将 1min 再分为 2 个小周期，统计每个小周期的访问数量，则第一个时间周期内，访问数量为 75，第二个时间周期内，访问数量为 100，超过 100 的访问则被限流掉了。</li>
<li><img src="/2019/09/01/%E5%B7%A5%E7%A8%8B/%E6%8E%A5%E5%8F%A3/%E6%8E%A5%E5%8F%A3-0-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95_%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%AE%97%E6%B3%95.png" alt="限流算法_滑动窗口算法"></li>
</ul>
</li>
<li>当滑动窗口的格子划分的越多，那么滑动窗口的滚动就越平滑，限流的统计就会越精确。</li>
<li>此算法可以很好的解决固定窗口算法的临界问题。</li>
</ul>
</li>
<li>漏桶算法<ul>
<li>漏桶算法是访问请求到达时直接放入漏桶，如当前容量已达到上限（限流值），则进行丢弃（触发限流策略）。漏桶以固定的速率进行释放访问请求（即请求通过），直到漏桶为空。</li>
<li><img src="/2019/09/01/%E5%B7%A5%E7%A8%8B/%E6%8E%A5%E5%8F%A3/%E6%8E%A5%E5%8F%A3-0-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95_%E6%BC%8F%E6%A1%B6%E7%AE%97%E6%B3%95.png" alt="限流算法_漏桶算法"></li>
</ul>
</li>
<li>令牌桶算法<ul>
<li>令牌桶算法是程序以 r（r=时间周期/限流值）的速度向令牌桶中增加令牌，直到令牌桶满，请求到达时向令牌桶请求令牌，如获取到令牌则通过请求，否则触发限流策略。</li>
<li><img src="/2019/09/01/%E5%B7%A5%E7%A8%8B/%E6%8E%A5%E5%8F%A3/%E6%8E%A5%E5%8F%A3-0-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95_%E4%BB%A4%E7%89%8C%E6%A1%B6%E7%AE%97%E6%B3%95.png" alt="限流算法_令牌桶算法"></li>
<li>Google 开源工具包 Guava 提供了限流工具类 RateLimiter，该类基于令牌桶算法来完成限流，非常易于使用。</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/10/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><span class="page-number current">11</span><a class="page-number" href="/page/12/">12</a><span class="space">&hellip;</span><a class="page-number" href="/page/69/">69</a><a class="extend next" rel="next" href="/page/12/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Zhang Wetts"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">Zhang Wetts</p>
  <div class="site-description" itemprop="description">Stay Hungry, Stay Foolish. <br><br><p style="font-size:8px;">[build by hexo/next/gitalk/hexo-generator-search/LaTeX]</p></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">682</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">67</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">350</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/wetts" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;wetts" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:zhang.wetts@163.com" title="E-Mail → mailto:zhang.wetts@163.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Zhang Wetts</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

  


<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/hibiki.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"react":{"opacity":0}});</script></body>
</html>
